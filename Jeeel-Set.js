/**
 * @fileOverview 汎用性がある機能の集まりです。<br />
 *                 FireFox, Safari, Chrome, Opera, IE6以上に対応しています。(個々のビルド段階のバグは考慮していません)<br />
 *                 _JEEEL_MANUAL_LOAD_を定義すると自動読み込みが無効になります。<br />
 *                 _JEEEL_CLEAN_MODE_を定義するとグローバル変数がJeeelのみの定義になります。<br />
 *                 _JEEEL_DEBUG_MODE_を定義するとデバッグが有効になります。また、デバッグメソッドへのショートカットが作成されます。<br />
 *                 _JEEEL_EXTEND_MODE_を連想配列で定義し機能ごとに論理値を埋め込むと拡張機能が追加されます。(WebStorage等)<br />
 *                 _JEEEL_FULL_MODE_を定義すると全ての機能が有効になります。(上記のモード定義より優先される)<br />
 *                 また、エラーを詳細に表示する機能も追加されます。<br />
 *                 このライブラリ内ではいくつかの疑似的型表現を用いています。<br />
 *                 以下の型表現がそれにあたり、外部で定義されているものとは異なることに注意してください。<br />
 *                 Integer: 整数値<br />
 *                 Digit: 整数値もしくは整数値文字列<br />
 *                 Hash: 配列及び連想配列(基本的には基本型と関数以外すべて)<br />
 *                 Primitive: 基本型(真偽値・数値・文字列値・null・undefined)<br />
 *                 Mixied: なんでも良い<br />
 *                 引数にvar_argsがあったらそれは可変引数を示します。<br />
 *                 var_argsを含めて順に引数を必要数渡します。
 *
 * @name Jeeel.js(Javascript Easy Error and Exception handling Library: Japanease Eeel)
 * @author Masato Shimada
 * @version 2.0.0β60
 * @license <a href="http://en.wikipedia.org/wiki/BSD_licenses">BSD License</a>
 */
 
 var _JEEEL_MANUAL_LOAD_ = true;

// Jeeelが定義されていた場合バックアップを取ってから書き換えを行う
if (typeof window !== 'undefined' && window.Jeeel) {

    (function (backupPrefix, backupValue) {
        if ( ! arguments.callee.backupPrefix) {
            arguments.callee.backupPrefix = backupPrefix;
        }

        var backupName = backupPrefix + 'Jeeel';

        if (backupName in window) {
            arguments.callee(backupPrefix + arguments.callee.backupPrefix, window[backupName]);
        }

        window[backupName] = backupValue;
    })('_', window.Jeeel);
}

/**
 * 汎用メソッド等を提供するネームスペース
 */
var Jeeel = {

    /**
     * 現在のJeeelのバージョン<br />
     * 1.0.0<br />
     * | | |<br />
     * A B C<br />
     * <br />
     * Aバージョンは互換性が無いバージョンを示す<br />
     * Bバージョンは新規機能追加を示す<br />
     * Cバージョンは既存機能追加・微調整・バグ修正を示す
     *
     * @type String
     * @constant
     */
    VERSION: '2.0.0β60',
    
    /**
     * Jeeelのscriptタグに付くclass名
     *
     * @type String
     * @constant
     */
    SCRIPT_CLASS: 'jeeel-script-class',
    
    /**
     * Jeeelのscriptタグに付くid名(実際にはこれにインデックス番号が付く)
     *
     * @type String
     * @constant
     */
    SCRIPT_ID: 'jeeel-script-id',

    /**
     * Jeeelファイルが置かれているホスト<br />
     * 通常は空文字にする
     *
     * @type String
     * @constant
     */
    HOST: 'http://localhost',

    /**
     * Jeeelファイルが置かれている相対URL<br />
     * 通常は指定しなくても良い
     *
     * @type String
     * @constant
     */
    BASE_URL: '',
    
    /**
     * クロスドメインかどうか
     * 
     * @type Boolean
     * @constant
     */
    CROSS_DOMAIN: false,
    
    /**
     * サーバー側のevalを使用できる相対URL<br />
     * 以下のパラメータを受け取り実行した後結果を返す機能をサーバーに実装
     *
     * <pre>
     * パラメータ {
     * &nbsp;   script: サーバー言語スクリプト,
     * &nbsp;   params: サーバ側に渡す任意パラメータ
     * }
     * </pre>
     *
     * @type String
     * @constant
     */
    DEBUG_URL: '/dev/debug/eval/',

    /**
     * サーバー側でSQLを実行できる相対URL<br />
     * 以下のパラメータを受け取り実行した後結果を返す機能をサーバーに実装
     *
     * <pre>
     * パラメータ {
     * &nbsp;   sql: SQL文字列
     * }
     * </pre>
     *
     * @type String
     * @constant
     */
    SQL_DEBUG_URL: '/dev/debug/eval-sql/',

    /**
     * サーバー側でメール送信を出来る相対URL<br />
     * 以下のパラメータを処理してメール送信する機能をサーバーに実装
     *
     * <pre>
     * パラメータ {
     * &nbsp;   to  : 送信先,
     * &nbsp;   body: 送信内容,
     * &nbsp;   type: メールのタイプ
     * }
     * </pre>
     *
     * @type String
     * @constant
     */
    MAIL_URL: '/dev/debug/mail/',

    /**
     * サーバー側でパラメータを表記した文字列をファイルとして読み込ませるための相対URL<br />
     * 以下のパラメータを処理してファイルを渡す機能をサーバーに実装
     *
     * <pre>
     * パラメータ {
     * &nbsp;   file : ファイル名(省略可能),
     * &nbsp;   value: ファイルに変換するパラメータ
     * }
     * </pre>
     *
     * @type String
     * @constant
     */
    FILE_OPEN_URL: '/dev/debug/file-open/',
    
    /**
     * Jsonp通信を行うための相対URL<br />
     * 以下のパラメータを処理してファイルを渡す機能をサーバーに実装
     *
     * <pre>
     * パラメータ {
     * &nbsp;   exec-action: 実行アクション名,
     * &nbsp;   callback: コールバック関数名
     * }
     * </pre>
     *
     * @type String
     * @constant
     */
    JSONP_URL: '/dev/debug/jsonp/',
    
    /**
     * このJeeelオブジェクト固有ID
     * 
     * @type String
     * @constant
     */
    UNIQUE_ID: null,

    /**
     * 現在の階層のDocumentで作成したJeeel.Dom.Document
     *
     * @type Jeeel.Dom.Document
     * @readOnly
     */
    Document: null,
    
    /**
     * 現在の階層のWindowで作成したJeeel.Dom.Window
     *
     * @type Jeeel.Dom.Window
     * @readOnly
     */
    Window: null,
    
    /**
     * Jsonp通信のためのキャッシュ
     * 
     * @private
     */
    _jsp: {
        
    },

    /**
     * Jeeel系のサブクラス保存のための媒体
     *
     * @private
     */
    _Object: {
      
    },

    /**
     * IEのための高速化手法
     * 
     * @type Document
     * @readOnly
     * @private
     */
    _doc: (typeof document !== 'undefined' ? document : null),
    
    /**
     * IEのための高速化手法
     * 
     * @type Global
     * @readOnly
     * @private
     */
    _global: (typeof window !== 'undefined' ? window : this),

    /**
     * 自動的にスクリプトを読み込むかどうか
     *
     * @type Boolean
     * @readOnly
     * @private
     */
    _auto: typeof _JEEEL_MANUAL_LOAD_ === 'undefined',

    /**
     * グローバル変数をJeeelのみにするかどうか
     *
     * @type Boolean
     * @readOnly
     * @private
     */
    _cleanMode: typeof _JEEEL_CLEAN_MODE_ !== 'undefined',

    /**
     * デバッグを使用できるようにするかどうか(_cleanModeがtrueの場合はショートカットが作成されない)
     *
     * @type Boolean
     * @readOnly
     * @private
     */
    _debugMode: typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_DEBUG_MODE_ !== 'undefined',

    /**
     * 拡張機能を機能ごとに使用するかどうかを設定する
     *
     * @type Hash
     * @readOnly
     * @private
     */
    _extendMode: {
        /**
         * GUIの拡張機能を使用するかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        Gui: !!(typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_EXTEND_MODE_ !== 'undefined' && _JEEEL_EXTEND_MODE_.Gui),
        
        /**
         * Web Storage(localStorage)の拡張機能を使用するかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        WebStorage: !!(typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_EXTEND_MODE_ !== 'undefined' && _JEEEL_EXTEND_MODE_.WebStorage),

        /**
         * Indexed Database APIの拡張機能を使用するかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        Database: !!(typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_EXTEND_MODE_ !== 'undefined' && _JEEEL_EXTEND_MODE_.Database),
        
        /**
         * WebWorkersの拡張機能を使用するかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        Worker: !!(typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_EXTEND_MODE_ !== 'undefined' && _JEEEL_EXTEND_MODE_.Worker),
        
        /**
         * Geolocation APIの拡張機能を使用するかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        Geolocation: !!(typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_EXTEND_MODE_ !== 'undefined' && _JEEEL_EXTEND_MODE_.Geolocation),
        
        /**
         * File APIの拡張機能を使用するかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        File: !!(typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_EXTEND_MODE_ !== 'undefined' && _JEEEL_EXTEND_MODE_.File),
        
        /**
         * メディア系の拡張機能を使用するかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        Media: !!(typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_EXTEND_MODE_ !== 'undefined' && _JEEEL_EXTEND_MODE_.Media),
        
        /**
         * グラフィックス系の拡張機能を使用するかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        Graphics: !!(typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_EXTEND_MODE_ !== 'undefined' && _JEEEL_EXTEND_MODE_.Graphics),
        
        /**
         * ネットワーク系の拡張機能を使用するかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        Net: !!(typeof _JEEEL_FULL_MODE_ !== 'undefined' || typeof _JEEEL_EXTEND_MODE_ !== 'undefined' && _JEEEL_EXTEND_MODE_.Net)
    },

    /**
     * エラーメッセージを表示するメソッド
     *
     * @param {String|Event} message エラーメッセージ
     * @param {String} file エラーファイル
     * @param {Integer} line エラー行数
     * @private
     */
    _error: (function (message, file, line) {

        if (typeof console !== 'undefined') {
            return function (message, file, line) {
                if (Jeeel.Type.isEvent(message)) {
                    file = message.target.src;
                    line = 'undefined';
                }
                
                console.log(file + '(' + line + ')', message);
            };
        } else {
            return function (message, file, line) {
                if (Jeeel.Type.isEvent(message)) {
                    file = message.target.src;
                    line = 'undefined';
                }
                
                Jeeel.errorDump(file + '(' + line + ')\n'+ message);
            };
        }
    })(),

    /**
     * Jeeel.jsの個別読み込みを行う
     * 
     * @param {String} dir ディレクトリ
     * @param {String} file ソース
     */
    _import: function (dir, file) {
        if ( ! Jeeel._doc) {
            if (typeof importScripts !== 'undefined') {
                importScripts(dir + file + '.js');
            }

            return;
        }
        
        if ( ! arguments.callee.index) {
            arguments.callee.index = 1;
        }
        
        var index = arguments.callee.index;
        
        Jeeel._doc.write('<script type="text/javascript" id="' + this.SCRIPT_ID + '-' + index + '" class="' + this.SCRIPT_CLASS + '" src="' + dir + file + '.js"></script>\n');

        arguments.callee.index++;
    },
    
    /**
     * Jeeel.jsのディレクトリ別、自動読み込みを行う
     * 
     * @param {String} dir ディレクトリ
     * @param {Array} files ソースのリスト
     */
    _autoImports: function (dir, files) {
        if (this._auto) {
            for (var i = 0, l = files.length; i < l; i++) {
                this._import(dir, files[i]);
            }
        }
    },

    /**
     * 読み込むディレクトリを示す
     */
    directory: {

    },

    /**
     * ディレクトリに対してのforeach
     *
     * @param {Object} directory ディレクトリ
     * @param {Function} callBack コールバックメソッド(要素、キー、配列)
     */
    directoryForEach: function (directory, callBack) {
        for (var key in directory) {
            if (key !== 'toString') {
                callBack.call(this, directory[key], key, directory);
            }
        }
    },

    /**
     * 読み込むファイルを示す
     */
    file: {

    },

    /**
     * ファイルに対してのforeach
     *
     * @param {Array} file ファイル
     * @param {Function} callBack コールバックメソッド(要素、キー、配列)
     */
    fileForEach: function (file, callBack) {
        for (var key in file) {
            if (isNaN(key) && key !== 'length') {
                callBack.call(this, file[key], key, file);
            }
        }
    },

    /**
     * ファイルの相対パスを全て返す
     *
     * @return {String} ファイルパスを示す文字列
     */
    getFilePath: function () {
        var paths = (arguments.length === 0 ? [this.directory.Jeeel + 'Jeeel.js\n'] : []);
        var directory = (arguments.length === 0 ? this.directory : arguments[0]);
        var file = (arguments.length === 0 ? this.file : arguments[1]);

        var self = arguments.callee;

        Jeeel.directoryForEach(directory,
            function (dir, key) {

                for (var i = 0, l = file[key].length; i < l; i++) {

                    var subKey = file[key][i];
                    
                    if ( ! this._debugMode && subKey === 'Debug') {
                        continue;
                    } else if ( ! this._debugMode && key === 'Technical' && Jeeel.Type.inArray(subKey, ['Information', 'Trace'], true)) {
                        continue;
                    } else if ( ! this._extendMode.Gui && subKey === 'Gui') {
                        continue;
                    } else if ( ! this._extendMode.WebStorage && subKey === 'WebStorage') {
                        continue;
                    } else if ( ! this._extendMode.Database && subKey === 'Database') {
                        continue;
                    } else if ( ! this._extendMode.Worker && subKey === 'Worker') {
                        continue;
                    } else if ( ! this._extendMode.Geolocation && subKey === 'Geolocation') {
                        continue;
                    } else if ( ! this._extendMode.File && subKey === 'File') {
                        continue;
                    } else if ( ! this._extendMode.Media && subKey === 'Media') {
                        continue;
                    } else if ( ! this._extendMode.Graphics && subKey === 'Graphics') {
                        continue;
                    } else if ( ! this._extendMode.Net && Jeeel.Type.inArray(subKey, ['Comet', 'Socket'], true)) {
                        continue;
                    }

                    paths[paths.length] = dir + subKey+'.js\n';

                    if (dir[subKey] && file[key][subKey]) {
                        var dirTmp = {};
                        var fileTmp = {};
                        dirTmp[subKey] = dir[subKey];
                        fileTmp[subKey] = file[key][subKey];

                        paths[paths.length] = self(dirTmp, fileTmp);
                    }
                }
            }
        );

        return paths.join('');
    },

    /**
     * ファイルをスクリプトタグで囲った状態で全て返す
     *
     * @return {String} スクリプトタグで囲われたファイルパスを示す文字列
     */
    getScript: function () {
        var paths = (arguments.length === 0 ? ['<script type="text/javascript" class="'+Jeeel.SCRIPT_CLASS+'" src="'+this.directory.Jeeel+'Jeeel.js"></script>\n'] : []);
        var directory = (arguments.length === 0 ? this.directory : arguments[0]);
        var file = (arguments.length === 0 ? this.file : arguments[1]);

        var self = arguments.callee;

        Jeeel.directoryForEach(directory,
            function (dir, key) {

                for (var i = 0, l = file[key].length; i < l; i++) {
                  
                    var subKey = file[key][i];

                    if ( ! this._debugMode && subKey === 'Debug') {
                        continue;
                    }else if ( ! this._debugMode && key === 'Technical' && Jeeel.Type.inArray(subKey, ['Information', 'Trace'], true)) {
                        continue;
                    } else if ( ! this._extendMode.Gui && subKey === 'Gui') {
                        continue;
                    } else if ( ! this._extendMode.WebStorage && subKey === 'WebStorage') {
                        continue;
                    } else if ( ! this._extendMode.Database && subKey === 'Database') {
                        continue;
                    } else if ( ! this._extendMode.Worker && subKey === 'Worker') {
                        continue;
                    }else if ( ! this._extendMode.Geolocation && subKey === 'Geolocation') {
                        continue;
                    } else if ( ! this._extendMode.File && subKey === 'File') {
                        continue;
                    } else if ( ! this._extendMode.Media && subKey === 'Media') {
                        continue;
                    } else if ( ! this._extendMode.Graphics && subKey === 'Graphics') {
                        continue;
                    } else if ( ! this._extendMode.Net && Jeeel.Type.inArray(subKey, ['Comet', 'Socket'], true)) {
                        continue;
                    }

                    paths[paths.length] = '<script type="text/javascript" class="'+Jeeel.SCRIPT_CLASS+'" src="'+dir + subKey+'.js"></script>\n';

                    if (dir[subKey] && file[key][subKey]) {
                        var dirTmp = {};
                        var fileTmp = {};
                        dirTmp[subKey] = dir[subKey];
                        fileTmp[subKey] = file[key][subKey];

                        paths[paths.length] = self(dirTmp, fileTmp);
                    }
                }
            }
        );

        return paths.join('');
    },

    /**
     * 全てのファイルを接続した状態で返す
     *
     * @param {Boolean} [minimize] 必要最小限のファイルのみ接続するかどうか
     * @param {Boolean} [disableDebug] デバッグ関連のファイル読み込みを無効にするかどうか
     * @param {Boolean} [disableExtend] 追加関連のファイル読み込みを無効にするかどうか
     * @return {String} 全てのファイルを接続した文字列
     */
    getJoinScript: function (minimize, disableDebug, disableExtend) {
        var debugTmp = this._debugMode;
        var geneTmp  = this._extendMode;

        if (minimize) {
            this._debugMode = false;
            this._extendMode = {};
        }
        
        if (disableDebug) {
            this._debugMode = false;
        }
        
        if (disableExtend) {
            this._extendMode = {};
        }

        var files = this.getFilePath().replace(/\n$/g, '').split('\n');
        var script = [];

        for (var i = 0, l = files.length; i < l; i++) {
            script[i] = Jeeel.Net.Ajax.serverResponse(files[i]);
        }

        this._debugMode  = debugTmp;
        this._extendMode = geneTmp;
        
        var url = Jeeel.UserAgent.getProtocol() + '://' + Jeeel.UserAgent.getHost();

        return 'var _JEEEL_MANUAL_LOAD_ = true;\n' + script.join('').replace("HOST: ''", "HOST: '" + url + "'");
    },
    
    getCompressScript: function (minimize, disableDebug, disableExtend) {
        return Jeeel.Debug.Compressor.compress(this.getJoinScript(minimize, disableDebug, disableExtend));
    },

    /**
     * デバッグモードが有効である場合に限りエラーをダンプする
     *
     * @param {Mixied} var_args エラー出力する値の可変引数
     * @return {Boolean} エラーをダンプしたかどうか
     */
    errorDump: function (var_args) {
        if ( ! Jeeel._debugMode || ! Jeeel.Debug) {
            return false;
        }

        Jeeel.Debug.ErrorMessage.dump.apply(null, arguments);
        return true;
    },

    /**
     * デバッグモードが有効である場合に限りエラーをHTMLとしてダンプする
     *
     * @param {Mixied} var_args エラー出力する値の可変引数
     * @return {Boolean} エラーをダンプしたかどうか
     */
    errorHtmlDump: function (var_args) {
        if ( ! Jeeel._debugMode || ! Jeeel.Debug) {
            return false;
        }

        Jeeel.Debug.ErrorMessage.dumpHtml.apply(null, arguments);
        return true;
    },

    /**
     * デバッグモードが有効である場合に限りエラーをConsoleにダンプする
     *
     * @param {Mixied} var_args エラー出力する値の可変引数
     * @return {Boolean} エラーをダンプしたかどうか
     */
    errorDumpConsole: function (var_args) {
        if ( ! Jeeel._debugMode || ! Jeeel.Debug) {
            return false;
        }

        Jeeel.Debug.Console.log.apply(null, arguments);
        return true;
    },
    
    /**
     * Domが完成した時に呼び出されるイベントの登録を行う
     *
     * @param {Function} listener 登録イベント
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはJeeel.Windowになる)
     */
    addLoadEvent: function (listener, thisArg) {
        Jeeel.Window.addEventListener(Jeeel.Dom.Event.Type.LOAD, listener, thisArg);
    }
};

Jeeel.directory.Jeeel = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.HOST + Jeeel.BASE_URL + 'Jeeel/';
    }
};

(function () {
    
    // 基本デバッグの有効化
    if (Jeeel._global && Jeeel._debugMode) {
        Jeeel._global.onerror = Jeeel._error;
    }
    
    // クロスドメインの判定
    if (Jeeel.HOST && Jeeel.HOST.match(/^https?:\/\//) && typeof location !== 'undefined') {
        var host = (location.protocol + '//' + location.host).replace(/([\/()\[\]{}|*+-.,\^$?\\])/g, '\\$1');

        if ( ! Jeeel.HOST.match(new RegExp('^' + host))) {
            Jeeel.CROSS_DOMAIN = true;
        }
    }
    
    // ユニークIDを設定する
    Jeeel.UNIQUE_ID = 'Jeeel-' + (Jeeel.VERSION + Math.random()).replace(/\D/g, '');
    Jeeel.SCRIPT_ID = Jeeel.SCRIPT_ID + '-' + Jeeel.UNIQUE_ID;
    
    // ベースURLとクラス、IDの設定
    if (Jeeel._doc) {
        
        var scripts = Jeeel._doc.getElementsByTagName('script');
        var jeeelRegExp = /^(.*)\/Jeeel\/\w+\.js(.*)$/i,
            jeeelMatch;

        for (var i = scripts.length; i--;) {
            var script = scripts[i],
                src = script.getAttribute('src');

            if ( ! src || ! (jeeelMatch = src.match(jeeelRegExp))) {
                continue;
            }

            Jeeel.BASE_URL = jeeelMatch[1] + '/';

            script.className = Jeeel.SCRIPT_CLASS;
            script.id = Jeeel.SCRIPT_ID + '-0';

            break;
        }
    }
    
    if (Jeeel._global) {
        Jeeel._global.Jeeel = Jeeel;
    }
    
    Jeeel.file.Jeeel = ['Class', 'Filter', 'Type', 'Method', 'Hash', 'String', 'Number', 'Code', 'Loader', 'Function', 'UserAgent', 'Json', 'Session', 'Dom', 'Net', 'Evaluator', 'Template', 'Timer', 'DataStructure', 'Object', 'Parameter', 'Validator', 'Storage', 'Namespace', 'External', 'Deferred', 'Framework', 'Config', 'Util'];
   
    if (Jeeel._extendMode.Gui && Jeeel._doc) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Gui';
    }
    
    if (Jeeel._extendMode.Worker && Jeeel._global && Jeeel._global.Worker) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Worker';
    }
    
    if (Jeeel._extendMode.Database && Jeeel._global && Jeeel._global.openDatabase) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Database';
    }
    
    if (Jeeel._extendMode.File && Jeeel._global && Jeeel._global.FileReader) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'File';
    }
    
    if (Jeeel._extendMode.Media && Jeeel._global && Jeeel._global.Audio) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Media';
    }
    
    if (Jeeel._extendMode.Graphics) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Graphics';
    }

    if (Jeeel._debugMode) {
        if ( ! Jeeel._extendMode.Gui && Jeeel._doc) {
            Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Gui';
        }
        
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Debug';
    }

    // 自動ロードを始動
    if (Jeeel._auto) {
        Jeeel._tmp = function () {
            for (var i = 4, l = Jeeel.file.Jeeel.length; i < l; i++) {
                Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[i]);
            }

            delete Jeeel._tmp;
        };

        Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[0]);
        Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[1]);
        Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[2]);
        Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[3]);
    }
})();

// グローバル関数・変数の設定
(function () {
    if ( ! Jeeel._global) {
        return;
    } else if (Jeeel._cleanMode) {
        return;
    }
    
    // undefinedが未定義の特殊なブラウザに対してundefinedを定義する
    if ( ! ('undefined' in Jeeel._global)) {
        Jeeel._global.undefined = void 0;
    }
      
    if (Jeeel._debugMode && (typeof Jeeel.DEBUG_URL === 'string') && (typeof Jeeel._global.evalServer === 'undefined')) {

        /**
         * サーバ側のスクリプトを走らせる
         *
         * @param {String} script サーバー側で走らせるスクリプト文字列
         * @param {Hash} [params] サーバー側に渡すパラメータ
         * @param {Function} [callback] クロスドメイン時のコールバック
         * @return {Mixied} サーバー側からの戻り値をデコードしたもの
         */
        Jeeel._global.evalServer = function evalServer(script, params, callback) {
            return Jeeel.Debug.Debugger.evalServer(script, params, callback);
        };
    }

    if (Jeeel._debugMode && (typeof Jeeel.SQL_DEBUG_URL === 'string') && (typeof Jeeel._global.evalSql === 'undefined')) {

        /**
         * サーバー側でSQLを実行する
         *
         * @param {String} sql サーバー側実行するSQL文字列
         * @param {Function} [callback] クロスドメイン時のコールバック
         * @return {Mixied} サーバー側からの戻り値をデコードしたもの
         */
        Jeeel._global.evalSql = function evalSql(sql, callback) {
            return Jeeel.Debug.Debugger.evalSql(sql, callback);
        };
    }

    if (Jeeel._debugMode && (typeof Jeeel.MAIL_URL === 'string') && (typeof Jeeel._global.sendMail === 'undefined')) {

        /**
         * メールを送信する
         *
         * @param {String} to メール送信先
         * @param {Mixied} body メール本文
         * @param {Boolean} [isHtml] HTMLメールとして送信を行うかどうかを示す(デフォルトはfalse)
         * @param {Function} [callback] クロスドメイン時のコールバック
         * @return {Boolean} メール送信が成功ならばtrueそれ以外はfalseを返す
         */
        Jeeel._global.sendMail = function sendMail(to, body, isHtml, callback) {
            return Jeeel.Debug.Debugger.sendMail(to, body, isHtml, callback);
        };
    }

    if (Jeeel._debugMode && (typeof Jeeel.FILE_OPEN_URL === 'string') && (typeof Jeeel._global.fileOpen === 'undefined')) {

        /**
         * 識別子をファイルとしてブラウザに読み込ませる
         *
         * @param {Mixied} value 読み込ませる値
         * @param {String} [fileName] 指定した名前で認識させたい時に指定する
         */
        Jeeel._global.fileOpen = function fileOpen(value, fileName) {
            return Jeeel.Debug.Debugger.fileOpen(value, fileName);
        };
    }

    if (Jeeel._debugMode && (typeof Jeeel._global.createConsole === 'undefined')) {

        /**
         * コンソールを生成する
         */
        Jeeel._global.createConsole = function createConsole() {
            Jeeel.Debug.Console.create();
        };
    }

    if (typeof Jeeel._global.$ID === 'undefined') {

        /**
         * idからElementを取得する
         *
         * @param {String} id 検索ID
         * @param {Document|Element} [target] 検索対象(省略時は現階層のDocument)
         * @return {Element} 取得したElement
         */
        Jeeel._global.$ID = function $ID(id, target) {

            if (Jeeel.Type.isDocument(target) && Jeeel._doc !== target) {
                return Jeeel.Dom.Document.create(target).getElementById(id);
            } else if (Jeeel.Type.isElement(target)) {
                return Jeeel.Dom.Element.create(target).getElementById(id);
            }

            return Jeeel.Document.getElementById(id);
        };
    }

    if (typeof Jeeel._global.$CLASS === 'undefined') {

        /**
         * classからElementを全て取得する
         *
         * @param {String} className 検索Class
         * @param {Document|Element} [target] 検索対象(省略時は現階層のDocument)
         * @return {Element[]} 取得したElement配列
         */
        Jeeel._global.$CLASS = function $CLASS(className, target) {

            if (Jeeel.Type.isDocument(target) && Jeeel._doc !== target) {
                return Jeeel.Dom.Document.create(target).getElementsByClassName(className);
            } else if (Jeeel.Type.isElement(target)) {
                return Jeeel.Dom.Element.create(target).getElementsByClassName(className);
            }

            return Jeeel.Document.getElementsByClassName(className);
        };
    }

    if (typeof Jeeel._global.$NAME === 'undefined') {

        /**
         * nameからElementを全て取得する
         *
         * @param {String} name 検索Name
         * @param {Document|Element} [target] 検索対象(省略時は現階層のDocument)
         * @return {Element[]} 取得したElement配列
         */
        Jeeel._global.$NAME = function $NAME(name, target) {

            if (Jeeel.Type.isDocument(target) && Jeeel._doc !== target) {
                return Jeeel.Dom.Document.create(target).getElementsByName(name);
            } else if (Jeeel.Type.isElement(target)) {
                return Jeeel.Dom.Element.create(target).getElementsByName(name);
            }

            return Jeeel.Document.getElementsByName(name);
        };
    }

    if (typeof Jeeel._global.$TAG === 'undefined') {

        /**
         * タグ名からElementを全て取得する
         *
         * @param {String} tagName 検索Tag
         * @param {Document|Element} [target] 検索対象(省略時は現階層のDocument)
         * @return {Element[]} 取得したElement配列
         */
        Jeeel._global.$TAG = function $TAG(tagName, target) {

            if (Jeeel.Type.isDocument(target) && Jeeel._doc !== target) {
                return Jeeel.Dom.Document.create(target).getElementsByTagName(tagName);
            } else if (Jeeel.Type.isElement(target)) {
                return Jeeel.Dom.Element.create(target).getElementsByTagName(tagName);
            }

            return Jeeel.Document.getElementsByTagName(tagName);
        };
    }

    if (typeof Jeeel._global.$PRM === 'undefined') {

        /**
         * Jeeel.Parameterインスタンスの作成
         *
         * @param {Hash} [params] 入力パラメータ
         * @return {Jeeel.Parameter} インスタンス
         * @throws {Error} paramsが配列式でない場合に起こる
         */
        Jeeel._global.$PRM = function $PRM(params) {
            return new Jeeel.Parameter(params);
        };
    }

    if (typeof Jeeel._global.$ELM === 'undefined') {

        /**
         * Jeeel.Dom.Elementインスタンスの作成
         *
         * @param {Element} element 対象Element
         * @return {Jeeel.Dom.Element} 作成したインスタンス
         */
        Jeeel._global.$ELM = function $ELM(element) {
            return new Jeeel.Dom.Element(element);
        };
    }

    if (typeof Jeeel._global.$ELMOP === 'undefined') {

        /**
         * Jeeel.Dom.ElementOperatorインスタンスの作成
         *
         * @param {Element|Element[]} elementList 対象Elementまたは複数のElementリスト
         * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
         */
        Jeeel._global.$ELMOP = function $ELMOP(elementList) {
            return new Jeeel.Dom.ElementOperator(elementList);
        };
    }
    
    if (typeof Jeeel._global.$BIND === 'undefined') {

        /**
         * Jeeel.Functionを使用したthisのバインド
         *
         * @param {Function} func 対象の関数
         * @param {Mixied} [thisArg] バインドするthis
         * @return {Jeeel.Function} 作成したインスタンス
         */
        Jeeel._global.$BIND = function $BIND(func, thisArg) {
            return Jeeel.Function.create(func).bind(thisArg);
        };
    }
    
    if (typeof Jeeel._global.$AJAX === 'undefined') {

        /**
         * Jeeel.Net.Ajaxインスタンスの作成
         *
         * @param {String} url Ajax対象URL文字列
         * @param {String} [method] HTTPメソッド(getまたはpost、大文字小文字は問わない、初期値はPOST)
         * @return {Jeeel.Net.Ajax} 作成したインスタンス
         */
        Jeeel._global.$AJAX = function $AJAX(url, method) {
            return new Jeeel.Net.Ajax(url, method);
        };
    }
    
    if (typeof Jeeel._global.$SUBMIT === 'undefined') {

        /**
         * Jeeel.Net.Submitインスタンスの作成
         *
         * @param {String|Element} form フォームを示すIDもしくはフォーム自身
         * @return {Jeeel.Net.Submit} 作成したインスタンス
         */
        Jeeel._global.$SUBMIT = function $SUBMIT(form) {
            return new Jeeel.Net.Submit(form);
        };
    }
})();
Jeeel.directory.Jeeel.Class = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Class/';
    }
};

/**
 * クラスに関するネームスペース 
 */
Jeeel.Class = {
    
    /**
     * 新しいクラスを定義して返す
     * 
     * @param {Object} properties 定義クラスのプロパティ
     * @param {Function} [superClass] 継承元クラス(デフォルトはObject)
     * @return {Function} 定義したクラス
     */
    define: function (properties, superClass) {
        var subClass = function () {
            if (this._super && this._super.hasOwnProperty('__construct')) {
                this._super.__construct.apply(this, arguments);
            }
            
            if (subClass.prototype.hasOwnProperty('__construct')) {
                subClass.prototype.__construct.apply(this, arguments);
            }
        };
        
        this.extend(subClass, superClass || Object);
        
        for (var key in properties) {
            if (properties.hasOwnProperty(key)) {
                subClass.prototype[key] = properties[key];
            }
        }
        
        var list = ['toString', 'valueOf'];

        for (var i = list.length; i--;) {
            if (properties[list[i]] !== Object.prototype[list[i]]) {
                subClass.prototype[list[i]] = properties[list[i]];
            }
        }
        
        return subClass;
    },
    
    /**
     * クラスの継承を行う<br />
     * 継承後には_superがプロパティに反映される
     * 
     * @param {Function} subClass 継承先クラス
     * @param {Function} superClass 継承元クラス
     * @return {Function} 継承先クラス(Jeeel.Class.Abstractも同時に疑似継承する)
     * @example 
     * var Person = function () {
     * };
     * 
     * Person.prototype = {
     *     _age: 0,
     *     _weight: 0,
     *     _height: 0,
     *     _gender: '不明',
     *     
     *     getStatus: function () {
     *         return '性別: ' + this._gender + '\n'
     *              + '年齢: ' + this._age + '歳\n'
     *              + '身長: ' + this._height + 'cm\n'
     *              + '体重: ' + this._weight + 'kg\n';
     *     }
     * };
     * 
     * var Man = function (age, height, weight) {
     *     this._age = age;
     *     this._height = height;
     *     this._weight = weight;
     * };
     * 
     * Man.prototype = {
     *    _gender: '男'
     * }; 
     * 
     * Jeeel.Class.extend(Man, Person);
     * 
     * var man = new Man(25, 172, 56);
     * var status = man.getStatus();
     * 
     * // statusの値
     * 性別: 男
     * 年齢: 25歳
     * 身長: 172cm
     * 体重: 56kg
     */
    extend: function (subClass, superClass) {
        this.Abstract.prototype = superClass.prototype;
        var prototypeObject = subClass.prototype;
        
        subClass.prototype = new this.Abstract(superClass);
        
        if (prototypeObject) {
            for (var property in prototypeObject) {
                subClass.prototype[property] = prototypeObject[property];
            }
            
            var list = ['toString', 'valueOf'];
            
            for (var i = 0, l = list.length; i < l; i++) {
                if (prototypeObject[list[i]] !== Object.prototype[list[i]]) {
                    subClass.prototype[list[i]] = prototypeObject[list[i]];
                }
            }
            
            subClass.prototype.constructor = subClass;
        }
        
        this.Abstract.prototype = null;
        
        return subClass;
    }
};

Jeeel.file.Jeeel.Class = ['Abstract', 'Mixin'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Class, Jeeel.file.Jeeel.Class);/**
 * コンストラクタ
 * 
 * @abstractClass 継承時に使用する抽象クラス
 * @param {Function} superClass スーパークラス
 */
Jeeel.Class.Abstract = function (superClass) {
    this._super = superClass.prototype;
};

Jeeel.Class.Abstract.prototype = {
    
    /**
     * 親クラスのプロトタイプ
     * 
     * @type Object
     * @readOnly
     */
    _super: null
};
    
/**
 * コンストラクタ
 * 
 * @class インスタンス混合クラス
 * @param {Object|Object[]} [mixinInstances] 混合インスタンス、もしくは混合インスタンスリスト
 * @param {Boolean} [returnInstance] 戻り値に自インスタンス許可するかどうか
 */
Jeeel.Class.Mixin = function (mixinInstances, returnInstance) {
    if ( ! mixinInstances) {
        mixinInstances = [];
    } else if ( ! Jeeel.Type.isArray(mixinInstances)) {
        mixinInstances = [mixinInstances];
    }
    
    returnInstance = !!returnInstance;
    
    for (var i = mixinInstances.length; i--;) {
        mixinInstances[i] = {instance: mixinInstances[i], returnInstance: returnInstance};
    }
    
    this._mixinInstances = mixinInstances;
    
    this._mixinMethod();
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Object|Object[]} [mixinInstances] 混合インスタンス、もしくは混合インスタンスリスト
 * @param {Boolean} [returnInstance] 戻り値に自インスタンス許可するかどうか
 * @return {Jeeel.Class.Mixin} 作成したインスタンス
 */
Jeeel.Class.Mixin.create = function (mixinInstances, returnInstance) {
    return new this(mixinInstances, returnInstance);
};

Jeeel.Class.Mixin.prototype = {
  
    /**
     * 混ぜているインスタンスリスト
     * 
     * @type Hash[]
     * @private
     */
    _mixinInstances: [],
    
    /**
     * 新たにインスタンスを混合する<br />
     * 同じメソッドが存在した場合後から混合したインスタンスが優先される
     * 
     * @param {Object} mixinInstance 混合インスタンス
     * @param {Boolean} [returnInstance] 戻り値に自インスタンス許可するかどうか
     * @return {Jeeel.Class.Mixin} 自インスタンス
     */
    mixin: function (mixinInstance, returnInstance) {
        this._mixinInstances[this._mixinInstances.length] = {instance: mixinInstance, returnInstance: !!returnInstance};
        
        return this._mixinMethod();
    },
    
    /**
     * メソッドを呼び出す
     * 
     * @param {String} methodName メソッド名
     * @param {Mixied} var_args 引数を順に渡す
     * @return {Jeeel.Class.Mixin|Mixied} 自インスタンスもしくは戻り値
     */
    call: function (methodName, var_args) {
        var args = Array.prototype.slice.call(arguments, 1, arguments.length);
        
        return this.apply(methodName, args);
    },
    
    /**
     * メソッドを呼び出す
     * 
     * @param {String} methodName メソッド名
     * @param {Array} [args] 引数のリスト
     * @return {Jeeel.Class.Mixin|Mixied} 自インスタンスもしくは戻り値
     */
    apply: function (methodName, args) {
        var instance = this._getInstance(methodName);
        
        if ( ! instance) {
            throw new Error(methodName + ' メソッドは見つかりません。');
        }
        
        var returnInstance = instance.returnInstance;
        
        instance = instance.instance;
        
        var res = instance[methodName].apply(instance, args || []);
        
        if (returnInstance && res === instance) {
            return this;
        }
        
        return res;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Class.Mixin,
    
    /**
     * メソッド名からインスタンスを特定して返す
     * 
     * @param {String} methodName メソッド名
     * @return {Hash} インスタンス情報
     * @private
     */
    _getInstance: function (methodName) {
      
        // 後ろから検索してインスタンスを取得する
        for (var i = this._mixinInstances.length; i--;) {
            if (typeof this._mixinInstances[i].instance[methodName] === 'function') {
                return this._mixinInstances[i];
            }
        }
        
        return null;
    },
    
    /**
     * メソッドの混合を行う
     * 
     * @return {Jeeel.Class.Mixin} 自インスタンス
     * @private
     */
    _mixinMethod: function () {
      
        // インスタンスは後に混ぜた方を優先
        for (var i = 0, l = this._mixinInstances.length; i < l; i++) {
            
            // インスタンスのプロパティを全て列挙
            for (var methodName in this._mixinInstances[i].instance) {
                
                // メソッド以外と元からあるプロパティは除外
                if (typeof this._mixinInstances[i].instance[methodName] !== 'function') {
                    continue;
                } else if (this[methodName] && ! this.hasOwnProperty(methodName)) {
                    continue;
                }
                
                // クロージャによってインスタンスに直接アクセスするメソッドを作成
                this[methodName] = (function (self, instance, returnInstance, methodName) {
                    return function () {
                        var res = instance[methodName].apply(instance, arguments);

                        if (returnInstance && res === instance) {
                            return self;
                        }

                        return res;
                    };
                })(this, this._mixinInstances[i].instance, this._mixinInstances[i].returnInstance, methodName);
            }
        }
        
        return this;
    }
};Jeeel.directory.Jeeel.Filter = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Filter/';
    }
};

Jeeel.Filter = {

    /**
     * コンストラクタ
     * 
     * @abstractClass フィルタークラスを作る際の抽象クラス
     */
    Abstract: function () {}
};

Jeeel.Filter.Abstract.prototype = {

    /**
     * 指定した値に対してフィルターを掛ける
     *
     * @param {Mixied} val フィルターを掛ける値
     * @return {Mixied} フィルターを掛けた後の値
     */
    filter: function (val) {
        if (Jeeel.Type.isHash(val)) {
            val = this._filterArray(val);
        } else {
            val = this._filter(val);
        }

        return val;
    },

    /**
     * 通常値の場合のメソッド<br />
     * 必ずオーバーライドしなければならない
     *
     * @param {Mixied} val フィルターを掛ける値
     * @return {Mixied} フィルターを掛けた後の値
     * @protected
     * @abstract
     */
    _filter: function (val) {
        throw new Error('_filterメソッドが実装されていません。');
    },

    /**
     * 配列式の場合のメソッド
     *
     * @param {Hash} arr フィルターを掛ける値のリスト
     * @return {Mixied} フィルターを掛けた後の値
     * @protected
     */
    _filterArray: function (arr) {
        var result = {};

        Jeeel.Hash.forEach(arr,
            function (val, key) {
                result[key] = this.filter(val);
            }, this
        );

        return result;
    }
};

Jeeel._Object.JeeelFilter = {
    
    getInputs: function (elm) {
        var selector = "input, select, textarea, button";
        var res = [], i, l;
        
        if (elm.querySelectorAll) {
            var sres = elm.querySelectorAll(selector);
            
            for (i = 0, l = sres.length; i < l; i++) {
                res[i] = sres[i];
            }
        } else {
            
            var tags = ['INPUT', 'SELECT', 'TEXTAREA', 'BUTTON'];

            res = Jeeel.Dom.Core.Searcher.create(elm).getElementsByTagName(tags);
        }
        
        return res;
    },
    
    getInputName: function (name) {
        var names1 = decodeURIComponent(name).split('][');
        var names2 = names1[0].split('[');
        
        if (names2.length === 1) {
            return [name];
        }
        
        var i, l, names = [];

        for (i = 0, l = names2.length; i < l; i++) {
            names[names.length] = names2[i];
        }

        for (i = 1, l = names1.length; i < l; i++) {
            names[names.length] = names1[i];
        }

        names[names.length-1] = names[names.length-1].replace(']', '');
        
        return names;
    },
    
    repairInputName: function (names) {
        var name = [names[0]];
        
        for (var i = 1, l = names.length; i < l; i++) {
            name[name.length] = '[';

            name[name.length] = names[i];
            
            name[name.length] = ']';
        }
        
        return name.join('');
    }
};

Jeeel.file.Jeeel.Filter = ['Each', 'Chain', 'Join', 'Replace', 'Split', 'RegularExpressionEscape', 'Subset', 'CopyKey', 'DeleteKey', 'Map', 'Cast', 'Array', 'Url', 'Html'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter, Jeeel.file.Jeeel.Filter);

/**
 * コンストラクタ
 * 
 * @class フィルターを配列の各要素にそれぞれ掛けるためのフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {Jeeel.Filter.Abstract} innerFilter 内部フィルター
 * @param {String[]} [keys] 操作許可キーリスト(初期値は全て)
 */
Jeeel.Filter.Each = function (innerFilter, keys) {
  
    Jeeel.Filter.Abstract.call(this);
    
    if (keys && ! Jeeel.Type.isArray(keys)) {
        keys = [keys];
    }
    
    this._innerFilter = innerFilter;
    this._keys = keys || null;
};

/**
 * インスタンスを作成して返す
 *
 * @param {Jeeel.Filter.Abstract} innerFilter 内部フィルター
 * @param {String[]} [keys] 操作許可キーリスト(初期値は全て)
 * @return {Jeeel.Filter.Each} 作成したインスタンス
 */
Jeeel.Filter.Each.create = function (innerFilter, keys) {
    return new this(innerFilter, keys);
};

Jeeel.Filter.Each.prototype = {
  
    /**
     * 操作対象キーリスト
     * 
     * @type String[]
     * @private
     */
    _keys: null,
    
    /**
     * 内部フィルター
     * 
     * @type Jeeel.Filter.Abstract
     * @private
     */
    _innerFilter: null,
    
    /**
     * 内部フィルターを取得する
     * 
     * @return {Jeeel.Filter.Abstract} innerFilter 内部フィルター
     */
    getInnerFilter: function () {
        return this._innerFilter;
    },

    /**
     * 内部フィルターをセットする
     *
     * @param {Jeeel.Filter.Abstract} innerFilter 内部フィルター
     * @return {Jeeel.Filter.Each} 自身のインスタンス
     */
    setInnerFilter: function (innerFilter) {
        this._innerFilter = innerFilter;

        return this;
    },

    /**
     * @private
     */
    _filter: function (params) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (params) {
        var result = {};
        var filter = this.getInnerFilter();

        Jeeel.Hash.forEach(params,
            function (val, key) {

                if ( ! this._keys || Jeeel.Type.inArray(key, this._keys)) {
                    result[key] = filter.filter(val);
                }
                else {
                    result[key] = val;
                }
            }
        );

        return result;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Each, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class フィルターを複数連結するフィルター
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Chain = function () {
  
    Jeeel.Filter.Abstract.call(this);

    this._filters = [];
    this._log = {};
};

/**
 * インスタンスを作成して返す
 *
 * @return {Jeeel.Filter.Chain} 作成したインスタンス
 */
Jeeel.Filter.Chain.create = function () {
    return new this();
};

Jeeel.Filter.Chain.prototype = {
    
    /**
     * 連結フィルター
     * 
     * @type Jeeel.Filter.Abstract[]
     * @private
     */
    _filters: [],
    
    /**
     * フィルターログ
     * 
     * @type Hash
     * @private
     */
    _log: {},
    
    /**
     * フィルターログ使用の可否
     * 
     * @type Boolean
     * @private
     */
    _useLog: false,
    
    /**
     * 連結するフィルタを追加する
     *
     * @param {Jeeel.Filter.Abstract} filter 連結するフィルタ
     * @param {String} [name] 連結するフィルタの名前を指定する(デフォルトは無名)<br />
     *                         名前をしてした場合途中結果を保持する対象に入る
     * @return {Jeeel.Filter.Chain} 自インスタンス
     */
    add: function (filter, name) {
        this._filters[this._filters.length] = {name: name, filter: filter};

        return this;
    },

    /**
     * 途中結果を取得する
     *
     * @return {Hash} 名前のついたフィルターの結果をキーと結果のペア
     */
    getLog: function () {
        return this._log;
    },

    /**
     * 途中結果を保持するかどうかを設定する
     *
     * @param {Boolean} useLog 途中結果を保持するかどうか
     * @return {Jeeel.Filter.Chain} 自インスタンス
     */
    setUseLog: function (useLog) {
        this._useLog = Boolean(useLog);

        return this;
    },
    
    /**
     * @private
     */
    _filter: function (params) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (params) {
        var log = {};

        for (var i = 0, l = this._filters.length; i < l; i++) {
            var filter = this. _filters[i];

            params = filter.filter.filter(params);

            if (this._useLog && filter.name) {
                log[filter.name] = params;
            }
        }

        this._log = log;

        return params;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Chain, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 対象のHashの各要素を連結して文字列にするフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} [separator] 連結時の区切り文字列
 * @param {String[]} [keys] 連結するキーのリスト
 */
Jeeel.Filter.Join = function (separator, keys) {
    Jeeel.Filter.Abstract.call(this);

    this._separator = (separator ? '' + separator : '');
    this._keys = keys || null;
};

/**
 * インスタンスの作成
 *
 * @param {String} [separator] 連結時の区切り文字列
 * @param {String[]} [keys] 連結するキーのリスト
 * @return {Jeeel.Filter.Join} 作成したインスタンス
 */
Jeeel.Filter.Join.create = function (separator, keys) {
    return new this(separator, keys);
};

Jeeel.Filter.Join.prototype = {
    
    /**
     * 連結時の区切り文字列
     * 
     * @type String
     * @private
     */
    _separator: '',
    
    /**
     * 連結するキーリスト
     * 
     * @type String[]
     * @private
     */
    _keys: null,
    
    /**
     * @private
     */
    _filter: function (array) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (array) {
        var keys = this._keys || Jeeel.Hash.getKeys(array);

        var params = Jeeel.Parameter.create(array)
                                  .getSubset(keys)
                                  .getAll();

        var res = [];

        Jeeel.Hash.forEach(params,
            function (val) {
                res[res.length] = '' + val;
            }
        );

        return res.join(this._separator);
    }
};

Jeeel.Class.extend(Jeeel.Filter.Join, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 対象の要素に対して文字列として扱い文字列置換を行うフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String|RegExp} reg 検索パターン及び検索文字列
 * @param {String} replace 置換後の文字列
 * @throws {Error} regが文字列・正規表現どちらでもない場合に投げられる
 * @throws {Error} replaceが文字列ではない場合に投げられる
 */
Jeeel.Filter.Replace = function (reg, replace) {
    Jeeel.Filter.Abstract.call(this);

    if ( ! Jeeel.Type.isString(reg) && ! (reg instanceof RegExp)) {
        throw new Error('regが文字列でも正規表現でもありません。');
    }

    if ( ! Jeeel.Type.isString(replace)) {
        throw new Error('replaceが文字列ではありません。');
    }

    this._reg = reg;
    this._replace = replace;
};

/**
 * インスタンスの作成
 *
 * @param {String|RegExp} reg 検索パターン及び検索文字列
 * @param {String} replace 置換後の文字列
 * @return {Jeeel.Filter.Replace} 作成したインスタンス
 */
Jeeel.Filter.Replace.create = function (reg, replace) {
    return new this(reg, replace);
};

Jeeel.Filter.Replace.prototype = {
    
    /**
     * 検索パターン及び検索文字列
     * 
     * @type String|RegExp
     * @private
     */
    _reg: '',
    
    /**
     * 置換文字列
     * 
     * @type String
     * @private
     */
    _replace: '',
    
    /**
     * @private
     */
    _filter: function (val) {
        val = '' + val;

        return val.replace(this._reg, this._replace);
    }
};

Jeeel.Class.extend(Jeeel.Filter.Replace, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 対象の要素に対して文字列として扱い文字列置換を行うフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} separator 区切り文字
 * @param {Integer} [limit] 配列の要素数の制限をする場合に指定
 * @throws {Error} separatorが文字列ではない場合に投げられる
 */
Jeeel.Filter.Split = function (separator, limit) {
    Jeeel.Filter.Abstract.call(this);

    if ( ! Jeeel.Type.isString(separator)) {
        throw new Error('separatorが文字列ではありません。');
    }

    this._separator = separator;
    this._limit = limit;
};

/**
 * インスタンスの作成
 *
 * @param {String} separator 区切り文字
 * @param {Integer} [limit] 配列の要素数の制限をする場合に指定
 * @return {Jeeel.Filter.Split} 作成したインスタンス
 */
Jeeel.Filter.Split.create = function (separator, limit) {
    return new this(separator, limit);
};

Jeeel.Filter.Split.prototype = {
  
    /**
     * 区切り文字
     * 
     * @type String
     * @private
     */
    _separator: '',
    
    /**
     * 配列の要素数の制限
     * 
     * @type Integer
     * @private
     */
    _limit: -1,
    
    /**
     * @private
     */
    _filter: function (val) {
        val = '' + val;

        return val.split(this._separator, this._limit);
    }
};

Jeeel.Class.extend(Jeeel.Filter.Split, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 正規表現に使用するメタ文字をエスケープするフィルター
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.RegularExpressionEscape = function () {
    Jeeel.Filter.Abstract.call(this);
};

/**
 * インスタンスの作成
 *
 * @return {Jeeel.Filter.RegularExpressionEscape} 作成したインスタンス
 */
Jeeel.Filter.RegularExpressionEscape.create = function () {
    return new this();
};

Jeeel.Filter.RegularExpressionEscape.prototype = {
  
    /**
     * エスケープ対象の正規表現
     * 
     * @type RegExp
     * @private
     */
    _reg: /([\/()\[\]{}|*+-.,\^$?\\])/g,
    
    /**
     * @private
     */
    _filter: function (val) {
        return ('' + val).replace(this._reg, '\\$1');
    }
};

Jeeel.Class.extend(Jeeel.Filter.RegularExpressionEscape, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class キーを複数指定し、部分集合を作成するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {Hash|String} keys 部分集合を表す複数のキー
 * @param {Mixed} [defaultValue] キーが存在しなかった場合のデフォルト値
 */
Jeeel.Filter.Subset = function (keys, defaultValue) {
    Jeeel.Filter.Abstract.call(this);

    if ( ! Jeeel.Type.isHash(keys)) {
        keys = [keys];
    }

    this._keys = keys;
    this._defaultValue = defaultValue;
};

/**
 * インスタンスの作成
 *
 * @param {Hash|String} keys 部分集合を表す複数のキー
 * @param {Mixed} [defaultValue] キーが存在しなかった場合のデフォルト値
 * @return {Jeeel.Filter.Subset} 作成したインスタンス
 */
Jeeel.Filter.Subset.create = function (keys, defaultValue) {
    return new this(keys, defaultValue);
};

Jeeel.Filter.Subset.prototype = {
    
    /**
     * 部分集合を表す複数のキー
     * 
     * @type Hash|String
     * @private
     */
    _keys: [],
    
    /**
     * キーが存在しなかった場合のデフォルト値
     * 
     * @type Mixed
     * @private
     */
    _defaultValue: undefined,
    
    /**
     * @private
     */
    _filter: function (val) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (array) {

        var globalDefault = null;
        var defaults;

        if (Jeeel.Type.isUndefined(this._defaultValue)) {
            defaults = {};
        }
        else if ( ! Jeeel.Type.isHash(this._defaultValue)) {
            defaults = {'*': this._defaultValue};
        }
        else {
            defaults = this._defaultValue;
        }

        if ('*' in defaults) {
            globalDefault = defaults['*'];
            
            delete defaults['*'];
        }

        var result = {};

        for (var arrayKey in this._keys) {
            var key = this._keys[arrayKey];

            if (key in array) {
                result[key] = array[key];
                
                continue;
            }
            
            if (key in defaults) {
                result[key] = defaults[key];
                
                continue;
            }
            
            if (globalDefault !== null) {
                result[key] = globalDefault;
            }
        }

        return result;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Subset, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class フィルタ対象の配列の指定キーの値を他のキーにコピーする
 * @augments Jeeel.Filter.Abstract
 * @param {Hash} [copyMap] コピーマップ
 */
Jeeel.Filter.CopyKey = function (copyMap) {
    Jeeel.Filter.Abstract.call(this);
  
    this._copyMap = copyMap || {};
};

/**
 * インスタンスを作成して返す
 *
 * @param {Hash} [copyMap] コピーマップ
 * @return {Jeeel.Filter.CopyKey} 作成したインスタンス
 */
Jeeel.Filter.CopyKey.create = function (copyMap) {
    return new this(copyMap);
};

Jeeel.Filter.CopyKey.prototype = {
  
    /**
     * コピーマップ
     * 
     * @type Hash
     * @private
     */
    _copyMap: {},
    
    /**
     * コピーマップを取得する
     * 
     * @return {Hash} コピーマップ
     */
    getCopyMap: function () {
        return this._copyMap;
    },

    /**
     * コピーマップを設定する
     * 
     * @param {Hash} copyMap コピーマップ
     * @return {Jeeel.Filter.CopyKey} 自インスタンス
     */
    setCopyMap: function (copyMap) {
        this._copyMap = copyMap;

        return this;
    },

    /**
     * @private
     */
    _filter: function () {
        throw new Error('valは配列・連想配列でなければなりません。');
    },

    /**
     * @private
     */
    _filterArray: function (vals) {
      
        var res = {};
        var map = this.getCopyMap();

        Jeeel.Hash.forEach(vals,
            function (val, key) {

                if ( ! (key in res)) {
                    res[key] = val;
                }

                if (key in map) {
                    if ( ! Jeeel.Type.isHash(map[key])) {
                        map[key] = [map[key]];
                    }

                    Jeeel.Hash.forEach(map[key],
                        function (copyKey) {
                            res[copyKey] = val;
                        }
                    );
                }
            }
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.CopyKey, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class フィルタ対象の配列内の指定したキーを削除する
 * @augments Jeeel.Filter.Abstract
 * @param {String[]} [deleteKeys] 削除キーのリスト
 */
Jeeel.Filter.DeleteKey = function (deleteKeys) {
    Jeeel.Filter.Abstract.call(this);
  
    this._deleteKeys = deleteKeys || [];
};

/**
 * インスタンスを作成して返す
 *
 * @param {String[]} [deleteKeys] 削除キーのリスト
 * @return {Jeeel.Filter.DeleteKey} 作成したインスタンス
 */
Jeeel.Filter.DeleteKey.create = function (deleteKeys) {
    return new this(deleteKeys);
};

Jeeel.Filter.DeleteKey.prototype = {
  
    /**
     * 削除キーリスト
     * 
     * @type String[]
     * @private
     */
    _deleteKeys: [],
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('valは配列・連想配列でなければなりません。');
    },

    /**
     * @private
     */
    _filterArray: function (vals) {
        var res = {};

        Jeeel.Hash.forEach(vals,
            function (val, key) {

                if ( ! Jeeel.Type.inArray(key, this._deleteKeys)) {
                    res[key] = val;
                }
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.DeleteKey, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 指定した値を他の値に変換して新たな値を返す
 * @augments Jeeel.Filter.Abstract
 * @param {Function} callback 値を変換するコールバックメソッド(1番目の引数に値、二番目の引数はHash形式の値を対象にした場合のキー)<br />
 *                             Mixied callback(Mixied value, String Key)
 */
Jeeel.Filter.Map = function (callback) {
    Jeeel.Filter.Abstract.call(this);
  
    this._callback = callback;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Function} callback 値を変換するコールバックメソッド(1番目の引数に値、二番目の引数はHash形式の値を対象にした場合のキー)<br />
 *                             Mixied callback(Mixied value, String Key)
 * @return {Jeeel.Filter.Html.Hidden} 作成したインスタンス
 */
Jeeel.Filter.Map.create = function (callback) {
    return new this(callback);
};

Jeeel.Filter.Map.prototype = {
    
    /**
     * 値を変換するコールバックメソッド(1番目の引数に値、二番目の引数はHash形式の値を対象にした場合のキー)
     * 
     * @type Function Mixied callback(Mixied value, String Key)
     */
    _callback: null,
    
    /**
     * @private
     */
    _filter: function (val, key) {
        return this._callback(val, key);
    },
    
    /**
     * @private
     */
    _filterArray: function (vals) {
        var res = {};
        
        Jeeel.Hash.forEach(vals,
            function (val, key) {
                res[key] = this._filter(val, key);
            }, this
        );
          
        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Map, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Filter.Cast = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Filter + 'Cast/';
    }
};

/**
 * キャスト系のネームスペース
 */
Jeeel.Filter.Cast = {
    
};

Jeeel.file.Jeeel.Filter.Cast = ['Number', 'String'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter.Cast, Jeeel.file.Jeeel.Filter.Cast);

/**
 * コンストラクタ
 * 
 * @class Numberにキャストするフィルター
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Cast.Number = function () {
    Jeeel.Filter.Abstract.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Filter.Cast.Number} 作成したインスタンス
 */
Jeeel.Filter.Cast.Number.create = function () {
    return new this();
};

Jeeel.Filter.Cast.Number.prototype = {
  
    /**
     * @private
     */
    _filter: function (val) {
        return +val;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Cast.Number, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class Stringにキャストするフィルター
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Cast.String = function () {
    Jeeel.Filter.Abstract.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Filter.Cast.String} 作成したインスタンス
 */
Jeeel.Filter.Cast.String.create = function () {
    return new this();
};

Jeeel.Filter.Cast.String.prototype = {
  
    /**
     * @private
     */
    _filter: function (val) {
        return '' + val;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Cast.String, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Filter.Array = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Filter + 'Array/';
    }
};

/**
 * 配列・連想配列関連のフィルター管理ネームスペース
 */
Jeeel.Filter.Array = {

};

Jeeel.file.Jeeel.Filter.Array = ['Reduce', 'Bundle', 'Key', 'Flat', 'KeySpecify', 'Fill', 'Unique', 'Difference'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter.Array, Jeeel.file.Jeeel.Filter.Array);

/**
 * コンストラクタ
 * 
 * @class 指定したキーのリストを作成する
 * @augments Jeeel.Filter.Abstract
 * @param {String} key リスト化したい値を保持するキー
 * @param {String} [hashKey] リスト化した際のキーに持たせたい値を保持するキー
 */
Jeeel.Filter.Array.Reduce = function (key, hashKey) {
    Jeeel.Filter.Abstract.call(this);
   
   this._key = key;
   this._hashKey = hashKey;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} key リスト化したい値を保持するキー
 * @param {String} [hashKey] リスト化した際のキーに持たせたい値を保持するキー
 * @return {Jeeel.Filter.Array.Reduce} 作成したインスタンス
 */
Jeeel.Filter.Array.Reduce.create = function (key, hashKey) {
    return new this(key, hashKey);
};

Jeeel.Filter.Array.Reduce.prototype = {
    
    /**
     * リスト化したい値を保持するキー
     * 
     * @type String
     * @private
     */
    _key: null,
    
    /**
     * リスト化した際のキーに持たせたい値を保持するキー
     * 
     * @type String
     * @private
     */
    _hashKey: null,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('valは配列・連想配列でなければなりません。');
    },

    /**
     * @private
     */
    _filterArray: function (val) {
        var res = {};

        Jeeel.Hash.forEach(val,
            function (row, rowKey) {

                if ( ! (this._key in row)) {
                    throw new Error('valには' + this._key + '要素がありません。');
                }

                if (this._hashKey) {
                    if ( ! (this._hashKey in row)) {
                        throw new Error('valには' + this._hashKey + 'がありません。');
                    }

                    res[row[this._hashKey]] = row[this._key];
                    return;
                }

                res[rowKey] = row[this._key];
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Array.Reduce, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class 多次元配列をあるキーで纏めるフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} key バンドルするキー
 */
Jeeel.Filter.Array.Bundle = function (key) {
    Jeeel.Filter.Abstract.call(this);
    
    this._key = key;
};

/**
 * インスタンスの作成
 *
 * @param {String} key バンドルするキー
 * @return {Jeeel.Filter.Array.Bundle} 作成したインスタンス
 */
Jeeel.Filter.Array.Bundle.create = function (key) {
    return new this(key);
};

Jeeel.Filter.Array.Bundle.prototype = {
    
    /**
     * バンドルキー
     * 
     * @type String
     * @private
     */
    _key: null,
    
    /**
     * @private
     */
    _filter: function (array) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (array) {
        var res = {};
        
        Jeeel.Hash.forEach(array,
            function (val, arrayKey) {
                if ( ! (this._key in val)) {
                    throw new Error('valには' + this._key + '要素がありません');
                }

                if ( ! (res[val[this._key]])) {
                    res[val[this._key]] = {};
                }
                
                res[val[this._key]][arrayKey] = val;
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Array.Bundle, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class あるキーについて調べ、そのキーの値が指定値以外だった場合排除するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} key キー
 * @param {Hash} allowList 許可値リスト
 * @throws {Error} allowListが配列式でない場合に起こる
 */
Jeeel.Filter.Array.Key = function (key, allowList) {

    Jeeel.Filter.Abstract.call(this);
    
    if ( ! Jeeel.Type.isHash(allowList)) {
        throw new Error('allowListは配列式でなければなりません。');
    }

    this._key = key;
    this._allowList = allowList;
};

/**
 * インスタンスの作成
 *
 * @param {String} key キー
 * @param {Hash} allowList 許可値リスト
 * @return {Jeeel.Filter.Array.Key} 作成したインスタンス
 */
Jeeel.Filter.Array.Key.create = function (key, allowList) {
    return new this(key, allowList);
};

Jeeel.Filter.Array.Key.prototype = {
    
    /**
     * キー
     * 
     * @type String
     * @private
     */
    _key: null,
    
    /**
     * 許可値リスト
     * 
     * @type Hash
     * @private
     */
    _allowList: [],
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (array) {

        var res = {};

        Jeeel.Hash.forEach(array,
            function (row, rowKey) {

                var allow = false;

                if ( ! (this._key in row)) {
                    throw new Error("この配列には " + this._key + " が含まれていません。");
                }

                Jeeel.Hash.forEach(row,
                    function (val, key) {
                        if (key === this._key) {
                            allow = Jeeel.Type.inArray(val, this._allowList);
                           return Jeeel.Hash.FOR_EACH_EXIT;
                        }
                    }, this
                );

                if (allow) {
                    res[rowKey] = row;
                }
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Array.Key, Jeeel.Filter.Abstract);
/**
 * コンストラクタ
 *
 * @class 配列の階層を減らすフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {Integer} from 階層を減らす階層の深さの始め
 * @param {Integer} length 階層を減らす回数
 * @throws {Error} fromが整数でない場合に起こる
 * @throws {Error} lengthが整数でない場合に起こる
 */
Jeeel.Filter.Array.Flat = function (from, length) {

    Jeeel.Filter.Abstract.call(this);
    
    if ( ! Jeeel.Type.isInteger(from)) {
        throw new Error('fromは整数でなければなりません。');
    }

    if ( ! Jeeel.Type.isInteger(length)) {
        throw new Error('lengthは整数でなければなりません。');
    }

    this._from = from;
    this._length = length;
};

/**
 * インスタンスの作成
 *
 * @param {Integer} from 階層を減らす階層の深さの始め
 * @param {Integer} length 階層を減らす回数
 * @return {Jeeel.Filter.Array.Flat} 作成したインスタンス
 */
Jeeel.Filter.Array.Flat.create = function (from, length) {
    return new this(from, length);
};

Jeeel.Filter.Array.Flat.prototype = {
    
    /**
     * 階層を減らす階層の深さの始め
     * 
     * @type Integer
     * @private
     */
    _from: 0,
    
    /**
     * 階層を減らす回数
     * 
     * @type Integer
     * @private
     */
    _length: 0,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (rows) {
        var result = this._arrayWhile(0, rows);

        return result;
    },
    
    /**
     * @private
     */
    _push: function (hash, value) {
        var cnt = 0;

        while (true) {
            if ( ! (cnt in hash)) {
                hash[cnt] = value;
                break;
            }

            cnt++;
        }
    },

    /**
     * @private
     */
    _arrayWhile: function (count, array) {

        if ( ! Jeeel.Type.isHash(array) || this._length === (count - this._from)) {
            return array;
        }

        if (count >= this._from) {
            var res = {};

            Jeeel.Hash.forEach(array,
                function (val) {
                    if (Jeeel.Type.isHash(val)) {
                        res = Jeeel.Hash.merge(res, this._arrayWhile(count + 1, val));
                    } else {
                        this._push(res, val);
                    }
                }, this
            );

            array = res;
        } else {
            Jeeel.Hash.forEach(array,
                function (val, key) {
                    if (Jeeel.Type.isHash(val)) {
                        array[key] = this._arrayWhile(count + 1, val);
                    }
                }, this
            );
        }

        return array;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Array.Flat, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 指定した内部キーの値をリストの固有キーにする
 * @augments Jeeel.Filter.Abstract
 * @param {String} key キー
 */
Jeeel.Filter.Array.KeySpecify = function (key) {
  
    Jeeel.Filter.Abstract.call(this);

    this._key = key;
};

/**
 * インスタンスの作成
 *
 * @param {String} key キー
 * @return {Jeeel.Filter.Array.KeySpecify} 作成したインスタンス
 */
Jeeel.Filter.Array.KeySpecify.create = function (key) {
    return new this(key);
};

Jeeel.Filter.Array.KeySpecify.prototype = {
    
    /**
     * キー
     * 
     * @type String
     * @private
     */
    _key: null,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (array) {

        var res = {};

        Jeeel.Hash.forEach(array,
            function (row) {
                res[row[this._key]] = row;
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Array.KeySpecify, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 指定したインデックスから指定要素数を指定値で埋めるフィルター(戻り値は配列なら配列、連想配列なら連想配列になる)
 * @augments Jeeel.Filter.Abstract
 * @param {Integer} index 開始インデックス
 * @param {Integer} length 挿入要素数
 * @param {Mixied} [value] 挿入値(デフォルトはnull)
 * @throws {Error} indexが整数でない場合に起こる
 * @throws {Error} lengthが整数でない場合に起こる
 */
Jeeel.Filter.Array.Fill = function (index, length, value) {
    Jeeel.Filter.Abstract.call(this);
    
    if ( ! Jeeel.Type.isInteger(index)) {
        throw new Error('indexが整数ではありません。');
    } else if ( ! Jeeel.Type.isInteger(length)) {
        throw new Error('lengthが整数ではありません。');
    }

    this._index = index;
    this._length = length + index;
    this._value = value || null;
};

/**
 * インスタンスの作成
 *
 * @param {Integer} index 開始インデックス
 * @param {Integer} length 挿入要素数
 * @param {Mixied} [value] 挿入値(デフォルトはnull)
 * @return {Jeeel.Filter.Array.Fill} 作成したインスタンス
 */
Jeeel.Filter.Array.Fill.create = function (index, length, value) {
    return new this(index, length, value);
};

Jeeel.Filter.Array.Fill.prototype = {
    
    /**
     * 開始インデックス
     * 
     * @type Integer
     * @private
     */
    _index: 0,
    
    /**
     * 挿入要素数
     * 
     * @type Integer
     * @private
     */
    _length: 0,
    
    /**
     * 挿入値
     * 
     * @type Mixied
     * @private
     */
    _value: null,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (array) {
        var result = Jeeel.Method.clone(array);

        for (var i = this._index; i < this._length; i++) {
            result[i] = this._value;
        }

        return result;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Array.Fill, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 配列の重複する内部値を削除する
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [strict] 厳密な型チェックを行うかどうか
 * @param {Boolean} [toValues] キーを無視して値だけのリストにするかどうか(trueの場合は必ず配列が帰ってくるようになる)
 */
Jeeel.Filter.Array.Unique = function (strict, toValues) {

    Jeeel.Filter.Abstract.call(this);
    
    this._strict = !!strict;
    this._toValues = !!toValues;
};

/**
 * インスタンスの作成
 *
 * @param {Boolean} [strict] 厳密な型チェックを行うかどうか
 * @param {Boolean} [toValues] キーを無視して値だけのリストにするかどうか(trueの場合は必ず配列が帰ってくるようになる)
 * @return {Jeeel.Filter.Array.Unique} 作成したインスタンス
 */
Jeeel.Filter.Array.Unique.create = function (strict, toValues) {
    return new this(strict, toValues);
};

Jeeel.Filter.Array.Unique.prototype = {
    
    /**
     * 厳密な型チェックを行うかどうか
     * 
     * @type Boolean
     * @private
     */
    _strict: false,
    
    /**
     * キーを無視して値だけのリストにするかどうか
     * 
     * @type Boolean
     * @private
     */
    _toValues: false,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (array) {
      
        array = Jeeel.Hash.create(array);

        var res = Jeeel.Hash.create();

        array.forEach(
            function (val, key) {
                if (res.search(val, this._strict) === null) {
                    res.set(key, val);
                }
            }, this
        );

        return (this._toValues ? res.getValues() : res.getHash());
    }
};

Jeeel.Class.extend(Jeeel.Filter.Array.Unique, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class 配列の差分を取得するフィルター
 * @param {Hash} baseArray 比較元のHash
 */
Jeeel.Filter.Array.Difference = function (baseArray) {
    Jeeel.Filter.Abstract.call(this);
    
    this._baseArray = new Jeeel.Hash(baseArray);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Hash} baseArray 比較元のHash
 * @return {Jeeel.Filter.Array.Difference} 作成したインスタンス
 */
Jeeel.Filter.Array.Difference.create = function (baseArray) {
    return new this(baseArray);
};

Jeeel.Filter.Array.Difference.prototype = {
  
    /**
     * @type Jeeel.Hash
     * @private
     */
    _baseArray: null,
    
    /**
     * 対象のHashと比較を行い結果を返す
     * 
     * @param {Hash} targetArray 比較先のHash
     * @return {Object} 差分結果(baseに比較元にしか存在しない値、targetに比較先にしか存在しない値)
     */
    filter: function (targetArray) {
        return this._super.filter.call(this, targetArray);
    },
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (array) {
      
        array = new Jeeel.Hash(array);

        var res = {base: {}, target: {}};
        
        this._baseArray.forEach(
            function (val, key) {
                if (array.search(val, true) === null) {
                    res.base[key] = val;
                }
            }
        );

        array.forEach(
            function (val, key) {
                if (this._baseArray.search(val, true) === null) {
                    res.target[key] = val;
                }
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Array.Difference, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Filter.Url = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Filter + 'Url/';
    }
};

/**
 * Url関連のフィルター管理ネームスペース
 */
Jeeel.Filter.Url = {

};

Jeeel.file.Jeeel.Filter.Url = ['Escape', 'QueryString', 'QueryParameter'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter.Url, Jeeel.file.Jeeel.Filter.Url);
/**
 * コンストラクタ
 *
 * @class 値をGetやPostで送信できる形に変換する(非可逆変換)
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [useEncodeURIComponent] encodeURIComponentを使用するかどうか(デフォルトは使用しない)
 */
Jeeel.Filter.Url.Escape = function (useEncodeURIComponent) {

    Jeeel.Filter.Abstract.call(this);
    
    this._useEncodeURIComponent = !!useEncodeURIComponent;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [useEncodeURIComponent] encodeURIComponentを使用するかどうか(デフォルトは使用しない)
 * @return {Jeeel.Filter.Url.Escape} 作成したインスタンス
 */
Jeeel.Filter.Url.Escape.create = function (useEncodeURIComponent) {
    return new this(useEncodeURIComponent);
};

Jeeel.Filter.Url.Escape.prototype = {
  
    /**
     * encodeURIComponentを使用するかどうか
     * 
     * @type Boolean
     * @private
     */
    _useEncodeURIComponent: false,
  
    /**
     * @private
     */
    _filter: function (val) {
        var res;

        if (Jeeel.Type.isEmpty(val)) {
            res = '';
        } else if (Jeeel.Type.isBoolean(val)) {
            res = (val ? '1' : '');
        } else if (Jeeel.Type.isNumber(val)) {
            res = val.toString();
        } else {
            res = '' + val;
        }

        if (this._useEncodeURIComponent) {
            res = encodeURIComponent(res);
        }

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Url.Escape, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 連想配列をGetパラメータ用の形式にするフィルター(先頭の?はつかない)
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Url.QueryString = function () {
    Jeeel.Filter.Abstract.call(this);
};

/**
 * インスタンスの作成を行う
 *
 * @return {Jeeel.Filter.Url.QueryString} 作成したインスタンス
 */
Jeeel.Filter.Url.QueryString.create = function () {
    return new this();
};

Jeeel.Filter.Url.QueryString.prototype = {
    _sFilter: Jeeel.Filter.Url.Escape.create(true),
    
    _filter: function () {
        throw new Error('valは配列式でなければなりません。');
    },

    _filterArray: function (params) {
        var tmp, res = [];

        for (var key in params) {
            tmp = this._getParams(key, params[key], res.length === 0);
            
            if (tmp) {
                res[res.length] = tmp;
            }
        }

        return res.join('');
    },
    
    _getParams: function (parent, vals, first) {
        if ( ! Jeeel.Type.isHash(vals)) {
            return (first ? '' : '&') + parent + '=' + this._sFilter.filter(vals);
        }

        var tmp, res = [];

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                var nextParent;

                if (parent) {
                    nextParent = parent + '[' + key + ']';
                } else {
                    nextParent = key;
                }
                
                tmp = this._getParams(nextParent, val, first);

                if (tmp) {
                    res[res.length] = tmp;

                    first = false;
                }
            }, this
        );

        return res.join('');
    }
};

Jeeel.Class.extend(Jeeel.Filter.Url.QueryString, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class Getパラメータの形式の文字列を連想配列に変換するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} [overwriteName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
 */
Jeeel.Filter.Url.QueryParameter = function (overwriteName) {
    Jeeel.Filter.Abstract.call(this);
    
    this._overwriteName = overwriteName || null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} [overwriteName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
 * @return {Jeeel.Filter.Url.QueryParameter} 作成したインスタンス
 */
Jeeel.Filter.Url.QueryParameter.create = function (overwriteName) {
    return new this(overwriteName);
};

Jeeel.Filter.Url.QueryParameter.prototype = {
    
    _overwriteName: null,
    
    _avoidValues: [],
    
    /**
     * @private
     */
    _filter: function (params) {

        if ( ! Jeeel.Type.isString(params) || params.length === 0) {
            return {};
        }

        if (params.charAt(0) === '?') {
            params = params.substring(1, params.length);
        }

        params = params.split('&');
        
        this._avoidValues = [];
        
        var i, l, pair, res = {};
        
        for (i = 0, l = params.length; i < l; i++) {
            pair = params[i].split('=');

            if (pair.length === 2) {
                this._setParams(res, pair[0], pair[1]);
            }
        }
        
        if (this._overwriteName) {
            res[this._overwriteName] = this._avoidValues;
        }

        return res;
    },
    
    _getName: Jeeel._Object.JeeelFilter.getInputName,
    
    _repairName: Jeeel._Object.JeeelFilter.repairInputName,
    
    _repairValue: function (name, hash) {
        if ( ! Jeeel.Type.isHash(hash)) {
            return new Jeeel.Object.Item(name, hash);
        }

        var tmp, res = [];

        for (var key in hash) {
            var nextParent, 
                val = hash[key];

            if (name) {
                nextParent = name + '[' + key + ']';
            } else {
                nextParent = key;
            }

            tmp = this._repairValue(nextParent, val);

            if (tmp) {
                res = res.concat(tmp);
            }
        }

        return res;
    },
    
    _setParams: function (res, name, value) {
        var key, names = this._getName(name);

        for (var i = 0, l = names.length; i < l; i++) {

            if (key) {
                res = res[key];
            }

            key = names[i] || this._getMaxCount(res);

            if (i < l -1) {
                if (typeof res[key] === 'string') {
                    this._avoidValues[this._avoidValues.length] = new Jeeel.Object.Item(this._repairName(names.slice(0, i + 1)), res[key]);
                      
                    res[key] = {};
                } else if ( ! (key in res)) {
                    res[key] = {};
                }
            }
        }
        
        if (key in res) {
            this._avoidValues = this._avoidValues.concat(this._repairValue(name, res[key]));
        }

        res[key] = decodeURIComponent(value);
    },
    
    _getMaxCount: function (res) {
        var cnt = null;

        for (var key in res) {

            var digit = +key;

            if (Jeeel.Type.isInteger(digit) && (cnt === null || digit > cnt)) {
                cnt = digit;
            }
        }

        return (cnt === null ? 0 : cnt + 1);
    }
};

Jeeel.Class.extend(Jeeel.Filter.Url.QueryParameter, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Filter.Html = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Filter + 'Html/';
    }
};

/**
 * Html関連のフィルター管理ネームスペース
 */
Jeeel.Filter.Html = {

};

Jeeel.file.Jeeel.Filter.Html = ['Escape', 'Unescape', 'Form', 'FormValue', 'Hidden', 'HiddenString', 'ElementTagBundle', 'ElementAttributeReduce'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter.Html, Jeeel.file.Jeeel.Filter.Html);

/**
 * コンストラクタ
 *
 * @class HTML内で使用できない文字を特殊文字にエスケープするフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [replaceSpaceAndLineFeed] 改行とスペースを置き換えるかどうか(デフォルトは置き換えない)
 */
Jeeel.Filter.Html.Escape = function (replaceSpaceAndLineFeed) {
    Jeeel.Filter.Abstract.call(this);
    
    this._replaceSpaceAndLineFeed = !!replaceSpaceAndLineFeed;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [replaceSpaceAndLineFeed] 改行とスペースを置き換えるかどうか(デフォルトは置き換えない)
 * @return {Jeeel.Filter.Html.Escape} 作成したインスタンス
 */
Jeeel.Filter.Html.Escape.create = function (replaceSpaceAndLineFeed) {
    return new this(replaceSpaceAndLineFeed);
};

Jeeel.Filter.Html.Escape.prototype = {
  
    /**
     * 改行とスペースを置き換えるかどうか
     * 
     * @type Boolean
     * @private
     */
    _replaceSpaceAndLineFeed: false,
    
    _filter: function (val) {
        val = '' + val;

        val = val.replace(/&/g, '&amp;')
                 .replace(/"/g, '&quot;')
                 .replace(/</g, '&lt;')
                 .replace(/>/g, '&gt;');

        if (this._replaceSpaceAndLineFeed) {
            val = val.replace(/ /g, '&nbsp;')
                     .replace(/\n/g, '<br />');
        }

        return val;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.Escape, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class HTML内の特殊文字にを元に戻すフィルター(全てを全て置き換える訳ではない)
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [replaceSpaceAndLineFeed] 改行とスペースを置き換えるかどうか(デフォルトは置き換えない)
 */
Jeeel.Filter.Html.Unescape = function (replaceSpaceAndLineFeed) {

    Jeeel.Filter.Abstract.call(this);
    
    this._replaceSpaceAndLineFeed = !!replaceSpaceAndLineFeed;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [replaceSpaceAndLineFeed] 改行とスペースを置き換えるかどうか(デフォルトは置き換えない)
 * @return {Jeeel.Filter.Html.Unescape} 作成したインスタンス
 */
Jeeel.Filter.Html.Unescape.create = function (replaceSpaceAndLineFeed) {
    return new this(replaceSpaceAndLineFeed);
};

Jeeel.Filter.Html.Unescape.prototype = {

    /**
     * 改行とスペースを置き換えるかどうか
     * 
     * @type Boolean
     * @private
     */
    _replaceSpaceAndLineFeed: false,
  
    _filter: function (val) {
        val = '' + val;

        val = val.replace(/&amp;|&#38;|&#x26;/g, '&')
                 .replace(/&quot;|&#34;|&#x22;/g, '"')
                 .replace(/&lt;|&#60;|&#x3C;/g, '<')
                 .replace(/&gt;|&#62;|&#x3E;/g, '>');

        if (this._replaceSpaceAndLineFeed) {
            val = val.replace(/&nbsp;|&#160;|&#xA0;/g, ' ')
                     .replace(/<br *(\/)?>/g, '\n');
        }

        return val;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.Unescape, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class Html要素毎に内部のinputをまとめあげる(送信時のパラメータのようにnameで区分け)<br />
 *         その際radioボタンは強制的にリストになる
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [useDefaultValue] trueにすると現在値でなくデフォルト値を参照して纏め上げる
 * @param {String} [unknownName] 名前のついていないinputに使用する名前(デフォルトは無視する)
 * @param {String} [overwrittenName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はElement[]になる)
 */
Jeeel.Filter.Html.Form = function (useDefaultValue, unknownName, overwrittenName) {

    Jeeel.Filter.Abstract.call(this);
    
    this._useDefaultValue = !!useDefaultValue;
    
    if (unknownName) {
        this._unknownName = unknownName + '[]';
    }
    
    this._overwrittenName = overwrittenName || null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [useDefaultValue] trueにすると現在値でなくデフォルト値を参照して纏め上げる
 * @param {String} [unknownName] 名前のついていないinputに使用する名前(デフォルトは無視する)
 * @param {String} [overwrittenName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はElement[]になる)
 * @return {Jeeel.Filter.Html.Form} 作成したインスタンス
 */
Jeeel.Filter.Html.Form.create = function (useDefaultValue, unknownName, overwrittenName) {
    return new this(useDefaultValue, unknownName, overwrittenName);
};

Jeeel.Filter.Html.Form.prototype = {
  
    _useDefaultValue: false,
    
    _unknownName: '',
    
    _overwrittenName: null,
    
    _avoidValues: [],
    
    /**
     * @private
     */
    _filter: function (val) {
        if ( ! Jeeel.Type.isElement(val)) {
            throw new Error('Elementではない要素を含んでいます。');
        }

        var inputs = this._getInputs(val);

        var res = {}, name;
        
        this._avoidValues = [];
        
        for (var i = 0, l = inputs.length; i < l; i++) {

            name = this._getProp(inputs[i], 'name') || this._unknownName;

            if ( ! name) {
                continue;
            }

            this._setParams(res, name, inputs[i]);
        }
        
        if (this._overwrittenName) {
            res[this._overwrittenName] = this._avoidValues;
        }

        return res;
    },

    /**
     * @private
     */
    _filterArray: function (vals) {

        if (Jeeel.Type.isElement(vals)) {
            return this._filter(vals);
        }

        var res = {};

        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                res[key] = self._filter(val);
            }
        );

        return res;
    },
    
    _getInputs: Jeeel._Object.JeeelFilter.getInputs,

    _getName: Jeeel._Object.JeeelFilter.getInputName,
    
    _repairName: Jeeel._Object.JeeelFilter.repairInputName,
    
    _repairValue: function (hash) {
        if (Jeeel.Type.isElement(hash)) {
            return hash;
        }

        var tmp, res = [];

        for (var key in hash) {
            var val = hash[key];

            tmp = this._repairValue(val);

            if (tmp) {
                res = res.concat(tmp);
            }
        }

        return res;
    },
    
    _getProp: function (elm, propName) {
        if (this._useDefaultValue) {
            return elm.getAttribute(propName);
        }
        
        return elm[propName];
    },
    
    _setParams: function (res, name, element) {

        if (element.tagName.toUpperCase() === 'INPUT' && element.type.toLowerCase() === 'radio') {
            name = name + '[]';
        }

        var key, names = this._getName(name);

        for (var i = 0, l = names.length; i < l; i++) {
          
            if (key) {
                res = res[key];
            }

            key = names[i] || this._getMaxCount(res);

            if (i < l -1) {
                if (Jeeel.Type.isElement(res[key])) {
                    this._avoidValues[this._avoidValues.length] = new Jeeel.Object.Item(this._repairName(names.slice(0, i + 1)), res[key]);
                    
                    res[key] = {};
                } else if ( ! (key in res)) {
                    res[key] = {};
                }
            }
        }
        
        if (key in res) {
            this._avoidValues = this._avoidValues.concat(this._repairValue(res[key]));
        }
        
        res[key] = element;
    },
    
    _getMaxCount: function (res) {
        var cnt = null;

        for (var key in res) {

            var digit = +key;

            if (Jeeel.Type.isInteger(digit) && (cnt === null || digit > cnt)) {
                cnt = digit;
            }
        }

        return (cnt === null ? 0 : cnt + 1);
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.Form, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class Html要素毎に内部のinputの値をまとめあげる(送信時のパラメータのようにnameで区分け)<br />
 *         その際無効なinputは無視する(checkedが付いていないradioボタンやcheckbox、選択されていないselectbox)
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [useDefaultValue] trueにすると現在値でなくデフォルト値を参照して纏め上げる(値もデフォルト値になる)
 * @param {String} [unknownName] 名前のついていないinputに使用する名前(デフォルトは無視する)
 * @param {String} [overwrittenName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
 */
Jeeel.Filter.Html.FormValue = function (useDefaultValue, unknownName, overwrittenName) {

    Jeeel.Filter.Abstract.call(this);
    
    this._useDefaultValue = !!useDefaultValue;
    
    if (unknownName) {
        this._unknownName = unknownName + '[]';
    }
    
    this._overwrittenName = overwrittenName || null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [useDefaultValue] trueにすると現在値でなくデフォルト値を参照して纏め上げる
 * @param {String} [unknownName] 名前のついていないinputに使用する名前(デフォルトは無視する)
 * @param {String} [overwrittenName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
 * @return {Jeeel.Filter.Html.FormValue} 作成したインスタンス
 */
Jeeel.Filter.Html.FormValue.create = function (useDefaultValue, unknownName, overwrittenName) {
    return new this(useDefaultValue, unknownName, overwrittenName);
};

Jeeel.Filter.Html.FormValue.prototype = {
    
    _useDefaultValue: false,
    
    _unknownName: '',
    
    _overwrittenName: null,
    
    _avoidValues: [],
    
    /**
     * @private
     */
    _filter: function (val) {
        if ( ! Jeeel.Type.isElement(val)) {
            throw new Error('Elementではない要素を含んでいます。');
        }

        var inputs = this._getInputs(val);
        
        var res = {}, name;
        
        this._avoidValues = [];
        
        for (var i = 0, l = inputs.length; i < l; i++) {
            name = this._getProp(inputs[i], 'name') || this._unknownName;

            if ( ! name) {
                continue;
            }

            this._setParams(res, name, inputs[i]);
        }
        
        if (this._overwrittenName) {
            res[this._overwrittenName] = this._avoidValues;
        }

        return res;
    },

    /**
     * @private
     */
    _filterArray: function (vals) {

        if (Jeeel.Type.isElement(vals)) {
            return this._filter(vals);
        }

        var res = {};

        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                res[key] = self._filter(val);
            }
        );

        return res;
    },
    
    _getInputs: Jeeel._Object.JeeelFilter.getInputs,
    
    _getName: Jeeel._Object.JeeelFilter.getInputName,
    
    _repairName: Jeeel._Object.JeeelFilter.repairInputName,
    
    _repairValue: function (name, hash) {
        if ( ! Jeeel.Type.isHash(hash)) {
            return new Jeeel.Object.Item(name, hash);
        }

        var tmp, res = [];

        for (var key in hash) {
            var nextParent, 
                val = hash[key];

            if (name) {
                nextParent = name + '[' + key + ']';
            } else {
                nextParent = key;
            }

            tmp = this._repairValue(nextParent, val);

            if (tmp) {
                res = res.concat(tmp);
            }
        }

        return res;
    },
    
    _getProp: function (elm, propName) {
        if (this._useDefaultValue) {
            if (propName === 'value') {
                var tag = elm.tagName.toUpperCase();
                
                if (tag === 'SELECT') {
                    var ops = elm.options;

                    for (var i = 0, l = ops.length; i < l; i++) {
                        if (ops[i].getAttribute('selected')) {
                            return ops[i].getAttribute(propName);
                        }
                    }

                    return l && ops[0].getAttribute(propName) || null;
                } else if (tag === 'INPUT') {
                    return elm.defaultValue;
                }
            }
            
            return elm.getAttribute(propName);
        }
        
        return elm[propName];
    },
    
    _setParams: function (res, name, element) {

        if (element.tagName.toUpperCase() === 'INPUT') {
            if (element.type.toLowerCase() === 'checkbox' && ! this._getProp(element, 'checked')) {
                return;
            } else if (element.type.toLowerCase() === 'radio' && ! this._getProp(element, 'checked')) {
                return;
            }
        } else if (element.tagName.toLowerCase() === 'select') {
            if (element.selectedIndex < 0) {
                return;
            }
        }

        var key, names = this._getName(name);

        for (var i = 0, l = names.length; i < l; i++) {
          
            if (key) {
                res = res[key];
            }

            key = names[i] || this._getMaxCount(res);

            if (i < l -1) {
                if (typeof res[key] === 'string') {
                    this._avoidValues[this._avoidValues.length] = new Jeeel.Object.Item(this._repairName(names.slice(0, i + 1)), res[key]);
                    
                    res[key] = {};
                } else if ( ! (key in res)) {
                    res[key] = {};
                }
            }
        }
        
        if (key in res) {
            this._avoidValues = this._avoidValues.concat(this._repairValue(name, res[key]));
        }
        
        res[key] = this._getProp(element, 'value');
    },
    
    _getMaxCount: function (res) {
        var cnt = null;

        for (var key in res) {

            var digit = +key;

            if (Jeeel.Type.isInteger(digit) && (cnt === null || digit > cnt)) {
                cnt = digit;
            }
        }

        return (cnt === null ? 0 : cnt + 1);
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.FormValue, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 配列値をhiddenタグに加工するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} [key] 特定のキーとしてまとめ上げたい場合に指定する
 */
Jeeel.Filter.Html.Hidden = function (key) {

    Jeeel.Filter.Abstract.call(this);
    
    this._key = key || null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} [key] 特定のキーとしてまとめ上げたい場合に指定する
 * @return {Jeeel.Filter.Html.Hidden} 作成したインスタンス
 */
Jeeel.Filter.Html.Hidden.create = function (key) {
    return new this(key);
};

Jeeel.Filter.Html.Hidden.prototype = {
    _key: null,
    
    _sFilter: new Jeeel.Filter.Url.Escape(),
    
    _filter: function (vals) {

        if (this._key) {
            return this._makeHiddenString(this._key, vals);
        }

        throw new Error('keyを作成時に指定せずに配列式が使えない値に対しては対応していません。');
    },

    _filterArray: function (vals) {

        if (this._key) {
            return this._scanArray(this._key, vals);
        }
        
        var res = [];

        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                val = this._scanArray(key, val);

                Jeeel.Hash.forEach(val,
                    function (v) {
                        res[res.length] = v;
                    }, self
                );
            }, self
        );

        return res;
    },

    _scanArray: function (origKey, a) {
        if ( ! Jeeel.Type.isHash(a)) {
            return [this._makeHiddenString(origKey, a)];
        }

        var self = this;

        var result = [];

        Jeeel.Hash.forEach(a,
            function (v0, k0) {

                var key = origKey + '[' + k0 + ']';

                if ( ! Jeeel.Type.isHash(v0)) {
                    result[result.length] = this._makeHiddenString(key, v0);
                    return;
                }

                var val = this._scanArray(key, v0);

                Jeeel.Hash.forEach(val,
                    function (v1) {
                        result[result.length] = v1;
                    }, self
                );
            }, self
        );

        return result;
    },

    _makeHiddenString: function (key, val) {
        var hidden = Jeeel.Document.createElement('input');

        hidden.type  = 'hidden';
        hidden.name  = key;
        hidden.value = this._sFilter.filter(val);

        return hidden;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.Hidden, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 配列値をhiddenタグのHTML文字列に加工するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} [key] 特定のキーとしてまとめ上げたい場合に指定する
 */
Jeeel.Filter.Html.HiddenString = function (key) {
    Jeeel.Filter.Abstract.call(this);
    
    this._key = key || null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} [key] 特定のキーとしてまとめ上げたい場合に指定する
 * @return {Jeeel.Filter.Html.HiddenString} 作成したインスタンス
 */
Jeeel.Filter.Html.HiddenString.create = function (key) {
    return new this(key);
};

Jeeel.Filter.Html.HiddenString.prototype = {
    _key: null,
    
    _mFilter: Jeeel.Filter.Chain.create().add(new Jeeel.Filter.Url.Escape())
                                       .add(new Jeeel.Filter.Html.Escape()),
  
    _filter: function (vals) {

        if (this._key) {
            return this._makeHiddenString(this._key, vals);
        }
        
        throw new Error('keyを作成時に指定せずに配列式が使えない値に対しては対応していません。');
    },

    _filterArray: function (vals) {

        if (this._key) {
            return this._scanArray(this._key, vals);
        }

        var res = [];
        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                val = this._scanArray(key, val);

                Jeeel.Hash.forEach(val,
                    function (v) {
                        res[res.length] = v;
                    }, self
                );
            }, self
        );

        return res;
    },

    _scanArray: function (origKey, a) {
        if ( ! Jeeel.Type.isHash(a)) {
            return [this._makeHiddenString(origKey, a)];
        }

        var self = this;

        var res = [];

        Jeeel.Hash.forEach(a,
            function (v0, k0) {

                var key = origKey + '[' + k0 + ']';

                if ( ! Jeeel.Type.isHash(v0)) {
                    res[res.length] = this._makeHiddenString(key, v0);
                    return;
                }

                var val = this._scanArray(key, v0);

                Jeeel.Hash.forEach(val,
                    function (v1) {
                        res[res.length] = v1;
                    }, self
                );
            }, self
        );

        return res;
    },

    _makeHiddenString: function (key, val) {
        val = this._mFilter.filter(val);
        return '<input type="hidden" name="' + key + '" value="' + val + '" />';
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.HiddenString, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class HTML要素のリストをタグ名にて纏め上げる
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Html.ElementTagBundle = function () {
    Jeeel.Filter.Abstract.call(this);
};

/**
 * インスタンスの作成を行う
 *
 * @return {Jeeel.Filter.Html.ElementTagBundle} 作成したインスタンス
 */
Jeeel.Filter.Html.ElementTagBundle.create = function () {
    return new this();
};

Jeeel.Filter.Html.ElementTagBundle.prototype = {
  
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列形式のオブジェクトにしか対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (vals) {

        var res = {};

        Jeeel.Hash.forEach(vals,
            function (val) {
                
                if ( ! Jeeel.Type.isElement(val)) {
                    throw new Error('このフィルターはHTML要素のリストのみにしか対応していません。');
                }

                var name = val.tagName.toLowerCase();

                if ( ! (name in res)) {
                    res[name] = [];
                }

                res[name].push(val);
            }
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.ElementTagBundle, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class HTML要素のリストから指定した属性の値をリスト化する
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Html.ElementAttributeReduce = function (attribute) {
    Jeeel.Filter.Abstract.call(this);
    
    this._attribute = attribute;
};

/**
 * インスタンスの作成を行う
 *
 * @return {Jeeel.Filter.Html.ElementAttributeReduce} 作成したインスタンス
 */
Jeeel.Filter.Html.ElementAttributeReduce.create = function (attribute) {
    return new this(attribute);
};

Jeeel.Filter.Html.ElementAttributeReduce.prototype = {
    _attribute: null,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列形式のオブジェクトにしか対応していません。');
    },

    /**
     * @private
     */
    _filterArray: function (vals) {

        var result = [];

        Jeeel.Hash.forEach(vals,
            function (val) {
                
                if ( ! Jeeel.Type.isElement(val)) {
                    throw new Error('このフィルターはHTML要素のリストのみにしか対応していません。');
                }

                var attr = val.getAttribute(this._attribute);

                result.push(attr);
            }, this
        );

        return result;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.ElementAttributeReduce, Jeeel.Filter.Abstract);

Jeeel.directory.Jeeel.Type = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Type/';
    }
};

/**
 * 型に関する関数や定数を保持するスタティッククラス
 */
Jeeel.Type = {

    /**
     * 指定した値の型を返す
     *
     * @param {Mixied} val 判定値
     * @return {String} 判定結果
     */
    getType: function (val) {

        var types = Jeeel.Type.ObjectType;
        var type;

        switch (Object.prototype.toString.call(val)) {
            case '[object Function]':
                type = types.FUNCTION;
                break;

            case '[object Array]':
                type = types.ARRAY;
                break;

            case '[object Boolean]':
                type = types.BOOLEAN;
                break;

            case '[object String]':
                type = types.STRING;
                break;

            case '[object RegExp]':
                type = types.REGULAR_EXPRESSION;
                break;

            case '[object Date]':
                type = types.DATE;
                break;

            case '[object Number]':
                type = types.NUMBER;
                break;
                
            case '[object Math]':
                type = types.MATH;
                break;
                
            case '[object JSON]':
                type = types.JSON;
                break;

            default:

                if (this.isNull(val)) {
                    type = types.NULL;
                }
                else if (this.isUndefined(val)) {
                    type = types.UNDEFINED;
                }
                else if (this.isElement(val)) {
                    type = types.ELEMENT;
                }
                else if (this.isAttribute(val)) {
                    type = types.ATTRIBUTE;
                }
                else if (this.isText(val)) {
                    type = types.TEXT;
                }
                else if (this.isComment(val)) {
                    type = types.COMMENT;
                }
                else if (this.isDocumentFragment(val)) {
                    type = types.DOCUMENT_FRAGMENT;
                }
                else if (this.isDocument(val)) {
                    type = types.DOCUMENT;
                }
                else if (this.isWindow(val)) {
                    type = types.WINDOW;
                }
                else if (this.isArguments(val)) {
                    type = types.ARGUMENTS;
                }
                else if (this.isEvent(val)) {
                    type = types.EVENT;
                }
                else if (this.isError(val)) {
                    type = types.ERROR;
                }
                else if (this.isStorage(val)) {
                    type = types.STORAGE;
                }
                else if (this.isPrototype(val)) {
                    type = types.PROTOTYPE;
                }
                else {
                    type = types.OBJECT;
                }
                break;
        }

        return type;
    },

    /**
     * オブジェクトが元々保持しているキーのリストを返す
     *
     * @param {String} type 型を示す文字列値(Jeeel.Type.ObjectType 参照)
     * @return {String[]} キーのリスト
     */
    getKeys: function (type) {

        var types  = Jeeel.Type.ObjectType;
        var obKeys = Jeeel.Type.ObjectKeys;
        var keys = [];

        switch (type) {
            case types.NULL:
            case types.UNDEFINED:
                return [];
                break;

            case types.ARRAY:
                keys = keys.concat(obKeys.ARRAY);
                break;

            case types.BOOLEAN:
                keys = keys.concat(obKeys.BOOLEAN);
                break;

            case types.STRING:
                keys = keys.concat(obKeys.STRING);
                break;

            case types.NUMBER:
                keys = keys.concat(obKeys.NUMBER);
                break;

            case types.FUNCTION:
                keys = keys.concat(obKeys.FUNCTION);
                break;

            case types.REGULAR_EXPRESSION:
                keys = keys.concat(obKeys.REGULAR_EXPRESSION);
                break;

            case types.DATE:
                keys = keys.concat(obKeys.DATE);
                break;

            case types.ELEMENT:
                keys = keys.concat(obKeys.ELEMENT);
                break;
                
            case types.ATTRIBUTE:
                keys = keys.concat(obKeys.ATTRIBUTE);
                break;

            case types.TEXT:
                keys = keys.concat(obKeys.TEXT);
                break;

            case types.COMMENT:
                keys = keys.concat(obKeys.COMMENT);
                break;

            case types.DOCUMENT_FRAGMENT:
                keys = keys.concat(obKeys.DOCUMENT_FRAGMENT);
                break;

            case types.DOCUMENT:
                keys = keys.concat(obKeys.DOCUMENT);
                break;

            case types.WINDOW:
                keys = keys.concat(obKeys.WINDOW);
                break;

            case types.ARGUMENTS:
                keys = keys.concat(obKeys.ARGUMENTS);
                break;

            case types.EVENT:
                keys = keys.concat(obKeys.EVENT);
                break;

            case types.ERROR:
                keys = keys.concat(obKeys.ERROR);
                break;
                
            case types.MATH:
                keys = keys.concat(obKeys.MATH);
                break;
                
            case types.JSON:
                keys = keys.concat(obKeys.JSON);
                break;

            case types.STORAGE:
                keys = keys.concat(obKeys.STORAGE);
                break;

            case types.PROTOTYPE:
                keys = keys.concat(obKeys.PROTOTYPE);
                break;

            case types.OBJECT:
                break;

            default:
                break;
        }

        if (type != types.PROTOTYPE) {
            keys = keys.concat(obKeys.OBJECT);
        }

        return keys;
    },

    /**
     * オブジェクト型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isObject: function (val) {
        return !!(val && Object.prototype.toString.call(val) === "[object Object]");
    },

    /**
     * オブジェクトのprototype型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isPrototype: function (val) {
        return (Object.prototype === val);
    },

    /**
     * 関数型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isFunction: function (val) {
        return (Object.prototype.toString.call(val) === "[object Function]");
    },

    /**
     * 配列型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isArray: function (val) {
        return (Object.prototype.toString.call(val) === "[object Array]");
    },

    /**
     * ハッシュかどうか返す(name[key]の形が扱えるもの)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isHash: function (val) {
        var type = typeof val;
        
        // NodeList, HTMLCollection, RegExpのインスタンスはブラウザによってはfunctionになるので回避
        return !!(val && (type === 'object' || type === 'function' && ! (val instanceof Function)));
    },

    /**
     * 配列のように扱えると思われるlengthプロパティを保持しているかどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    hasLength: function (val) {
        return !!(val && this.isInteger(val.length));
    },

    /**
     * 真偽値型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isBoolean: function (val) {
        return (Object.prototype.toString.call(val) === "[object Boolean]");
    },

    /**
     * 文字列型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isString: function (val) {
        return (Object.prototype.toString.call(val) === "[object String]");
    },

    /**
     * 正規表現型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isRegularExpression: function (val) {
        return (Object.prototype.toString.call(val) === "[object RegExp]");
    },

    /**
     * 日付型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDate: function (val) {
        return (Object.prototype.toString.call(val) === "[object Date]");
    },

    /**
     * 数値型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNumber: function (val) {
        return (Object.prototype.toString.call(val) === "[object Number]");
    },
    
    /**
     * 実数かどうかを返す(数値型で無限大・非数値以外だったらtrue)
     * 
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isRealNumber: function (val) {
        if ( ! this.isNumber(val)) {
            return false;
        } else if (typeof val === 'object') {
            val = +val;
        }
        
        if (isNaN(val) || val === -Infinity || val === Infinity) {
            return false;
        }
        
        return true;
    },

    /**
     * 整数型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isInteger: function (val) {
        if ( ! this.isNumber(val)) {
            return false;
        } else if (typeof val === 'object') {
            val = +val;
        }
        
        if (isNaN(val) || val === -Infinity || val === Infinity) {
            return false;
        }

        val = '' + val;

        if (val.indexOf('.') < 0) {
            return true;
        }

        return false;
    },

    /**
     * 小数型かどうかを返す(小数値の部分が0になった場合整数になるのでfalseとなる)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isFloat: function (val) {
        if ( ! this.isNumber(val)) {
            return false;
        } else if (typeof val === 'object') {
            val = +val;
        }
        
        if (isNaN(val) || val === -Infinity || val === Infinity) {
            return false;
        }

        val = '' + val;

        if (val.indexOf('.') < 0) {
            return false;
        }

        return true;
    },

    /**
     * 数値型もしくは数値文字列型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNumeric: function (val) {
        if ( ! val && val !== 0) {
            return false;
        }
      
        val = +val;
        
        return ! (isNaN(val) || val === -Infinity || val === Infinity);
    },

    /**
     * 整数値型もしくは整数値文字列型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDigit: function (val) {
        if ( ! val && val !== 0) {
            return false;
        }
        
        return this.isInteger(+val);
    },
    
    /**
     * 16進数を表している文字列かどうかを返す<br />
     * 先頭に - があっても良く、0xはついて無くても良い(なお0xは代わりに#でも良い)
     * 
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isHexadecimalNumber: function (val) {
        if ( ! this.isString(val)) {
            return false;
        }
        
        if (val.match(/^-?(0x|#)?[0-9a-fA-F]+$/)) {
            return true;
        }

        return false;
    },

    /**
     * 基本型かどうかを返す(真偽値・数値・文字列値・null・undefined)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isPrimitive: function (val) {
        return (this.isBoolean(val) || this.isNumber(val) || this.isString(val) || this.isEmpty(val));
    },

    /**
     * HTML要素コレクション型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isElementCollection: function (val) {
        if ( ! this.isHash(val)) {
            return false;
        }
        
        var member = ['length', 'item', 'namedItem'];

        for (var i = 0, l = member.length; i < l; i++) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },

    /**
     * Nodeリスト型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNodeList: function (val) {
        if ( ! this.isHash(val)) {
            return false;
        }
        
        var member = ['length', 'item'];

        for (var i = 0, l = member.length; i < l; i++) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },
    
    /**
     * Element型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isElement: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.ELEMENT_NODE);
    },
    
    /**
     * Attribute型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isAttribute: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.ATTRIBUTE_NODE);
    },

    /**
     * Text型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isText: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.TEXT_NODE);
    },
    
    /**
     * CDATASection型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isCDATASection: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.CDATA_SECTION_NODE);
    },
    
    /**
     * EntityReference型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEntityReference: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.ENTITY_REFERENCE_NODE);
    },
    
    /**
     * Entity型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEntity: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.ENTITY_NODE);
    },
    
    /**
     * ProcessingInstruction型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isProcessingInstruction: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.PROCESSING_INSTRUCTION_NODE);
    },

    /**
     * Comment型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isComment: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.COMMENT_NODE);
    },

    /**
     * Document型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDocument: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.DOCUMENT_NODE);
    },
    
    /**
     * DocumentType型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDocumentType: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.DOCUMENT_TYPE_NODE);
    },
    
    /**
     * DocumentFragment型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDocumentFragment: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.DOCUMENT_FRAGMENT_NODE);
    },
    
    /**
     * Notation型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNotation: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.NOTATION_NODE);
    },

    /**
     * Window型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isWindow: function (val) {
        if (typeof val !== 'object' || ! val) {
            return false;
        }
        
        var member = ['Object', 'Array', 'String', 'Number', 'Boolean', 'Function'];

        for (var i = 0, l = member.length; i < l; i++) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },

    /**
     * Event型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEvent: function (val) {
        if (typeof val !== 'object' || ! val) {
            return false;
        }
        
        var member;
        
        if ('reason' in val) {
            member = ['type', 'keyCode', 'shiftKey', 'ctrlKey', 'altKey', 'srcElement', 'reason'];
        } else {
            member = ['type', 'target', 'currentTarget'];
        }

        for (var i = member.length; i--;) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },

    /**
     * Error型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isError: function (val) {
        return (val instanceof Error) || (typeof DOMException !== "undefined" && val instanceof DOMException);
    },

    /**
     * Arguments型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isArguments: function (val) {
        if (typeof val !== 'object' || ! val) {
            return false;
        }
        
        var member = ['callee', 'length'];

        for (var i = 0, l = member.length; i < l; i++) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },
    
    /**
     * Math型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isMath: function (val) {
        return (Object.prototype.toString.call(val) === "[object Math]");
    },
    
    /**
     * JSON型かどうかを返す(Json文字列とは違う)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isJSON: function (val) {
        return (Object.prototype.toString.call(val) === "[object JSON]");
    },

    /**
     * Storage型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isStorage: function (val) {
        if (typeof val !== 'object' || ! val) {
            return false;
        }
        
        var member = ['key', 'getItem', 'setItem', 'removeItem', 'clear'];

        for (var i = 0, l = member.length; i < l; i++) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },

    /**
     * nullかどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNull: function (val) {
        return (val === null);
    },

    /**
     * 未定義かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isUndefined: function (val) {
        return (typeof val === 'undefined');
    },

    /**
     * 空変数かどうかを返す(nullまたはundefined)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEmpty: function (val) {
        return (this.isNull(val) || this.isUndefined(val));
    },

    /**
     * 変数がセットされているかかどうかを返す(undefinedでない)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isSet: function (val) {
        return (typeof val !== 'undefined');
    },

    /**
     * 指定した値が配列式型の中に存在するかどうかを返す
     *
     * @param {Mixied} val 判定値
     * @param {Hash} array 配列式型
     * @param {Boolean} [strict] 厳密に型のチェックをするかどうか
     * @return {Boolean} 判定結果
     * @throws {Error} arrayが配列式でない場合に起こる
     */
    inArray: function (val, array, strict) {
        var check = false;
        
        Jeeel.Hash.forEach(array,
            function (elm) {
                if (( ! strict && val == elm) || (strict && val === elm)) {
                    check = true;
                    return Jeeel.Hash.FOR_EACH_EXIT;
                }
            }
        );

        return check;
    },

    /**
     * 変数が配列式型で更に空であるかどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEmptyHash: function (val) {
        if ( ! this.isHash(val)) {
            return false;
        }

        var check = true;

        Jeeel.Hash.forEach(val,
            function () {
                check = false;
                return Jeeel.Hash.FOR_EACH_EXIT;
            }
        );

        return check;
    },

    /**
     * 指定したキーが配列式型に存在するかどうかを返す
     *
     * @param {String|Integer} key 判定値
     * @param {Hash} array 配列式型
     * @return {Boolean} 判定結果
     * @throws {TypeError} arrayが配列式でない場合に起こる
     */
    keyExists: function (key, array) {
        return key in array;
    }
};

Jeeel.file.Jeeel.Type = ['ObjectType', 'ObjectKeys'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Type, Jeeel.file.Jeeel.Type);

/**
 * オブジェクトの型の種類を示す列挙体
 */
Jeeel.Type.ObjectType = {
    /**
     * オブジェクト型を示す
     *
     * @type String
     * @constant
     */
    OBJECT: 'Object',

    /**
     * オブジェクトのprototype型を示す
     *
     * @type String
     * @constant
     */
    PROTOTYPE: 'Prototype',

    /**
     * Function型を示す
     *
     * @type String
     * @constant
     */
    FUNCTION: 'Function',

    /**
     * Array型を示す
     *
     * @type String
     * @constant
     */
    ARRAY: 'Array',

    /**
     * Arguments型を示す
     *
     * @type String
     * @constant
     */
    ARGUMENTS: 'Arguments',

    /**
     * Boolean型を示す
     *
     * @type String
     * @constant
     */
    BOOLEAN: 'Boolean',

    /**
     * String型を示す
     *
     * @type String
     * @constant
     */
    STRING: 'String',

    /**
     * RegExp型を示す
     *
     * @type String
     * @constant
     */
    REGULAR_EXPRESSION: 'RegularExpression',

    /**
     * Date型を示す
     *
     * @type String
     * @constant
     */
    DATE: 'Date',

    /**
     * Number型を示す
     *
     * @type String
     * @constant
     */
    NUMBER: 'Number',

    /**
     * Element型を示す
     *
     * @type String
     * @constant
     */
    ELEMENT: 'Element',
    
    /**
     * Attribute型を示す
     *
     * @type String
     * @constant
     */
    ATTRIBUTE: 'Attribute',

    /**
     * Text型を示す
     *
     * @type String
     * @constant
     */
    TEXT: 'Text',

    /**
     * Comment型を示す
     *
     * @type String
     * @constant
     */
    COMMENT: 'Comment',

    /**
     * DocumentFragment型を示す
     *
     * @type String
     * @constant
     */
    DOCUMENT_FRAGMENT: 'DocumentFragment',

    /**
     * Document型を示す
     *
     * @type String
     * @constant
     */
    DOCUMENT: 'Document',

    /**
     * Window型を示す
     *
     * @type String
     * @constant
     */
    WINDOW: 'Window',
    
    /**
     * Event型を示す
     *
     * @type String
     * @constant
     */
    EVENT: 'Event',

    /**
     * Error型を示す
     *
     * @type String
     * @constant
     */
    ERROR: 'Error',
    
    /**
     * Math型を示す
     *
     * @type String
     * @constant
     */
    MATH: 'Math',
    
    /**
     * JSON型を示す
     *
     * @type String
     * @constant
     */
    JSON: 'JSON',

    /**
     * Storage型を示す
     *
     * @type String
     * @constant
     */
    STORAGE: 'Storage',

    /**
     * nullを示す
     *
     * @type String
     * @constant
     */
    NULL: 'Null',

    /**
     * 未定義を示す
     *
     * @type String
     * @constant
     */
    UNDEFINED: 'Undefined'
};

/**
 * オブジェクトが元々保持しているキーのリストの列挙体
 */
Jeeel.Type.ObjectKeys = {

    /**
     * オブジェクト型のキーリスト
     *
     * @type String[]
     * @constant
     */
    OBJECT: (['toString', 'toLocaleString', 'valueOf', 'constructor', 'hasOwnProperty', 'propertyIsEnumerable', 'isPrototypeOf', '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__']).concat(({}).__proto__ ? ['__proto__'] : []),

    /**
     * オブジェクトのprototype型を示す
     *
     * @type String[]
     * @constant
     */
    PROTOTYPE: ['toString', 'toLocaleString', 'valueOf', 'constructor', 'hasOwnProperty', 'propertyIsEnumerable', 'isPrototypeOf', '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__'],

    /**
     * Function型のキーリスト
     *
     * @type String[]
     * @constant
     */
    FUNCTION: ['arguments', 'caller', 'length', 'name', 'prototype', 'call', 'apply', 'bind'],

    /**
     * Array型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ARRAY: ['length', 'concat', 'join', 'shift', 'unshift', 'push', 'pop', 'splice', 'slice', 'sort', 'reverse', 'indexOf', 'lastIndexOf', 'every', 'some', 'forEach', 'map', 'filter', 'reduce', 'reduceRight'],

    /**
     * Arguments型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ARGUMENTS: ['length', 'callee'],

    /**
     * Boolean型のキーリスト
     *
     * @type String[]
     * @constant
     */
    BOOLEAN: [],

    /**
     * String型のキーリスト
     *
     * @type String[]
     * @constant
     */
    STRING: ['length', 'charAt', 'substring', 'substr', 'slice', 'split', 'concat', 'replace', 'toUpperCase', 'toLowerCase', 'indexOf', 'lastIndexOf', 'match', 'search', 'charCodeAt', 'bold', 'italics', 'fixed', 'big', 'small', 'blink', 'strike', 'sup', 'sub', 'fontcolor', 'fontsize', 'anchor', 'link'],

    /**
     * RegExp型のキーリスト
     *
     * @type String[]
     * @constant
     */
    REGULAR_EXPRESSION: ['ignoreCase', 'global', 'source', 'exec', 'test', 'compile', 'lastIndex'],

    /**
     * Date型のキーリスト
     *
     * @type String[]
     * @constant
     */
    DATE: ['getFullYear', 'getYear', 'getMonth', 'getDate', 'getDay', 'getHours', 'getMinutes', 'getSeconds', 'getMilliseconds', 'setFullYear', 'setYear', 'setMonth', 'setDate', 'setHours', 'setMinutes', 'setSeconds', 'setMilliseconds', 'getUTCFullYear', 'getUTCYear', 'getUTCMonth', 'getUTCDate', 'getUTCDay', 'getUTCHours', 'getUTCMinutes', 'getUTCSeconds', 'getUTCMilliseconds', 'setUTCFullYear', 'setUTCYear', 'setUTCMonth', 'setUTCDate', 'setUTCHours', 'setUTCMinutes', 'setUTCSeconds', 'setUTCMilliseconds', 'getTime', 'setTime', 'toGMTString', 'toUTCString', 'toLocaleString', 'toString'],

    /**
     * Number型のキーリスト
     *
     * @type String[]
     * @constant
     */
    NUMBER: ['toString', 'toPrecision', 'toFixed', 'toExponential'],

    /**
     * Element型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ELEMENT: ['name', 'id', 'className', 'tagName', 'nodeName', 'nodeType', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'parentNode', 'children', 'childNodes', 'hasChildNodes', 'style', 'appendChild', 'removeChild', 'replaceChild', 'insertBefore', 'setAttribute', 'getAttribute', 'removeAttribute', 'blur', 'focus', 'cloneNode', 'tabIndex', 'innerHTML'],

    /**
     * Attribute型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ATTRIBUTE: ['name', 'value', 'childNodes', 'firstChild', 'lastChild', 'nodeName', 'nodeType'],
    
    /**
     * Text型のキーリスト
     *
     * @type String[]
     * @constant
     */
    TEXT: ['nodeName', 'nodeType', 'data'],

    /**
     * Comment型のキーリスト
     *
     * @type String[]
     * @constant
     */
    COMMENT: ['nodeName', 'nodeType', 'data'],

    /**
     * DocumentFragment型のキーリスト
     *
     * @type String[]
     * @constant
     */
    DOCUMENT_FRAGMENT: ['nodeName', 'nodeType', 'childNodes', 'appendChild', 'removeChild', 'firstChild', 'lastChild'],

    /**
     * Document型のキーリスト
     *
     * @type String[]
     * @constant
     */
    DOCUMENT: ['nodeType', 'getElementById', 'getElementsByName', 'getElementsByTagName', 'documentElement', 'body', 'childNodes', 'write', 'writeln', 'open', 'close', 'cookie', 'createElement', 'createTextNode', 'createDocumentFragment', 'createComment', 'createAttribute'],

    /**
     * Window型のキーリスト
     *
     * @type String[]
     * @constant
     */
    WINDOW: ['Object', 'Number', 'String', 'Boolean', 'Array', 'RegExp', 'Date', 'JSON', 'document', 'location', 'navigator', 'name', 'parent', 'self', 'postMessage', 'setTimeout', 'setInterval', 'alert', 'prompt', 'confirm', 'open', 'close', 'closed', 'showModalDialog'],

    /**
     * Event型のキーリスト
     *
     * @type String[]
     * @constant
     */
    EVENT: ['type'],

    /**
     * Error型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ERROR: ['name', 'message', 'toString'],
    
    /**
     * Math型のキーリスト
     *
     * @type String[]
     * @constant
     */
    MATH: ['PI', 'SQRT2', 'SQRT1_2', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'abs', 'max', 'min', 'ceil', 'floor', 'random', 'pow', 'exp', 'log', 'sqrt', 'sin', 'cos', 'tan', 'acos', 'asin', 'atan', 'atan2'],

    /**
     * JSON型のキーリスト
     *
     * @type String[]
     * @constant
     */
    JSON: ['parse', 'stringify'],
    
    /**
     * Storage型のキーリスト
     *
     * @type String[]
     * @constant
     */
    STORAGE: ['length', 'key', 'getItem', 'setItem', 'removeItem', 'clear']
};
Jeeel.directory.Jeeel.Method = {
    toString: function () {
        return Jeeel.directory.Jeeel + 'Method/';
    }
};

/**
 * 汎用的なメソッドを保持するネームスペース
 */
Jeeel.Method = {

};

Jeeel._Object.JeeelMethod = {

};

Jeeel.file.Jeeel.Method = ['Clone'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Method, Jeeel.file.Jeeel.Method);
/**
 * 指定した変数を複製して返す<br />
 * ただし比較の際型は違うものとしてとらえられる可能性がある<br />
 * なおコピー方法はシャローコピーであり内部変数までは複製しない
 *
 * @param {Mixied} value 複製する変数
 * @return {Mixied} 複製後の値
 */
Jeeel.Method.clone = function (value) {

    if (Jeeel.Type.isPrimitive(value)) {
        return value;
    } else if (Jeeel.Type.isArray(value)) {
        return (value.length === 1 ? [value[0]] : Array.apply(null, value));
    } else if (Jeeel.Type.isFunction(value)) {
        value = value.toString();
        
        if (value.match(/\{(\n|\s)+\[native code\](\n|\s)+\}/)) {
            return value;
        }
        
        eval('value = '+value);
        
        return value;
    }

    var newClass = function (){};

    newClass.prototype = value;

    return new newClass();
};

if (Jeeel._auto) {
    Jeeel._tmp();
}Jeeel.directory.Jeeel.Hash = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Hash/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 配列もしくは連想配列について複雑な処理をするクラス<br />
 *         そのままの連想配列やJeeel.Parameterよりも高速に連想配列にアクセス出来るが、初期化にかなりのロスを伴う
 * @param {Hash} [hash] 基となるHash
 */
Jeeel.Hash = function (hash) {
    this._init(hash);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Hash} [hash] 基となるHash
 * @return {Jeeel.Hash} 作成したインスタンス
 */
Jeeel.Hash.create = function (hash) {
    return new this(hash);
};

/**
 * Jeeel.Hash.forEachを途中で終了するための定数
 *
 * @type Object
 * @constant
 */
Jeeel.Hash.FOR_EACH_EXIT = {
    exit: true
};

Jeeel.Hash.prototype = {

    /**
     * 基のHash
     *
     * @type Hash
     */
    _hash: null,

    /**
     * Hashのキーリスト
     *
     * @type String[]
     */
    _keys: [],

    /**
     * Hashの値リスト
     *
     * @type Array
     */
    _vals: [],

    /**
     * Hashの値を全て数値に変更したリスト
     *
     * @type Number[]
     */
    _nums: null,

    /**
     * Hashの要素数
     *
     * @type Integer
     */
    _length: 0,
    
    /**
     * Hash内のキーの内最大の数値
     * 
     * @type Integer
     */
    _lastIndex: -1,
    
    /**
     * Hashの値を取得する
     * 
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 取得した値
     */
    get: function (key, defaultValue) {
        return (key in this._hash ? this._hash[key] : defaultValue);
    },
    
    /**
     * Hashに値を設定する
     * 
     * @param {String} key キー
     * @param {Mixed} val 保存する値
     * @return {Jeeel.Hash} 自インスタンス
     */
    set: function (key, val) {
        var c = ! (key in this._hash);
        
        this._hash[key] = val;
        
        if (c) {
            this._keys[this._length] = key;
            this._vals[this._length] = val;
            this._length++;
            
            this._nums = null;
            
            this._resetLastIndex(key, true);
        }

        return this;
    },
    
    /**
     * Hashの値を削除する
     * 
     * @param {String} key キー
     * @return {Jeeel.Hash} 自インスタンス
     */
    unset: function (key) {
        if (key in this._hash) {
            delete this._hash[key];
            var index, i;
            
            for (i = 0; i < this._length; i++) {
                if (this._keys[i] == key) {
                    index = i;
                    break;
                }
            }
            
            this._keys.splice(index, 1);
            this._vals.splice(index, 1);
            
            this._length--;
            
            this._nums = null;
            
            this._resetLastIndex(key);
        }

        return this;
    },
    
    /**
     * 指定したキーに対応するインデックスを取得する
     * 
     * @param {String} key キー
     * @return {Integer} インデックス
     */
    getIndex: function (key) {
        var index = -1;
        
        for (var i = 0; i < this._length; i++) {
            if (this._keys[i] == key) {
                index = i;
                break;
            }
        }
        
        return index;
    },
    
    /**
     * 指定したインデックスに対応するキーを取得する
     * 
     * @param {Integer} index インデックス
     * @return {String} キー
     */
    getKey: function (index) {
        return this._keys[index];
    },
    
    /**
     * 指定したインデックスに対応する値を取得する
     * 
     * @param {Integer} index インデックス
     * @return {Mixied} 取得した値
     */
    getValue: function (index) {
        return this._vals[index];
    },

    /**
     * Hashの要素数を返す
     *
     * @return {Integer} 要素数
     */
    getLength: function () {
        return this._length;
    },

    /**
     * 最初の値を取得する
     *
     * @return {Mixied} 取得した値
     */
    getFirst: function () {
        return this._vals[0];
    },

    /**
     * 最後の値を取得する
     *
     * @return {Mixied} 取得した値
     */
    getLast: function () {
        return this._vals[this._length - 1];
    },

    /**
     * 基のHashを返す
     *
     * @return {Hash} 基のHash
     */
    getHash: function () {
        return this._hash;
    },

    /**
     * Hashのキーのリストを作成して取得する
     *
     * @return {String[]} キーのリスト
     */
    getKeys: function () {
        return this._keys;
    },

    /**
     * Hashの値のリストを作成して取得する
     *
     * @return {Array} 値のリスト
     */
    getValues: function () {
        return this._vals;
    },
    
    /**
     * Hash内の値を全て数値と見立てて最大値を得る
     *
     * @return {Number} 最大値
     */
    getMax: function () {
        return Math.max.apply(null, this._getNums());
    },

    /**
     * Hash内の値を全て数値と見立てて最小値を得る
     *
     * @return {Number} 最小値
     */
    getMin: function () {
        return Math.min.apply(null, this._getNums());
    },

    /**
     * Hash内の値を全て数値と見立てて合計値を得る
     *
     * @return {Number} 合計値
     */
    getSum: function () {
        var nums = this._getNums();
        var sum  = 0;

        for (var i = nums.length; i--;) {
            sum += nums[i];
        }

        return sum;
    },

    /**
     * Hash内の値を全て数値と見立てて平均値を得る
     *
     * @return {Number} 平均値
     */
    getAvg: function () {
        return this.getSum() / this._length;
    },

    /**
     * 指定された関数を実行し、それらに合格した要素からなる新しいインスタンスを作成する
     *
     * @param {Function} callback Boolean callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    filter: function (callback, thisArg) {
        var res = {};
        
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        for (var i = 0; i < this._length; i++) {
            if (callback.call(thisArg, this._vals[i], this._keys[i], this._hash)) {
                res[this._keys[i]] = this._vals[i];
            }
        }

        return this.constructor.create(res);
    },

    /**
     * 指定された関数を実行し、それらの戻り値から新しいインスタンスを作成する
     *
     * @param {Function} callback Mixied callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    map: function (callback, thisArg) {
        var res = {};
        
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        for (var i = 0; i < this._length; i++) {
            res[this._keys[i]] = callback.call(thisArg, this._vals[i], this._keys[i], this._hash);
        }

        return this.constructor.create(res);
    },

    /**
     * 前の戻り値とHashの値を先頭から1つ引数に取り、<br />
     * 最終的にひとつの値を結果として得る<br />
     * 始めの時の戻り値には初期値もしくは先頭の値が来る(先頭の値の場合は引数に二番目の値が来る)
     * 
     * @param {Function} callback Mixied callback(Mixied tmp, Mixied val, String key, Hash hash)
     * @param {Mixied} [initVal] 初期値(指定しない場合は最初の値を使う)
     * @return {Mixied} 戻り値
     */
    reduce: function (callback, initVal) {
        if ( ! Jeeel.Type.isSet(initVal) && this._length <= 0) {
            throw new Error('空のHashに対して初期値未指定でReduceメソッドは使えません。');
        }

        var val;
        var min = 0;

        if (Jeeel.Type.isSet(initVal)) {
            val = initVal;
        } else {
            val = this._vals[0];
            min++;
        }

        for (var i = min; i < this._length; i++) {
            val = callback(val, this._vals[i], this._keys[i], this._hash);
        }

        return val;
    },

    /**
     * 前の戻り値とHashの値を後尾から1つ引数に取り、<br />
     * 最終的にひとつの値を結果として得る<br />
     * 始めの時の戻り値には初期値もしくは先頭の値が来る(先頭の値の場合は引数に二番目の値が来る)
     *
     * @param {Function} callback Mixied reduce(Mixied tmp, Mixied val, String key, Hash hash)
     * @param {Mixied} [initVal] 初期値(指定しない場合は最初の値を使う)
     * @return {Mixied} 戻り値
     */
    reduceRight: function (callback, initVal) {
        if ( ! Jeeel.Type.isSet(initVal) && this._length <= 0) {
            throw new Error('空のHashに対して初期値未指定でReduceRightメソッドは使えません。');
        }

        var val;
        var max = this._length - 1;

        if (Jeeel.Type.isSet(initVal)) {
            val = initVal;
        } else {
            val = this._vals[max];
            max--;
        }

        for (var i = max; i >= 0; i--) {
            val = callback(val, this._vals[i], this._keys[i], this._hash);
        }

        return val;
    },

    /**
     * 指定された関数を実行し、全ての要素がそれを合格するかどうかを返す
     *
     * @param {Function} callback Boolean callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Boolean} 全ての要素が合格したかどうか
     */
    every: function (callback, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        for (var i = 0; i < this._length; i++) {
            if ( ! callback.call(thisArg, this._vals[i], this._keys[i], this._hash)) {
                return false;
            }
        }

        return true;
    },

    /**
     * 指定された関数を実行し、それに合格する要素があるかどうかを返す
     *
     * @param {Function} callback Boolean callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Boolean} 合格する要素があるかどうか
     */
    some: function (callback, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        for (var i = 0; i < this._length; i++) {
            if (callback.call(thisArg, this._vals[i], this._keys[i], this._hash)) {
                return true;
            }
        }

        return false;
    },

    /**
     * 指定された関数を各要素に一度ずつ実行する
     *
     * @param {Function} callback void callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Jeeel.Hash} 自インスタンス
     */
    forEach: function (callback, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        for (var i = 0; i < this._length; i++) {
            callback.call(thisArg, this._vals[i], this._keys[i], this._hash);
        }

        return this;
    },
    
    /**
     * Hash内の要素が配列もしくはJeeel.Hashインスタンスだった場合は押しつぶして、1次元に変換して新しいインスタンスとして作成する<br />
     * その際キーは失われる
     *
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    flatten: function () {
        var res = [];
        
        var _flatten = function (arr) {
            for (var i = 0, l = arr.length; i < l; i++) {
                
                if (Jeeel.Type.isArray(arr[i])) {
                    _flatten(arr[i]);
                    continue;
                } else if(arr[i] instanceof this.constructor) {
                    _flatten(arr[i].getValues());
                    continue;
                }
                
                res[res.length] = arr[i];
            }
        };
        
        _flatten(this._vals);
        
        return new this.constructor(res);
    },
    
    /**
     * 指定したキー同士の値を交換する
     * 
     * @param {String} keyLeft キー1
     * @param {String} keyRight キー2
     * @return {Jeeel.Hash} 自インスタンス
     */
    swap: function (keyLeft, keyRight) {
        var left, right, both = 0;
        
        for (var i = 0; i < this._length; i++) {
            if (this._keys[i] == keyLeft) {
                left  = i;
                both++;
            } else if (this._keys[i] == keyRight) {
                right = i;
                both++;
            }
            
            if (both === 2) {
                break;
            }
        }
        
        return this.swapValue(left, right);
    },

    /**
     * 指定したインデックス同士の値を交換する
     * 
     * @param {Integer} left インデックス1
     * @param {Integer} right インデックス2
     * @return {Jeeel.Hash} 自インスタンス
     */
    swapValue: function (left, right) {
        if ( ! (0 <= left && left < this._length)) {
            return this;
        }
        else if ( ! (0 <= right && right < this._length)) {
            return this;
        }
        else if (left === right) {
            return this;
        }
        
        var key = this._keys[left];
        var val = this._vals[left];

        this._keys[left] = this._keys[right];
        this._vals[left] = this._vals[right];

        this._keys[right] = key;
        this._vals[right] = val;

        return this;
    },
    
    /**
     * Hash内から最後の要素を取り除き、<br />
     * その値を返す
     *
     * @return {Mixied} 取りだした値
     */
    pop: function () {
        if ( ! this._length) {
            return undefined;
        }
        
        this._length--;

        var key = this._keys.pop();
        var val = this._vals.pop();

        delete this._hash[key];

        this._nums = null;
        
        this._resetLastIndex(key);

        return val;
    },

    /**
     * 引数で受け取った値をHashの最後に挿入する
     *
     * @param {Mixied} var_args 挿入値の可変引数
     * @return {Integer} 挿入後の要素数
     */
    push: function (var_args) {
        var len = arguments.length;
        
        if ( ! len) {
            return this._length;
        }
        
        var max = this._lastIndex + 1;

        for (var i = 0; i < len; i++) {
            this._hash[max] = arguments[i];
            this._vals[this._length] = arguments[i];
            this._keys[this._length] = '' + max;

            max++;
            this._length++;
        }

        this._nums = null;
        this._lastIndex = max - 1;

        return this._length;
    },

    /**
     * Hash内の先頭の要素を取り除き、<br />
     * その値を返す
     *
     * @return {Mixied} 取りだした値
     */
    shift: function () {
        if ( ! this._length) {
            return undefined;
        }
        
        this._length--;

        var key = this._keys.shift();
        var val = this._vals.shift();

        delete this._hash[key];

        this._nums = null;
        
        this._resetLastIndex(key);

        return val;
    },

    /**
     * 引数で受け取った値をHashの先頭に挿入する
     *
     * @param {Mixied} var_args 挿入値の可変引数
     * @return {Integer} 挿入後の要素数
     */
    unshift: function (var_args) {
        var len = arguments.length;
        
        if ( ! len) {
            return this._length;
        }
        
        var li, i, keys = [], vals = [], repKeys = {};
        
        if (this._lastIndex >= 0) {
            for (i = this._lastIndex; i >= 0; i--) {
                if (i in this._hash) {
                    this._hash[i + len] = this._hash[i];
                    
                    repKeys[i] = '' + (i + len);
                    
                    if ( ! li) {
                        li = i + len;
                    }
                }
            }
        } else {
            li = len - 1;
        }
        
        for (i = 0; i < len; i++) {
            this._hash[i] = arguments[i];
            vals[i] = arguments[i];
            keys[i] = '' + i;
        }

        for (i = 0; i < this._length; i++) {
            vals[len + i] = this._vals[i];
            keys[len + i] = repKeys[this._keys[i]] || this._keys[i];
        }
        
        this._keys = keys;
        this._vals = vals;

        this._nums = null;
        
        if (li) {
            this._lastIndex = li;
        }

        return this._length += len;
    },
    
    /**
     * Hashの一部を取り出して新たにインスタンスを作成する
     * 
     * @param {Integer} [start] どこから取り出すかを示すインデックス<br />
     *                           負の数を指定した場合Hashの終わりからのオフセットを示す<br />
     *                           省略時は0
     * @param {Integer} [end] どこまで取りだすかを示すインデックス(この数値は含まない)<br />
     *                         負の数を指定した場合Hashの終わりからのオフセットを示す<br />
     *                         省略時はHashの最後まで
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    slice: function (start, end) {
        if ( ! Jeeel.Type.isInteger(start)) {
            start = 0;
        } else if (start < 0) {
            start = start + this._length;
            
            if (start < 0) {
                start = 0;
            }
        }
        
        if ( ! Jeeel.Type.isSet(end) || end > this._length) {
            end = this._length;
        } else if (end < 0) {
            end = end + this._length + 1;
        }
        
        return this._copy(start, end - 1);
    },

    /**
     * Hash内の古い要素を取り除き、代わりに新しい要素を挿入する
     * 
     * @param {Integer} index 配列を変化させ始めるインデックス
     * @param {Integer} [count] 配列から取り除く要素の数(省略はindex以降全ての要素)
     * @param {Mixied} var_args 追加要素の可変引数
     * @return {Array} 古い要素の配列
     */
    splice: function (index, count, var_args) {
        if ( ! Jeeel.Type.isInteger(index)) {
            return [];
        }
        
        if ( ! Jeeel.Type.isInteger(count)) {
            count = this._length;
        }
        
        var i, idx, ai = 2, li = -1;
        var len = index + count;
        var res = [], keys = [], vals = [];
        
        for (i = 0; i < index; i++) {
            keys[i] = this._keys[i];
            vals[i] = this._vals[i];
            
            idx = +keys[i];
            
            if (Jeeel.Type.isInteger(idx) && li < idx) {
                li = idx;
            }
        }
        
        for (i = index; i < len; i++) {
            res[res.length] = this._vals[i];
            
            if (ai in arguments) {
                keys[i] = this._keys[i];
                vals[i] = arguments[ai];
                
                idx = +keys[i];

                if (Jeeel.Type.isInteger(idx) && li < idx) {
                    li = idx;
                }
                
                this._hash[keys[i]] = vals[i];
                
                ai++;
            } else {
                delete this._hash[this._keys[i]];
            }
        }
        
        for (i = len; i < this._length; i++) {
            keys[keys.length] = this._keys[i];
            vals[vals.length] = this._vals[i];
            
            idx = +keys[i];
            
            if (Jeeel.Type.isInteger(idx) && li < idx) {
                li = idx;
            }
        }
        
        this._keys = keys;
        this._vals = vals;
        
        this._length = this._vals.length;
        
        this._nums = null;
        
        this._lastIndex = li;
        
        return res;
    },

    /**
     * 配列をソートする<br />
     * ソートアルゴリズムはクイックソート
     * 
     * @param {Function} [compareFunction] 比較関数(大きい数値の場合はaを優先、小さい数値の場合はbを優先、0は同値とする)<br />
     *                                      Integer compareFunction(Mixied a, Mixied b)
     * @return {Jeeel.Hash} 自インスタンス
     */
    sort: function (compareFunction) {
        if ( ! compareFunction ) {
            compareFunction = function (a, b) {
                a = '' + a;
                b = '' + b;
                
                return a > b ? 1 : (a < b ? -1 : 0);
            };
        }
        
        var middle = function (h, t) {
            return h + ((t - h) >>> 1);
        };

        var stack = [0, this._length - 1];
        
        while(stack.length) {
            var tail = stack.pop();
            var head = stack.pop();
            var pivot = this._vals[middle(head, tail)];
            var i = head - 1;
            var j = tail + 1;
            
            while (1) {
                while (i < tail && compareFunction(this._vals[++i], pivot) < 0);
                while (j > head && compareFunction(this._vals[--j], pivot) > 0);
                
                if (i >= j) break;
                
                this.swapValue(i, j);
            }
            
            if (head < i - 1) {stack.push(head);stack.push(i - 1);}
            if (j + 1 < tail) {stack.push(j + 1);stack.push(tail);}
        }
        
        return this;
    },

    /**
     * Hash内の要素をシャッフルする
     *
     * @return {Jeeel.Hash} 自インスタンス
     */
    shuffle: function () {
        var i = this._length;

        while(i) {
            var j = Math.floor(Math.random() * i);

            i--;

            if (i == j) {
                continue;
            }

            this.swapValue(i, j);
        }
        
        this._nums = null;

        return this;
    },

    /**
     * Hash内の並びを逆転させる
     *
     * @return {Jeeel.Hash} 自インスタンス
     */
    reverse: function () {

        this._keys.reverse();
        this._vals.reverse();
        this._nums = null;

        return this;
    },

    /**
     * Hashに他のインスタンス・配列や値を結合し新しいインスタンスとして返す<br />
     * その際キーは失われる
     * 
     * @param {Mixied} var_args 接続値の可変引数
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    concat: function (var_args) {
        var i, j, res = [];

        for (i = 0; i < this._length; i++) {
            res[i] = this._vals[i];
        }

        var len = arguments.length;
        var idx = this._length;
        var arg;
        
        for (i = 0; i < len; i++) {
            arg = arguments[i];
            
            if (arg instanceof this.constructor) {
                for (j = 0; j < arg._length; j++) {
                    res[idx++] = arg._vals[j];
                }
            }
            else if (Jeeel.Type.isArray(arg)) {
                for (j = 0; j < arg.length; j++) {
                    res[idx++] = arg[j];
                }
            } 
            else {
                res[idx++] = arg;
            }
        }

        return new this.constructor(res);
    },

    /**
     * Hash内の要素を全て繋げて文字列にする
     *
     * @param {String} [separator] 連結時の区切り文字列
     * @return {String} 連結文字列
     */
    join: function (separator) {
        if ( ! Jeeel.Type.isSet(separator)) {
            separator = ',';
        }

        return this._vals.join(separator);
    },
    
    /**
     * 指定した値をHash内で検索し、見つかった場合は対応するキーを返す
     *
     * @param {Mixied} searchValue 検索する値
     * @param {Boolean} [strict] 厳密な検索を行うかどうか
     * @return {String} 見つかった値に対応するキー(見つからなかった場合はnull)
     */
    search: function (searchValue, strict) {
        var len = this._length;
        
        for (var from = 0; from < len; from++) {
            if (strict && this._vals[from] === searchValue) {
                return this._keys[from];
            } else if ( ! strict && this._vals[from] == searchValue) {
                return this._keys[from];
            }
        }

        return null;
    },

    /**
     * 指定した値をHash内で検索し、見つかった場合は対応するインデックスを返す
     *
     * @param {Mixied} searchValue 検索する値
     * @param {Integer} [fromIndex] 検索を始める初期インデックス
     * @return {Integer} 見つかった値に対応するインデックス(見つからなかった場合は-1)
     */
    indexOf: function (searchValue, fromIndex) {
        var len = this._length;

        var from = Number(fromIndex) || 0;

        from = (from < 0 ? Math.ceil(from) : Math.floor(from));

        if (from < 0) {
            from += len;
        }

        for (; from < len; from++) {
            if (from in this._vals && this._vals[from] === searchValue) {
                return from;
            }
        }

        return -1;
    },
    
    /**
     * 指定した値をHash内で後ろから検索し、見つかった場合は対応するインデックスを返す
     *
     * @param {Mixied} searchValue 検索する値
     * @param {Integer} [fromIndex] 検索を始める初期インデックス
     * @return {Integer} 見つかった値に対応するインデックス(見つからなかった場合は-1)
     */
    lastIndexOf: function (searchValue, fromIndex) {
        var len = this.length;

        var from = Number(fromIndex);
        
        if (isNaN(from)) {
            from = len - 1;
        }
        else {
            from = (from < 0 ? Math.ceil(from) : Math.floor(from));

            if (from < 0) {
                from += len;
            }
            else if (from >= len) {
                from = len - 1;
            }
        }

        for (; from > -1; from--) {
            if (from in this._vals && this._vals[from] === searchValue) {
                return from;
            }
        }
        
        return -1;
    },

    /**
     * HashをGetパラメータ文字列に変換する(先頭に?はつかない)
     *
     * @return {String} Getパラメータ文字列
     */
    toQueryString: function () {
        return Jeeel.Filter.Url.QueryString.create().filter(this._hash);
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Hash} [hash] 基となるHash
     * @constructor
     */
    constructor: Jeeel.Hash,
    
    /**
     * 初期化を行う
     * 
     * @param {Hash} [hash] 基となるHash
     */
    _init: function (hash) {
        if ( ! Jeeel.Type.isHash(hash)) {
            hash = {};
        } else if (hash instanceof this.constructor) {
            hash = hash.getHash();
        } else if (hash instanceof Jeeel.Parameter) {
            hash = hash.getAll();
        }
        
        var keys = [], vals = [];
        
        if ('length' in hash && (Jeeel.Type.isArray(hash) || Jeeel.Type.isArguments(hash) || Jeeel.Type.isElementCollection(hash) || Jeeel.Type.isNodeList(hash))) {
            for (var i = 0, l = hash.length; i < l; i++) {
                keys[i] = '' + i;
                vals[i] = hash[i];
            }
            
            this._lastIndex = l - 1;
        } else {
            var max = -1;
            
            for (var key in hash) {
                keys[keys.length] = key;
                vals[vals.length] = hash[key];
                
                key = +key;
                
                if (Jeeel.Type.isInteger(key) && max < key) {
                    max = key;
                }
            }
            
            this._lastIndex = max;
        }

        this._hash = hash;
        this._keys = keys;
        this._vals = vals;
        this._length = vals.length;
    },
    
    _copy: function (from, to) {
        var res = new this.constructor();
        var max = -1;
        
        for (var i = from; i <= to; i++) {
            var key = this._keys[i];
            
            res._keys[res._keys.length] = key;
            res._vals[res._vals.length] = this._vals[i];
            res._hash[key] = this._vals[i];
            
            key = +key;

            if (Jeeel.Type.isInteger(key) && max < key) {
                max = key;
            }
        }
        
        res._lastIndex = max;
        res._length = res._keys.length;
        
        return res;
    },
    
    _resetLastIndex: function (key, set) {
        
        if ( ! Jeeel.Type.isSet(key)) {
            key = -1;
            
            for (var i = 0; i < this._length; i++) {
                var tmp = +this._keys[i];
                
                if (Jeeel.Type.isInteger(tmp) && key < tmp) {
                    key = tmp;
                }
            }
            
            this._lastIndex = key;
            
            return;
        }
        
        key = +key;

        if (set && this._lastIndex < key) {
            this._lastIndex = key;
        } else if (this._lastIndex == key) {
            for (var i = key; i >= 0; i--) {
                if (i in this._hash) {
                    this._lastIndex = i;
                    return;
                }
            }

            this._lastIndex = -1;
        }
    },

    /**
     * Hash内の物を全て数値だと仮定してキャストして取得する
     * 
     * @return {Number[]} 数値配列
     */
    _getNums: function () {
        if (this._nums) {
            return this._nums;
        }

        var nums = [];

        for (var i = 0; i < this._length; i++) {
            nums[i] = +this._vals[i];
        }
        
        this._nums = nums;

        return nums;
    }
};

Jeeel.file.Jeeel.Hash = ['GetCount', 'GetKeys', 'GetValues', 'GetPairs', 'Merge', 'Search', 'ToArray', 'ForEach'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Hash, Jeeel.file.Jeeel.Hash);/**
 * 指定したHashから配列の長さを返す
 *
 * @param {Hash} hash 配列・連想配列
 * @return {Integer} キーの数
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.getCount = function (hash) {
    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }

    if (Jeeel.Type.hasLength(hash)) {
        return hash.length;
    }

    var count = 0;

    for (var key in hash) {
        count++;
    }

    return count;
};
/**
 * 指定したHashからキーのリストを取得する
 *
 * @param {Hash} hash 配列・連想配列(キーを保持する全てを許可する)
 * @param {Mixied} [value] キーの取得条件値
 * @param {Boolean} [strict] 厳密な検索を行うかどうか
 * @return {String[]} キーのリスト
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.getKeys = function (hash, value, strict) {

    if (Jeeel.Type.isEmpty(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }
    
    var valSet = Jeeel.Type.isSet(value);
    var res = [];

    if (Jeeel.Type.isArray(hash) || Jeeel.Type.isArguments(hash) || Jeeel.Type.isElementCollection(hash) || Jeeel.Type.isNodeList(hash)) {
        for (var i = 0, l = hash.length; i < l; i++) {
            
            if (valSet) {
                if (strict && value !== hash[i]) {
                    continue;
                } else if ( ! strict && value != hash[i]) {
                    continue;
                }
            }

            res[res.length] = '' + i;
        }
    } else {
        for (var key in hash) {

            if (valSet) {
                if (strict && value !== hash[key]) {
                    continue;
                } else if ( ! strict && value != hash[key]) {
                    continue;
                }
            }

            res[res.length] = key;
        }
    }

    return res;
};

/**
 * 指定したHashの値を全て返す
 *
 * @param {Hash} hash 配列・連想配列
 * @return {Array} 値のリスト
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.getValues = function (hash) {

    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }

    if (Jeeel.Type.isArray(hash) || Jeeel.Type.isArguments(hash)) {
        return Array.prototype.slice.call(hash, 0, hash.length);
    }

    var res = [];

    for (var key in hash) {
        res[res.length] = hash[key];
    }

    return res;
};
/**
 * 指定したHashのキーと値のペアを全て返す<br />
 * 配列等に関しても全て返す
 *
 * @param {Hash} hash 配列・連想配列
 * @param {Boolean} [enableChainKey] プロトタイプチェーンのキーを全て参照するかどうか(__proto__が定義されていないブラウザには意味がない)
 * @return {Jeeel.Object.Item[]} キーと値のリスト(valueはセキュリティ系のエラーの場合、値ではなくエラーオブジェクトを代入する)
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.getPairs = function (hash, enableChainKey) {
    
    if (Jeeel.Type.isEmpty(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }

    var type = Jeeel.Type.getType(hash);
    var list = Jeeel.Type.getKeys(type);

    var pair = [];

    for (var key in hash) {

        if ( ! enableChainKey && (hash.__proto__ || Object.getPrototypeOf) && hash.hasOwnProperty && ! hash.hasOwnProperty(key)) {
            continue;
        }

        var val;

        try {
            val = hash[key];
        } catch (e) {
            val = e;
        }

        pair[pair.length] = new Jeeel.Object.Item(key, val);

        var searchKey = Jeeel.Hash.search(key, list, true);

        if ( ! Jeeel.Type.isEmpty(searchKey)) {
            list.splice(searchKey, 1);
        }
    }
    
    for (var i = 0, l = list.length; i < l; i++) {
        if (list[i] !== '__proto__' && ! enableChainKey && (hash.__proto__ || Object.getPrototypeOf) && hash.hasOwnProperty && ! hash.hasOwnProperty(list[i])) {
            continue;
        }
        
        if ( ! (list[i] in hash)) {
            continue;
        }
        
        try {
            pair[pair.length] = new Jeeel.Object.Item(list[i], hash[list[i]]);
        } catch (e) {
            pair[pair.length] = new Jeeel.Object.Item(list[i], e);
        }
    }
    
    if ( ! ('__proto__' in hash) && Object.getPrototypeOf) {
        pair[pair.length] = new Jeeel.Object.Item('__proto__', Object.getPrototypeOf(hash));
    }

    return pair;
};


/**
 * 配列・連想配列をマージする
 *
 * @param {Hash} hash1 配列・連想配列
 * @param {Hash} hash2 配列・連想配列
 * @return {Hash} mergeした後の連想配列
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.merge = function (hash1, hash2) {
    if ( ! Jeeel.Type.isHash(hash1) || ! Jeeel.Type.isHash(hash2)) {
        throw new Error('hash1・hash2が配列・連想配列ではありません');
    }

    var res = {};

    var digit, count = 0;

    Jeeel.Hash.forEach(hash1,
        function (val, key) {

            digit = +key;

            if (Jeeel.Type.isInteger(digit) && digit > count) {
                count = digit;
            }

            res[key] = val;
        }
    );

    Jeeel.Hash.forEach(hash2,
        function (val, key) {

            if (Jeeel.Type.isInteger(+key)) {
                res[++count] = val;
            } else {
                res[key] = val;
            }
        }
    );
   
    return res;
};

/**
 * 指定した値をHash内で検索し、見つかった場合は対応するキーを返す
 *
 * @param {Mixied} value 検索する値
 * @param {Hash} hash 配列・連想配列
 * @param {Boolean} [strict] 厳密な検索を行うかどうか
 * @return {String} 見つかった値の対応するキー(見つからなかった場合はnull)
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.search = function (value, hash, strict) {
    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }
    
    var _key = null;

    Jeeel.Hash.forEach(hash,
        function (val, key) {
            if (strict && value === val) {
                _key = key;
                return Jeeel.Hash.FOR_EACH_EXIT;
            } else if ( ! strict && value == val) {
                _key = key;
                return Jeeel.Hash.FOR_EACH_EXIT;
            }
        }
    );

    return _key;
};

/**
 * Hash形式のオブジェクトを配列に修正して返す
 *
 * @param {Hash} hash 配列・連想配列
 * @return {Array} 配列に修正したHashの値リスト(hashのキーが数字の部分を優先し、その後ろからキーが文字列のものを入れていく)
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.toArray = function (hash) {
    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }

    if (Jeeel.Type.isArray(hash)) {
        return Jeeel.Method.clone(hash);
    }
    else if (Jeeel.Type.isArguments(hash)) {
        return (hash.length === 1 ? [hash[0]] : Array.apply(null, hash));
    }
    else if (Jeeel.Type.isElementCollection(hash) || Jeeel.Type.isNodeList(hash)) {
        var arr = [];

        for (var i = 0, l = hash.length; i < l; i++) {
            arr[i] = hash[i];
        }

        return arr;
    }

    var key, num, nums = [];
    var res = [];
    var max = -1;
    
    for (key in hash) {
        num = +key;
        
        if (Jeeel.Type.isInteger(num)) {
            nums[nums.length] = num;
            
            res[num] = hash[num];
            
            if (max < num) {
                max = num;
            }
        }
    }

    for (key in hash) {
        if ( ! Jeeel.Type.isInteger(+key)) {
            res[++max] = hash[key];
        }
    }

    return res;
};

/**
 * 配列・連想配列に対して各要素にアクセスするメソッド<br />
 * 配列の場合は初期化していない要素にはアクセスしない
 * 
 * @param {Hash} hash 配列・連想配列
 * @param {Function} callback void callBack(Mixied value, String key, Hash hash)<br />
 *                             引数は左から要素,キー,配列となる(戻り値に指定定数を返すとbreakする)
 * @param {Mixied} [thisArg] コールバックメソッド中のthisに変わるオブジェクト(初期値はhashになる)
 * @throws {Error} hashが配列式でない場合に起こる
 * @see Jeeel.Hash.FOR_EACH_EXIT
 */
Jeeel.Hash.forEach = function (hash, callback, thisArg) {
    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }
    
    if ( ! Jeeel.Type.isSet(thisArg)) {
        thisArg = hash;
    }

    var tmp, length;
    var exit = Jeeel.Hash.FOR_EACH_EXIT;

    if (Jeeel.Type.hasLength(hash)) {
        length = hash.length;

        for (var i = 0; i < length; i++) {

            if (i in hash) {

                tmp = callback.call(thisArg, hash[i], i, hash);

                if (tmp === exit) {
                    break;
                }
            }
        }
    } else {
        for (var key in hash) {
            
            tmp = callback.call(thisArg, hash[key], key, hash);

            if (tmp === exit) {
                break;
            }
        }
    }
};
Jeeel.directory.Jeeel.String = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'String/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 文字列の複雑な処理をするクラス
 * @param {String} [string] 基となる文字列
 */
Jeeel.String = function (string) {
    
    if ( ! Jeeel.Type.isSet(string)) {
        string = '';
    }
    
    this._str = ('' + string).replace(/\r\n/g, '\n');
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} [string] 基となる文字列
 * @return {Jeeel.String} 作成したインスタンス
 */
Jeeel.String.create = function (string) {
    return new this(string);
};

/**
 * バイナリコードよりインスタンスの作成を行う<br />
 * 多バイトには対応していない
 *
 * @param {String|String[]} binary 連結したバイナリコードまたはバイナリコード配列
 * @return {Jeeel.String} 作成したインスタンス
 * @throws {Error} binaryがバイナリコード・バイナリコード配列で無い場合に発生する
 */
Jeeel.String.fromBinary = function (binary) {
    var tmp = [];
    var i, l = binary.length;

    if (Jeeel.Type.isString(binary)) {
        for (i = 0; i < l; i += 2) {
            tmp[tmp.length] = '0x' + binary.slice(i, i + 2);
        }
    } else if (Jeeel.Type.isArray(binary)) {
        for (i = 0; i < l; i++) {
            tmp[i] = '0x' + binary[i];
        }
    } else {
        throw new Error('binaryはバイナリコードまたはバイナリコード配列でなければなりません。');
    }

    return new this(String.fromCharCode.apply(null, tmp));
};

Jeeel.String.prototype = {
  
    /**
     * 元の文字列
     * 
     * @type String
     * @private
     */
    _str: '',
    
    /**
     * 行数
     * 
     * @type Integer
     */
    _lineCount: null,
    
    /**
     * 改行部分のインデックス配列
     * 
     * @type Integer[]
     */
    _lineIndex: null,
    
    /**
     * 内部文字列を取得する
     * 
     * @return {String} 文字列
     */
    getString: function () {
        return this._str;
    },
    
    /**
     * 文字列の行数を取得する
     * 
     * @return {Integer} 行数
     */
    getLineCount: function () {
        if (this._lineCount) {
            return this._lineCount;
        }
        
        return this._lineCount = this._str.length - this._str.replace(/\n/g, '').length + 1;
    },
    
    /**
     * 指定した行の文字列を得る
     *
     * @param {Integer} [line] 行インデックス(範囲以外の数や文字を入れると全ての文字列が返ってくる)
     * @return {String} 指定行の文字列
     */
    getLine: function (line) {
      
        this._createLineIndex();

        var first = (line <= 0 ? 0 : this._lineIndex[line-1] + 1);
        var last  = this._lineIndex[line];
        
        return this._str.slice(first, last);
    },
    
    /**
     * 指定した文字列が最初に見つかった行インデックスとその行でのインデックスを取得する
     *
     * @param {String} search 検索文字列
     * @return {Jeeel.Object.Technical.LineIndex} 行数とその行でのインデックスを保持する構造体
     */
    lineIndexOf: function (search) {
        this._createLineIndex();
        
        var idx = this._str.indexOf(search);

        var line = 0;
        var tmp  = 0;

        for (var i = 0, l = this._lineIndex.length; i < l; i++) {
            if (tmp < idx && idx < this._lineIndex[i]) {
                line += i;
                idx  -= tmp + 1;
                break;
            }

            tmp = this._lineIndex[i];
        }

        return new Jeeel.Object.Technical.LineIndex({line: line, index: idx});
    },
    
    /**
     * Bsse64エンコードを行う
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    encodeBase64: function () {
        this._str = this.toBase64();
        
        return this._reset();
    },
    
    /**
     * Bsse64デコードを行う
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    decodeBase64: function () {
        this._str = this.constructor.Hash.Base64.decode(this._str);
        
        return this._reset();
    },
    
    /**
     * MD5エンコードを行う
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    encodeMd5: function () {
        this._str = this.toMd5();
        
        return this._reset();
    },
    
    /**
     * Jsonエンコードを行う
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    encodeJson: function () {
        this._str = Jeeel.Json.encode(this._str);
        
        return this._reset();
    },
    
    /**
     * Html文字列にあたる部分をエスケープする
     * 
     * @param {Boolean} [replaceSpaceAndLineFeed] 改行とスペースを置き換えるかどうか(デフォルトは置き換えない)
     * @return {Jeeel.String} 自インスタンス
     */
    escapeHtml: function (replaceSpaceAndLineFeed) {
        this._str = Jeeel.Filter.Html.Escape.create(replaceSpaceAndLineFeed).filter(this._str);
        
        return this._reset();
    },
    
    /**
     * エスケープされたHtml文字列を元に戻す
     * 
     * @param {Boolean} [replaceSpaceAndLineFeed] 改行とスペースを置き換えるかどうか(デフォルトは置き換えない)
     * @return {Jeeel.String} 自インスタンス
     */
    unescapeHtml: function (replaceSpaceAndLineFeed) {
        this._str = Jeeel.Filter.Html.Unescape.create(replaceSpaceAndLineFeed).filter(this._str);
        
        return this._reset();
    },
    
    /**
     * RegExpに使用するメタ文字をエスケープする
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    escapeRegExp: function () {
        this._str = Jeeel.Filter.RegularExpressionEscape.create().filter(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列からHTMLタグ文字を全て取り除く
     *
     * @return {Jeeel.String} 自インスタンス
     */
    stripTags: function () {
        this._str = this.constructor.stripTags(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列の前後から空白を取り除く
     *
     * @return {Jeeel.String} 自インスタンス
     */
    trim: function () {
        this._str = this.constructor.trim(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列をキャメルケースに変更する
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    camelCase: function () {
        this._str = this.constructor.toCamelCase(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列をスネークケースに変更する
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    snakeCase: function () {
        this._str = this.constructor.toSnakeCase(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列をハイフネーションに変更する
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    hyphenation: function () {
        this._str = this.constructor.toHyphenation(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列に対して指定箇所に文字列を挿入する
     * 
     * @param {Integer} index 挿入箇所のインデックス(マイナスのインデックスの場合は先頭に、インデックスをオーバーしたら末尾に挿入文字列が付けられる)
     * @param {String} insertStr 挿入文字列
     * @return {Jeeel.String} 自インスタンス
     */
    insert: function (index, insertStr) {
        this._str = this.constructor.insert(this._str, index, insertStr);
        
        return this._reset();
    },
    
    /**
     * 文字列に対して指定箇所に文字列を挿入する
     * 
     * @param {Integer[]} indexArr 挿入箇所のインデックス配列(マイナスのインデックスの場合は先頭に、インデックスをオーバーしたら末尾に挿入文字列が付けられる)<br />
     *                              もしもこの配列内のインデックスの並びが昇順ではない場合、insertStrArrの配列のインデックスとずれるので注意
     * @param {String|String[]} insertStrArr 挿入文字列もしくは挿入文字列配列(配列にした場合はインデックスの配列と数が一致しなければならない)
     * @return {Jeeel.String} 自インスタンス
     */
    multiInsert: function (indexArr, insertStrArr) {
        this._str = this.constructor.multiInsert(this._str, indexArr, insertStrArr);
        
        return this._reset();
    },
    
    /**
     * Query形式の文字列を連想配列に変換する
     * 
     * @return {Hash} 変換後の連想配列
     */
    toQueryParameters: function () {
        return Jeeel.Filter.Url.QueryParameter.create().filter(this._str);
    },
    
    /**
     * Json形式の文字列を変換する
     * 
     * @return {Mixied} 変換後の値
     */
    parseJson: function () {
        return Jeeel.Json.decode(this._str);
    },
    
    /**
     * Base64文字列に変換する
     * 
     * @return {String} Base64文字列
     */
    toBase64: function () {
        return this.constructor.Hash.Base64.encode(this._str);
    },
    
    /**
     * MD5文字列に変換する
     * 
     * @return {String} MD5文字列
     */
    toMd5: function () {
        return this.constructor.Hash.md5(this._str);
    },
    
    /**
     * 文字単位バイナリコードに変換して返す
     *
     * @param {String} [prefix] 16進数を示す接頭辞(デフォルトはなし)
     * @return {String} バイナリコード
     */
    toBinary: function (prefix) {
        return this.toBinaryArray(prefix).join('');
    },

    /**
     * 文字単位バイナリコード配列に変換して返す
     *
     * @param {String} [prefix] 16進数を示す接頭辞(デフォルトはなし)
     * @return {String[]} バイナリコード配列
     */
    toBinaryArray: function (prefix) {
        if ( ! Jeeel.Type.isString(prefix)) {
            prefix = '';
        }

        var res = [];

        for (var i = 0, l = this._str.length; i < l; i++) {
            var tmp = this._str.charCodeAt(i);
            tmp = tmp.toString(16);

            if (tmp.length & 1) {
                tmp = '0' + tmp;
            }

            res[i] = prefix + tmp;
        }

        return res;
    },
    
    /**
     * インスタンスを文字列に変換する
     * 
     * @return {String} 文字列
     */
    toString: function () {
        return this._str;
    },
    
    /**
     * インスタンスを文字列に変換する
     * 
     * @return {String} 文字列
     */
    valueOf: function () {
        return this._str;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {String} [str] 基となる文字列
     * @constructor
     */
    constructor: Jeeel.String,
    
    _createLineIndex: function () {
        if (this._lineIndex) {
            return;
        }
        
        this._lineIndex = [];
        
        var tmp = 0;

        while (1) {
            tmp = this._str.indexOf('\n', tmp);

            if (tmp < 0) {
                break;
            }

            this._lineIndex[this._lineIndex.length] = tmp;
            tmp++;
        }
    },
    
    _reset: function () {
        this._lineCount = null;
        this._lineIndex = null;
        
        return this;
    }
};

Jeeel._Object.JeeelString = {

};

Jeeel.file.Jeeel.String = ['StripTags', 'Trim', 'ToCamelCase', 'ToSnakeCase', 'ToHyphenation', 'Insert', 'MultiInsert', 'Sprintf', 'Hash'];

Jeeel._autoImports(Jeeel.directory.Jeeel.String, Jeeel.file.Jeeel.String);

/**
 * HTML文字列からタグ文字を全て取り除く
 *
 * @param {String} html HTML文字列
 * @return {String} タグを取り除いた文字列
 */
Jeeel.String.stripTags = function (html) {

//    return html.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, '');

    var nodes = {childNodes: Jeeel.Document.createNodeList(html)};

    var res = [];
    var txt = Jeeel.Dom.Node.TEXT_NODE;

    function _search(target) {
        if (target.nodeType === txt) {
            res[res.length] = target.data;
        }

        for (var i = 0, l = target.childNodes.length; i < l; i++) {
            _search(target.childNodes[i]);
        }
    }

    _search(nodes);

    return res.join('');
};

/**
 * 文字列の前後から空白を取り除く
 *
 * @param {String} str 対象の文字列(文字列以外を入れた場合は文字列に変換された後に値を返す)
 * @return {String} 空白を取り除いた後の値
 */
Jeeel.String.trim = function (str) {
    if ( ! str) {
        return '';
    }

    var trimLeft  = /^\s+/;
    var trimRight = /\s+$/;

    return str.toString().replace(trimLeft, '').replace(trimRight, '');
};

/**
 * 対象文字列をキャメルケースに変更する(パスカルケースではない)<br />
 * 変換対象はハイフネーションまたはスネークケースが対象となる
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toCamelCase = function (str) {
    return ('' + str).replace(/(-|_)([a-z])/g, function (str, p1, p2){return p2.toUpperCase();});
};

/**
 * 対象文字列をスネークケースに変更する<br />
 * 変換対象はハイフネーションまたはキャメルケースが対象となる
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toSnakeCase = function (str) {
    return ('' + str).replace(/([A-Z])/g, '_$1').replace(/-/g, '_').toLowerCase();
};
/**
 * 対象文字列をハイフネーションに変更する<br />
 * 変換対象はスネークケースまたはキャメルケースが対象となる
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toHyphenation = function (str) {
    return ('' + str).replace(/([A-Z])/g, '-$1').replace(/_/g, '-').toLowerCase();
};
/**
 * 文字列の指定箇所に指定文字列を挿入する
 *
 * @param {String} str 対象の文字列(文字列以外を入れた場合は文字列に変換された後に値を返す)
 * @param {Integer} index 挿入箇所のインデックス(マイナスのインデックスの場合は先頭に、インデックスをオーバーしたら末尾に挿入文字列が付けられる)
 * @param {String} insertStr 挿入文字列
 * @return {String} 挿入後の文字列
 */
Jeeel.String.insert = function (str, index, insertStr) {
    if ( ! str) {
        return insertStr;
    }
    
    str = '' + str;
    
    var leftStr = str.substring(0, index);
    var rightStr = str.substring(index, str.length);

    return leftStr + insertStr + rightStr;
};

/**
 * Jeeel.String.insertの複数版
 *
 * @param {String} str 対象の文字列(文字列以外を入れた場合は文字列に変換された後に値を返す)
 * @param {Integer[]} indexArr 挿入箇所のインデックス配列(マイナスのインデックスの場合は先頭に、インデックスをオーバーしたら末尾に挿入文字列が付けられる)<br />
 *                              もしもこの配列内のインデックスの並びが昇順ではない場合、insertStrArrの配列のインデックスとずれるので注意
 * @param {String|String[]} insertStrArr 挿入文字列もしくは挿入文字列配列(配列にした場合はインデックスの配列と数が一致しなければならない)
 * @return {String} 挿入後の文字列
 * @throws {Error} insertStrArrが配列でindexArrとinsertStrArrの配列の要素数が一致しない場合に起こる
 */
Jeeel.String.multiInsert = function (str, indexArr, insertStrArr) {
    if ( ! Jeeel.Type.isArray(indexArr)) {
        indexArr = [indexArr];
    }
    
    str = '' + str;
    
    var res = [];
    var insertStrIsArray = Jeeel.Type.isArray(insertStrArr);
    var insertStr;
    
    if (insertStrIsArray && indexArr.length != insertStrArr.length) {
        throw new Error('インデックスの配列と挿入文字の配列の数が違います。');
    }
    
    indexArr.sort(function (a, b) {return a - b});

    indexArr.unshift(0);
    
    if (insertStrIsArray) {
        insertStrArr.unshift('');
    }
    
    for (var i = 1, l = indexArr.length; i < l; i++) {
        if (insertStrIsArray) {
            insertStr = insertStrArr[i];
        } else {
            insertStr = insertStrArr;
        }
        
        res[res.length] = str.substring(indexArr[i - 1], indexArr[i]);
        res[res.length] = insertStr;
    }
    
    res[res.length] = str.substring(indexArr[l - 1], str.length);
    
    return res.join('');
};
/**
 * SprintfのJS版<br />
 * オーダー及びバグ検証・最適化をしていない<br />
 * 多用はお勧めしない
 *
 * @param {String} format フォーマット
 * @param {Mixied} var_args フォーマットに対して割り当てる値
 */
Jeeel.String.sprintf = function (format, var_args) {
    var ch;
    var value;
    var longflag;
    var ljust;
    var len, llen;
    var zpad;
    var p;
    var output;
    var formatIndex, argIndex;
    var argc, argv;
    var specin;
    var method = Jeeel._Object.JeeelString;

    output = '';
    formatIndex = 0;
    argIndex = 1;
    argv = arguments;
    argc = arguments.length;

    while (formatIndex < format.length) {
        ch = format.substr(formatIndex++, 1);

        if (ch != '%' || formatIndex == format.length) {
            output += ch;
        } else {
            // ch == '%'
            ljust = len = zpad = longflag = 0;
            llen = -1;
            p = formatIndex;
            specin = true;

            while (specin) {
                ch = format.substr(formatIndex++, 1);

                switch(ch) {
                    case '-':
                        ljust = 1;
                        continue;

                    case '0':         // set zero padding if len not set
                        if(len == 0) {
                            zpad = 1;
                        }
                    // FALLTHROUGH
                    case '1': case '2': case '3':
                    case '4': case '5': case '6':
                    case '7': case '8': case '9':
                        len = len * 10 + (+ch);
                        continue;

                    case '.':
                        llen = len;
                        len = 0;
                        continue;

                    case '*':
                        if (argIndex < argc) {
                            len = parseInt(argv[argIndex++]);
                        }
                        else {
                            len = 0;
                        }
                        
                        if (len < 0) {
                            ljust = 1;
                            len = -len;
                        }
                        continue;

                    case 'l':
                        longflag = 1;
                        continue;

                    case 'u': case 'U':
                        if (argIndex < argc) {
                            if (longflag) {
                                value = parseInt(argv[argIndex++]);
                            } else {
                                value = parseInt(argv[argIndex++]);
                                value %= 4294967296;
                            }
                        } else {
                            value = 0;
                        }

                        output += method.doprFmtnum(value, 10,0, ljust, len, zpad);
                        break;

                    case 'o': case 'O':
                        if (argIndex < argc) {
                            if (longflag) {
                                value = parseInt(argv[argIndex++]);
                            } else {
                                value = parseInt(argv[argIndex++]);
                                value %= 4294967296;
                            }
                        } else {
                            value = 0;
                        }

                        output += method.doprFmtnum(value, 8,0, ljust, len, zpad);
                        break;

                    case 'd': case 'D':
                        if (argIndex < argc) {
                            if (longflag) {
                                value = parseInt(argv[argIndex++]);
                            } else {
                                value = parseInt(argv[argIndex++]);
                                value %= 4294967296;
                            }
                        } else {
                            value = 0;
                        }

                        output += method.doprFmtnum(value, 10,1, ljust, len, zpad);
                        break;

                    case 'x':
                        if (argIndex < argc) {
                            if (longflag) {
                                value = parseInt(argv[argIndex++]);
                            } else {
                                value = parseInt(argv[argIndex++]);
                                value %= 4294967296;
                            }
                        } else {
                            value = 0;
                        }

                        output += method.doprFmtnum(value, 16,0, ljust, len, zpad);
                        break;

                    case 'X':
                        if (argIndex < argc) {
                            if (longflag) {
                                value = parseInt(argv[argIndex++]);
                            } else {
                                value = parseInt(argv[argIndex++]);
                                value %= 4294967296;
                            }
                        } else {
                            value = 0;
                        }

                        output += method.doprFmtnum(value, -16,0, ljust, len, zpad);
                        break;

                    case 's':
                        if (argIndex < argc) {
                            value = argv[argIndex++];
                            if(value == null)
                                value = "(null)";
                            else
                                value = value + "";	// toString
                        } else {
                            value = '';
                        }

                        output += method.doprFmtstr(value, ljust, len, llen);
                        break;

                    case 'c':
                        if (argIndex < argc) {
                            value = parseInt(argv[argIndex++]);
                        } else {
                            value = 0;
                        }
                        
                        output += method.doprFromCharCode(value);
                        break;

                    case '%':
                        output += '%';
                        break;

                    // Not supported
//                    case 'f': case 'e': case 'E': case 'g': case 'G':
//                      if (argIndex < argc) {
//                        value = argv[argIndex++];
//                      } else {
//                        value = 0.0;
//                      }
//                      output += _dopr_fmtdouble(format.substr(p, formatIndex - p), value);
//                      break;

                    default:
                        if(p + 1 == formatIndex) {
                            output += '%';
                            output += ch;
                        }
                        else {
                        // alert("format error: " + format);
                        }
                        break;
                }
                specin = false;
            }
        }
    }
    return output;
};

Jeeel._Object.JeeelString.doprFmtnum = function (value, base, dosign, ljust, len, zpad) {
    var signvalue = '';
    var uvalue;
    var place = 0;
    var padlen;		// amount to pad
    var caps = 0;
    var convert;
    var output;

    convert = '';
    output = '';

    if(value >= 0) {
        uvalue = value;
    }
    else {
        uvalue = (value % 4294967296) + 4294967296;
    }

    if (dosign) {
        if (value < 0) {
            signvalue = '-';
            uvalue = -value;
        }
    }

    if (base < 0) {
        caps = 1;
        base = -base;
    }

    if(uvalue == 0) {
        convert = '0';
        place = 1;
    } else {
        while (uvalue) {
            if(caps) {
                convert = '0123456789ABCDEF'.substr(uvalue % base, 1) + convert;
            }
            else {
                convert = '0123456789abcdef'.substr(uvalue % base, 1) + convert;
            }
            
            uvalue = Math.floor(uvalue / base);
            place++;
        }
    }

    padlen = len - place;

    if (padlen < 0) {
        padlen = 0;
    }

    if (ljust) {
        padlen = -padlen;
    }

    if (zpad && padlen > 0) {
        if(signvalue) {
            output += signvalue;
            --padlen;
            signvalue = 0;
        }

        while (padlen > 0) {
            output += '0';
            --padlen;
        }
    }

    while (padlen > 0) {
        output += ' ';
        --padlen;
    }

    if (signvalue) {
        output += signvalue;
    }

    output += convert;

    while(padlen < 0) {
        output += ' ';
        ++padlen;
    }
    
    return output;
};

Jeeel._Object.JeeelString.doprFmtstr = function (value, ljust, field_len, llen) {
    var padlen;			// amount to pad
    var slen, truncstr = 0;
    var output = '';

    slen = value.length;

    if (llen != -1) {
        var rlen;

        rlen = field_len;
        
        if (slen > rlen) {
            truncstr = 1;
            slen = rlen;
        }
        
        field_len = llen;
    }
    
    padlen = field_len - slen;

    if (padlen < 0) {
        padlen = 0;
    }
    
    if (ljust) {
        padlen = -padlen;
    }
    
    while (padlen > 0) {
        output += ' ';
        --padlen;
    }
    
    if (truncstr) {
        output += value.substr(0, slen);
    } else {
        output += value;
    }

    while (padlen < 0) {
        output += ' ';
        ++padlen;
    }
    
    return output;
};

// Private function
Jeeel._Object.JeeelString.doprFromCharCodeChars = null;
Jeeel._Object.JeeelString.doprFromCharCode = function (code) {
    if (String.fromCharCode) {
        return String.fromCharCode(code);
    }
    
    if( ! this.doprFromCharCodeChars) {
        this.doprFromCharCodeChars
            = "\000\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020"
            + "\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037 !\"#$%&"
            + "'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghi"
            + "jklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211"
            + "\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232"
            + "\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253"
            + "\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274"
            + "\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315"
            + "\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336"
            + "\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357"
            + "\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377";
    }

    if(code < 0) {
        return "";
    }

    if(code <= 255) {
        return this.doprFromCharCodeChars.substr(code, 1);
    }
    
    return eval(Jeeel.String.sprintf("\"\\u%04x\"", code));
};
Jeeel.directory.Jeeel.String.Hash = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.String + 'Hash/';
    }
};

/**
 * Hash関数関連のネームスペース
 */
Jeeel.String.Hash = {

};

Jeeel._Object.JeeelStringHash = {
    
};

Jeeel.file.Jeeel.String.Hash = ['Base64', 'Md5'];

Jeeel._autoImports(Jeeel.directory.Jeeel.String.Hash, Jeeel.file.Jeeel.String.Hash);
Jeeel.directory.Jeeel.String.Hash.Base64 = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.String.Hash + 'Base64/';
    }
};

/**
 * Base64関連のモジュール
 */
Jeeel.String.Hash.Base64 = {
    
    /**
     * エンコード文字列
     *
     * @type String
     * @constant
     */
    ENCODE_CHARS: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    
    /**
     * デコード配列
     * 
     * @type Integer[]
     * @constant
     */
    DECODE_CHARS: [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
        -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
    ]
};

Jeeel.file.Jeeel.String.Hash.Base64 = ['Encode', 'Decode'];

Jeeel._autoImports(Jeeel.directory.Jeeel.String.Hash.Base64, Jeeel.file.Jeeel.String.Hash.Base64);

/**
 * 指定した文字列に対してbsse64エンコードを行う
 * 
 * @param {String} str エンコード対象文字列
 * @return {String} bsse64文字列
 */
Jeeel.String.Hash.Base64.encode = function (str) {
    
    str = '' + str;
    
    var out, i, len;
    var c1, c2, c3;

    len = str.length;
    i = 0;
    out = [];
    
    while(i < len) {
        c1 = str.charCodeAt(i++) & 0xff;
        
        if (i == len) {
            out[out.length] = this.ENCODE_CHARS.charAt(c1 >> 2);
            out[out.length] = this.ENCODE_CHARS.charAt((c1 & 0x3) << 4);
            out[out.length] = "==";
            break;
        }
        
        c2 = str.charCodeAt(i++);
        
        if (i == len) {
            out[out.length] = this.ENCODE_CHARS.charAt(c1 >> 2);
            out[out.length] = this.ENCODE_CHARS.charAt(((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4));
            out[out.length] = this.ENCODE_CHARS.charAt((c2 & 0xF) << 2);
            out[out.length] = "=";
            break;
        }
        
        c3 = str.charCodeAt(i++);
        
        out[out.length] = this.ENCODE_CHARS.charAt(c1 >> 2);
        out[out.length] = this.ENCODE_CHARS.charAt(((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4));
        out[out.length] = this.ENCODE_CHARS.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6));
        out[out.length] = this.ENCODE_CHARS.charAt(c3 & 0x3F);
    }
    
    return out.join('');
};

/**
 * bsse64エンコードされた文字列を復元する
 * 
 * @param {String} str base64文字列
 * @return {String} 復元した文字列
 */
Jeeel.String.Hash.Base64.decode = function (str) {
    str = '' + str;
    
    var c1, c2, c3, c4;
    var i, len, out;

    len = str.length;
    i = 0;
    out = [];
    
    while(i < len) {
        /* c1 */
        do {
            c1 = this.DECODE_CHARS[str.charCodeAt(i++) & 0XFF];
        } while(i < len && c1 == -1);
        
        if (c1 == -1) {
            break;
        }

        /* c2 */
        do {
            c2 = this.DECODE_CHARS[str.charCodeAt(i++) & 0XFF];
        } while(i < len && c2 == -1);
        
        if (c2 == -1) {
            break;
        }

        out[out.length] = String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));

        /* c3 */
        do {
            c3 = str.charCodeAt(i++) & 0XFF;
            
            if (c3 == 61) {
                return out.join('');
            }
            
            c3 = this.DECODE_CHARS[c3];
        } while(i < len && c3 == -1);
        
        if (c3 == -1) {
            break;
        }

        out[out.length] = String.fromCharCode(((c2 & 0XF) << 4) | ((c3 & 0x3C) >> 2));

        /* c4 */
        do {
            c4 = str.charCodeAt(i++) & 0XFF;
            
            if (c4 == 61) {
                return out.join('');
            }
            
            c4 = this.DECODE_CHARS[c4];
        } while(i < len && c4 == -1);
        
        if (c4 == -1) {
            break;
        }
        
        out[out.length] = String.fromCharCode(((c3 & 0x03) << 6) | c4);
    }
    
    return out.join('');
};

/**
 * 文字列をMD5に変換する
 * 
 * @param {String} data 対象の文字列
 * @return {String} MD5文字列
 */
Jeeel.String.Hash.md5 = function (data) {
    return Jeeel._Object.JeeelStringHash.Md5.hexHash('' + data);
};

Jeeel._Object.JeeelStringHash.Md5 = {
  
    /**
     * 16進数に使用する文字列
     * 
     * @type String
     * @constant
     */
    HEX_TEXT: "0123456789abcdef",
    
    /**
     * 16進数に使用する文字列
     * 
     * @type Integer[]
     * @constant
     */
    T: [],

    round: [],
    
    pack: function (n32) {
        return String.fromCharCode(n32 & 0xFF) 
             + String.fromCharCode((n32 >>> 8) & 0xFF) 
             + String.fromCharCode((n32 >>> 16) & 0xFF) 
             + String.fromCharCode((n32 >>> 24) & 0xFF);
    },

    unpack: function (s4) {
        return (s4.charCodeAt(0))
             | (s4.charCodeAt(1) <<  8) 
             | (s4.charCodeAt(2) << 16) 
             | (s4.charCodeAt(3) << 24);
    },

    number: function (n) {
        while (n < 0) {
            n += 4294967296;
        }
        
        while (n > 4294967295) {
            n -= 4294967296;
        }
        
        return n;
    },

    applyRound: function (x, s, f, abcd, r) {
        var a, b, c, d;
        var kk, ss, ii;
        var t, u;

        a = abcd[0];
        b = abcd[1];
        c = abcd[2];
        d = abcd[3];
        kk = r[0];
        ss = r[1];
        ii = r[2];

        u = f(s[b], s[c], s[d]);
        t = s[a] + u + x[kk] + this.T[ii];
        t = this.number(t);
        t = ((t<<ss) | (t>>>(32-ss)));
        t += s[b];
        s[a] = this.number(t);
    },
    
    hash: function (data) {
        this.init();
        
        var abcd, x, state, s;
        var len, index, padLen, f, r;
        var i, j, k;
        var tmp;

        state = [0X67452301, 0XEFCDAB89, 0X98BADCFE, 0X10325476];
        
        len = data.length;
        index = len & 0x3f;
        
        padLen = (index < 56) ? (56 - index) : (120 - index);
        
        if (padLen > 0) {
            data += "\x80";
            
            for (i = 0; i < padLen - 1; i++) {
                data += "\x00";
            }
        }
        
        data += this.pack(len * 8);
        data += this.pack(0);
        len  += padLen + 8;
        
        abcd = [0, 1, 2, 3];
        x    = [];
        s    = [];

        for (k = 0; k < len; k += 64) {
            for (i = 0, j = k; i < 16; i++, j += 4) {
                x[i] = (data.charCodeAt(j))
                     | (data.charCodeAt(j + 1) <<  8) 
                     | (data.charCodeAt(j + 2) << 16) 
                     | (data.charCodeAt(j + 3) << 24);
            }
            
            for (i = 0; i < 4; i++) {
                s[i] = state[i];
            }
            
            for (i = 0; i < 4; i++) {
                f = this.round[i][0];
                r = this.round[i][1];
                
                for (j = 0; j < 16; j++) {
                    this.applyRound(x, s, f, abcd, r[j]);
                    
                    tmp = abcd[0];
                    abcd[0] = abcd[3];
                    abcd[3] = abcd[2];
                    abcd[2] = abcd[1];
                    abcd[1] = tmp;
                }
            }

            for (i = 0; i < 4; i++) {
              state[i] += s[i];
              state[i] = this.number(state[i]);
            }
        }

        return this.pack(state[0]) 
             + this.pack(state[1]) 
             + this.pack(state[2]) 
             + this.pack(state[3]);
    },
    
    hexHash: function (data) {
        var i, out, c;
        var bit128;

        bit128 = this.hash(data);
        out = [];
        
        for (i = 0; i < 16; i++) {
            c = bit128.charCodeAt(i);
            
            out[out.length] = this.HEX_TEXT.charAt((c>>4) & 0xF);
            out[out.length] = this.HEX_TEXT.charAt(c & 0xF);
        }
        
        return out.join('');
    },
    
    init: function () {
        if (arguments.callee.ignore) {
            return;
        }
        
        arguments.callee.ignore = true;
        
        var merge = {
            T: [
                0X00000000, 0XD76AA478, 0XE8C7B756, 0X242070DB,
                0XC1BDCEEE, 0XF57C0FAF, 0X4787C62A, 0XA8304613,
                0XFD469501, 0X698098D8, 0X8B44F7AF, 0XFFFF5BB1,
                0X895CD7BE, 0X6B901122, 0XFD987193, 0XA679438E,
                0X49B40821, 0XF61E2562, 0XC040B340, 0X265E5A51,
                0XE9B6C7AA, 0XD62F105D, 0X02441453, 0XD8A1E681,
                0XE7D3FBC8, 0X21E1CDE6, 0XC33707D6, 0XF4D50D87,
                0X455A14ED, 0XA9E3E905, 0XFCEFA3F8, 0X676F02D9,
                0X8D2A4C8A, 0XFFFA3942, 0X8771F681, 0X6D9D6122,
                0XFDE5380C, 0XA4BEEA44, 0X4BDECFA9, 0XF6BB4B60,
                0XBEBFBC70, 0X289B7EC6, 0XEAA127FA, 0XD4EF3085,
                0X04881D05, 0XD9D4D039, 0XE6DB99E5, 0X1FA27CF8,
                0XC4AC5665, 0XF4292244, 0X432AFF97, 0XAB9423A7,
                0XFC93A039, 0X655B59C3, 0X8F0CCC92, 0XFFEFF47D,
                0X85845DD1, 0X6FA87E4F, 0XFE2CE6E0, 0XA3014314,
                0X4E0811A1, 0XF7537E82, 0XBD3AF235, 0X2AD7D2BB,
                0XEB86D391
            ],

            round1: [
                [ 0, 7, 1], [ 1,12, 2],
                [ 2,17, 3], [ 3,22, 4],
                [ 4, 7, 5], [ 5,12, 6],
                [ 6,17, 7], [ 7,22, 8],
                [ 8, 7, 9], [ 9,12,10],
                [10,17,11], [11,22,12],
                [12, 7,13], [13,12,14],
                [14,17,15], [15,22,16]
            ],

            round2: [
                [ 1, 5,17], [ 6, 9,18],
                [11,14,19], [ 0,20,20],
                [ 5, 5,21], [10, 9,22],
                [15,14,23], [ 4,20,24],
                [ 9, 5,25], [14, 9,26],
                [ 3,14,27], [ 8,20,28],
                [13, 5,29], [ 2, 9,30],
                [ 7,14,31], [12,20,32]
            ],

            round3: [
                [ 5, 4,33], [ 8,11,34],
                [11,16,35], [14,23,36],
                [ 1, 4,37], [ 4,11,38],
                [ 7,16,39], [10,23,40],
                [13, 4,41], [ 0,11,42],
                [ 3,16,43], [ 6,23,44],
                [ 9, 4,45], [12,11,46],
                [15,16,47], [ 2,23,48]
            ],

            round4: [
                [ 0, 6,49], [ 7,10,50],
                [14,15,51], [ 5,21,52],
                [12, 6,53], [ 3,10,54],
                [10,15,55], [ 1,21,56],
                [ 8, 6,57], [15,10,58],
                [ 6,15,59], [13,21,60],
                [ 4, 6,61], [11,10,62],
                [ 2,15,63], [ 9,21,64]
            ],

            F: function (x, y, z) {return (x & y) | (~x & z);},
            G: function (x, y, z) {return (x & z) | (y & ~z);},
            H: function (x, y, z) {return x ^ y ^ z;},
            I: function (x, y, z) {return y ^ (x | ~z);}
        };
    
        this.T = merge.T;
        this.round = [
            [merge.F, merge.round1],
            [merge.G, merge.round2],
            [merge.H, merge.round3],
            [merge.I, merge.round4]
        ];
    }
};Jeeel.directory.Jeeel.Number = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Number/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 数値の複雑な処理をするクラス
 * @param {Number} [number] 基となる数値
 */
Jeeel.Number = function (number) {
    
    if ( ! Jeeel.Type.isSet(number)) {
        number = 0;
    }
    
    this._num = +number;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Number} [number] 基となる数値
 * @return {Jeeel.Number} 作成したインスタンス
 */
Jeeel.Number.create = function (number) {
    return new this(number);
};

Jeeel.Number.prototype = {
  
    /**
     * 元の数値
     * 
     * @type Number
     * @private
     */
    _num: 0,
    
    /**
     * 数値を絶対値にする
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    abs: function () {
        this._num =  (this._num > 0 ? this._num : -this._num);
        
        return this;
    },
    
    /**
     * 数値を切り上げる
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    ceil: function () {
        this._num = Math.ceil(this._num);
        
        return this;
    },
    
    /**
     * 数値を切り下げる
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    floor: function () {
        this._num = Math.floor(this._num);
        
        return this;
    },
    
    /**
     * 数値を四捨五入する
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    round: function () {
        this._num = Math.round(this._num);
        
        return this;
    },
    
    /**
     * 数値を指定範囲に収める
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    limit: function (min, max) {
        this._num = this.constructor.limit(this._num, min, max);
        
        return this;
    },
    
    /**
     * 数値を千単位でグループ化してフォーマットする
     * 
     * @param {String} [separator] 千単位を区切る文字列(デフォルトは , )
     * @param {String} [prefix] 接頭辞
     * @param {String} [suffix] 接尾辞
     * @return {String} フォーマット後の文字列
     */
    toFormatted: function (separator, prefix, suffix) {
        return this.constructor.format(this._num, separator, prefix, suffix);
    },
    
    /**
     * 数値を百分率表記に変換する
     * 
     * @return {String} 百分率表記の文字列
     */
    toPercentage: function () {
        return this.constructor.percentage(this._num);
    },
    
    /**
     * インスタンスを文字列に変換する
     * 
     * @param {Integer} [radix] 進数を指定する場合に指定
     * @return {String} 文字列
     */
    toString: function (radix) {
        return (radix ? this._num.toString(radix) : this._num.toString());
    },
    
    /**
     * インスタンスを数値に変換する
     * 
     * @return {Number} 数値
     */
    valueOf: function () {
        return this._num;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Number} [number] 基となる数値
     * @constructor
     */
    constructor: Jeeel.Number
};

Jeeel.file.Jeeel.Number = ['Limit', 'Format', 'Percentage', 'GetSum', 'GetAvg', 'GetGcd', 'GetLcm'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Number, Jeeel.file.Jeeel.Number);

/**
 * 数値を指定範囲内に収める
 * 
 * @param {Number} number 対象の数値
 * @param {Number} min 最小値
 * @param {Number} max 最大値
 * @return {Number} 収めた後の数値
 */
Jeeel.Number.limit = function (number, min, max) {
    if (number < min) {
        number = min;
    }
    
    if (number > max) {
        number = max;
    }
    
    return number;
};
/**
 * 数字を千単位でグループ化してフォーマットする
 * 
 * @param {Number} number 対象の数値
 * @param {String} [separator] 千単位を区切る文字列(デフォルトは , )
 * @param {String} [prefix] 接頭辞
 * @param {String} [suffix] 接尾辞
 * @return {String} 変換後の値
 */
Jeeel.Number.format = function (number, separator, prefix, suffix) {
    var str = (+number || 0).toString();
    var dpi = str.indexOf('.');
    var moi = str.indexOf('-') + 1;
    
    if (dpi < 0) {
        dpi = str.length;
    }
    
    var indexArr = [];

    for (var i = dpi - 3; i > moi; i -= 3) {
        indexArr[indexArr.length] = i;
    }

    return (prefix || '') + Jeeel.String.multiInsert(str, indexArr, separator || ',') + (suffix || '');
};
/**
 * 数値を百分率にして返す
 * 
 * @param {Number} number 対象の数値
 * @return {String} 百分率表記の文字列(後ろに%が付く)
 */
Jeeel.Number.percentage = function (number) {
    return number * 100 + '%';
};/**
 * 合計値を求める
 * 
 * @param {Number} var_args 合計値を求める際に数を可変で引き渡す
 */
Jeeel.Number.getSum = function (var_args) {
    var i, sum = 0;
    
    for (i = arguments.length; i--;) {
        sum += arguments[i];
    }
    
    return sum;
};/**
 * 平均値を求める
 * 
 * @param {Number} var_args 平均値を求める際に数を可変で引き渡す
 */
Jeeel.Number.getAvg = function (var_args) {
    return this.getSum.apply(this, arguments) / arguments.length;
};/**
 * 最大公約数を求める
 * 
 * @param {Integer} base 最大公約数を求める際の数
 * @param {Integer} var_args 可変引数、2つ以上の数を指定する場合に渡す
 * @return {Integer} 最大公約数(正)
 */
Jeeel.Number.getGcd = function (base, var_args) {
    var i, j, l, r;
    
    for (i = 0, l = arguments.length - 1; i < l; i++) {
        j = i + 1;
        r = arguments[i] % arguments[j];

        arguments[j] = r === 0 ? arguments[j] : arguments.callee(arguments[j], r < 0 ? -r : r);
    }
    
    return arguments[l];
};/**
 * 最小公倍数を求める
 * 
 * @param {Integer} base 最小公倍数を求める際の数
 * @param {Integer} var_args 可変引数、2つ以上の数を指定する場合に渡す
 * @return {Integer} 最小公倍数(正)
 */
Jeeel.Number.getLcm = function (base, var_args) {
    var i, j, l;
    
    for (i = 0, l = arguments.length - 1; i < l; i++) {
        j = i + 1;
        
        arguments[j] = arguments[i] * arguments[j] / this.getGcd(arguments[i], arguments[j]);
    }

    return arguments[l] < 0 ? -arguments[l] : arguments[l];
};
Jeeel.directory.Jeeel.Code = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Code/';
    }
};

/**
 * コード関連のネームスペース
 */
Jeeel.Code = {

};

Jeeel.file.Jeeel.Code = ['KeyCode', 'CharCode', 'CharEncoding', 'HtmlCode'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Code, Jeeel.file.Jeeel.Code);

/**
 * キーボードのコードに関する列挙体
 */
Jeeel.Code.KeyCode = {

    /**
     * A
     *
     * @type Integer
     * @constant
     */
    A: 65,

    /**
     * B
     *
     * @type Integer
     * @constant
     */
    B: 66,

    /**
     * C
     *
     * @type Integer
     * @constant
     */
    C: 67,

    /**
     * D
     *
     * @type Integer
     * @constant
     */
    D: 68,

    /**
     * E
     *
     * @type Integer
     * @constant
     */
    E: 69,

    /**
     * F
     *
     * @type Integer
     * @constant
     */
    F: 70,

    /**
     * G
     *
     * @type Integer
     * @constant
     */
    G: 71,

    /**
     * H
     *
     * @type Integer
     * @constant
     */
    H: 72,

    /**
     * I
     *
     * @type Integer
     * @constant
     */
    I: 73,

    /**
     * J
     *
     * @type Integer
     * @constant
     */
    J: 74,

    /**
     * K
     *
     * @type Integer
     * @constant
     */
    K: 75,

    /**
     * L
     *
     * @type Integer
     * @constant
     */
    L: 76,

    /**
     * M
     *
     * @type Integer
     * @constant
     */
    M: 77,

    /**
     * N
     *
     * @type Integer
     * @constant
     */
    N: 78,

    /**
     * O
     *
     * @type Integer
     * @constant
     */
    O: 79,

    /**
     * P
     *
     * @type Integer
     * @constant
     */
    P: 80,

    /**
     * Q
     *
     * @type Integer
     * @constant
     */
    Q: 81,

    /**
     * R
     *
     * @type Integer
     * @constant
     */
    R: 82,

    /**
     * S
     *
     * @type Integer
     * @constant
     */
    S: 83,

    /**
     * T
     *
     * @type Integer
     * @constant
     */
    T: 84,

    /**
     * U
     *
     * @type Integer
     * @constant
     */
    U: 85,

    /**
     * V
     *
     * @type Integer
     * @constant
     */
    V: 86,

    /**
     * W
     *
     * @type Integer
     * @constant
     */
    W: 87,

    /**
     * X
     *
     * @type Integer
     * @constant
     */
    X: 88,

    /**
     * Y
     *
     * @type Integer
     * @constant
     */
    Y: 89,

    /**
     * Z
     *
     * @type Integer
     * @constant
     */
    Z: 90,

    /**
     * 0
     *
     * @type Integer
     * @constant
     */
    0: 48,

    /**
     * 1
     *
     * @type Integer
     * @constant
     */
    1: 49,

    /**
     * 2
     *
     * @type Integer
     * @constant
     */
    2: 50,

    /**
     * 3
     *
     * @type Integer
     * @constant
     */
    3: 51,

    /**
     * 4
     *
     * @type Integer
     * @constant
     */
    4: 52,

    /**
     * 5
     *
     * @type Integer
     * @constant
     */
    5: 53,

    /**
     * 6
     *
     * @type Integer
     * @constant
     */
    6: 54,

    /**
     * 7
     *
     * @type Integer
     * @constant
     */
    7: 55,

    /**
     * 8
     *
     * @type Integer
     * @constant
     */
    8: 56,

    /**
     * 9
     *
     * @type Integer
     * @constant
     */
    9: 57,

    /**
     * テンキー0
     *
     * @type Integer
     * @constant
     */
    T0: 96,

    /**
     * テンキー1
     *
     * @type Integer
     * @constant
     */
    T1: 97,

    /**
     * テンキー2
     *
     * @type Integer
     * @constant
     */
    T2: 98,

    /**
     * テンキー3
     *
     * @type Integer
     * @constant
     */
    T3: 99,

    /**
     * テンキー4
     *
     * @type Integer
     * @constant
     */
    T4: 100,

    /**
     * テンキー5
     *
     * @type Integer
     * @constant
     */
    T5: 101,

    /**
     * テンキー6
     *
     * @type Integer
     * @constant
     */
    T6: 102,

    /**
     * テンキー7
     *
     * @type Integer
     * @constant
     */
    T7: 103,

    /**
     * テンキー8
     *
     * @type Integer
     * @constant
     */
    T8: 104,

    /**
     * テンキー9
     *
     * @type Integer
     * @constant
     */
    T9: 105,

    /**
     * テンキー&lowast;
     *
     * @type Integer
     * @constant
     */
    TMultiplicationSign: 106,

    /**
     * テンキー+
     *
     * @type Integer
     * @constant
     */
    TAdditionSign: 107,

    /**
     * テンキー-
     *
     * @type Integer
     * @constant
     */
    TSubtractionSign: 109,

    /**
     * テンキー.
     *
     * @type Integer
     * @constant
     */
    TPeriod: 110,

    /**
     * テンキー/
     *
     * @type Integer
     * @constant
     */
    TDivisionSign: 111,

    /**
     * F1
     *
     * @type Integer
     * @constant
     */
    F1: 112,

    /**
     * F2
     *
     * @type Integer
     * @constant
     */
    F2: 113,

    /**
     * F3
     *
     * @type Integer
     * @constant
     */
    F3: 114,

    /**
     * F4
     *
     * @type Integer
     * @constant
     */
    F4: 115,

    /**
     * F5
     *
     * @type Integer
     * @constant
     */
    F5: 116,

    /**
     * F6
     *
     * @type Integer
     * @constant
     */
    F6: 117,

    /**
     * F7
     *
     * @type Integer
     * @constant
     */
    F7: 118,

    /**
     * F8
     *
     * @type Integer
     * @constant
     */
    F8: 119,

    /**
     * F9
     *
     * @type Integer
     * @constant
     */
    F9: 120,

    /**
     * F10
     *
     * @type Integer
     * @constant
     */
    F10: 121,

    /**
     * F11
     *
     * @type Integer
     * @constant
     */
    F11: 122,

    /**
     * F12
     *
     * @type Integer
     * @constant
     */
    F12: 123,

    /**
     * BackSpace
     *
     * @type Integer
     * @constant
     */
    BackSpace: 8,

    /**
     * Enter
     *
     * @type Integer
     * @constant
     */
    Enter: 13,

    /**
     * Shift
     *
     * @type Integer
     * @constant
     */
    Shift: 16,

    /**
     * Ctrl
     *
     * @type Integer
     * @constant
     */
    Ctrl: 17,

    /**
     * Alt
     *
     * @type Integer
     * @constant
     */
    Alt: 18,

    /**
     * Pause
     *
     * @type Integer
     * @constant
     */
    Pause: 19,

    /**
     * 変換
     *
     * @type Integer
     * @constant
     */
    Change: 28,

    /**
     * 無変換
     *
     * @type Integer
     * @constant
     */
    NonChange: 29,

    /**
     * スペース
     *
     * @type Integer
     * @constant
     */
    Space: 32,

    /**
     * PageUp
     *
     * @type Integer
     * @constant
     */
    PageUp: 33,

    /**
     * PageDown
     *
     * @type Integer
     * @constant
     */
    PageDown: 34,

    /**
     * End
     *
     * @type Integer
     * @constant
     */
    End: 35,

    /**
     * Home
     *
     * @type Integer
     * @constant
     */
    Home: 36,

    /**
     * ←
     *
     * @type Integer
     * @constant
     */
    Left: 37,

    /**
     * ↑
     *
     * @type Integer
     * @constant
     */
    Up: 38,

    /**
     * →
     *
     * @type Integer
     * @constant
     */
    Right: 39,

    /**
     * ↓
     *
     * @type Integer
     * @constant
     */
    Down: 40,

    /**
     * Insert
     *
     * @type Integer
     * @constant
     */
    Insert: 45,

    /**
     * Delete
     *
     * @type Integer
     * @constant
     */
    Delete: 46,

    /**
     * Windowsキー
     *
     * @type Integer
     * @constant
     */
    Windows: 91,

    /**
     * Esc
     *
     * @type Integer
     * @constant
     */
    Esc: 243,

    /**
     * Tab
     *
     * @type Integer
     * @constant
     */
    Tab: 9,

    /**
     * Applicationキー
     *
     * @type Integer
     * @constant
     */
    Application: 93,

    /**
     * NumLock
     *
     * @type Integer
     * @constant
     */
    NumLock: 144,

    /**
     * ScrollLock
     *
     * @type Integer
     * @constant
     */
    ScrollLock: 145,

    /**
     * &lowast;
     *
     * @type Integer
     * @constant
     */
    MultiplicationSign: 186,

    /**
     * +
     *
     * @type Integer
     * @constant
     */
    AdditionSign: 187,

    /**
     * ,
     *
     * @type Integer
     * @constant
     */
    Comma: 188,

    /**
     * -
     *
     * @type Integer
     * @constant
     */
    SubtractionSign: 189,

    /**
     * .
     *
     * @type Integer
     * @constant
     */
    Period: 190,

    /**
     * &frasl;
     *
     * @type Integer
     * @constant
     */
    DivisionSign: 191,

    /**
     * &#64;
     *
     * @type Integer
     * @constant
     */
    Atmark: 192,

    /**
     * [
     *
     * @type Integer
     * @constant
     */
    LeftBracket: 219,

    /**
     * \
     *
     * @type Integer
     * @constant
     */
    YenMark: 220,

    /**
     * ]
     *
     * @type Integer
     * @constant
     */
    RightBracket: 221,

    /**
     * ^
     *
     * @type Integer
     * @constant
     */
    Caret: 222,

    /**
     * _
     *
     * @type Integer
     * @constant
     */
    Underscore: 226
};

Jeeel.Code.KeyCode.getKey = function (keyCode) {
    return Jeeel.Hash.search(keyCode, this, true);
};

/**
 * 文字コードに関する列挙体
 */
Jeeel.Code.CharCode = {

    /**
     * 空文字
     *
     * @type Integer
     * @constant
     */
    Null: 0x00,

    /**
     * ヘッダ開始
     *
     * @type Integer
     * @constant
     */
    StartOfHeading: 0x01,

    /**
     * テキスト開始
     *
     * @type Integer
     * @constant
     */
    StartOfText: 0x02,

    /**
     * テキスト終了
     *
     * @type Integer
     * @constant
     */
    EndOfText: 0x03,

    /**
     * 伝送終了
     *
     * @type Integer
     * @constant
     */
    EndOfTransmission: 0x04,

    /**
     * 問い合わせ
     *
     * @type Integer
     * @constant
     */
    Enquiry: 0x05,
    
    /**
     * 肯定応答
     *
     * @type Integer
     * @constant
     */
    Acknowledge: 0x06,

    /**
     * ベル
     *
     * @type Integer
     * @constant
     */
    Bell: 0x07,

    /**
     * 1文字後退
     *
     * @type Integer
     * @constant
     */
    BackSpace: 0x08,

    /**
     * 水平タブ
     *
     * @type Integer
     * @constant
     */
    HorizontalTabulation: 0x09,
    
    /**
     * 改行
     *
     * @type Integer
     * @constant
     */
    LineFeed: 0x0A,

    /**
     * 垂直タブ
     *
     * @type Integer
     * @constant
     */
    VerticalTabulation: 0x0B,
    
    /**
     * 改ページ
     *
     * @type Integer
     * @constant
     */
    FormFeed: 0x0C,

    /**
     * 復帰
     *
     * @type Integer
     * @constant
     */
    CarriageReturn: 0x0D,
    
    /**
     * シフトアウト
     *
     * @type Integer
     * @constant
     */
    ShiftOut: 0x0E,

    /**
     * シフトイン
     *
     * @type Integer
     * @constant
     */
    ShiftIn: 0x0F,
    
    /**
     * データリンク拡張
     *
     * @type Integer
     * @constant
     */
    DataLinkEscape: 0x10,

    /**
     * 装置制御1(XON)
     *
     * @type Integer
     * @constant
     */
    DeviceControl1: 0x11,

    /**
     * 装置制御2
     *
     * @type Integer
     * @constant
     */
    DeviceControl2: 0x12,

    /**
     * 装置制御3(XOFF)
     *
     * @type Integer
     * @constant
     */
    DeviceControl3: 0x13,
    
    /**
     * 装置制御4
     *
     * @type Integer
     * @constant
     */
    DeviceControl4: 0x14,

    /**
     * 否定応答
     *
     * @type Integer
     * @constant
     */
    NegativeAcKnowledge: 0x15,

    /**
     * 同期信号
     *
     * @type Integer
     * @constant
     */
    SynchronousIdle: 0x16,

    /**
     * ブロック転送終了
     *
     * @type Integer
     * @constant
     */
    EndOfTransmissionBlock: 0x17,

    /**
     * 取り消し
     *
     * @type Integer
     * @constant
     */
    Cancel: 0x18,

    /**
     * メディア終了
     *
     * @type Integer
     * @constant
     */
    EndOfMedium: 0x19,
    
    /**
     * 置換(EOF)
     *
     * @type Integer
     * @constant
     */
    SubstituteCharacter: 0x1A,

    /**
     * エスケープ
     *
     * @type Integer
     * @constant
     */
    Escape: 0x1B,

    /**
     * ファイル区切り
     *
     * @type Integer
     * @constant
     */
    FileSeparator: 0x1C,

    /**
     * グループ区切り
     *
     * @type Integer
     * @constant
     */
    GroupSeparator: 0x1D,

    /**
     * レコード区切り
     *
     * @type Integer
     * @constant
     */
    RecordSeparator: 0x1E,

    /**
     * ユニット区切り
     *
     * @type Integer
     * @constant
     */
    UnitSeparator: 0x1F,

    /**
     * 空白
     *
     * @type Integer
     * @constant
     */
    Space: 0x20,

    /**
     * !
     *
     * @type Integer
     * @constant
     */
    ExclamationMark: 0x21,

    /**
     * "
     *
     * @type Integer
     * @constant
     */
    DoubleQuote: 0x22,

    /**
     * #
     *
     * @type Integer
     * @constant
     */
    Sharp: 0x23,

    /**
     * $
     *
     * @type Integer
     * @constant
     */
    DollarMark: 0x24,

    /**
     * %
     *
     * @type Integer
     * @constant
     */
    PercentSign: 0x25,

    /**
     * &amp;
     *
     * @type Integer
     * @constant
     */
    Ampersand: 0x26,

    /**
     * '
     *
     * @type Integer
     * @constant
     */
    SingleQuote: 0x27,

    /**
     * (
     *
     * @type Integer
     * @constant
     */
    LeftParenthesis: 0x28,

    /**
     * )
     *
     * @type Integer
     * @constant
     */
    RightParenthesis: 0x29,

    /**
     * &lowast;
     *
     * @type Integer
     * @constant
     */
    MultiplicationSign: 0x2A,

    /**
     * +
     *
     * @type Integer
     * @constant
     */
    AdditionSign: 0x2B,

    /**
     * ,
     *
     * @type Integer
     * @constant
     */
    Comma: 0x2C,

    /**
     * -
     *
     * @type Integer
     * @constant
     */
    SubtractionSign: 0x2D,

    /**
     * .
     *
     * @type Integer
     * @constant
     */
    Period: 0x2E,
    
    /**
     * /
     *
     * @type Integer
     * @constant
     */
    DivisionSign: 0x2F,

    /**
     * 0
     *
     * @type Integer
     * @constant
     */
    0: 0x30,

    /**
     * 1
     *
     * @type Integer
     * @constant
     */
    1: 0x31,

    /**
     * 2
     *
     * @type Integer
     * @constant
     */
    2: 0x32,

    /**
     * 3
     *
     * @type Integer
     * @constant
     */
    3: 0x33,

    /**
     * 4
     *
     * @type Integer
     * @constant
     */
    4: 0x34,

    /**
     * 5
     *
     * @type Integer
     * @constant
     */
    5: 0x35,

    /**
     * 6
     *
     * @type Integer
     * @constant
     */
    6: 0x36,

    /**
     * 7
     *
     * @type Integer
     * @constant
     */
    7: 0x37,

    /**
     * 8
     *
     * @type Integer
     * @constant
     */
    8: 0x38,

    /**
     * 9
     *
     * @type Integer
     * @constant
     */
    9: 0x39,

    /**
     * :
     *
     * @type Integer
     * @constant
     */
    Colon: 0x3A,

    /**
     * ;
     *
     * @type Integer
     * @constant
     */
    Semicolon: 0x3B,

    /**
     * &lt;
     *
     * @type Integer
     * @constant
     */
    LessThan: 0x3C,

    /**
     * =
     *
     * @type Integer
     * @constant
     */
    EqualsSign: 0x3D,

    /**
     * &gt;
     *
     * @type Integer
     * @constant
     */
    GreaterThan: 0x3E,

    /**
     * ?
     *
     * @type Integer
     * @constant
     */
    QuestionMark: 0x3F,

    /**
     * &#64;
     *
     * @type Integer
     * @constant
     */
    Atmark: 0x40,

    /**
     * A
     *
     * @type Integer
     * @constant
     */
    A: 0x41,

    /**
     * B
     *
     * @type Integer
     * @constant
     */
    B: 0x42,

    /**
     * C
     *
     * @type Integer
     * @constant
     */
    C: 0x43,

    /**
     * D
     *
     * @type Integer
     * @constant
     */
    D: 0x44,

    /**
     * E
     *
     * @type Integer
     * @constant
     */
    E: 0x45,

    /**
     * F
     *
     * @type Integer
     * @constant
     */
    F: 0x46,

    /**
     * G
     *
     * @type Integer
     * @constant
     */
    G: 0x47,

    /**
     * H
     *
     * @type Integer
     * @constant
     */
    H: 0x48,

    /**
     * I
     *
     * @type Integer
     * @constant
     */
    I: 0x49,

    /**
     * J
     *
     * @type Integer
     * @constant
     */
    J: 0x4A,

    /**
     * K
     *
     * @type Integer
     * @constant
     */
    K: 0x4B,

    /**
     * L
     *
     * @type Integer
     * @constant
     */
    L: 0x4C,

    /**
     * M
     *
     * @type Integer
     * @constant
     */
    M: 0x4D,

    /**
     * N
     *
     * @type Integer
     * @constant
     */
    N: 0x4E,

    /**
     * O
     *
     * @type Integer
     * @constant
     */
    O: 0x4F,

    /**
     * P
     *
     * @type Integer
     * @constant
     */
    P: 0x50,

    /**
     * Q
     *
     * @type Integer
     * @constant
     */
    Q: 0x51,

    /**
     * R
     *
     * @type Integer
     * @constant
     */
    R: 0x52,

    /**
     * S
     *
     * @type Integer
     * @constant
     */
    S: 0x53,

    /**
     * T
     *
     * @type Integer
     * @constant
     */
    T: 0x54,

    /**
     * U
     *
     * @type Integer
     * @constant
     */
    U: 0x55,

    /**
     * V
     *
     * @type Integer
     * @constant
     */
    V: 0x56,

    /**
     * W
     *
     * @type Integer
     * @constant
     */
    W: 0x57,

    /**
     * X
     *
     * @type Integer
     * @constant
     */
    X: 0x58,

    /**
     * Y
     *
     * @type Integer
     * @constant
     */
    Y: 0x59,

    /**
     * Z
     *
     * @type Integer
     * @constant
     */
    Z: 0x5A,

    /**
     * [
     *
     * @type Integer
     * @constant
     */
    LeftBracket: 0x5B,

    /**
     * \
     *
     * @type Integer
     * @constant
     */
    YenMark: 0x5C,

    /**
     * ]
     *
     * @type Integer
     * @constant
     */
    RightBracket: 0x5D,

    /**
     * ^
     *
     * @type Integer
     * @constant
     */
    Caret: 0x5E,

    /**
     * _
     *
     * @type Integer
     * @constant
     */
    Underscore: 0x5F,

    /**
     * `
     *
     * @type Integer
     * @constant
     */
    BackQuote: 0x60,

    /**
     * a
     *
     * @type Integer
     * @constant
     */
    a: 0x61,

    /**
     * b
     *
     * @type Integer
     * @constant
     */
    b: 0x62,

    /**
     * c
     *
     * @type Integer
     * @constant
     */
    c: 0x63,

    /**
     * d
     *
     * @type Integer
     * @constant
     */
    d: 0x64,

    /**
     * e
     *
     * @type Integer
     * @constant
     */
    e: 0x65,

    /**
     * f
     *
     * @type Integer
     * @constant
     */
    f: 0x66,

    /**
     * g
     *
     * @type Integer
     * @constant
     */
    g: 0x67,

    /**
     * h
     *
     * @type Integer
     * @constant
     */
    h: 0x68,

    /**
     * i
     *
     * @type Integer
     * @constant
     */
    i: 0x69,

    /**
     * j
     *
     * @type Integer
     * @constant
     */
    j: 0x6A,

    /**
     * k
     *
     * @type Integer
     * @constant
     */
    k: 0x6B,

    /**
     * l
     *
     * @type Integer
     * @constant
     */
    l: 0x6C,

    /**
     * m
     *
     * @type Integer
     * @constant
     */
    m: 0x6D,

    /**
     * n
     *
     * @type Integer
     * @constant
     */
    n: 0x6E,

    /**
     * o
     *
     * @type Integer
     * @constant
     */
    o: 0x6F,

    /**
     * p
     *
     * @type Integer
     * @constant
     */
    p: 0x70,

    /**
     * q
     *
     * @type Integer
     * @constant
     */
    q: 0x71,

    /**
     * r
     *
     * @type Integer
     * @constant
     */
    r: 0x72,

    /**
     * s
     *
     * @type Integer
     * @constant
     */
    s: 0x73,

    /**
     * t
     *
     * @type Integer
     * @constant
     */
    t: 0x74,

    /**
     * u
     *
     * @type Integer
     * @constant
     */
    u: 0x75,

    /**
     * v
     *
     * @type Integer
     * @constant
     */
    v: 0x76,

    /**
     * w
     *
     * @type Integer
     * @constant
     */
    w: 0x77,

    /**
     * x
     *
     * @type Integer
     * @constant
     */
    x: 0x78,

    /**
     * y
     *
     * @type Integer
     * @constant
     */
    y: 0x79,

    /**
     * z
     *
     * @type Integer
     * @constant
     */
    z: 0x7A,

    /**
     * &#123;
     *
     * @type Integer
     * @constant
     */
    LeftBrace: 0x7B,

    /**
     * |
     *
     * @type Integer
     * @constant
     */
    VerticalBar: 0x7C,

    /**
     * &#125;
     *
     * @type Integer
     * @constant
     */
    RightBrace: 0x7D,

    /**
     * ~
     *
     * @type Integer
     * @constant
     */
    Tilde: 0x7E,

    /**
     * 削除
     *
     * @type Integer
     * @constant
     */
    Delete: 0x7F
};

Jeeel.Code.CharCode.getChar = function (charCode) {
    var res = Jeeel.Hash.getKeys(this, charCode, true);
    
    if (res.length < 1) {
        return null;
    } else if (res.length == 1) {
        return res[0];
    } else {
        return (res[0].length < res[1].length ? res[1] : res[0]);
    }
};

(function () {
    for (var i = 0; i < 128; i++) {
        var chr = String.fromCharCode(i);

        if ( ! (chr in Jeeel.Code.CharCode)) {
            Jeeel.Code.CharCode[chr] = i;
        }
    }
})();

/**
 * 文字のエンコーディングに関する列挙体
 */
Jeeel.Code.CharEncoding = {

    /**
     * UTF-8
     *
     * @type String
     * @constant
     */
    UTF8: 'UTF-8',

    /**
     * Shift_JIS
     *
     * @type String
     * @constant
     */
    SHIFT_JIS: 'Shift_JIS',

    /**
     * JIS
     *
     * @type String
     * @constant
     */
    JIS: 'ISO-2022-JP',

    /**
     * EUC-JP
     *
     * @type String
     * @constant
     */
    EUC: 'EUC-JP'
};

/**
 * HTML特殊文字に関する列挙体
 */
Jeeel.Code.HtmlCode = {
    HalfWidthSpace: '&nbsp;',
    FullWidthSpace: '&emsp;',
    DoubleQuote: '&quot;',
    Ampersand: '&amp;',
    LessThan: '&lt;',
    GreaterThan: '&gt;',
    CarriageReturn: '&crarr;',
    Copyright: '&copy;',
    TradeMark: '&trade;',
    RegisteredTrademark : '&reg;',
    PlusMinusSign: '&plusmn;',
    MultiplicationSign: '&times;',
    DivisionSign: '&divide;',
    ZipCode: '&#12306;',
    EncircledNumber1: '&#9312;',
    EncircledNumber2: '&#9313;',
    EncircledNumber3: '&#9314;',
    EncircledNumber4: '&#9315;',
    EncircledNumber5: '&#9316;',
    EncircledNumber6: '&#9317;',
    EncircledNumber7: '&#9318;',
    EncircledNumber8: '&#9319;',
    EncircledNumber9: '&#9320;',
    EncircledNumber10: '&#9321;',
    EncircledNumber11: '&#9322;',
    EncircledNumber12: '&#9323;',
    EncircledNumber13: '&#9324;',
    EncircledNumber14: '&#9325;',
    EncircledNumber15: '&#9326;',
    EncircledNumber16: '&#9327;',
    EncircledNumber17: '&#9328;',
    EncircledNumber18: '&#9329;',
    EncircledNumber19: '&#9330;',
    EncircledNumber20: '&#9331;',
    LargeRomanNumeral1: '&#8544;',
    LargeRomanNumeral2: '&#8545;',
    LargeRomanNumeral3: '&#8546;',
    LargeRomanNumeral4: '&#8547;',
    LargeRomanNumeral5: '&#8548;',
    LargeRomanNumeral6: '&#8549;',
    LargeRomanNumeral7: '&#8550;',
    LargeRomanNumeral8: '&#8551;',
    LargeRomanNumeral9: '&#8552;',
    LargeRomanNumeral10: '&#8553;',
    LargeRomanNumeral11: '&#8554;',
    LargeRomanNumeral12: '&#8555;',
    SmallRomanNumeral1: '&#8560;',
    SmallRomanNumeral2: '&#8561;',
    SmallRomanNumeral3: '&#8562;',
    SmallRomanNumeral4: '&#8563;',
    SmallRomanNumeral5: '&#8564;',
    SmallRomanNumeral6: '&#8565;',
    SmallRomanNumeral7: '&#8566;',
    SmallRomanNumeral8: '&#8567;',
    SmallRomanNumeral9: '&#8568;',
    SmallRomanNumeral10: '&#8569;',
    SmallRomanNumeral11: '&#8570;',
    SmallRomanNumeral12: '&#8571;',
    Millimeter: '&#13212;',
    Centimeter: '&#13213;',
    Kilometer: '&#13214;',
    Milligram: '&#13198;',
    Kilogram: '&#13199;',
    BlackSpade: '&spades;',
    BlackClub: '&clubs;',
    BlackHeart: '&hearts;',
    BlackDiamond: '&diams;',
    BlackStar: '&#9733;',
    WhiteSpade: '&#9828;',
    WhiteClub: '&#9831;',
    WhiteHeart: '&#9825;',
    WhiteDiamond: '&#9826;',
    WhiteStar: '&#9734;',
    Feminine: '&#9792;',
    Muscular: '&#9794;',
    CheckBox: '&#9744;',
    CheckBoxChecked: '&#9745;',
    Fine: '&#9728;',
    Rain: '&#9730;',
    Snow: '&#9731;',
    Cloud: '&#9729;',
    BlackPawn: '&#9823;',
    BlackKnight: '&#9822;',
    BlackBishop: '&#9821;',
    BlackRook: '&#9820;',
    BlackQueen: '&#9819;',
    BlackKing: '&#9818;',
    WhitePawn: '&#9817;',
    WhiteKnight: '&#9816;',
    WhiteBishop: '&#9815;',
    WhiteRook: '&#9814;',
    WhiteQueen: '&#9813;',
    WhiteKing: '&#9812;',
    BioHazard: '&#9763;',
    Hexagram: '&#10017;'
};

/**
 * 読み込み関連のメソッドを提供するModule
 */
Jeeel.Loader = {

    /**
     * Prototype.jsが読み込まれているかどうかを返す。
     * 
     * @return {Boolean} 読み込みが完了していたらtrueそれ以外はfalseを返す
     */
    completePrototype: function () {
        if (Jeeel._global.Prototype && ! Jeeel.Type.isEmpty(Prototype.Version)) {
            return true;
        }

        return false;
    },

    /**
     * jQuery.jsが読み込まれているかどうかを返す。
     *
     * @return {Boolean} 読み込みが完了していたらtrueそれ以外はfalseを返す
     */
    completeJQuery: function () {
        if (Jeeel._global.jQuery && Jeeel.Type.isFunction(jQuery) && Jeeel.Type.isString(jQuery.prototype.jquery)) {
            return true;
        }

        return false;
    },

    /**
     * YUI.jsが読み込まれているかどうかを返す。
     *
     * @return {Boolean} 読み込みが完了していたらtrueそれ以外はfalseを返す
     */
    completeYUI: function () {
        if (Jeeel._global.YUI && Jeeel.Type.isFunction(YUI) && Jeeel.Type.isString(YUI.version)) {
            return true;
        }

        return false;
    },

    /**
     * JavaScriptを読み込む
     *
     * @param {String} url JavaScriptのURL
     * @param {Function} [callback] 読み込み完了時のコールバック
     * @param {String} [charCode] 明示的にキャラクターコードを設定する場合に指定(Jeeel.Code.CharEncoding参照)
     * @return {Element} scriptタグのElement
     * @see Jeeel.Code.CharEncoding
     */
    loadScript: function (url, callback, charCode) {
        var script  = Jeeel.Document.createElement('script');
        script.type = 'text/javascript';

        if (Jeeel.Type.isString(charCode)) {
            script.charset = charCode;
        }

        if (callback) {
            script.onreadystatechange = function () {
                if (script.readyState === 'loaded' || script.readyState === 'complete') {
                    script.onreadystatechange = null;
                    script.onload = null;
                    callback(script);
                }
            };
            
            script.onload = function () {
                script.onreadystatechange = null;
                script.onload = null;
                callback(script);
            };
        }
        
        script.src  = url;

        Jeeel.Document.appendToHead(script);
        
        return script;
    },

    /**
     * CSSを読み込む
     *
     * @param {String} url CSSのURL
     * @param {String} [charCode] 明示的にキャラクターコードを設定する場合に指定(Jeeel.Code.CharEncoding参照)
     * @return {Element} linkタグのElement
     * @see Jeeel.Code.CharEncoding
     */
    loadStyle: function (url, charCode) {
        var style  = Jeeel.Document.createElement('link');
        style.type = 'text/css';
        style.rel  = 'stylesheet';

        if (Jeeel.Type.isString(charCode)) {
            style.charset = charCode;
        }
        
        style.href = url;

        Jeeel.Document.appendToHead(style);
        
        return style;
    },

    /**
     * スクリプトを記述したJavaScript文字列を実行してヘッダに埋め込む
     *
     * @param {String} script JavaScript文字列
     * @return {Element} scriptタグのElement
     */
    addScript: function (script) {
        var scriptTag  = Jeeel.Document.createElement('script');
        scriptTag.type = 'text/javascript';
        scriptTag.innerHTML = script;

        Jeeel.Document.appendToHead(scriptTag);
        
        return scriptTag;
    },

    /**
     * スタイルを記述したCSS文字列を適用してヘッダに埋め込む
     *
     * @param {String} style CSS文字列
     * @return {Element} styleタグのElement
     */
    addStyle: function (style) {
        var styleTag  = Jeeel.Document.createElement('style');
        styleTag.type = 'text/css';
        
        style = '\n' + style + '\n';

        if (styleTag.styleSheet) {
            styleTag.styleSheet.cssText = style;
        } else {
            styleTag.innerHTML = style;
        }

        Jeeel.Document.appendToHead(styleTag);
        
        return styleTag;
    },
    
    /**
     * ファイルの事前読み込みを行う<br />
     * これを行う事により事前にキャッシュを作る事が可能になる
     * 
     * @param {String} url 読み込みファイルのURL
     */
    preloadFile: function (url) {},

    /**
     * 現在読み込み中のJavaScriptのscriptタグを取得する<br />
     * 読み込み中のJavaScript内から呼ばないと意味がない
     *
     * @return {Element} scriptタグのElement
     */
    getCurrentScript: function () {
        return (
            function (e) {
                return (e.nodeName.toLowerCase() === 'script' ? e : arguments.callee(e.lastChild));
            })(Jeeel._doc);
    },

    /**
     * 指定したURLのファイルがあるかどうかを返す
     *
     * @param {String} url ファイルのURL
     * @return {Boolean} ファイルが存在するかどうか
     */
    existsFile: function (url) {
        var file = Jeeel.Net.Ajax.serverResponse(url);

        if (Jeeel.Type.isString(file)) {
            return true;
        }

        return false;
    },
    
    _init: function () {
      
        if (/*@cc_on!@*/false) {
            this.preloadFile = function (url) {
                new Image().src = url;
            };
        } else {
            this.preloadFile = function (url) {
                var obj = Jeeel.Document.createElement('object');
                
                obj.width  = 0;
                obj.height = 0;
                obj.data = url;
                Jeeel.Document.appendToBody(obj);
            };
        }
      
        delete this._init;
    }
};

Jeeel.Loader._init();
/**
 * コンストラクタ
 *
 * @class メソッドを拡張するクラス(name, length等の部分は初期化される)
 * @augments Function
 * @param {Function} target 基となるメソッド
 * @throws {Error} targetがメソッドでない場合に起こる
 * @example
 * var base = function (name, id) {
 * &nbsp;   return 'id: ' + id + ' name: ' + name + this;
 * }
 * var func = Jeeel.Function.create(base);
 * func.bind(' hello!!');
 *
 * var b = func('devid', 22);
 * //b = 'id: 22 name: devid hello!!'
 */
Jeeel.Function = function (target) {

    if ( ! Jeeel.Type.isFunction(target)) {
        throw new Error('targetがメソッドではありません。');
    }

    var f = function () {
        return arguments.callee._cnvTarget.apply(this, arguments);
    };

    for (var key in Jeeel.Function.prototype) {
        f[key] = Jeeel.Function.prototype[key];
    }
    
    /**
     * 対象のメソッド
     *
     * @type Function
     * @private
     */
    f._target = target;

    /**
     * 変換後のメソッド
     *
     * @type Function
     * @private
     */
    f._cnvTarget = target;
    
    target = null;

    try {
        return f;
    } finally {
        f = null;
    }
};

/**
 * インスタンスの作成を行う
 *
 * @param {Function} target 基となるメソッド
 * @return {Jeeel.Function} 作成したインスタンス
 */
Jeeel.Function.create = function (target) {
    return new this(target);
};

/**
 * 関数ネイティブ化を行う<br />
 * コンストラクタやapplyのないIEのためのメソッド
 * 
 * @param {Mixied} obj 親オブジェクト
 * @param {String} methodName ネイティブにしたいメソッドの名前
 * @param {Boolean} [useNew] インスタンス化するかどうか
 * @return {Function} ネイティブ化した関数
 */
Jeeel.Function.toNative = function (obj, methodName, useNew) {
    methodName = (useNew ? 'new' : '') + ' this["' + methodName + '"]';
    
    return function () {
        var params = [];
        
        for (var i = arguments.length; i--;) {
            params[i] = "_" + i;
        }
        
        params = params.join(',');
        
        return Function(
            params,
            'return ' + methodName + '(' + params + ')'
        ).apply(obj, arguments);
    };
};

/**
 * 単にthisをbindするメソッド<br />
 * メモリ消費等が少ないがエラー処理等は一切しない
 * 
 * @param {Function} target bind対象のメソッド
 * @param {Mixied} thisArg thisの部分にあたる値
 * @return {Function} bind後のメソッド
 */
Jeeel.Function.simpleBind = function (target, thisArg) {
    return function () {
        return target.apply(thisArg, arguments);
    };
};

Jeeel.Function.prototype = {
  
    /**
     * 対象のメソッド
     *
     * @type Function
     * @private
     */
    _target: null,
    
    /**
     * 変換後のメソッド
     *
     * @type Function
     * @private
     */
    _cnvTarget: null,
    
    /**
     * メソッドないのthisの部分を定義する<br />
     * 一度しか意味がない
     *
     * @param {Mixied} thisArg thisの部分にあたる値
     * @return {Jeeel.Function} 自インスタンス
     */
    bind: function (thisArg) {
        var target = this._cnvTarget;

        this._cnvTarget = function () {
            return target.apply(thisArg, arguments);
        };

        return this;
    },

    /**
     * メソッドの遅延実行を定義する<br />
     * メソッドの戻り値はタイムアウトIDに変更される
     *
     * @param {Integer} delayTime 遅延時間(ミリ秒)
     * @return {Jeeel.Function} 自インスタンス
     */
    delay: function (delayTime) {

        var func = function () {
            Array.prototype.unshift.call(arguments, arguments.callee._target, arguments.callee._delayTime);

            return Jeeel.Timer.setTimeout.apply(null, arguments);
        };

        func._target = this._cnvTarget;
        func._delayTime = delayTime;

        this._cnvTarget = func;
        
        func = null;

        return this;
    },

    /**
     * メソッドを複数回実行する<br />
     * メソッドの戻り値はJeeel.Timerのインスタンスになる<br />
     * メソッド内部のthisはこのメソッド前にbindしていない限りJeeel.Timerのインスタンスになる
     *
     * @param {Integer} interval 実行間隔(ミリ秒)
     * @param {Integer} count 実行回数
     * @return {Jeeel.Function} 自インスタンス
     */
    repeat: function (interval, count) {

        var func = function () {
            Array.prototype.unshift.call(arguments, arguments.callee._target, interval, count);

            return Jeeel.Timer.setLimitInterval.apply(null, arguments);
        };

        func._target = this._cnvTarget;

        this._cnvTarget = func;

        return this;
    },

    /**
     * 複数のメソッドを結合する<br />
     * 現在のメソッドが最初に実行される<br />
     * メソッドの戻り値は複数のメソッドの戻り値のリストになる
     *
     * @param {Mixied} var_args 結合するメソッドを順に渡す
     * @return {Jeeel.Function} 自インスタンス
     * @throws {Error} 引数にメソッド以外を渡した場合に起こる
     * @example
     * <pre>
     * var f1 = function (n) {
     * &nbsp;   return a + 1;
     * };
     * var f2 = function (n) {
     * &nbsp;   return a + 2;
     * };
     * var f3 = function (n) {
     * &nbsp;   return a + 3;
     * };
     * var sf = Jeeel.Function.create(f1);
     * sf.join(f2, f3);
     *
     * var res = sf(2);
     *
     * //res = [3, 4, 5]
     * </pre>
     */
    join: function (var_args) {
        var funcs = Array.prototype.slice.call(arguments, 0, arguments.length);

        for (var i = 0, l = funcs.length; i < l; i++) {
            if ( ! Jeeel.Type.isFunction(funcs[i])) {
                throw new Error('引数にメソッド以外が含まれています。');
            }
        }

        var func = function () {
            var res = [];

            res[res.length] = arguments.callee._target.apply(this, arguments);

            for (var i = 0, l = funcs.length; i < l; i++) {
                res[res.length] = funcs[i].apply(this, arguments);
            }

            return res;
        };

        func._target = this._cnvTarget;

        this._cnvTarget = func;

        return this;
    },

    /**
     * 複数のメソッドを切り替えて実行する機能を付加する<br />
     * 現在のメソッドを起点として、引数に指定したメソッドを呼び出す毎に切り替えて実行する<br />
     * 最後まで実行したら自動的に最初に戻る
     *
     * @param {Mixied} var_args 順次実行するメソッドを順に渡す
     * @return {Jeeel.Function} 自インスタンス
     * @throws {Error} 引数にメソッド以外を渡した場合に起こる
     * @example
     * <pre>
     * var f1 = function (n) {
     * &nbsp;   return a + 1;
     * };
     * var f2 = function (n) {
     * &nbsp;   return a + 2;
     * };
     * var f3 = function (n) {
     * &nbsp;   return a + 3;
     * };
     * var sf = Jeeel.Function.create(f1);
     * sf.iterate(f2, f3);
     *
     * var res = [];
     *
     * for (var i = 0; i &lt; 3; i++) {
     * &nbsp;   res[i] = sf(i);
     * }
     *
     * //res = [1, 3, 5]
     * </pre>
     */
    iterate: function (var_args) {
        var funcs = Array.prototype.slice.call(arguments, 0, arguments.length);

        for (var i = 0, l = funcs.length; i < l; i++) {
            if ( ! Jeeel.Type.isFunction(funcs[i])) {
                throw new Error('引数にメソッド以外が含まれています。');
            }
        }

        var func = function () {

            var res = funcs[arguments.callee._cnt].apply(this, arguments);

            arguments.callee._cnt++;

            if (funcs.length <= arguments.callee._cnt) {
                arguments.callee._cnt = 0;
            }

            return res;
        };

        funcs.unshift(this._cnvTarget);
        func._cnt = 0;

        this._cnvTarget = func;

        return this;
    },

    /**
     * パラメータを定義づける
     *
     * @param {Mixied} var_args 定義づけるパラメータを左から順に渡す
     * @return {Jeeel.Function} 自インスタンス
     * @example
     * <pre>
     * var f = function (a, b, c) {
     * &nbsp;   return a + b + c;
     * };
     * var sf = Jeeel.Function.create(f);
     * sf.curry('Hello! ', 'World ');
     *
     * var res = sf('Jhon!!');
     * //res = 'Hello! World Jhon!!'
     * </pre>
     */
    curry: function (var_args) {
        var slice = Array.prototype.slice;
        var args = slice.call(arguments);

        var func = function () {
            var prms = slice.call(arguments);
            prms = args.concat(prms);

            return arguments.callee._target.apply(this, prms);
        };

        func._target = this._cnvTarget;

        this._cnvTarget = func;

        return this;
    },

    /**
     * メソッドの変更を元に戻す
     * 
     * @return {Jeeel.Function} 自インスタンス
     */
    reset: function () {
        this._cnvTarget = this._target;

        return this;
    },

    /**
     * ベースとなったメソッドを取得する
     *
     * @return {Function} ベースになったメソッド
     */
    getBaseMethod: function () {
        return this._target;
    }
};
Jeeel.directory.Jeeel.UserAgent = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'UserAgent/';
    }
};

/**
 * ブラウザの情報を判別するためのクラス
 */
Jeeel.UserAgent = {

    /**
     * ユーザーエージェントの文字列情報
     *
     * @type String
     * @private
     */
    _info: navigator.userAgent,
    
    /**
     * ブラウザがSafariかどうかを返す
     *
     * @return {Boolean} Safariかどうか
     */
    isSafari: function () {},

    /**
     * ブラウザがFireFoxかどうかを返す
     *
     * @return {Boolean} FireFoxかどうか
     */
    isFireFox: function () {},

    /**
     * ブラウザがOperaかどうかを返す
     *
     * @return {Boolean} Operaかどうか
     */
    isOpera: function () {},

    /**
     * ブラウザがNetscapeかどうかを返す
     *
     * @return {Boolean} Netscapeかどうか
     */
    isNetscape: function () {},
    
    /**
     * ブラウザがNetscape.4かどうかを返す
     *
     * @return {Boolean} Netscape.4かどうか
     */
    isNetscape4: function () {},

    /**
     * ブラウザがInternetExplorerかどうかを返す
     *
     * @return {Boolean} InternetExplorerかどうか
     */
    isInternetExplorer: function () {},

    /**
     * ブラウザがInternetExplorer6かどうかを返す
     *
     * @return {Boolean} InternetExplorer6かどうか
     */
    isInternetExplorer6: function () {},
    
    /**
     * iPhoneかどうかを返す
     * 
     * @return {Boolean} iPhoneかどうか
     */
    isIPhone: function () {},
    
    /**
     * iPadかどうかを返す
     * 
     * @return {Boolean} iPadかどうか
     */
    isIPad: function () {},
    
    /**
     * iPod touchかどうかを返す
     * 
     * @return {Boolean} iPhoneかどうか
     */
    isIPod: function () {},
    
    /**
     * Androidかどうかを返す
     * 
     * @return {Boolean} Androidかどうか
     */
    isAndroid: function () {},
    
    /**
     * Mobileかどうかを返す(現在スマートフォンのみ考慮)
     * 
     * @return {Boolean} Mobileかどうか
     */
    isMobile: function () {},

    /**
     * ブラウザのレンダリングエンジンがTridentかどうかを返す
     *
     * @return {Boolean} Tridentかどうか
     */
    isTridentEngine: function () {},

    /**
     * ブラウザのレンダリングエンジンがGeckoかどうかを返す
     *
     * @return {Boolean} Geckoかどうか
     */
    isGeckoEngine: function () {},

    /**
     * ブラウザのレンダリングエンジンがWebkitかどうかを返す
     *
     * @return {Boolean} Webkitかどうか
     */
    isWebkitEngine: function () {},

    /**
     * ブラウザのレンダリングエンジンがPrestoかどうかを返す
     *
     * @return {Boolean} Prestoかどうか
     */
    isPrestoEngine: function () {},
    
    /**
     * ブラウザ名を取得する
     *
     * @return {String} ブラウザ名
     */
    getBrowserName: function () {
        return navigator.appName;
    },

    /**
     * ブラウザのコードネームを取得する
     *
     * @return {String} ブラウザのコードネーム
     */
    getCodeName: function () {
        return navigator.appCodeName;
    },

    /**
     * ブラウザのバージョンを取得する
     *
     * @return {String} ブラウザのバージョン
     */
    getVersion: function () {
        return navigator.appVersion;
    },

    /**
     * ブラウザのユーザエージェントを取得する
     *
     * @return {String} ブラウザのユーザエージェント
     */
    getUserAgent: function () {
        return this._info;
    },

    /**
     * ユーザーのOSプラットフォームを取得する
     *
     * @return {String} ユーザーのOSプラットフォーム
     */
    getPlatform: function () {
        return navigator.platform;
    },

    /**
     * ブラウザの使用言語を取得する
     *
     * @return {String} ブラウザの使用言語
     */
    getLanguage: function () {
        return navigator.language;
    },

    /**
     * 現在のパスを取得する
     *
     * @return {String} パス
     */
    getPath: function () {
        return location.pathname;
    },

    /**
     * 現在のURLを取得する
     *
     * @return {String} URL
     */
    getUrl: function () {
        return location.href;
    },

    /**
     * 現在のURLを設定する(ページ遷移する)
     *
     * @param {String} url 遷移対象URL
     */
    setUrl: function (url) {
        location.href = url;
    },
    
    /**
     * 現在のURLをパラメータやフラグメントの付いていない状態で返す。
     * 
     * @return {String} URL
     */
    getUrlPath: function () {
        return location.href.replace(/\?.+$/, '');
    },
    
    /**
     * 現在のフラグメントを取得する
     * 
     * @return {String} フラグメント
     */
    getFragment: function () {
        return location.hash.replace('#', '');
    },

    /**
     * 現在のポートを取得する
     *
     * @return {String} ポート
     */
    getPort: function () {
        return location.port;
    },

    /**
     * 現在のプロトコルを取得する
     *
     * @return {String} プロトコル
     */
    getProtocol: function () {},
    
    /**
     * 現在のスキーマを取得する
     * 
     * @return {String} スキーマ
     */
    getSchema: function () {},

    /**
     * 現在のホストを取得する
     *
     * @return {String} ホスト
     */
    getHost: function () {
        return location.host;
    },

    /**
     * 現在のドメインを取得する
     *
     * @return {String} ドメイン
     */
    getDomain: function () {
        return location.hostname;
    },

    /**
     * 現在のURLパラメータを示す文字列を取得する<br />
     * 先頭に?は付かない
     *
     * @return {String} Urlパラメータを示す文字列
     */
    getQueryString: function () {
        return '';
    },

    /**
     * 現在のURLパラメータを取得する<br />
     * URLパラメータは連想配列でもよいが、<br />
     * 正しく記述されている必要がある<br />
     * 以下は正しく取得できない可能性のある例である
     *
     * <pre>
     * ?a[&]=2&a[2]=3   //配列の添え字に&が入っている
     * ?a[=]=2&a[2]=3   //配列の添え字に=が入っている
     * ?a[[1]]=2&a[2]=3 //配列の添え字に[]のいずれかが入っている
     * ?a[1][=2&a[2]=3  //配列の形式が途中で途切れている
     * ?a[]=2&a[]=3     //配列の添え字がない
     * </pre>
     *
     * @param {String} [overwriteName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
     * @return {Hash} URLパラメータの連想配列
     */
    getQueryParameters: function (overwriteName) {
        return {};
    },

    /**
     * クッキーが有効かどうかを返す
     *
     * @return {Boolean} クッキーが有効かどうか
     */
    isCookieEnabled: function () {
        return navigator.cookieEnabled;
    },

    /**
     * 現在のページが暗号化されているかどうかを返す
     *
     * @return {Boolean} 暗号化されているかどうか
     */
    isSecure: function () {},
    
    /**
     * ブラウザの対応MIMEタイプの一覧を取得する
     * 
     * @return {Hash} MimeTypeリスト(キーがタイプになる)
     */
    getMimeTypes: function () {
        var res = {};
        
        for (var i = 0, l = navigator.mimeTypes.length; i < l; i++) {
            res[navigator.mimeTypes[i].type] = navigator.mimeTypes[i];
        }
        
        return res;
    },
    
    /**
     * VMLの有効・無効化を行う(IE限定: それ以外のブラウザでは何も起こらない)
     * 
     * @param {Boolean} enable 有効にするかどうか
     */
    enableVml: function (enable) {
        if ( ! Jeeel._doc.uniqueID) {
            return;
        }
        
        var root = Jeeel.Document.getDocumentElement();

        root = Jeeel.Dom.Element.create(root);

        if (enable) {
            if ( ! root.hasAttribute('xmlns:v')) {
                root.setAttribute('xmlns:v', 'urn:schemas-microsoft-com:vml');
            }
            
            if ( ! arguments.callee._tag) {
                var self = arguments.callee;
                
                Jeeel.Timer.setTimeout(function () {
                    var style = 'v\\:* { behavior: url(#default#VML); }';

                    self._tag = Jeeel.Loader.addStyle(style);
                }, 1);
            }
        } else {
            if (root.hasAttribute('xmlns:v')) {
                root.removeAttribute('xmlns:v');
            }
            
            if (arguments.callee._tag) {
                Jeeel.Dom.Element.create(arguments.callee._tag).remove();
                
                delete arguments.callee._tag;
            }
        }
    },
    
    _init: function () {
        
        var uao = navigator && navigator.userAgent;
        var ua = navigator && navigator.userAgent && navigator.userAgent.toLowerCase();
        
        if ( ! ua) {
            delete this._init;
            return;
        }
        
        var trueF = function () {
            return true;
        };
        
        var falseF = function () {
            return false;
        };
        
        var pro = location && location.protocol && location.protocol.replace(':', '');
        var scm = pro && (pro + '://');
        var qs  = location && location.search && location.search.replace(/^\?/, '');
        var qsf = new Jeeel.Filter.Url.QueryParameter();
        
        this.isSafari = (ua.indexOf("safari") !== -1 ? trueF : falseF);
        this.isFireFox = (ua.indexOf("firefox") !== -1 ? trueF : falseF);
        this.isOpera = (ua.indexOf("opera") !== -1 ? trueF : falseF);
        this.isNetscape = (ua.indexOf("netscape") !== -1 ? trueF : falseF);
        this.isNetscape4 = (ua.indexOf("mozilla/4") !== -1 ? trueF : falseF);
        this.isInternetExplorer = (ua.indexOf("msie") !== -1 ? trueF : falseF);
        this.isInternetExplorer6 = (ua.indexOf("msie 6") !== -1 ? trueF : falseF);
        this.isIPhone = (uao.indexOf("(iPhone;") !== -1 ? trueF : falseF);
        this.isIPad = (uao.indexOf("(iPad;") !== -1 ? trueF : falseF);
        this.isIPod = (uao.indexOf("(iPod;") !== -1 ? trueF : falseF);
        this.isMobile = (uao.indexOf("Mobile") !== -1 ? trueF : falseF);
        this.isAndroid = (uao.indexOf("Android") !== -1 ? trueF : falseF);
        
        this.isTridentEngine = (this.isInternetExplorer() || ua.indexOf("trident/") !== -1 ? trueF : falseF);
        this.isGeckoEngine = (ua.match(/gecko\/(\d{4})/) !== -1 ? trueF : falseF);
        this.isWebkitEngine = (ua.indexOf("applewebkit/") !== -1 ? trueF : falseF);
        this.isPrestoEngine = (ua.indexOf("presto/") !== -1 ? trueF : falseF);

        if (pro) {
            this.isSecure = (pro === 'https' ? trueF : falseF);
            this.getProtocol = function () {
                return pro;
            };
            this.getSchema = function () {
                return scm;
            };
        }
        
        if (qs) {
            this.getQueryString = function () {
                return qs;
            };
            
            this.getQueryParameters = function (overwriteName) {
                return (overwriteName ? new Jeeel.Filter.Url.QueryParameter(overwriteName) : qsf).filter(qs);
            };
        }
        
        delete this._init;
    }
};

Jeeel.UserAgent._init();

Jeeel.file.Jeeel.UserAgent = [];

if (Jeeel._extendMode.Geolocation && typeof navigator !== 'undefined' && navigator.geolocation) {
    Jeeel.file.Jeeel.UserAgent[Jeeel.file.Jeeel.UserAgent.length] = 'Geolocation';
}

Jeeel._autoImports(Jeeel.directory.Jeeel.UserAgent, Jeeel.file.Jeeel.UserAgent);
Jeeel.directory.Jeeel.UserAgent.Geolocation = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.UserAgent + 'Geolocation/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 位置情報について操作するクラス
 */
Jeeel.UserAgent.Geolocation = function () {
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.UserAgent.Geolocation} 作成したインスタンス
 */
Jeeel.UserAgent.Geolocation.create = function () {
    return new this();
};
    
Jeeel.UserAgent.Geolocation.prototype = {
  
    /**
     * 成功コールバック
     * 
     * @type Hash
     * @private
     */
    _successMethod: null,
    
    /**
     * エラーコールバック
     * 
     * @type Hash
     * @private
     */
    _errorMethod: null,
    
    /**
     * 取得する情報の正確性
     * 
     * @type Boolean
     * @private
     */
    _enableHighAccuracy: false,
    
    /**
     * 接続タイムアウト
     * 
     * @type Integer
     * @private
     */
    _timeout: null,
    
    /**
     * キャッシュの有効期限
     * 
     * @type Integer
     * @private
     */
    _maximumAge: null,
    
    /**
     * 位置情報監視ID
     * 
     * @type Integer
     * @private
     */
    _watchId: null,
    
    /**
     * 最後に取得した位置情報
     * 
     * @type Jeeel.UserAgent.Geolocation.Position
     * @private
     */
    _lastPosition: null,
    
    /**
     * 成功メソッドの登録
     *
     * @param {Function} callBack 成功メソッド<br />
     *                             コールバックメソッドに渡される引数は位置情報となる<br />
     *                             void callBack(Jeeel.UserAgent.Geolocation.Position position)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    setSuccessMethod: function (callBack, thisArg) {
        this._successMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 例外メソッドの登録
     *
     * @param {Function} callBack 例外メソッド<br />
     *                             コールバックメソッドに渡される引数はエラーとなる<br />
     *                             void callBack(Error error)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    setErrorMethod: function (callBack, thisArg) {
        this._errorMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
       
    /**
     * 取得に掛かる時間の制限を設けタイムアウトの設定をする
     * 
     * @param {Integer} timeout タイムアウトの時間(ミリ秒)
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    setTimeout: function (timeout) {
        this._timeout = timeout;
        
        return this;
    },
    
    /**
     * キャッシュの有効期限
     * 
     * @param {Integer} maximumAge キャッシュが破棄されるまでの時間(ミリ秒)
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    setMaximumAge: function (maximumAge) {
        this._maximumAge = maximumAge;
        
        return this;
    },
    
    /**
     * 正確性の高い位置情報を要求するかどうかを設定する
     * 
     * @param {Booleans} enable 正確な情報を要求するかどうか
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    enableHighAccuracy: function (enable) {
        this._enableHighAccuracy = !!enable;
        
        return this;
    },
    
    /**
     * 最後の取得した位置情報を取得する<br />
     * なお成功メソッドが呼び出された後に更新が行われる
     * 
     * @return {Jeeel.UserAgent.Geolocation.Position} 位置情報を示すインスタンス
     */
    getLastPosition: function () {
        return this._lastPosition;
    },
    
    /**
     * 現在の位置情報を取得する
     * 
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    getCurrentPosition: function () {
        if (this._watchId) {
            throw new Error('このインスタンスは位置情報の監視を行っています。\n監視中はこのメソッドを使用できません。');
        }
        
        var self = this;

        navigator.geolocation.getCurrentPosition(
            function (pos) {
                pos = new Jeeel.UserAgent.Geolocation.Position(pos);
                
                if (self._successMethod) {
                    self._callMethod('_successMethod', pos);
                }
                
                self._lastPosition = pos;
            },
            function (error) {
                if (self._errorMethod) {
                    self._callMethod('_errorMethod', error);
                } else {
                    Jeeel.errorHtmlDump('Error', error.name, error.fileName + '(' + error.lineNumber + ')', error.message);
                }
            },
            this._getOption()
        );
          
        return this;
    },
    
    /**
     * 位置情報の監視を行う
     * 
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    watchPosition: function () {
        if (this._watchId) {
            throw new Error('既に位置情報の監視を行っています。位置情報の監視は1つまでです。');
        }
        
        var self = this;
        
        this._watchId = navigator.geolocation.watchPosition(
            function (pos) {
                pos = new Jeeel.UserAgent.Geolocation.Position(pos);
                
                if (self._successMethod) {
                    self._callMethod('_successMethod', pos);
                }
                
                self._lastPosition = pos;
            },
            function (error) {
                if (self._errorMethod) {
                    self._callMethod('_errorMethod', error);
                } else {
                    Jeeel.errorHtmlDump('Error', error.name, error.fileName + '(' + error.lineNumber + ')', error.message);
                }
            },
            this._getOption()
        );
          
        return this;
    },
    
    /**
     * 位置情報の監視を破棄する
     * 
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    clearWatch: function () {
        if ( ! this._watchId) {
            throw new Error('このインスタンスで位置情報の監視は行っていません。');
        }
        
        navigator.geolocation.clearWatch(this._watchId);
        
        this._watchId = null;
        
        return this;
    },
    
    /**
     * オプションを作成して返す
     * 
     * @return {Hash} オプション
     * @private
     */
    _getOption: function () {
        var option = {
            enableHighAccuracy: this._enableHighAccuracy
        };
        
        if (Jeeel.Type.isInteger(this._timeout)) {
            option.timeout = this._timeout;
        }
        
        if (Jeeel.Type.isInteger(this._maximumAge)) {
            option.timeout = this._maximumAge;
        }
        
        return option;
    },
    
    _callMethod: function (name, arg) {
        this[name].func.call(this[name].thisArg || this, arg);
    }
};

Jeeel.file.Jeeel.UserAgent.Geolocation = ['Position'];

Jeeel._autoImports(Jeeel.directory.Jeeel.UserAgent.Geolocation, Jeeel.file.Jeeel.UserAgent.Geolocation);
/**
 * コンストラクタ
 * 
 * @class 位置情報を保持するクラス
 * @param {Geoposition} position 基となる位置情報
 */
Jeeel.UserAgent.Geolocation.Position = function (position) {
    this._position = position;
    this._timestamp = Jeeel.Object.Date.create(position.timestamp);
};

Jeeel.UserAgent.Geolocation.Position.prototype = {
  
    /**
     * 基となる位置情報
     * 
     * @type Geoposition
     * @private
     */
    _position: null,
    
    /**
     * 位置情報を取得した時刻
     * 
     * @type Jeeel.Object.Date
     * @private
     */
    _timestamp: null,
    
    /**
     * 経度を取得する
     * 
     * @return {Number} 経度
     */
    getLatitude: function () {
        return this._position.latitude;
    },
    
    /**
     * 緯度を取得する
     * 
     * @return {Number} 緯度
     */
    getLongitude: function () {
        return this._position.longitude;
    },
    
    /**
     * 標高を取得する
     * 
     * @return {Number} 標高
     */
    getAltitude: function () {
        return this._position.altitude;
    },
    
    /**
     * 経度・緯度の正確さを取得する
     * 
     * @return {Number} 正確さ
     */
    getAccuracy: function () {
        return this._position.accuracy;
    },
    
    /**
     * 標高の正確さを取得する
     * 
     * @return {Number} 正確さ
     */
    getAltitudeAccuracy: function () {
        return this._position.altitudeAccuracy;
    },
    
    /**
     * デバイスの進行方向を取得する
     * 
     * @return {Number} 進行方向
     */
    getHeading: function () {
        return this._position.heading;
    },
    
    /**
     * デバイスの進行速度を取得する
     * 
     * @return {Number} 進行速度
     */
    getSpeed: function () {
        return this._position.speed;
    },
    
    /**
     * 位置情報が取得された時刻を示すインスタンスを返す
     * 
     * @return {Jeeel.Object.Date} 位置情報の取得時刻を示すインスタンス
     */
    getTimestamp: function () {
        return this._timestamp;
    }
};

Jeeel.directory.Jeeel.Json = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Json/';
    }
};

/**
 * Json関連のモジュール
 */
Jeeel.Json = {

};

Jeeel.file.Jeeel.Json = ['Encode', 'Decode', 'IsJson'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Json, Jeeel.file.Jeeel.Json);

/**
 * Jsonをエンコードする<br/>
 * なお参照も全て展開するので、<br />
 * 参照先がまた自身を参照しているような無限ループの場合サイズオーバーが起こる<br />
 * またプライベートプロパティ・メソッドまでは修正変換されないので、<br />
 * デコード後にまったく同じように使えるとは限らない
 *
 * @param {Mixied} obj Jsonに変換するオブジェクト
 * @param {Boolean} [serializeScript] エンコード時にJavaScriptの型について厳密に変換するかどうか
 * @return {String} Jsonに変換後の文字列
 * @throws {RangeError} 無限ループに入った場合またはオブジェクトのサイズが限界を超えた場合に発生する
 */
Jeeel.Json.encode = function (obj, serializeScript) {

    var res;

    if (Jeeel.Type.isPrimitive(obj)) {
        if (Jeeel.Type.isString(obj)) {
            res = '"' + obj.replace('\\', '\\\\')
                           .replace(/(\r\n|\n)/ig, '\\n')
                           .replace(/\t/ig, '\\t')
                           .replace('"', '\\"')
                           .replace("'", "\\'") + '"';

            return res;
        }

        return '' + obj;
    }

    if (Jeeel.Type.isFunction(obj)) {
        
        if (serializeScript) {
            if (obj === Object) {
                return 'Object';
            } else if (obj === Array) {
                return 'Array';
            } else if (obj === String) {
                return 'String';
            } else if (obj === Boolean) {
                return 'Boolean';
            } else if (obj === Date) {
                return 'Date';
            } else if (obj === RegExp) {
                return 'RegExp';
            } else if (Jeeel._debugMode && Jeeel.Debug && obj[Jeeel.Debug.Debugger.INFORMATION_NAME]) {
                return obj[Jeeel.Debug.Debugger.INFORMATION_NAME].name;
            }
        }
        
        res = obj.toString().replace(/\/\/[^\r\n]*(\r\n|\n)/ig, '')
                            .replace(/((\r\n|\n) +|\t|\r\n|\n){1,}/ig, ' ');

        return res;
    }
    
    if (serializeScript) {
        if (Jeeel.Type.isDate(obj)) {
            return 'new Date(' + obj.getTime() + ')';
        } else if (Jeeel.Type.isMath(obj)) {
            return 'Math';
        } else if (Jeeel.Type.isJSON(obj)) {
            return 'JSON';
        } else if (Jeeel.Type.isRegularExpression(obj)) {
            return obj.toString();
        }
    }

    if (Jeeel.Type.isArray(obj)) {
        res  = [];

        for (var i = 0, l = obj.length; i < l; i++) {
            res[i] = arguments.callee(obj[i], serializeScript);
        }

        return '[' + res.join(',') + ']';
    } else {
        res = [];

        for (var key in obj) {
            if (Jeeel._debugMode && Jeeel.Debug && key === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }

            res[res.length] = '"' + key + '":' + arguments.callee(obj[key], serializeScript);
        }

        return '{' + res.join(',') + '}';
    }
};

/**
 * 作成したJsonをデコードする<br />
 * 検証を行い、evalして返す
 *
 * @param {String} json Json形式の文字列
 * @param {Boolean} [isSecure] JSONの中身の安全性が確実な場合にtrueにすると検証なしで動作するため速くなる(また、完全なJSON形式でなくても動作するようになる)
 * @return {Mixied} 変換後の値(空文字の場合はundefinedが返る)
 * @throws {TypeError} jsonが文字列ではないときに発生
 * @throws {SyntaxError} jsonがJson形式でないときに発生
 */
Jeeel.Json.decode = function (json, isSecure) {

    // jsonの中身が空の場合nullではなくundefinedを返す("null"をデコードした時と区別するため)
    if ( ! json) {
        return void 0;
    }
    
    if ( ! Jeeel.Type.isString(json)) {
        throw new TypeError('jsonが文字列ではありません。');
    } else if ( ! isSecure) {
        if (Jeeel._global.JSON) {
            return JSON.parse(json);
        } else if ( ! Jeeel.Json.isJson(json)) {
            throw new SyntaxError('jsonがJson形式になっていません。');
        }
    }

    return eval('(' + json + ')');
};

/**
 * 完全なJson形式であるかどうかを返す(メソッド等が入っていた場合は不可)
 *
 * @param {String} json 検査対象の文字列
 * @return {Boolean} Json形式であるかどうか
 */
Jeeel.Json.isJson = function (json) {

    if ( ! Jeeel.Type.isString(json)) {
        throw new TypeError('jsonが文字列ではありません。');
    }

    if (json.match(/^\s*$/)) {
        return false;
    }
    
    return !(/[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/.test(json.replace(/"(\\.|[^"\\])*"/g, ' ')));
};
Jeeel.directory.Jeeel.Session = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Session/';
    }
};

/**
 * Session関連のネームスペース
 */
Jeeel.Session = {

    /**
     * Sessionの保存期間の初期値を取得する
     *
     * @return {Integer} 保存期間(秒)
     */
    getExpires: function () {
        return Jeeel.Session.Core.expires;
    },

    /**
     * Sessionの保存期間の初期値を設定する<br />
     * マイナスを指定すると無制限になる
     *
     * @param {Integer} expires 保存期間(秒)
     * @return {Jeeel.Session} 自オブジェクト
     */
    setExpires: function (expires) {

        if ( ! Jeeel.Type.isInteger(expires)) {
            throw new Error('expiresが整数ではありません。');
        }

        Jeeel.Session.Core.expires = expires;

        return this;
    },

    /**
     * Sessionの読み込み許可をするドメインの初期値を取得する
     *
     * @return {String} 読み込み可能ドメイン
     */
    getDomain: function () {
        return Jeeel.Session.Core.domain;
    },

    /**
     * Sessionの読み込み許可をするドメインの初期値を設定する
     *
     * @param {String} domain 読み込み可能ドメイン
     * @return {Jeeel.Session} 自オブジェクト
     */
    setDomain: function (domain) {

        if ( ! Jeeel.Type.isString(domain)) {
            throw new Error('domainが文字列ではありません。');
        }

        Jeeel.Session.Core.domain = domain;

        return this;
    },

    /**
     * Sessionの読み込み可能パスの初期値を取得する
     *
     * @return {String} 読み込み可能パス
     */
    getPath: function () {
        return Jeeel.Session.Core.path;
    },

    /**
     * Sessionの読み込み可能パスの初期値を設定する
     *
     * @param {String} path 読み込み可能パス
     * @return {Jeeel.Session} 自オブジェクト
     */
    setPath: function (path) {

        if ( ! Jeeel.Type.isString(path)) {
            throw new Error('pathが文字列ではありません。');
        }

        Jeeel.Session.Core.path = path;

        return this;
    }
};

Jeeel.file.Jeeel.Session = ['Core', 'Abstract', 'Cookie', 'Name'];

if (Jeeel._extendMode.WebStorage && Jeeel._global && Jeeel._global.sessionStorage && Jeeel._global.localStorage) {
    Jeeel.file.Jeeel.Session[Jeeel.file.Jeeel.Session.length] = 'WebStorage';
}

Jeeel._autoImports(Jeeel.directory.Jeeel.Session, Jeeel.file.Jeeel.Session);

/**
 * コンストラクタ
 * 
 * @class セッション内のデータのやり取りを提供するコアクラス
 * @param {Hash} params リスト化したい値を保持するキー
 * @param {Integer} [expires] Sessionの保存期限(秒)<br />
 *                             マイナスを指定すると無制限になる
 * @param {String} [domain] 許可ドメイン
 * @param {String} [path] 許可パス
 */
Jeeel.Session.Core = function (params, expires, domain, path) {
    if ( ! Jeeel.Type.isHash(params)) {
        throw new Error('paramsがHashではありません。');
    }

    this.params  = params;
    this.created = (arguments[4] ? new Date(arguments[4]) : new Date());
    this.expires = (Jeeel.Type.isInteger(expires) ? expires : 1440);
    this.path    = (Jeeel.Type.isString(path) ? path : '/');
    this.domain  = (Jeeel.Type.isString(domain) ? domain : Jeeel.UserAgent.getDomain());
};

/**
 * インスタンスの作成を行う
 *
 * @param {Hash} params リスト化したい値を保持するキー
 * @return {Jeeel.Session.Core} 作成したインスタンス
 */
Jeeel.Session.Core.create = function (params) {
    return new this(params, this.expires, this.domain, this.path);
};

/**
 * Sessionオブジェクトかどうかを返す
 *
 * @param {Mixied} val 判定値
 * @return {Boolean} 判定結果
 */
Jeeel.Session.Core.isSessionObject = function (val) {
    if ( ! Jeeel.Type.isObject(val)) {
        return false;
    }
    else if ( ! Jeeel.Type.isHash(val.params)) {
        return false;
    }
    else if ( ! Jeeel.Type.isString(val.created)) {
        return false;
    }
    else if ( ! Jeeel.Type.isInteger(val.expires)) {
        return false;
    }
    else if ( ! Jeeel.Type.isString(val.domain)) {
        return false;
    }
    else if ( ! Jeeel.Type.isString(val.path)) {
        return false;
    }

    return true;
};

/**
 * 現在のドメインが許可されているのかどうかを調べる
 *
 * @param {String} target 対象のドメイン
 * @return {Boolean} 許可されたドメインならばtrueそれ以外はfalseを返す
 */
Jeeel.Session.Core.isAllowDomain = function (target) {
    var domain = Jeeel.UserAgent.getDomain();

    var reg = new RegExp('^'+target.replace('.', '\\.'));

    if (domain.match(reg)) {
        return true;
    }

    return false;
};

/**
 * 現在アクセスしているパスが許可されているのかどうか調べる
 *
 * @param {String} target 対象のパス
 * @return {Boolean} 許可されたパスならばtrueそれ以外はfalseを返す
 */
Jeeel.Session.Core.isAllowPath = function (target) {
    var path = Jeeel.UserAgent.getPath();

    var reg = new RegExp('^'+target+(target.charAt(target.length-1) == '/' ? '' : '(/|$)'));

    if (path.match(reg)) {
        return true;
    }

    return false;
};

/**
 * シリアライズされてオブジェクトの復元を行う
 *
 * @param {String} serializeObj シリアライズされているオブジェクト
 * @return {Jeeel.Session.Core} 復元したインスタンス
 */
Jeeel.Session.Core.unserialize = function (serializeObj) {
    var session;

    try {
        session = Jeeel.Json.decode(decodeURIComponent(serializeObj));
    } catch(e) {
        session = {};
    }
    
    if ( ! Jeeel.Type.isHash(session)) {
        return this.create({});
    }

    var res = {};

    for (var domain in session) {

        if ( ! this.isAllowDomain(domain)) {
            continue;
        }

        for (var path in session[domain]) {

            if ( ! this.isAllowPath(path)) {
                continue;
            }

            var val = session[domain][path];

            if ( ! this.isSessionObject(val)) {
                val = this.create({});
            } else {
                val = new this(val.params, val.expires, val.domain, val.path, val.created);
            }

            if (val.isTimeOver()) {
                val = this.create({});
            }

            res = Jeeel.Hash.merge(res, val.params);
        }

        break;
    }

    session = this.create(res);

    return session;
};

/**
 * クッキーの内容をロードする
 *
 * @param {String} cookieObj document.cookie内部の値
 * @return {Jeeel.Session.Core} 作成したインスタンス
 */
Jeeel.Session.Core.loadCookie = function (cookieObj) {
    var objs = cookieObj.split(/:|; /);

    var params = {};

    for (var i = 0, l = objs.length; i < l; i++) {
        var pair = objs[i].split('=');

        var session = decodeURIComponent(pair[1]);

        try {
            session = Jeeel.Json.decode(session);
        } catch (e) {}

        params[pair[0]] = session;
    }

    return this.create(params);
};

/**
 * Sessionの保存期限の初期値(秒)<br />
 * マイナスを指定すると無制限になる
 *
 * @type Integer
 */
Jeeel.Session.Core.expires = 1440;

/**
 * Sessionの読み込み可能ドメインの初期値
 *
 * @type String
 */
Jeeel.Session.Core.domain = Jeeel.UserAgent.getDomain();

if (Jeeel.Session.Core.domain === 'localhost') {
    Jeeel.Session.Core.domain = '';
}

/**
 * Sessionの読み込み可能パスの初期値
 *
 * @type String
 */
Jeeel.Session.Core.path = '/';

Jeeel.Session.Core.prototype = {
    
    /**
     * Sessionに保存するパラメータ
     *
     * @type Hash
     */
    params: {},

    /**
     * Sessionを作成した時刻
     *
     * @type Date
     */
    created: null,

    /**
     * Sessionの保存期限(秒)<br />
     * マイナスを指定すると無制限になる
     *
     * @type Integer
     */
    expires: -1,

    /**
     * Sessionの読み込み可能パス
     *
     * @type String
     */
    path: '',

    /**
     * Sessionの読み込み可能ドメイン
     *
     * @type String
     */
    domain: '',
    
    /**
     * シリアライズが可能なオブジェクトを返す
     *
     * @return {Object} シリアライズ可能オブジェクト
     */
    getSerializeableObject: function () {
        return {
            params:  this.params,
            created: this.created.toGMTString(),
            expires: this.expires,
            domain:  this.domain,
            path:    this.path
        };
    },

    /**
     * Sessionオブジェクトをシリアライズする
     *
     * @param {String} windowName window.nameの値
     * @return {String} シリアライズされたSessionオブジェクト
     */
    serialize: function (windowName) {
        var sessionOwner;

        try {
            sessionOwner = Jeeel.Json.decode(decodeURIComponent(windowName));
        } catch(e) {
            sessionOwner = {};
        }

        if ( ! Jeeel.Type.isObject(sessionOwner)) {
            sessionOwner = {};
        }

        if ( ! (this.domain in sessionOwner)) {
            sessionOwner[this.domain] = {};
        }

        if ( ! this.constructor.isSessionObject(sessionOwner[this.domain][this.path])) {
            sessionOwner[this.domain][this.path] = this.getSerializeableObject();
        } else {

            var selfObj = this.getSerializeableObject();

            delete selfObj.params;

            sessionOwner[this.domain][this.path] = Jeeel.Hash.merge(sessionOwner[this.domain][this.path], selfObj);

            for (var key in this.params) {
                sessionOwner[this.domain][this.path].params[key] = this.params[key];

                if ( ! Jeeel.Type.isSet(sessionOwner[this.domain][this.path].params[key])) {
                    delete sessionOwner[this.domain][this.path].params[key];
                }
            }
        }

        return encodeURIComponent(Jeeel.Json.encode(sessionOwner));
    },

    /**
     * Session情報をクッキーに保存できる形式に変換して返す
     *
     * @return {String} クッキー保存形式の文字列
     */
    getCookie: function () {
        var expires = new Date(this.created.toString());

        expires.setSeconds(expires.getSeconds() + this.expires);
        expires = expires.toGMTString();

        var params = [];

        for (var key in this.params) {
            if (Jeeel.Type.isString(this.params[key])) {
                params[params.length] = key + '=' + encodeURIComponent(this.params[key]);
            } else {
                params[params.length] = key + '=' + encodeURIComponent(Jeeel.Json.encode(this.params[key]));
            }
        }

        return params.join(':') + (this.expires < 0 ? '' : ';expires=' + expires) + (this.domain == '' ? '' : ';domain=' + this.domain) + ';path=' + this.path + ';';
    },

    /**
     * このSessionオブジェクトの期限が切れていないかどうかを調べる
     *
     * @return {Boolean} 期限切れならばtrueそれ以外はfalseを返す
     */
    isTimeOver: function () {

        if (this.expires < 0) {
            return false;
        }

        var expires = new Date(this.created.toString());

        expires.setSeconds(expires.getSeconds() + this.expires);

        var now = new Date();

        if (now.getTime() > expires.getTime()) {
            return true;
        }

        return false;
    },

    /**
     * 現在のドメインが許可されているのかどうかを調べる
     *
     * @return {Boolean} 許可されたドメインならばtrueそれ以外はfalseを返す
     */
    isAllowDomain: function () {
        var domain = Jeeel.UserAgent.getDomain();

        var reg = new RegExp('^'+this.domain.replace('.', '\\.'));

        if (domain.match(reg)) {
            return true;
        }

        return false;
    },

    /**
     * 現在アクセスしているパスが許可されているのかどうか調べる
     *
     * @return {Boolean} 許可されたパスならばtrueそれ以外はfalseを返す
     */
    isAllowPath: function () {
        var path = Jeeel.UserAgent.getPath();

        var reg = new RegExp('^'+this.path+(this.path.charAt(this.path.length-1) == '/' ? '' : '(/|$)'));

        if (path.match(reg)) {
            return true;
        }

        return false;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Hash} params リスト化したい値を保持するキー
     * @param {Integer} [expires] Sessionの保存期限(秒)<br />
     *                             マイナスを指定すると無制限になる
     * @param {String} [domain] 許可ドメイン
     * @param {String} [path] 許可パス
     * @constructor
     */
    constructor: Jeeel.Session.Core
};

/**
 * コンストラクタ
 *
 * @abstractClass セッションクラスを作る際の抽象クラス
 */
Jeeel.Session.Abstract = function () {
    this._session = Jeeel.Session.Core.create({});
};

Jeeel.Session.Abstract.prototype = {

    /**
     * セッションの必要値の保存領域
     * 
     * @type Jeeel.Session.Core
     * @protected
     */
    _session: null,

    /**
     * パラメータを取得する
     *
     * @param {String} key 保存する値を示すキー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixed} 保存されていた値
     */
    get: function (key, defaultValue) {
        return (key in this._session.params ? this._session.params[key] : defaultValue);
    },

    /**
     * パラメータを全て取得する
     *
     * @return {Hash} 保存されていた値の連想配列
     */
    getAll: function () {
        return this._session.params;
    },

    /**
     * パラメータを設定する
     *
     * @param {String} key 保存する値を示すキー
     * @param {Mixed} value 保存する値
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    set: function (key, value) {
        this._session.params[key] = value;

        return this;
    },

    /**
     * パラメータを設定する
     *
     * @param {Hash} values 保存する値の連想配列
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    setAll: function (values) {

        if ( ! Jeeel.Type.isHash(values)) {
            throw new Error('valuesがHashではありません。');
        }

        this._session.params = values;

        return this;
    },

    /**
     * 指定したキーの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    unset: function (key) {
        this._session.params[key] = undefined;

        return this;
    },

    /**
     * 指定したキーの値を保持しているかどうかを返す
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    has: function (key) {
        return key in this._session.params;
    },

    /**
     * パラメータを全て破棄する
     *
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    clear: function () {
        this._session.params = {};
        
        return this;
    },

    /**
     * Sessionの保存期間を取得する
     *
     * @return {Integer} 保存期間(秒)
     */
    getExpires: function () {
        return this._session.expires;
    },

    /**
     * Sessionの保存期間を設定する<br />
     * マイナスを指定すると無制限になる
     *
     * @param {Integer} expires 保存期間(秒)
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    setExpires: function (expires) {

        if ( ! Jeeel.Type.isInteger(expires)) {
            throw new Error('expiresが整数ではありません。');
        }

        this._session.expires = expires;

        return this;
    },

    /**
     * Sessionの読み込み許可をするドメインを取得する
     *
     * @return {String} 読み込み可能ドメイン
     */
    getDomain: function () {
        return this._session.domain;
    },

    /**
     * Sessionの読み込み許可をするドメインを設定する
     *
     * @param {String} domain 読み込み可能ドメイン
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    setDomain: function (domain) {

        if ( ! Jeeel.Type.isString(domain)) {
            throw new Error('domainが文字列ではありません。');
        }

        this._session.domain = domain;

        return this;
    },

    /**
     * Sessionの読み込み可能パスを取得する
     *
     * @return {String} 読み込み可能パス
     */
    getPath: function () {
        return this._session.path;
    },

    /**
     * Sessionの読み込み可能パスを設定する
     *
     * @param {String} path 読み込み可能パス
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    setPath: function (path) {

        if ( ! Jeeel.Type.isString(path)) {
            throw new Error('pathが文字列ではありません。');
        }

        this._session.path = path;

        return this;
    }
};
/**
 * コンストラクタ<br />
 * コンストラクタを直接使用した場合はロードは行われない
 *
 * @class Cookieを使用してセッションを扱うクラス(クッキーが使用できるのを前提に動作する)
 * @augments Jeeel.Session.Abstract
 */
Jeeel.Session.Cookie = function () {
    Jeeel.Session.Abstract.call(this);
};

/**
 * インスタンスの作成を行う<br />
 * さらにロードも同時に行う
 *
 * @param {Boolean} [loadsCookie] クッキーのロードを行うかどうか(初期は行わない)
 * @return {Jeeel.Session.Cookie} 作成したインスタンス
 */
Jeeel.Session.Cookie.create = function (loadsCookie) {
    var obj = new this();

    return (loadsCookie ? obj.load() : obj);
};

Jeeel.Session.Cookie.prototype = {
    
    /**
     * 設定した値をセッションに保存する<br >
     * 実際にクッキーに保存するのでログイン状態等に注意
     *
     * @return {Jeeel.Session.Cookie} 自インスタンス
     */
    save: function () {
        Jeeel._doc.cookie = this._session.getCookie();

        return this;
    },
    
    /**
     * セッションに保存されていた値を読み込む<br/>
     * なお、現在保持している値は全て削除される
     *
     * @return {Jeeel.Session.Cookie} 自インスタンス
     */
    load: function () {
        this._session = Jeeel.Session.Core.loadCookie(Jeeel._doc.cookie);

        return this;
    }
};

Jeeel.Class.extend(Jeeel.Session.Cookie, Jeeel.Session.Abstract);

/**
 * コンストラクタ<br />
 * コンストラクタを直接使用した場合はロードは行われない
 *
 * @class Cookieを使用しないセッションを扱うクラス(但しサーバー側には干渉しない、またドメインが変わっても参照できるため重要な情報保持には向かない)<br />なおこのクラスはwindow.nameを使用している
 * @augments Jeeel.Session.Abstract
 */
Jeeel.Session.Name = function () {
    Jeeel.Session.Abstract.call(this);
};

/**
 * インスタンスの作成を行う<br />
 * さらにロードも同時に行う
 *
 * @return {Jeeel.Session.Name} 作成したインスタンス
 */
Jeeel.Session.Name.create = function () {
    return (new this()).load();
};

Jeeel.Session.Name.prototype = {
  
    /**
     * 設定した値をセッションに保存する<br />
     * なおセーブ時は前に保持していた値は削除された後保存されるので、<br />
     * 注意して行う必要がある。
     *
     * @return {Jeeel.Session.Name} 自インスタンス
     */
    save: function () {
        Jeeel._global.name = this._session.serialize(Jeeel._global.name);

        return this;
    },
    
    /**
     * セッションに保存されていた値を読み込む<br/>
     * なお、現在保持している値は全て削除される
     *
     * @return {Jeeel.Session.Name} 自インスタンス
     */
    load: function () {
        this._session = Jeeel.Session.Core.unserialize(Jeeel._global.name);

        return this;
    }
};

Jeeel.Class.extend(Jeeel.Session.Name, Jeeel.Session.Abstract);

/**
 * コンストラクタ<br />
 * コンストラクタを直接使用した場合はロードは行われない
 *
 * @class Cookieを使用しないセッションを扱うクラス(但しサーバー側には干渉しない、またドメイン・プロトコル・ポート番号で制御されるため異なるドメイン間等ではデータのやりとりは出来ない)<br />なおこのクラスはwindow.localStorageを使用している
 * @augments Jeeel.Session.Abstract
 * @param {Boolean} [isPersistent] データの永続化をするかどうか(ブラウザを閉じてもアクセス出来るか)
 * @param {String} [name] 保存名を明示的に指定する場合に指定
 */
Jeeel.Session.WebStorage = function (isPersistent, name) {
  
    Jeeel.Session.Abstract.call(this);

    /**
     * 保存データを永続化するかどうか
     * 
     * @type Boolean
     * @private
     */
    this._isPersistent = !!isPersistent;
    
    /**
     * 保存する際に使用するキー
     *
     * @type String
     * @private
     */
    this._sessionName = name || Jeeel.Session.WebStorage.STORAGE_NAME;
};

/**
 * インスタンスの作成を行う<br />
 * さらにロードも同時に行う
 *
 * @param {Boolean} [isPersistent] データの永続化をするかどうか(ブラウザを閉じてもアクセス出来るか)
 * @param {String} [name] 保存名を明示的に指定する場合に指定
 * @return {Jeeel.Session.WebStorage} 作成したインスタンス
 */
Jeeel.Session.WebStorage.create = function (isPersistent, name) {
    return (new this(isPersistent, name)).load();
};

/**
 * localStorageに保存する際のキー
 * 
 * @type String
 * @constant
 */
Jeeel.Session.WebStorage.STORAGE_NAME = 'Jeeel-Session-WebStorage-Name';

Jeeel.Session.WebStorage.prototype = {
    
    /**
     * 設定した値をセッションに保存する<br />
     * なおセーブ時は前に保持していた値は削除された後保存されるので、<br />
     * 注意して行う必要がある。
     *
     * @return {Jeeel.Session.WebStorage} 自インスタンス
     */
    save: function () {
        (this._isPersistent ? Jeeel._global.localStorage : Jeeel._global.sessionStorage).setItem(this._sessionName, this._session.serialize((this._isPersistent ? Jeeel._global.localStorage : Jeeel._global.sessionStorage).getItem(this._sessionName)));

        return this;
    },
    
    /**
     * セッションに保存されていた値を読み込む<br/>
     * なお、現在保持している値は全て削除される
     *
     * @return {Jeeel.Session.WebStorage} 自インスタンス
     */
    load: function () {
        this._session = Jeeel.Session.Core.unserialize((this._isPersistent ? Jeeel._global.localStorage : Jeeel._global.sessionStorage).getItem(this._sessionName));

        return this;
    }
};

Jeeel.Class.extend(Jeeel.Session.WebStorage, Jeeel.Session.Abstract);
Jeeel.directory.Jeeel.Dom = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Dom/';
    }
};

/**
 * Domに関するネームスペース
 */
Jeeel.Dom = {

};

Jeeel.file.Jeeel.Dom = ['Core', 'Node', 'Window', 'Document', 'Xml', 'Event', 'Style', 'Element', 'ElementOperator', 'SearchOption'];

if (Jeeel._auto) {
    Jeeel.Dom._tmp = function () {
        for (var i = 1, l = Jeeel.file.Jeeel.Dom.length; i < l; i++) {
            Jeeel._import(Jeeel.directory.Jeeel.Dom, Jeeel.file.Jeeel.Dom[i]);
        }

        delete Jeeel.Dom._tmp;
    };

    Jeeel._import(Jeeel.directory.Jeeel.Dom, Jeeel.file.Jeeel.Dom[0]);
}
Jeeel.directory.Jeeel.Dom.Core = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Core/';
    }
};

Jeeel.Dom.Core = {
    
};

Jeeel.file.Jeeel.Dom.Core = ['Searcher'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Core, Jeeel.file.Jeeel.Dom.Core);

if (Jeeel.Dom._tmp) {
    Jeeel.Dom._tmp();
}
/**
 * コンストラクタ
 * 
 * @class 指定した要素内の検索を行うクラス
 * @param {Node} target 検索対象ノード
 */
Jeeel.Dom.Core.Searcher = function (target) {
    this._target = target;
    this._init();
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Node} target 検索対象ノード
 * @return {Jeeel.Dom.Core.Searcher} 作成したインスタンス
 */
Jeeel.Dom.Core.Searcher.create = function (target) {
    return new this(target);
};

Jeeel.Dom.Core.Searcher.caches = {};

Jeeel.Dom.Core.Searcher.prototype = {
  
    /**
     * 検索対象要素
     * 
     * @type Node
     * @private
     */
    _target: null,
    
    /**
     * このElement内から指定IDのHTML要素を取得する
     *
     * @param {String} id 検索ID
     * @return {Element} 取得したElement
     */
    getElementById: function (id) {
        return this._target.getElementById(id) || null;
    },
    
    /**
     * このElement内から指定ClassのHTML要素を取得する
     *
     * @param {String|String[]} className 検索Class
     * @return {Element[]} 取得したElement配列
     */
    getElementsByClassName: function (className) {

        if (Jeeel.Type.isArray(className)) {
            return this.searchElementsByClassName(className);
        }
      
        var res = this._target.getElementsByClassName(className);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定NameのHTML要素を取得する
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする
     *
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch=false] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか
     * @return {Element[]} 取得したElement配列
     */
    getElementsByName: function (name, submitSearch) {
        
        if (Jeeel.Type.isArray(name) || submitSearch) {
            return this.searchElementsByName(name, submitSearch);
        }
        
        var res = this._target.getElementsByName(name);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定TagのHTML要素を取得する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Element[]} 取得したElement配列
     */
    getElementsByTagName: function (tagName) {
      
        if (Jeeel.Type.isArray(tagName)) {
            return this.searchElementsByTagName(tagName);
        }
      
        var res = this._target.getElementsByTagName(tagName);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定属性が指定値のHTML要素を取得する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByAttribute: function (attribute, value) {
        var res = this._target.getElementsByAttribute(attribute, value);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定プロパティが指定値のHTML要素を取得する<br />
     * Elementのプロパティである事に注意
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value プロパティ値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByProperty: function (property, value) {
        var res = this._target.getElementsByProperty(property, value);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内部に絞り込みを掛ける<br />
     * 現在のHTML内に存在しない要素は取れない
     *
     * @param {String} selector CSSと同じ絞り込みセレクタ
     * @return {Element[]} 絞り込んだElement配列
     */
    getElementsBySelector: function (selector) {
        var res = this._target.querySelectorAll(selector);
        
        return Jeeel.Hash.toArray(res);
    },
    
    searchElementById: function (id) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var search = function (elm, id, f) {
            if ( ! f && elm.id === id) {
                return elm;
            }
            
            var tmp, child = elm.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    tmp = search(child, id);

                    if (tmp) {
                        return tmp;
                    }
                }

                child = child.nextSibling;
            }

            return null;
        };
        
        this.searchElementById = function (id) {
            return id && search(this._target, id, true) || null;
        };
        
        if (arguments.callee === this.getElementById) {
            this.constructor.caches[this._target.nodeType].getElementById = this.getElementById = this.searchElementById;
        }
        
        return this.searchElementById(id);
    },
    
    searchElementsByClassName: function (className) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var search = function (res, target, reg, f) {

            var className = target.className;
            
            if ( ! f && className.match && className.match(reg)) {
                res[res.length] = target;
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, reg);
                }

                child = child.nextSibling;
            }
        };
        
        this.searchElementsByClassName = function (className) {
            var res = [];
            
            if ( ! className) {
                return res;
            }
            
            var isArr = Jeeel.Type.isArray(className),
                reg;
            
            if (isArr) {
                
                if (className.length === 0) {
                    return res;
                }
                
                reg = new RegExp('(?:^| )' + className.join('|') + '(?: |$)', 'i');
            } else {
                
                reg = new RegExp('(?:^| )' + className + '(?: |$)', 'i');
            }

            search(res, this._target, reg, true);
            
            return res;
        };
        
        if (arguments.callee === this.getElementsByClassName) {
            this.constructor.caches[this._target.nodeType].getElementsByClassName = this.getElementsByClassName = this.searchElementsByClassName;
        }
        
        return this.searchElementsByClassName(className);
    },

    searchElementsByName: function (name, submitSearch) {
        var rf = new Jeeel.Filter.RegularExpressionEscape();
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var search = function (res, target, reg, s, f) {

            var name = target.name;
              
            if ( ! f && name) {
                if (s) {
                    if (name.match(reg)) {
                        res[res.length] = target;
                    }
                } else {
                    if (name === reg) {
                        res[res.length] = target;
                    }
                }
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, reg, s);
                }

                child = child.nextSibling;
            }
        };
        
        var multiSearch = function (res, target, regs, s, f) {

            var name = target.name;
              
            if ( ! f && name) {
                if (s) {
                    for (var i = regs.length; i--;) {
                        if (name.match(regs[i])) {
                            res[res.length] = target;
                            break;
                        }
                    }
                } else {
                    if (Jeeel.Type.inArray(name, regs, true)) {
                        res[res.length] = target;
                    }
                }
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    multiSearch(res, child, regs, s);
                }

                child = child.nextSibling;
            }
        };
        
        this.searchElementsByName = function (name, submitSearch) {
            var res = [];
            
            if ( ! name) {
                return res;
            }

            var isArr = Jeeel.Type.isArray(name),
                l = isArr && name.length;
            
            // 配列かどうかで検索手法を切り替える
            if (isArr && l === 0) {
                return res;
            } else if (isArr && name.length > 1) {
  
                if (submitSearch) {
                    while (l--) {
                        name[l] = new RegExp('^' + rf.filter(name[l]) + '(?:$|\\[)');
                    }
                }

                multiSearch(res, this._target, name, submitSearch, true);
            } else {
                if (isArr) {
                    name = name[0];
                }
                
                if (submitSearch) {
                    name = new RegExp('^' + rf.filter(name) + '(?:$|\\[)');
                }
                
                search(res, this._target, name, submitSearch, true);
            }
            
            return res;
        };
        
        if (arguments.callee === this.getElementsByName) {
            this.constructor.caches[this._target.nodeType].getElementsByName = this.getElementsByName = this.searchElementsByName;
        }
        
        return this.searchElementsByName(name, submitSearch);
    },

    searchElementsByTagName: function (tagName) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var search = function (res, target, tag, f) {

            if ( ! f && tag === '*' || target.nodeName.toUpperCase() === tag) {
                res[res.length] = target;
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, tag);
                }

                child = child.nextSibling;
            }
        };
        
        var multiSearch = function (res, target, tags, f) {

            if ( ! f && Jeeel.Type.inArray(target.nodeName.toUpperCase(), tags, true)) {
                res[res.length] = target;
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    multiSearch(res, child, tags);
                }

                child = child.nextSibling;
            }
        };
        
        this.searchElementsByTagName = function (tagName) {
            var res = [];
            
            if ( ! tagName) {
                return res;
            }
            
            var isArr = Jeeel.Type.isArray(tagName),
                l = isArr && tagName.length;
            
            if (isArr && l === 0) {
                return res;
            } else if (isArr && l > 1) {
                if (Jeeel.Type.inArray('*', tagName, true)) {
                    search(res, this._target, '*', true);
                } else {
                    while (l--) {
                        tagName[l] = tagName[l].toUpperCase();
                    }
                    
                    multiSearch(res, this._target, tagName, true);
                }
            } else {
                if (isArr) {
                    tagName = tagName[0];
                }
                
                search(res, this._target, tagName.toUpperCase(), true);
            }

            return res;
        };
        
        if (arguments.callee === this.getElementsByTagName) {
            this.constructor.caches[this._target.nodeType].getElementsByTagName = this.getElementsByTagName = this.searchElementsByTagName;
        }
        
        return this.searchElementsByTagName(tagName);
    },

    searchElementsByAttribute: function (attribute, value) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var search = function (res, target, attr, value, f) {

            if ( ! f && target.getAttribute) {
                var val = target.getAttribute(attr);

                if ((val && value === '*') || val === value) {
                    res[res.length] = target;
                }
            }
 
            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, attr, value);
                }

                child = child.nextSibling;
            }
        };
        
        this.searchElementsByAttribute = function (attribute, value) {
            var res = [];
            
            if ( ! attribute) {
                return res;
            }
            
            search(res, this._target, attribute, value, true);
            
            return res;
        };
        
        if (arguments.callee === this.getElementsByAttribute) {
            this.constructor.caches[this._target.nodeType].getElementsByAttribute = this.getElementsByAttribute = this.searchElementsByAttribute;
        }
        
        return this.searchElementsByAttribute(attribute, value);
    },
    
    searchElementsByProperty: function (property, value) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var search = function (res, target, prop, value, f) {

            if ( ! f && prop in target) {
                var val = target[prop];

                if (value === '*' || val == value) {
                    res[res.length] = target;
                }
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, prop, value);
                }

                child = child.nextSibling;
            }
        };
        
        this.searchElementsByProperty = function (property, value) {
            var res = [];
            
            if ( ! property) {
                return res;
            }
            
            search(res, this._target, property, value, true);
            
            return res;
        };
        
        if (arguments.callee === this.getElementsByProperty) {
            this.constructor.caches[this._target.nodeType].getElementsByProperty = this.getElementsByProperty = this.searchElementsByProperty;
        }
        
        return this.searchElementsByProperty(property, value);
    },
    
    searchElementsBySelector: function (selector) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var search = function (res, target, selector, f) {

        };
        
        this.searchElementsBySelector = function (selector) {
            var res = [];
            
            return res;
            
            if ( ! selector) {
                return res;
            }
            
            search(res, this._target, selector, true);
            
            return res;
        };
        
        if (arguments.callee === this.getElementsBySelector) {
            this.constructor.caches[this._target.nodeType].getElementsBySelector = this.getElementsBySelector = this.searchElementsBySelector;
        }
        
        return this.searchElementsBySelector(selector);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Core.Searcher,
    
    _init: function () {
        
        var key, cache = this.constructor.caches[this._target.nodeType];
        
        if (cache) {
            
            for (key in cache) {
                this[key] = cache[key];
            }
            
            return;
        }
        
        if ( ! this._target.getElementById) {
            this.getElementById = this.searchElementById;
        }
        
        if ( ! this._target.getElementsByClassName) {
            this.getElementsByClassName = this.searchElementsByClassName;
        }
        
        if ( ! this._target.getElementsByName) {
            this.getElementsByName = this.searchElementsByName;
        }
        
        if ( ! this._target.getElementsByTagName) {
            this.getElementsByTagName = this.searchElementsByTagName;
        }

        if ( ! this._target.getElementsByAttribute) {
            this.getElementsByAttribute = this.searchElementsByAttribute;
        }
        
        if ( ! this._target.getElementsByProperty) {
            this.getElementsByProperty = this.searchElementsByProperty;
        }
        
        if ( ! this._target.querySelectorAll) {
            this.getElementsBySelector = this.searchElementsBySelector;
        }
        
        cache = {};
        
        for (key in this) {
            if (key !== 'constructor' && key.indexOf('_') < 0) {
                cache[key] = this[key];
            }
        }
        
        this.constructor.caches[this._target.nodeType] = cache;
    }
};
/**
 * Nodeに関する事を保持するネームスペース
 */
Jeeel.Dom.Node = {
    
    /**
     * NodeがElement型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    ELEMENT_NODE: 1,

    /**
     * NodeがAttribute型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    ATTRIBUTE_NODE: 2,

    /**
     * NodeがText型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    TEXT_NODE: 3,
    
    /**
     * NodeがCDATASection型である事を示す定数
     * 
     * @type Integer
     * @constant
     */
    CDATA_SECTION_NODE: 4,
    
    /**
     * NodeがEntityReference型である事を示す定数
     * 
     * @type Integer
     * @constant
     */
    ENTITY_REFERENCE_NODE: 5,
    
    /**
     * NodeがEntity型である事を示す定数
     * 
     * @type Integer
     * @constant
     */
    ENTITY_NODE: 6,
    
    /**
     * NodeがProcessingInstruction型である事を示す定数
     * 
     * @type Integer
     * @constant
     */
    PROCESSING_INSTRUCTION_NODE: 7,

    /**
     * NodeがComment型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    COMMENT_NODE: 8,

    /**
     * NodeがDocument型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    DOCUMENT_NODE: 9,
    
    /**
     * NodeがDocumentType型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    DOCUMENT_TYPE_NODE: 10,

    /**
     * NodeがDocumentFragment型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    DOCUMENT_FRAGMENT_NODE: 11,
    
    /**
     * NodeがNotation型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    NOTATION_NODE: 12
};
Jeeel.directory.Jeeel.Dom.Window = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Window/';
    }
};

/**
 * コンストラクタ
 * 
 * @class windowをラップして拡張するクラス
 * @param {Window|IFrameElement} [window] 対象のウィンドウ(iframe等で階層が違う場合に指定)
 * @throws {Error} windowが指定されてかつiframeやWindow型でない場合に発生
 */
Jeeel.Dom.Window = function (window) {
  
    if (Jeeel.Window && ( ! window || window === Jeeel._global)) {
        return Jeeel.Window;
    }
    
    if ( ! window) {
        window = Jeeel._global;
    } else if (window.nodeName && window.nodeName.toUpperCase() == 'IFRAME') {
        window = window.contentWindow;
    } else if (window instanceof Jeeel.Dom.Document) {
        this._document = window;
        window = window.getDocument();
        window = window.defaultView || window.parentWindow;
    }
    
    if ( ! Jeeel.Type.isWindow(window)) {
        throw new Error('引数はWindowまたはIFrameElementを渡してください。');
    }
    
    this._window = window;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Window|IFrameElement} [window] 対象のウィンドウ(iframe等で階層が違う場合に指定)
 * @return {Jeeel.Dom.Window} 作成したインスタンス
 */
Jeeel.Dom.Window.create = function (window) {
    return new this(window);
};

Jeeel.Dom.Window.prototype = {
    /**
     * 操作対象のWindow
     * 
     * @type Window
     * @protected
     */
    _window: null,
    
    /**
     * Windowに属するDocumentのラッパーインスタンス
     * 
     * @type Jeeel.Dom.Document
     * @private
     */
    _document: null,
    
    /**
     * setIntervalを高速化するためのインスタンス
     * 
     * @type Jeeel.Dom.Window.Interval
     * @private
     */
    _interval: null,
    
    /**
     * 操作しているWindowを取得する
     * 
     * @return {Window} 操作しているWindow
     */
    getWindow: function () {
        return this._window;
    },
    
    /**
     * このWindowに属するDocumentのラッパーインスタンスを取得する
     * 
     * @return {Jeeel.Dom.Document} Documentラッパーインスタンス
     */
    getDocument: function () {
        return this._document || (this._document = Jeeel.Dom.Document.create(this));
    },
    
    /**
     * 現在のウィンドウのサイズを取得する(ブラウザサイズの切り替えで値も変わる)
     * 
     * @return {Jeeel.Object.Size} サイズ
     */
    getWindowSize: function () {},
    
    /**
     * 現在のウィンドウのスクロール位置を取得する
     * 
     * @return {Jeeel.Object.Point} スクロール位置
     */
    getScrollPosition: function () {},
    
    /**
     * モードレスなサブウィンドウを開くためのインスタンスを作成する
     * 
     * @param {String} url サブウィンドウを開く際のURL
     * @return {Jeeel.Dom.Window.Opener.Window} 作成したインスタンス
     */
    createWindowOpener: function (url) {
        return new this.constructor.Opener.Window(this._window, url);
    },
    
    /**
     * モーダルなサブウィンドウを開くためのインスタンスを作成する
     * 
     * @param {String} url サブウィンドウを開く際のURL
     * @return {Jeeel.Dom.Window.Opener.Dialog} 作成したインスタンス
     * @ignore 未完成
     */
    createDialogOpener: function (url) {
        return new this.constructor.Opener.Dialog(this._window, url);
    },
    
    /**
     * 定期的に実行するタイマーをセットする(複数のタイマーをセットする場合はこの関数を使う事で高速化が図れる)
     * 
     * @param {Function|String} func 一定時間毎に呼び出されるコールバック
     * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数
     * @return {Integer} タイマーID
     */
    setInterval: function (func, interval, var_args) {
        if ( ! this._interval) {
            this._interval = new this.constructor.Interval(this._window);
        }
        
        return this._interval.addTask.apply(this._interval, arguments);
    },
    
    /**
     * 定期実行タイマーを破棄する(このインスタンスのsetIntervalで無ければ無効)
     * 
     * @param {Integer} intervalID 破棄対象のタイマーID
     * @return {Jeeel.Dom.Window} 自インスタンス
     */
    clearInterval: function (intervalID) {
        if ( ! this._interval) {
            return this;
        }
        
        this._interval.removeTask(intervalID);
        
        return this;
    },
    
    /**
     * このWindowにイベントを追加する<br />
     * 引数はJeeel.Dom.Event, このWindowになる
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Window} 自インスタンス
     */
    addEventListener: function (type, listener, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        Jeeel.Dom.Event.addEventListener(this._window, type, listener, thisArg);
        
        return this;
    },

    /**
     * イベントの削除を行う<br />
     * このインスタンスのaddEventListenerに対して行わなければ削除はできない
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @return {Jeeel.Dom.Window} 自インスタンス
     */
    removeEventListener: function (type, listener) {
        Jeeel.Dom.Event.removeEventListener(this._window, type, listener);

        return this;
    },
    
    /**
     * このWindowに設定されているイベントを任意のタイミングで実行する
     *
     * @param {String} type イベントタイプ
     * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
     * @return {Jeeel.Dom.Window} 自インスタンス
     * @ignore 未完成
     */
    dispatchEvent: function (type, option) {
        Jeeel.Dom.Event.dispatchEvent(this._window, type, option);
        
        return this;
    },
    
    /**
     * このWindowにオーバーレイを設定する
     * 
     * @param {Boolean} enable オーバーレイを有効にするかどうか
     * @param {Hash} [styles] zIndex, backgroundColor, opacityを独自に設定する場合に指定<br />
     *                         デフォルトは以下である<br />
     *                         zIndex: 1000, backgroundColor: '#000000', opacity: 0.75
     * @return {Jeeel.Dom.Window} 自インスタンス
     */
    setOverlay: function (enable, styles) {
        if ( ! styles) {
            styles = {};
        }
        
        var doc = this._document;
        var size, overlay = doc.getElementById('jeeel-window-overlay');
        
        if ( ! enable) {
            if (overlay) {
                Jeeel.Dom.Element.create(overlay).hide();
            }
            
            return this;
        }
        
        size = Jeeel.Dom.Element.prototype.getSize.call({_element: doc.getDocumentElement()});
        
        if (overlay) {
            overlay = new Jeeel.Dom.Element(overlay);
            overlay.setStyleList({
                zIndex: styles.zIndex || 1000,
                backgroundColor: styles.backgroundColor || '#000000',
                width: size.width + 'px',
                height: size.height + 'px'
            }).setOpacity(styles.opacity ||0.75).show();

            return this;
        }
        
        overlay = new Jeeel.Dom.Element(doc.createElement('div'));

        overlay.setId('jeeel-window-overlay').setStyleList({
            position: 'absolute',
            top: '0px',
            left: '0px',
            zIndex: styles.zIndex || 1000,
            backgroundColor: styles.backgroundColor || '#000000',
            width: size.width + 'px',
            height: size.height + 'px'
        }).setOpacity(styles.opacity ||0.75).setBackgroundIframe();
        
        doc.appendToBody(overlay.getElement());
        
        return this;
    },

    /**
     * コンストラクタ
     * 
     * @param {Window|IFrameElement} [window] 対象のウィンドウ(iframe等で階層が違う場合に指定)
     * @constructor
     */
    constructor: Jeeel.Dom.Window,
    
    _init: function () {
      
        var doc = Jeeel._doc,
            win = Jeeel._global;
        
        if ( ! doc) {
            delete this._init;
            return;
        }
        
        var self = this,
            body;
        
        if (win.innerWidth) {
            self.getWindowSize = function () {
                var win = this._window;

                return new Jeeel.Object.Size(win.innerWidth, win.innerHeight);
            };
            
            self.getScrollPosition = function () {
                var win = this._window;
                
                return new Jeeel.Object.Point(win.pageXOffset, win.pageYOffset);
            };
        } else if (doc.documentElement && doc.documentElement.clientWidth) {
            self.getWindowSize = function () {
                var root = this._document.getDocumentElement();

                return new Jeeel.Object.Size(root.clientWidth, root.clientHeight);
            };
            
            self.getScrollPosition = function () {
                var root = this._document.getDocumentElement();
                
                return new Jeeel.Object.Point(root.scrollLeft, root.scrollTop);
            };
        } else if ((body = doc.body || doc.createElement('body')) && 'clientWidth' in body) {
            self.getWindowSize = function () {
                var root = this._document.getBody();

                return new Jeeel.Object.Size(root.clientWidth, root.clientHeight);
            };
            
            self.getScrollPosition = function () {
                var root = this._document.getBody();
                
                return new Jeeel.Object.Point(root.scrollLeft, root.scrollTop);
            };
        } else {
            self.getWindowSize = function () {
                return new Jeeel.Object.Size(0, 0);
            };
            
            self.getScrollPosition = function () {
                return new Jeeel.Object.Point(0, 0);
            };
        }

        delete this._init;
    }
};

Jeeel.Dom.Window.prototype._init();

Jeeel.file.Jeeel.Dom.Window = ['Opener', 'Interval'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Window, Jeeel.file.Jeeel.Dom.Window);Jeeel.directory.Jeeel.Dom.Window.Opener = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Window + 'Opener/';
    }
};

/**
 * ウィンドウやダイアログを開くためのクラスがあるネームスペース
 */
Jeeel.Dom.Window.Opener = {

};

Jeeel.file.Jeeel.Dom.Window.Opener = ['Abstract', 'Window', 'Dialog'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Window.Opener, Jeeel.file.Jeeel.Dom.Window.Opener);
/**
 * コンストラクタ
 * 
 * @abstractClass Opener系の抽象クラス
 */
Jeeel.Dom.Window.Opener.Abstract = function () {
    
};

Jeeel.Dom.Window.Opener.Abstract.prototype = {
    /**
     * 操作対象のWindow
     * 
     * @type Window
     * @private
     */
    _window: null,
    
    /**
     * 新しく開くウィンドウのURL
     * 
     * @type String
     * @private
     */
    _url: '',
    
    /**
     * HTTPメソッド
     * 
     * @type String
     * @private
     */
    _method: 'POST',

    /**
     * window.openの際にサーバー側に渡すパラメータ
     *
     * @type Jeeel.Parameter
     * @private
     */
    _params: null,
    
    /**
     * window.openの際のwindowオプション
     *
     * @type Jeeel.Parameter
     * @private
     */
    _options: null,
    
    /**
     * HTTPメソッドを取得する
     *
     * @return {String} HTTPメソッド(getまたはpost、大文字小文字は問わない)
     */
    getMethod: function () {
        return this._method;
    },
    
    /**
     * HTTPメソッドを設定する
     *
     * @param {String} method HTTPメソッド(getまたはpost、大文字小文字は問わない)
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setMethod: function (method) {
        if ( ! Jeeel.Type.isString(method)) {
            method = 'POST';
        }
        
        method = method.toUpperCase();

        if (method !== 'GET' && method !== 'POST') {
            method = 'POST';
        }

        this._method = method;

        return this;
    },
    
    /**
     * 新しく開くウィンドウのURLを取得する
     * 
     * @return {String} ウィンドウのURL
     */
    getUrl: function () {
        return this._url;
    },
    
    /**
     * 新しく開くウィンドウのURLを設定する
     * 
     * @param {String} url ウィンドウのURL
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setUrl: function (url) {
        this._url = url;
        
        return this;
    },
    
    /**
     * ウィンドウに渡すパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    get: function (key, defaultValue) {
        return this._params.get(key, defaultValue);
    },
    
    /**
     * ウィンドウに渡すパラメータ全取得
     *
     * @return {Hash} 値リスト
     */
    getAll: function () {
        return this._params.getAll();
    },
    
    /**
     * ウィンドウに渡すパラメータをセットする
     * 
     * @param {String} key キー
     * @param {Mixied} val 値
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    set: function (key, val) {
        this._params.set(key, val);
        
        return this;
    },
    
    /**
     * ウィンドウに渡すパラメータを総入れ替えする
     * 
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setAll: function (vals) {
        this._params.setAll(vals);
        
        return this;
    },
    
    /**
     * ウィンドウに渡すパラメータの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    unset: function (key) {
        this._params.unset(key);

        return this;
    },
    
    /**
     * ウィンドウのオプションの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getOption: function (key, defaultValue) {
        return this._options.get(key, defaultValue);
    },
    
    /**
     * ウィンドウのオプション全取得
     *
     * @return {Hash} 値リスト
     */
    getOptionAll: function () {
        return this._options.getAll();
    },
    
    /**
     * ウィンドウのオプションをセットする
     * 
     * @param {String} key キー
     * @param {String|Integer} val 値
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setOption: function (key, val) {
        this._options.set(key, val);
        
        return this;
    },
    
    /**
     * ウィンドウのオプションを総入れ替えする
     * 
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setOptionAll: function (vals) {
        this._options.setAll(vals);
        
        return this;
    },
    
    /**
     * ウィンドウのオプションの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    unsetOption: function (key) {
        this._options.unset(key);
        
        return this;
    },
    
    /**
     * ウィンドウを開く
     * 
     * @return {Mixied} 戻り値(子クラスの実装による)
     * @abstract
     */
    open: function () {
        throw new Error('実装されていません');
    }
};
/**
 * コンストラクタ
 * 
 * @class サブウィンドウの生成を管理するクラス
 * @param {Window} window サブウィンドウのオープン元となるWindow
 * @param {String} url サブウィンドウを開く際のURL
 * @throws {Error} windowが指定されていない場合に起こる
 * @throws {Error} urlが指定されていない場合に起こる
 */
Jeeel.Dom.Window.Opener.Window = function (window, url) {
    Jeeel.Dom.Window.Opener.Abstract.call(this);
    
    if ( ! Jeeel.Type.isWindow(window)) {
        throw new Error('Windowを指定してください。');
    } 
    else if ( ! Jeeel.Type.isString(url)) {
        throw new Error('URLを指定してください。');
    }
    
    this._window = window;
    this._url = url;
    
    this._params  = new Jeeel.Parameter();
    this._options = new Jeeel.Parameter();
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Window} window サブウィンドウのオープン元となるWindow
 * @param {String} url サブウィンドウを開く際のURL
 * @return {Jeeel.Dom.Window.Opener.Window} 作成したインスタンス
 */
Jeeel.Dom.Window.Opener.Window.create = function (window, url) {
    return new this(window, url);
};

Jeeel.Dom.Window.Opener.Window.prototype = {
  
    /**
     * 新しく開くウィンドウの名前
     * 
     * @type String
     * @private
     */
    _name: '',
  
    /**
     * 新しく開くウィンドウの名前を取得する
     * 
     * @return {String} ウィンドウの名前
     */
    getName: function () {
        return this._name;
    },
    
    /**
     * 新しく開くウィンドウの名前を設定する
     * 
     * @param {String} name ウィンドウの名前
     * @return {Jeeel.Dom.Window.Opener.Window} 自インスタンス
     */
    setName: function (name) {
        this._name = name;
        
        return this;
    },
  
    /**
     * 実際にウィンドウを開く
     * 
     * @return {Window} 開いたウィンドウ(ウィンドウを開けなかった場合はnull)
     */
    open: function () {
        var options = [];
        var ops = this._options.getAll();
        var markerName = this._name || '__MARK_WINDOW_NAME__';
        
        for (var key in ops) {
            options[options.length] = key + '=' + ops[key];
        }
        
        var window = this._window.open('', markerName, options.join(','));
        
        if ( ! window) {
            throw Error('ウィンドウを作成出来ませんでした。');
        }
        
        var submitter = Jeeel.Net.Submit.newForm(this._url, this._method);
        
        submitter.setAll(this._params.getAll())
                 .setTarget(markerName)
                 .execute();
                
        window.name = this._name;
        
        return window;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Window} window サブウィンドウのオープン元となるWindow
     * @param {String} url サブウィンドウを開く際のURL
     */
    constructor: Jeeel.Dom.Window.Opener.Window
};

Jeeel.Class.extend(Jeeel.Dom.Window.Opener.Window, Jeeel.Dom.Window.Opener.Abstract);
Jeeel.directory.Jeeel.Dom.Window.Opener.Dialog = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Window.Opener + 'Dialog/';
    }
};

/**
 * コンストラクタ
 * 
 * @class サブウィンドウの生成を管理するクラス
 * @param {Window} window サブウィンドウのオープン元となるWindow
 * @param {String} url サブウィンドウを開く際のURL
 * @throws {Error} windowが指定されていない場合に起こる
 * @throws {Error} urlが指定されていない場合に起こる
 * @ignore 未完成
 */
Jeeel.Dom.Window.Opener.Dialog = function (window, url) {
    Jeeel.Dom.Window.Opener.Abstract.call(this);
    
    if ( ! Jeeel.Type.isWindow(window)) {
        throw new Error('Windowを指定してください。');
    } 
    else if ( ! Jeeel.Type.isString(url)) {
        throw new Error('URLを指定してください。');
    }
    
    this._window = window;
    this._url = url;
    
    this._params  = new Jeeel.Parameter();
    this._options = new Jeeel.Parameter();
    this._args = new Jeeel.Parameter();
    this._method = 'GET';
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Window} window サブウィンドウのオープン元となるWindow
 * @param {String} url サブウィンドウを開く際のURL
 * @return {Jeeel.Dom.Window.Opener.Dialog} 作成したインスタンス
 */
Jeeel.Dom.Window.Opener.Dialog.create = function (window, url) {
    return new this(window, url);
};

Jeeel.Dom.Window.Opener.Dialog.prototype = {
  
    _args: null,
    
    /**
     * HTTPメソッドはGETのみ
     * 
     * @return {Jeeel.Dom.Window.Opener.Dialog} 自インスタンス
     */
    setMethod: function () {
        return this;
    },

    /**
     * ダイアログのパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getArgument: function (key, defaultValue) {
        return this._args.get(key, defaultValue);
    },
    
    /**
     * ダイアログのパラメータ全取得
     *
     * @return {Hash} 値リスト
     */
    getArgumentAll: function () {
        return this._args.getAll();
    },
    
    /**
     * ダイアログのパラメータをセットする
     * 
     * @param {String} key キー
     * @param {String|Integer} val 値
     * @return {Jeeel.Dom.Window.Opener.Dialog} 自インスタンス
     */
    setArgument: function (key, val) {
        this._args.set(key, val);
        
        return this;
    },
    
    /**
     * ダイアログのパラメータを総入れ替えする
     * 
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Dom.Window.Opener.Dialog} 自インスタンス
     */
    setArgumentAll: function (vals) {
        this._args.setAll(vals);
        
        return this;
    },
    
    /**
     * ダイアログのパラメータの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Dom.Window.Opener.Dialog} 自インスタンス
     */
    unsetArgument: function (key) {
        this._args.unset(key);
        
        return this;
    },

    /**
     * 実際にダイアログウィンドウを開く
     * 
     * @return {Mixied} ダイアログからの戻り値
     */
    open: function () {
        var options = [];
        var ops = this._options.getAll();
        
        for (var key in ops) {
            options[options.length] = key + '=' + ops[key];
        }
        
        var url;
        var prms = {};
        
        if (this._method == 'GET') {
            url = this._url + '?' + this._params.toQueryString();
            prms = this._args.getAll();
        } else {
            url = Jeeel.directory.Jeeel.Dom.Window.Opener.Dialog + 'Post.html';
            prms.Jeeel = Jeeel;
            prms.url = this._url;
            prms.method = this._method;
            prms.args = this._args.getAll();
            prms.params = this._params.getAll();
        }
        
        return this._window.showModalDialog(url, prms, options.join(';'));
    },
    
    /**
     * テンプレートを介してダイアログを開く
     * 
     * @param {Function} [callback] ページロード時のコールバック
     * @return {Mixied} ダイアログからの戻り値
     * @ignore
     */
    openTemplate: function (callback) {
        var options = [];
        var ops = this._options.getAll();
        
        for (var key in ops) {
            options[options.length] = key + '=' + ops[key];
        }
        
        var url = Jeeel.directory.Jeeel.Dom.Window.Opener.Dialog + 'Template.html?' + this._params.toQueryString();
        var prms = {
            Jeeel: Jeeel,
            parent: Jeeel._global,
            params: this._args.getAll(),
            callback: callback || function (){}
        };

        return this._window.showModalDialog(url, prms, options.join(';'));
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Window} window サブウィンドウのオープン元となるWindow
     * @param {String} url サブウィンドウを開く際のURL
     */
    constructor: Jeeel.Dom.Window.Opener.Dialog
};

Jeeel.Class.extend(Jeeel.Dom.Window.Opener.Dialog, Jeeel.Dom.Window.Opener.Abstract);
Jeeel.directory.Jeeel.Dom.Window.Interval = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Window + 'Interval/';
    }
};

/**
 * コンストラクタ
 * 
 * @class タイマーの負荷を軽減し、クロスブラウザの違いを吸収するクラス
 * @param {Window} window setInterval,clearIntervalを保持するWindow
 */
Jeeel.Dom.Window.Interval = function (window) {
    this._window = window;
    this._timestamp = Jeeel.Object.Date.create();
    this._tasks = [];
    this._tasksHash = {};
    
    var self = this, interval = this.interval;
    
    this.interval = function () {
        interval.call(self);
    };
    
    this.start();
};

Jeeel.Dom.Window.Interval.prototype = {
    /**
     * タイマー関数保持オブジェクト
     * 
     * @type Window
     * @private
     */
    _window: null,
    
    /**
     * インスタンス作成時間
     * 
     * @type Jeeel.Object.Date
     * @private
     */
    _timestamp: null,
    
    /**
     * 有効タスク一覧
     * 
     * @type Jeeel.Dom.Window.Interval[]
     * @private
     */
    _tasks: [],
    
    /**
     * タスク参照Hashテーブル
     * 
     * @type Hash
     * @private
     */
    _tasksHash: {},
    
    /**
     * タスクの実行数に応じて変化するタスクIDの元
     * 
     * @type Integer
     * @private
     */
    _taskIndex: 0,
    
    /**
     * 実際のタイマーID
     * 
     * @type Integer
     * @private
     */
    _id: 0,
    
    /**
     * ロックをしているかどうか
     * 
     * @type Boolean
     * @private
     */
    _lock: false,
    
    /**
     * 現在のタイマーにタスクを追加する
     * 
     * @param {Function|String} task タスク
     * @param {Integer} delay どれくらい置きに実行するか(ミリ秒)
     * @param {Mixied} var_args 可変引数、タスクに渡す引数
     * @return {Integer} タスクID
     * @throws {Error} taskの型が正しくなかった際に発生
     */
    addTask: function (task, delay, var_args) {
        var id = ++this._taskIndex;
        var args = Array.prototype.slice.call(arguments, 2, arguments.length);
        
        if (Jeeel.Type.isString(task)) {
            task = new Function(task);
        } else if ( ! Jeeel.Type.isFunction(task)) {
            throw new Error('taskが文字列もしくは関数ではありません。');
        }
        
        this._tasks[this._tasks.length] = this._tasksHash[id] = new this.constructor.Task(task, delay, args);
        
        this.start();
        
        args = null;
        
        return id;
    },
    
    /**
     * タイマーのタスクを破棄する
     * 
     * @param {Integer} id タスクID
     * @return {Jeeel.Dom.Window.Interval} 自インスタンス
     */
    removeTask: function (id) {
        var task = this._tasksHash[id];
        
        if ( ! task) {
            task = null;
            return this;
        }
        
        this._lock = true;
        
        for (var i = 0, l = this._tasks.length; i < l; i++) {
            if (this._tasks[i] === task) {
                this._tasks.splice(i, 1);
                break;
            }
        }
        
        task = null;
        
        delete this._tasksHash[id];
        
        if ( ! this._tasks.length) {
            this.stop();
        }
        
        this._lock = false;
        
        return this;
    },
    
    /**
     * タイマーの実行を開始する(実行中は意味が無い)
     * 
     * @return {Jeeel.Dom.Window.Interval} 自インスタンス
     */
    start: function () {
        if (this._id) {
            return this;
        }
        
        this._id = this._window.setInterval(this.interval, 10);
        
        return this;
    },
    
    /**
     * タイマーの実行を停止する(停止中は意味が無い)
     * 
     * @return {Jeeel.Dom.Window.Interval} 自インスタンス
     */
    stop: function () {
        if ( ! this._id) {
            return this;
        }
        
        this._window.clearInterval(this._id);
        
        this._id = null;
        
        return this;
    },
    
    /**
     * タイマーに呼び出されるメソッド
     */
    interval: function () {
        if (this._lock) {
            return;
        }
        
        var time = this._timestamp.getElapsedTime();
        
        this._timestamp.setElapsedTime(0);
      
        for (var i = 0, l = this._tasks.length; i < l; i++) {
            this._tasks[i].execute(time);
        }
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Window} window setInterval,clearIntervalを保持するWindow
     * @constructor
     */
    constructor: Jeeel.Dom.Window.Interval
};

Jeeel.file.Jeeel.Dom.Window.Interval = ['Task'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Window.Interval, Jeeel.file.Jeeel.Dom.Window.Interval);
/**
 * コンストラクタ
 * 
 * @class タイマー内で実行されるタスクを管理するクラス
 * @param {Function} func タスク
 * @param {Integer} delay どれくらい置きに実行するか(ミリ秒)
 * @param {Array} args タスクに渡す引数のリスト
 */
Jeeel.Dom.Window.Interval.Task = function (func, delay, args) {
    this._process = func;
    this._delay = delay;
    this._args = args || [];
};

Jeeel.Dom.Window.Interval.Task.prototype = {
    
    /**
     * 実行タスク
     * 
     * @type Function
     * @private
     */
    _process: null,
    
    /**
     * 実行遅延時間
     * 
     * @type Integer
     * @private
     */
    _delay: 0,
    
    /**
     * タスク引数
     * 
     * @type Array
     * @private
     */
    _args: [],
    
    /**
     * 前回実際にタスクを実行してからの経過時間
     * 
     * @type Integer
     * @private
     */
    _time: 0,
    
    /**
     * タスクの実行を行う
     * 
     * @param {Integer} time 前回の実行からの経過時間
     */
    execute: function (time) {
        this._time += time;
        
        while(this._time >= this._delay) {
            this._process.apply(null, this._args);
            this._time -= this._delay;
        }
    }
};Jeeel.directory.Jeeel.Dom.Document = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Document/';
    }
};

/**
 * コンストラクタ
 * 
 * @class documentをラップして拡張するクラス
 * @param {Document|IFrameElement} [document] 対象のドキュメント(iframe等で階層が違う場合に指定)
 * @throws {Error} documentが指定されてかつiframeやDocument型でない場合に発生
 */
Jeeel.Dom.Document = function (document) {

    if (Jeeel.Document && ( ! document || document === Jeeel._doc)) {
        return Jeeel.Document;
    }
    
    if ( ! document) {
        document = Jeeel._doc;
    } else if (document.nodeName && document.nodeName.toUpperCase() == 'IFRAME') {
        document = document.contentWindow.document;
    } else if (document instanceof Jeeel.Dom.Window) {
        this._window = document;
        document = document.getWindow().document;
    }
    
    if ( ! Jeeel.Type.isDocument(document)) {
        throw new Error('引数はDocumentまたはIFrameElementを渡してください。');
    }

    this._document = document;
    this._searcher = new Jeeel.Dom.Core.Searcher(document);
    this._elementCash = {};
};

/**
 * インスタンスの作成を行う
 *
 * @param {Document|IFrameElement} [document] 対象のドキュメント(iframe等で階層が違う場合に指定)
 * @return {Jeeel.Dom.Document} 作成したインスタンス
 */
Jeeel.Dom.Document.create = function (document) {
    return new this(document);
};

Jeeel.Dom.Document.prototype = {

    /**
     * 操作対象のDocument
     * 
     * @type Document
     * @protected
     */
    _document: null,
    
    /**
     * Documentに属するWindowのラッパーインスタンス
     * 
     * @type Jeeel.Dom.Window
     * @private
     */
    _window: null,
    
    /**
     * 検索インスタンス
     * 
     * @type Jeeel.Dom.Core.Searcher
     * @private
     */
    _searcher: null,
    
    /**
     * Elementの作成で使用するキャッシュ
     * 
     * @type Hash
     */
    _elementCash: {},
    
    /**
     * ネームスペース使用時のElementの作成で使用するキャッシュ
     * 
     * @type Hash
     */
    _elementNsCash: {},
    
    /**
     * 操作しているDocumentを取得する
     * 
     * @return {Document} 操作しているDocument
     */
    getDocument: function () {
        return this._document;
    },
    
    /**
     * このDocumentに属するWindowのラッパーインスタンスを取得する
     * 
     * @return {Jeeel.Dom.Window} Windowラッパーインスタンス
     */
    getWindow: function () {
        return this._window || (this._window = Jeeel.Dom.Window.create(this));
    },
    
    /**
     * Elementの作成を行う
     * 
     * @param {String} tagName 作成タグの名前(タグ名は大文字小文字を統一した方が早くなる)
     * @return {Element} 作成したタグ
     */
    createElement: function (tagName) {
        if (this._elementCash[tagName]) {
            return this._elementCash[tagName].cloneNode(false);
        }
        
        var elm = this._document.createElement(tagName);
        
        return elm && (this._elementCash[tagName] = elm).cloneNode(false) || null;
    },
    
    /**
     * ネームスペースを指定してElementの作成を行う
     * 
     * @param {String} namespaceUri ネームスペースURI(例： http://www.w3.org/1999/xhtml)
     * @param {String} tagName 作成タグの名前(タグ名は大文字小文字を統一した方が早くなる)
     * @return {Element} 作成したタグ
     */
    createElementNS: function (namespaceUri, tagName) {
        if ( ! this._elementNsCash[namespaceUri]) {
            this._elementNsCash[namespaceUri] = {};
        }
        
        if (this._elementNsCash[namespaceUri][tagName]) {
            return this._elementNsCash[namespaceUri][tagName].cloneNode(false);
        }
        
        var elm = this._document.createElementNS(namespaceUri, tagName);
        
        return elm && (this._elementNsCash[namespaceUri][tagName] = elm).cloneNode(false) || null;
    },
    
    /**
     * Textノードの作成を行う
     * 
     * @param {String} text 作成するテキスト
     * @return {Text} 作成したTextノード
     */
    createTextNode: function (text) {
        return this._document.createTextNode(text);
    },
    
    /**
     * DocumentFragmentの作成を行う
     * 
     * @return {DocumentFragment} 作成したDocumentFragment
     */
    createDocumentFragment: function () {
        return this._document.createDocumentFragment();
    },
    
    /**
     * HTML文字列からNodeリストを作成して返す
     *
     * @param {String} html HTML文字列
     * @return {Node[]} 作成されたNodeリスト
     */
    createNodeList: function (html) {

        var div;
        
        var supports = this.constructor.Supports;

        if ( ! supports.rhtml.test(html)) {
            div = {childNodes: [this.createTextNode(html)]};
        } else {
            // Fix "XHTML"-style tags in all browsers
            html = html.replace(supports.rxhtmlTag, "<$1></$2>");

            // Trim whitespace, otherwise indexOf won't work as expected
            var tag = (supports.rtagName.exec(html) || ["", ""])[1].toLowerCase(),
            wrap = supports.wrapMap[tag] || supports.wrapMap._default,
            depth = wrap[0];

            div = this.createElement('div');

            // Go to html and back, then peel off extra wrappers
            div.innerHTML = wrap[1] + html + wrap[2];

            // Move to the right depth
            while (depth--) {
                div = div.lastChild;
            }

            // Remove IE's autoinserted <tbody> from table fragments
            if ( ! supports.tbody) {

                // String was a <table>, *may* have spurious <tbody>
                var hasBody = supports.rtbody.test(html),
                  tbody = tag === "table" && !hasBody ?
                    div.firstChild && div.firstChild.childNodes :

                    // String was a bare <thead> or <tfoot>
                    wrap[1] === "<table>" && !hasBody ?
                      div.childNodes : [];

                for (var j = tbody.length - 1; j >= 0 ; --j) {
                    if (tbody[j].nodeName.toLowerCase() == "tbody" && ! tbody[j].childNodes.length ) {
                        tbody[j].parentNode.removeChild(tbody[j]);
                    }
                }
            }

            // IE completely kills leading whitespace when innerHTML is used
            if ( ! supports.leadingWhitespace && supports.rleadingWhitespace.test(html)) {
                div.insertBefore(this.createTextNode(supports.rleadingWhitespace.exec(html)[0]), div.firstChild);
            }
        }

        var res = [];

        var children = div.childNodes;

        for (var i = 0, l = children.length; i < l; i++) {
            res[i] = children[i];
        }

        return res;
    },
    
    /**
     * HTML文字列からElementリストを作成して返す
     *
     * @param {String} html HTML文字列
     * @return {Element[]} 作成されたElementリスト
     */
    createElementList: function (html) {
        var res = [];
        var tmp = this.createNodeList(html);
        var elmType = Jeeel.Dom.Node.ELEMENT_NODE;
        
        for (var i = 0, l = tmp.length; i < l; i++) {
            if (tmp[i].nodeType === elmType) {
                res[res.length] = tmp[i];
            }
        }
        
        return res;
    },
    
    /**
     * ヘッダの取得
     *
     * @return {Element} ヘッダElement
     */
    getHead: function () {
        return this._document.head || this.getElementsByTagName('head')[0];
    },

    /**
     * ボディの取得
     *
     * @return {Element} ボディElement
     */
    getBody: function () {
        return this._document.body;
    },
    
    /**
     * ルートElementの取得
     * 
     * @return {Element} ルートElement
     */
    getDocumentElement: function () {
        return this._document.documentElement;
    },

    /**
     * 指定IDのHTML要素を取得する
     *
     * @param {String} id 検索ID
     * @return {Element} 取得したElement
     */
    getElementById: function (id) {
        return this._searcher.getElementById(id);
    },

    /**
     * 指定ClassのHTML要素を取得する
     *
     * @param {String|String[]} className 検索Class
     * @return {Element[]} 取得したElement配列
     */
    getElementsByClassName: function (className) {
        return this._searcher.getElementsByClassName(className);
    },
    
    /**
     * 指定NameのHTML要素を取得する<br />
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする<br />
     * submitSearchなしのIEではName属性の解釈が違うので注意
     * 
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch=false] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか
     * @return {Element[]} 取得したElement配列
     */
    getElementsByName: function (name, submitSearch) {
        return this._searcher.getElementsByName(name, submitSearch);
    },
    
    /**
     * 指定TagのHTML要素を取得する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Element[]} 取得したElement配列
     */
    getElementsByTagName: function (tagName) {
        
        if ( ! tagName) {
            return [];
        }
        
        var isArr = Jeeel.Type.isArray(tagName);
        
        if ( ! isArr) {
            tagName = tagName.toUpperCase();

            if (tagName === 'BODY') {
                return [this._document.body];
            } else if (tagName === 'HEAD' && this._document.head) {
                return [this._document.head];
            } else if (tagName === 'HTML') {
                return [this._document.documentElement];
            }
        }
      
        return this._searcher.getElementsByTagName(tagName);
    },

    /**
     * 指定属性が指定値のHTML要素を取得する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByAttribute: function (attribute, value) {
        return this._searcher.getElementsByAttribute(attribute, value);
    },

    /**
     * 指定プロパティが指定値のHTML要素を取得する<br />
     * Elementのプロパティである事に注意
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value 指定値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByProperty: function (property, value) {
        return this._searcher.getElementsByProperty(property, value);
    },

    /**
     * 指定セレクタで絞り込んだHTML要素を取得する
     *
     * @param {String} selector CSSセレクタ
     * @return {Element[]} 取得したElement配列
     * @ignore
     */
    getElementsBySelector: function (selector) {
        return this._searcher.getElementsBySelector(selector);
    },
    
    /**
     * HTML要素を指定範囲検索する
     * 
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {Function} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Element[]} 範囲検索に引っかかったElement配列
     * @see Jeeel.Dom.SearchOption
     */
    searchElementsByRange: function (rect, option) {},
    
    /**
     * 計算済みのスタイルを取得する
     * 
     * @param {Element} element 取得対象のElement
     * @return {CSSCurrentStyleDeclaration|CSSStyleDeclaration} 取得した計算済みスタイル
     */
    getComputedStyle: function (element) {
        return element.currentStyle || this._document.defaultView.getComputedStyle(element, '');
    },
    
    /**
     * ヘッダに対して要素を追加する
     * 
     * @param {Element} element 追加Element
     * @return {Jeeel.Dom.Document} 自インスタンス
     */
    appendToHead: function (element) {
        this.getHead().appendChild(element);
        return this;
    },
    
    /**
     * ボディに対して要素を追加する
     * 
     * @param {Element} element 追加Element
     * @return {Jeeel.Dom.Document} 自インスタンス
     */
    appendToBody: function (element) {
        this.getBody().appendChild(element);
        return this;
    },
    
    /**
     * このDocumentにイベントを追加する<br />
     * 引数はJeeel.Dom.Event, このDocumentになる
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Document} 自インスタンス
     */
    addEventListener: function (type, listener, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        Jeeel.Dom.Event.addEventListener(this._document, type, listener, thisArg);
        
        return this;
    },

    /**
     * イベントの削除を行う<br />
     * このインスタンスのaddEventListenerに対して行わなければ削除はできない
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @return {Jeeel.Dom.Document} 自インスタンス
     */
    removeEventListener: function (type, listener) {
        Jeeel.Dom.Event.removeEventListener(this._document, type, listener);

        return this;
    },
    
    /**
     * このDocumentに設定されているイベントを任意のタイミングで実行する
     *
     * @param {String} type イベントタイプ
     * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
     * @return {Jeeel.Dom.Document} 自インスタンス
     * @ignore 未完成
     */
    dispatchEvent: function (type, option) {
        Jeeel.Dom.Event.dispatchEvent(this._document, type, option);
        
        return this;
    },

    /**
     * イメージ全てに対してロールオーバー動作を定義づける
     * 
     * @return {Jeeel.Dom.Document} 自インスタンス
     * @ignore
     */
    rolloverImages: function () {
        var inputs = this.getElementsByTagName('input');
        var images = this.getElementsByTagName('img');
        
        var rollover = new Jeeel.Dom.Event.Rollover.Image();
        
        rollover.rollover(inputs.concat(images));
        
        return this;
    },

    /**
     * コンストラクタ
     * 
     * @param {Document} [document] 対象のドキュメント(iframe等で階層が違う場合に指定)
     * @constructor
     */
    constructor: Jeeel.Dom.Document,
    
    _init: function () {
      
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var doc  = Jeeel._doc;

        if ( ! doc) {
            delete this._init;
            return;
        }
        
        var _option, _rect;

        function _searchRange(res, target) {
            var trect = Jeeel.Dom.Element.create(target).getRect();

            if (_option(_rect, trect)) {
                res[res.length] = target;
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    _searchRange(res, child);
                }

                child = child.nextSibling;
            }
        }
        
        var self = this;
        
        self.searchElementsByRange = function (rect, option) {
            if ( ! rect) {
                return [];
            }

            if ( ! option) {
                option = Jeeel.Dom.SearchOption.RANGE_OVERLAY;
            }
            
            _rect = rect;
            _option = option;

            var res = [];
            
            _searchRange(res, this._document.documentElement);

            return res;
        };
        
        // createElementNSが存在しないブラウザはネームスペースを無視
        if ( ! doc.createElementNS) {
            self.createElementNS = function (namespaceUri, tagName) {
                return this.createElement(tagName);
            };
        }
        
        delete this._init;
    }
};

Jeeel.Dom.Document.prototype._init();

Jeeel.file.Jeeel.Dom.Document = ['ReadyStatus'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Document, Jeeel.file.Jeeel.Dom.Document);

if (Jeeel._doc) {
    Jeeel.Document = new Jeeel.Dom.Document();
    Jeeel.Window = Jeeel.Document.getWindow();
} else if (Jeeel._global) {
    Jeeel.Window = new Jeeel.Dom.Window();
}

(function () {
    if ( ! Jeeel.Document) {
        return;
    }
    
    var div = Jeeel.Document.createElement('div');
    
    div.setAttribute("className", "t");
    div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

    Jeeel.Dom.Document.Supports = ({
        leadingWhitespace: ( div.firstChild.nodeType === 3 ),

        // Make sure that tbody elements aren't automatically inserted
        // IE will insert them into empty tables
        tbody: !div.getElementsByTagName( "tbody" ).length,

        // Make sure that link elements get serialized correctly by innerHTML
        // This requires a wrapper element in IE
        htmlSerialize: !!div.getElementsByTagName( "link" ).length,
        
        wrapMap: {
            option: [1, "<select multiple='multiple'>", "</select>"],
            legend: [1, "<fieldset>", "</fieldset>"],
            thead: [1, "<table>", "</table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            area: [1, "<map>", "</map>"],
            _default: [0, "", ""]
        },
        
        rtbody: /<tbody/i,
        rhtml: /<|&#?\w+;/,
        rleadingWhitespace: /^\s+/,
        rxhtmlTag: /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
        rtagName: /<([\w:]+)/,
        
        _init: function () {
            this.wrapMap.optgroup = this.wrapMap.option;
            this.wrapMap.tbody = this.wrapMap.tfoot = this.wrapMap.colgroup = this.wrapMap.caption = this.wrapMap.thead;
            this.wrapMap.th = this.wrapMap.td;
            
            if ( ! this.htmlSerialize ) {
                this.wrapMap._default = [1, "div<div>", "</div>"];
            }
            
            delete this._init;
            
            return this;
        }
    })._init();
})();

/**
 * Documentの読み込み状態を示す
 */
Jeeel.Dom.Document.ReadyStatus = {

    /**
     * 未初期化
     *
     * @type String
     * @constant
     */
    UNINITIALIZED: 'uninitialized',

    /**
     * ロード中
     *
     * @type String
     * @constant
     */
    LOADING: 'loading',

    /**
     * Document作成中
     *
     * @type String
     * @constant
     */
    INTERACTIVE: 'interactive',

    /**
     * 読み込み完了
     *
     * @type String
     * @constant
     */
    COMPLETE: 'complete'
};
Jeeel.directory.Jeeel.Dom.Xml = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Xml/';
    }
};

/**
 * コンストラクタ
 * 
 * @class XMLを簡単にアクセス可能にするクラス
 * @param {Document} xmlDocument XMLドキュメント
 * @throws {Error} xmlDocumentがXMLのドキュメントオブジェクトでない場合に発生
 */
Jeeel.Dom.Xml = function (xmlDocument) {
    this._init(xmlDocument);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Document} xmlDocument XMLドキュメント
 * @return {Jeeel.Dom.Xml} 作成したインスタンス
 * @throws {Error} xmlDocumentがXMLのドキュメントオブジェクトでない場合に発生
 */
Jeeel.Dom.Xml.create = function (xmlDocument) {
    return new this(xmlDocument);
};

/**
 * XMLを読み込んでインスタンスの作成を行う<br />
 * 同期的に読み込むので注意
 * 
 * @param {String} url XMLのURL
 * @param {Hash} [params] XML取得の際にサーバーに渡すパラメータ
 * @return {Jeeel.Dom.Xml} 作成したインスタンス
 */
Jeeel.Dom.Xml.load = function (url, params) {
    var ajax = Jeeel.Net.Ajax.create(url)
                    .setAsynchronous(false)
                    .setAll(params || {})
                    .execute();
    
    return new this(ajax.getResponse().responseXML);
};

Jeeel.Dom.Xml.prototype = {
    
    /**
     * XMLエンコーディング
     * 
     * @type String
     * @private
     */
    _encoding: '',
    
    /**
     * XMLバージョン
     * 
     * @type String
     * @private
     */
    _version: '',
    
    /**
     * XMLドキュメント
     * 
     * @type Document
     * @private
     */
    _doc: null,
    
    /**
     * ルートノード
     * 
     * @type Jeeel.Dom.Xml.Node
     * @private
     */
    _root: null,
    
    /**
     * この要素が持つ子要素リスト
     * 
     * @type Jeeel.Dom.Xml.Node[]
     * @private
     */
    _childNodes: [],
    
    /**
     * XMLのバージョンを取得する
     * 
     * @return {String} バージョン
     */
    getVersion: function () {
        return this._version;
    },
    
    /**
     * XMLのエンコーディングを取得する
     * 
     * @return {String} エンコーディング
     */
    getEncoding: function () {
        return this._encoding;
    },
    
    /**
     * ルートノードを取得する
     * 
     * @return {Jeeel.Dom.Xml.Node} ルートノード
     */
    getDocumentElement: function () {
        return this._root;
    },
    
    /**
     * この要素の子要素を全て取得する
     * 
     * @return {Jeeel.Dom.Xml.Node[]} 子要素リスト
     */
    getChildNodes: function () {
        return this._childNodes;
    },
    
    /**
     * 簡単なHashに変換して返す<br />
     * 変換対象はタグ・テキストのみである
     * 
     * @return {Hash} 変換後のHash
     */
    toHash: function() {
        var res = {};
        
        if (this._root) {
            res[this._root._name] = this._root.toHash();
        }
        
        return res;
    },
    
    /**
     * このXMLを文字列に変換して返す
     * 
     * @return {String} XML文字列
     */
    toString: function () {
        var header = '<?xml version="'
                   + this._version + '"'
                   + (this._encoding ? ' encoding="' + this._encoding + '"' : '')
                   + '?>\n';
        
        var children = [];
        
        for (var i = this._childNodes.length; i--;) {
            children[i] = this._childNodes[i].toXmlString();
        }
        
        return header
             + children.join('\n');
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Document} xmlDocument XMLドキュメント
     * @constructor
     */
    constructor: Jeeel.Dom.Xml,
    
    /**
     * 初期化
     * 
     * @param {Document} xmlDocument XMLドキュメント
     * @private
     */
    _init: function (xmlDocument) {
        delete this._init;
        
        if (xmlDocument.nodeType !== Jeeel.Dom.Node.DOCUMENT_NODE || Jeeel.Type.isEmpty(this._version)) {
            throw new Error('XMLドキュメントを指定して下さい。');
        }
        
        this._doc = xmlDocument;
        this._version  = xmlDocument.xmlVersion;
        this._encoding = xmlDocument.xmlEncoding;
        
        var root = xmlDocument.documentElement;
        var nodeName = root.nodeName;

        var nodes = xmlDocument.childNodes;
        
        for (var i = 0, l = nodes.length; i < l; i++) {
            this._childNodes[i] = new Jeeel.Dom.Xml.Node(nodes[i]);
            
            if (root === nodes[i]) {
                this._root = this[nodeName] = this._childNodes[i];
            }
        }
    }
};

Jeeel.file.Jeeel.Dom.Xml = ['Node'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Xml, Jeeel.file.Jeeel.Dom.Xml);

/**
 * コンストラクタ
 * 
 * @class XMLの内部ノードを示すクラス
 * @param {Element} xmlNode XMLノード
 */
Jeeel.Dom.Xml.Node = function (xmlNode) {
    this._init(xmlNode);
};

Jeeel.Dom.Xml.Node.prototype = {
    
    /**
     * この要素の名前
     * 
     * @type String
     * @private
     */
    _name: '',
    
    /**
     * この要素の名前空間
     * 
     * @type String
     * @private
     */
    _namespace: '',
    
    /**
     * この要素の名前空間URI
     * 
     * @type String
     * @private
     */
    _namespaceUri: '',
    
    /**
     * この要素を示す定数
     * 
     * @type Integer
     * @private
     */
    _type: 0,
    
    /**
     * この要素の持つ値
     * 
     * @type String
     * @private
     */
    _value: '',
    
    /**
     * この要素の持つ属性
     * 
     * @type Hash[]
     * @private
     */
    _attr: [],
    
    /**
     * この要素が持つ子要素リスト
     * 
     * @type Jeeel.Dom.Xml.Node[]
     * @private
     */
    _childNodes: [],
    
    /**
     * この要素の名前を取得する
     * 
     * @return {String} 要素名
     */
    getName: function () {
        return this._name;
    },
    
    /**
     * この要素の名前空間を取得する
     * 
     * @return {String} 名前空間
     */
    getNamespace: function () {
        return this._namespace;
    },
    
    /**
     * この要素の名前空間URIを取得する
     * 
     * @return {String} 名前空間URI
     */
    getNamespaceUri: function () {
        return this._namespaceUri;
    },
    
    /**
     * この要素の種類を取得する
     * 
     * @return {Integer} 要素の種類定数
     * @see Jeeel.Dom.Node
     */
    getType: function () {
        return this._type;
    },
    
    /**
     * この要素の値を取得する
     * 
     * @return {Mixied} 要素値
     */
    getValue: function () {
        return this._value;
    },
    
    /**
     * この要素に定義付けられている属性値を取得する
     * 
     * @param {String} attribute 属性名
     * @return {String} 属性値
     */
    getAttribute: function (attribute) {
        if (Jeeel.Type.isSet(this._attr[attribute])) {
            return this._attr[attribute];
        }
        
        return null;
    },
    
    /**
     * 属性の名前と値を連想配列にして返す
     * 
     * @return {Hash} 属性のリスト
     */
    getAttributes: function () {
        return this._attr;
    },
    
    /**
     * この要素の子要素を全て取得する
     * 
     * @return {Jeeel.Dom.Xml.Node[]} 子要素リスト
     */
    getChildNodes: function () {
        return this._childNodes;
    },
    
    /**
     * 簡単なHashに変換して返す<br />
     * 変換対象はタグ・テキストのみである
     * 
     * @return {Hash} 変換後のHash
     */
    toHash: function () {
        var res = {},
            len = this._childNodes.length;
        
        if (len === 0) {
            return '';
        }
        else if (len === 1 && this._childNodes[0]._type === Jeeel.Dom.Node.TEXT_NODE) {
            return this._childNodes[0] && this._childNodes[0]._value || '';
        }
        
        for (var i = 0; i < len; i++) {
            var child = this._childNodes[i];
            
            if (child._type !== Jeeel.Dom.Node.ELEMENT_NODE) {
                continue;
            }
            
            if (res[child._name]) {
                res[child._name].push(child.toHash());
            } else {
                var hash = child.toHash();
                
                if ( ! Jeeel.Type.isHash(hash)) {
                    res[child._name] = hash;
                } else {
                    res[child._name] = [hash];
                    
                    for (var key in hash) {
                        res[child._name][key] = hash[key];
                    }
                }
            }
        }
        
        return res;
    },
    
    /**
     * この要素の内部XMLを文字列にして返す
     * 
     * @return {String} XML文字列
     */
    toXmlString: function () {
        switch (this._type) {
            case Jeeel.Dom.Node.TEXT_NODE:
                return this._value;
                break;
                
            case Jeeel.Dom.Node.COMMENT_NODE:
                return '<!--' + this._value + '-->';
                break;
                
            case Jeeel.Dom.Node.CDATA_SECTION_NODE:
                return '<![CDATA[' + this._value + ']]>';
                break;
                
            case Jeeel.Dom.Node.PROCESSING_INSTRUCTION_NODE:
                return '<?' + this._name + ' ' + this._value + '?>';
                break;
                
            case Jeeel.Dom.Node.DOCUMENT_TYPE_NODE:
                return '<!DOCTYPE ' + this._name + '>';
                break;
            
            default:
                break;
        }
        
        var attrs = [],
            children = [],
            i;
        
        for (i = this._attr.length; i--;) {
            var attr = this._attr[i];
            attrs[i] = attr.name + '="' + attr.value + '"';
        }
        
        for (i = this._childNodes.length; i--;) {
            children[i] = this._childNodes[i].toXmlString();
        }
        
        return '<' + this._name
             + (attrs.length ? ' ' + attrs.join(' ') : '')
             + '>'
             + children.join('')
             + '</' + this._name + '>';
    },
    
    /**
     * この要素の要素値もしくはXML文字列を返す
     * 
     * @return {String} 要素値もしくはXML文字列
     */
    toString: function () {
        return this._value || this.toXmlString();
    },
    
    /**
     * この要素の値を取得する
     * 
     * @return {Mixied} 要素値
     */
    valueOf: function () {
        return this._value;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Element} xmlNode XMLノード
     * @constructor
     */
    constructor: Jeeel.Dom.Xml.Node,
    
    /**
     * 初期化
     * 
     * @param {Element} xmlNode XMLノード
     */
    _init: function (xmlNode) {
        delete this._init;
        
        this._value        = xmlNode.nodeValue;
        this._name         = xmlNode.nodeName;
        this._namespace    = xmlNode.prefix;
        this._namespaceUri = xmlNode.namespaceURI;
        this._type         = xmlNode.nodeType;
        this._attr         = [];
        this._childNodes   = [];
        
        var i, l, attrs = xmlNode.attributes;
        
        if (attrs) {
            for (i = attrs.length; i--;) {
                var attr = attrs[i];
                
                this._attr[i] = {
                    name: attr.nodeName,
                    value: attr.nodeValue
                };
            }
        }
        
        var elmType = Jeeel.Dom.Node.ELEMENT_NODE;
        var nodes = xmlNode.childNodes;
        
        for (i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            var nodeName = node.nodeName;
            var xml = new Jeeel.Dom.Xml.Node(node);
            
            this._childNodes[i] = xml;

            if (node.nodeType !== elmType) {
                if (l === 1) {
                    this._value = node.nodeValue;
                }

                continue;
            }
            
            if ( ! this[nodeName]) {
                this[nodeName] = [];
            }
            
            var accessNodes = this[nodeName];
            
            accessNodes[accessNodes.length] = xml;
            
            if (accessNodes.length === 1) {
                for (var property in xml) {
                    if (property !== '_init') {
                        accessNodes[property] = xml[property];
                    }
                }
            }
        }
    }
};
Jeeel.directory.Jeeel.Dom.Event = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Event/';
    }
};

/**
 * コンストラクタ
 *
 * @class Eventを拡張するラッパークラス
 * @param {Event} event 基となるEventインスタンス
 */
Jeeel.Dom.Event = function (event) {
    var self = this;

    self._event = event;

    var docElement = Jeeel._doc.documentElement;
    var body = Jeeel._doc.body || {scrollLeft: 0, scrollTop: 0};

    var x = event.changedTouches && event.changedTouches[0].pageX || event.pageX || (event.clientX +
      (docElement.scrollLeft || body.scrollLeft) -
      (docElement.clientLeft || 0));

    var y = event.changedTouches && event.changedTouches[0].pageY || event.pageY || (event.clientY +
       (docElement.scrollTop || body.scrollTop) -
       (docElement.clientTop || 0));

    var right, left, middle;
    var button = event.button;
    
    if (Jeeel.UserAgent.isInternetExplorer()) {
        right  = !!(button & 2);
        left   = !!(button & 1);
        middle = !!(button & 4);
    } else {
        right  = button === 2;
        left   = button === 0;
        middle = button === 1;
    }

    var code = Jeeel.Dom.Event._getCode(event);

    self.type = event.type.toLowerCase();
    self.data = event.data || null;
    self.target = self._target = event.target || event.srcElement;
    self.currentTarget = event.currentTarget || arguments[1] || null;
    self.relatedTarget = event.relatedTarget || event.fromElement || event.toElement || null;
    self.mouseX = x;
    self.mouseY = y;
    self.mouseWheel = (event.wheelDelta / 120) || -event.detail / 3;
    
    var c = self.currentTarget,
        p = self.target;
    
    if (p === c) {
        self.bubblingTargets = [p];
    }
    else if (c) {
        var elms = [];

        while (p && p !== c) {
            elms[elms.length] = p;
            p = p.parentNode;
        }

        elms[elms.length] = p;

        if (p) {
            self.bubblingTargets = elms;
        } else {
            self.bubblingTargets = null;
        }
    }

    self.mousePoint = new Jeeel.Object.Point(self.mouseX, self.mouseY);

    self.keyCode  = code[0];
    self.charCode = code[1];

    self.ctrlKey  = event.ctrlKey;
    self.shiftKey = event.shiftKey;
    self.altKey   = event.altKey;

    self.isRightDown  = right;
    self.isLeftDown   = left;
    self.isMiddleDown = middle;
};

Jeeel.Dom.Event.prototype = {

    /**
     * イベントオブジェクト
     *
     * @type Event
     */
    _event: null,
    
    _target: null,
  
    /**
     * イベントの種類
     *
     * @type String
     */
    type: '',
    
    /**
     * イベント発生Element
     * 
     * @type {Element}
     */
    target: null,
    
    /**
     * イベント補足Element
     * 
     * @type {Element}
     */
    currentTarget: null,
    
    /**
     * マウスの移動元・移動先の要素
     * 
     * @type {Element}
     */
    relatedTarget: null,
    
    /**
     * イベントが伝播してきたElementリスト(伝播順配列)
     * 
     * @type {Element[]}
     */
    bubblingTargets: null,
    
    /**
     * イベントのデータ
     * 
     * @type {Mixied}
     */
    data: null,

    /**
     * マウスのX座標
     *
     * @type Integer
     */
    mouseX: 0,
  
    /**
     * マウスのY座標
     *
     * @type Integer
     */
    mouseY: 0,

    /**
     * マウスの座標
     *
     * @type Jeeel.Object.Point
     */
    mousePoint: null,
    
    /**
     * マウスのホイール量
     * 
     * @type Integer
     */
    mouseWheel: 0,

    /**
     * キーコード
     *
     * @type Integer
     */
    keyCode: 0,

    /**
     * 文字コード
     *
     * @type Integer
     */
    charCode: 0,
  
    /**
     * Ctrlキーが押されているかどうか
     *
     * @type Boolean
     */
    ctrlKey: false,

    /**
     * Shiftキーが押されているかどうか
     *
     * @type Boolean
     */
    shiftKey: false,
  
    /**
     * Altキーが押されているかどうか
     *
     * @type Boolean
     */
    altKey: false,

    /**
     * マウスの右ボタンが押されたかどうか
     *
     * @type Boolean
     */
    isRightDown: false,
  
    /**
     * マウスの左ボタンが押されたかどうか
     *
     * @type Boolean
     */
    isLeftDown: false,

    /**
     * マウスの中ボタンが押されたかどうか
     *
     * @type Boolean
     */
    isMiddleDown: false,

    /**
     * 内部のEventインスタンスを返す
     *
     * @return {Event} Eventインスタンス
     */
    getEvent: function () {
        return this._event;
    },

    /**
     * イベントをストップする
     * 
     * @return {Jeeel.Dom.Event} 自インスタンス
     * @param {Boolean} [nonstopSelfEvent] イベントをそのまま実行するかどうか
     * @param {Boolean} [nonstopParentEvent] イベントをそのまま伝達するかどうか
     */
    stop: function (nonstopSelfEvent, nonstopParentEvent) {
        this.constructor.stopEvent(this._event, nonstopSelfEvent, nonstopParentEvent);
        
        return this;
    },
    
    /**
     * イベント対象のElementからの相対マウス座標を取得する
     * 
     * @param {Element} [element] イベント対象のElementの代わりに使用するElement
     * @return {Jeeel.Object.Point} 相対マウス座標
     */
    getRelativeMousePoint: function (element) {
        var bp = Jeeel.Dom.Element.prototype.getPosition.call({_element: element || this.target, _doc: Jeeel.Document});
        var mp = this.mousePoint;
        
        bp.x = mp.x - bp.x;
        bp.y = mp.y - bp.y;
        
        return bp;
    },

    /**
     * 全てのキーボードイベントで共通のキーコードを取得する<br />
     * 以下は例外入力(正しく取得できない)<br />
     * 1～8のキーをShiftと一緒に押したとき
     *
     * @return {Integer} キーコード
     */
    getKeyCode: function () {

        var keyCode  = this._event.keyCode;
        var charCode = this._event.charCode;
        var which    = this._event.which;

        if (this.type != 'keypress') {
            keyCode = this.keyCode;

            if (Jeeel.Code.KeyCode.T0 <= keyCode && keyCode <= Jeeel.Code.KeyCode.T9) {
                keyCode += Jeeel.Code.KeyCode[0] - Jeeel.Code.KeyCode.T0;
            } else if (Jeeel.Code.KeyCode.TMultiplicationSign <= keyCode && keyCode <= Jeeel.Code.KeyCode.TDivisionSign) {
                keyCode += Jeeel.Code.KeyCode.MultiplicationSign - Jeeel.Code.KeyCode.TMultiplicationSign;
            }

            return keyCode;
        }

        if (Jeeel.Code.CharCode.a <= keyCode && keyCode <= Jeeel.Code.CharCode.z) {
            keyCode += Jeeel.Code.CharCode.A - Jeeel.Code.CharCode.a;
        } else {

            switch (keyCode) {

                case Jeeel.Code.CharCode.RightParenthesis:
                    keyCode = Jeeel.Code.KeyCode[9];
                    break;

                case Jeeel.Code.CharCode.SubtractionSign:
                case Jeeel.Code.CharCode.EqualsSign:
                    keyCode = Jeeel.Code.KeyCode.SubtractionSign;
                    break;

                case Jeeel.Code.CharCode.Caret:
                case Jeeel.Code.CharCode.Tilde:
                    keyCode = Jeeel.Code.KeyCode.Caret;
                    break;

                case Jeeel.Code.CharCode.YenMark:
                case Jeeel.Code.CharCode.VerticalBar:
                    keyCode = Jeeel.Code.KeyCode.YenMark;
                    break;

                case Jeeel.Code.CharCode.Atmark:
                case Jeeel.Code.CharCode.BackQuote:
                    keyCode = Jeeel.Code.KeyCode.Atmark;
                    break;

                case Jeeel.Code.CharCode.LeftBracket:
                case Jeeel.Code.CharCode.LeftBrace:
                    keyCode = Jeeel.Code.KeyCode.LeftBracket;
                    break;

                case Jeeel.Code.CharCode.Semicolon:
                case Jeeel.Code.CharCode.AdditionSign:
                    keyCode = Jeeel.Code.KeyCode.AdditionSign;
                    break;

                case Jeeel.Code.CharCode.Colon:
                case Jeeel.Code.CharCode.MultiplicationSign:
                    keyCode = Jeeel.Code.KeyCode.MultiplicationSign;
                    break;

                case Jeeel.Code.CharCode.RightBracket:
                case Jeeel.Code.CharCode.RightBrace:
                    keyCode = Jeeel.Code.KeyCode.RightBracket;
                    break;

                case Jeeel.Code.CharCode.Comma:
                case Jeeel.Code.CharCode.LessThan:
                    keyCode = Jeeel.Code.KeyCode.Comma;
                    break;

                case Jeeel.Code.CharCode.Period:
                case Jeeel.Code.CharCode.GreaterThan:
                    keyCode = Jeeel.Code.KeyCode.Period;
                    break;

                case Jeeel.Code.CharCode.DivisionSign:
                case Jeeel.Code.CharCode.QuestionMark:
                    keyCode = Jeeel.Code.KeyCode.DivisionSign;
                    break;

                case Jeeel.Code.CharCode.YenMark:
                case Jeeel.Code.CharCode.Underscore:
                    keyCode = Jeeel.Code.KeyCode.Underscore;
                    break;

                case 0:
                    keyCode = Jeeel.Code.KeyCode.Application;
                    break;
            }
        }

        return keyCode;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Event} event 基となるEventインスタンス
     * @constructor
     */
    constructor: Jeeel.Dom.Event
};

/**
 * 指定したEventオブジェクトからkeyCodeとcharCodeを取得する
 *
 * @param {Event} event 対象のEvent
 * @return {Integer[]} 0にkeyCode, 1にcharCode
 * @private
 */
Jeeel.Dom.Event._getCode = function (event) {

    var keyCode  = event.keyCode;
    var charCode = event.charCode;
    var which    = event.which;

    if (event.type.toLowerCase() == 'keypress') {
        if (Jeeel.UserAgent.isGeckoEngine()) {
            if (keyCode == 0) {
                keyCode = charCode;
            }

            charCode = keyCode;
        } else if (Jeeel.UserAgent.isTridentEngine() || Jeeel.UserAgent.isOpera()) {
            charCode = keyCode;
        }

        keyCode  = 0;
    } else {
        charCode = 0;
    }

    return [keyCode, charCode];
};

/**
 * Eventインスタンスの取得を行う
 *
 * @return {Jeeel.Dom.Event} Eventインスタンス
 * @throws {Error} イベントのコールバックから呼ばれていない時に投げられる
 */
Jeeel.Dom.Event.getEventObject = function () {
  
    var caller = arguments.callee.caller;
    
    if ( ! caller || ! caller.arguments) {
        throw new Error('Eventインスタンスの取得はイベントのコールバックにて行ってください。');
    }

    var args = caller.arguments;
    
    if (args[0] instanceof this) {
        return args[0];
    }

    var e = args[0] || Jeeel._global.event;

    if ( ! Jeeel.Type.isEvent(e)) {
        throw new Error('Eventインスタンスの取得はイベントのコールバックにて行ってください。');
    }

    return new this(e);
};

/**
 * イベントの種類を内部的に取得する
 *
 * @param {String} type イベントのタイプ
 * @return {String} イベントの種類を示す文字列(MouseEvent等)
 * @private
 */
Jeeel.Dom.Event._getEventType = function (type) {
    var eventType;
    
    switch (type) {
        case Jeeel.Dom.Event.Type.KEY_DOWN:
        case Jeeel.Dom.Event.Type.KEY_PRESS:
        case Jeeel.Dom.Event.Type.KEY_UP:
            eventType = Jeeel.Dom.Event.Type.KEYBOARD_EVENT;
            break;
            
        case Jeeel.Dom.Event.Type.DRAG_START:
        case Jeeel.Dom.Event.Type.DRAG_END:
        case Jeeel.Dom.Event.Type.DRAG_ENTER:
        case Jeeel.Dom.Event.Type.DRAG_OVER:
        case Jeeel.Dom.Event.Type.DRAG_LEAVE:
        case Jeeel.Dom.Event.Type.DRAG:
        case Jeeel.Dom.Event.Type.DROP:
            eventType = Jeeel.Dom.Event.Type.DRAG_EVENT;
            break;
        
        case Jeeel.Dom.Event.Type.CLICK:
        case Jeeel.Dom.Event.Type.DOUBLE_CLICK:
        case Jeeel.Dom.Event.Type.MOUSE_DOWN:
        case Jeeel.Dom.Event.Type.MOUSE_UP:
        case Jeeel.Dom.Event.Type.MOUSE_MOVE:
        case Jeeel.Dom.Event.Type.MOUSE_OVER:
        case Jeeel.Dom.Event.Type.MOUSE_OUT:
        case Jeeel.Dom.Event.Type.MOUSE_WHEEL:
        case Jeeel.Dom.Event.Type.CONTEXT_MENU:
            eventType = Jeeel.Dom.Event.Type.MOUSE_EVENT;
            break;
            
        case Jeeel.Dom.Event.Type.TOUCH_START:
        case Jeeel.Dom.Event.Type.TOUCH_MOVE:
        case Jeeel.Dom.Event.Type.TOUCH_END:
        case Jeeel.Dom.Event.Type.TOUCH_CANCEL:
            eventType = Jeeel.Dom.Event.Type.TOUCH_EVENT;
            break;
            
        case Jeeel.Dom.Event.Type.BLUR:
        case Jeeel.Dom.Event.Type.FOCUS:
        case Jeeel.Dom.Event.Type.RESIZE:
        case Jeeel.Dom.Event.Type.SCROLL:
            eventType = Jeeel.Dom.Event.Type.UI_EVENT;
            break;
      
        default:
            eventType = Jeeel.Dom.Event.Type.EVENT;
            break;
    }
    
    return eventType;
};

/**
 * イベントの種類を取得する
 *
 * @param {Event|String} event イベントインスタンスもしくはイベントのタイプ(click等)
 * @return {String} イベントの種類を示す文字列(MouseEvent等)
 */
Jeeel.Dom.Event.getEventType = function (event) {
  
    var type;
    
    if (Jeeel.Type.isEvent(event)) {
        type = event.type.toLowerCase();
    } else if (Jeeel.Type.isString(event)) {
        type = event.toLowerCase();
    }
    
    if ( ! Jeeel.Type.isString(type)) {
        return 'NonEvent';
    }

    return this._getEventType(type);
};

/**
 * イベントの登録を行う<br />
 * タッチパネル系の場合はマウスイベントを対応するイベントに自動変換する
 *
 * @param {Element} element HTML要素
 * @param {String} type イベントタイプ
 * @param {Function} listener 登録イベントメソッド
 * @param {Mixied} [thisArg] コールバック中のthisに相当する値
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
 */
Jeeel.Dom.Event.addEventListener = function (element, type, listener, thisArg, var_args) {
    var m = this.Manager.getInstance();
    m.addEventListener.apply(m, arguments);
};

/**
 * イベントの削除を行う<br />
 * タッチパネル系の場合はマウスイベントを対応するイベントに自動変換する
 *
 * @param {Element} element HTML要素
 * @param {String} type イベントタイプ
 * @param {Function} listener 登録イベントメソッド
 */
Jeeel.Dom.Event.removeEventListener = function (element, type, listener) {
    this.Manager.getInstance().removeEventListener(element, type, listener);
};

/**
 * 複数のElementに対してのイベントを上位Elementに委譲して登録を行う<br />
 * タッチパネル系の場合はマウスイベントを対応するイベントに自動変換する
 *
 * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
 * @param {String} type イベントタイプ
 * @param {Function} listener 登録イベントメソッド
 * @param {Mixied} [thisArg] コールバック中のthisに相当する値
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
 */
Jeeel.Dom.Event.delegate = function (elementList, type, listener, thisArg, var_args) {
    var m = this.Manager.getInstance();
    m.delegate.apply(m, arguments);
};

/**
 *  複数のElementに対してのイベントを上位Elementに委譲してたものの削除を行う<br />
 * タッチパネル系の場合はマウスイベントを対応するイベントに自動変換する
 *
 * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
 * @param {String} type イベントタイプ
 * @param {Function} listener 登録イベントメソッド
 */
Jeeel.Dom.Event.undelegate = function (elementList, type, listener) {
    this.Manager.getInstance().undelegate(elementList, type, listener);
};

/**
 * イベントの呼び出しを行う
 *
 * @param {Element} element HTML要素
 * @param {String} type イベントタイプ
 * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
 * @ignore 未完成
 */
Jeeel.Dom.Event.dispatchEvent = function (element, type, option) {

    var evType = this.getEventType(type);
    var view = element.ownerDocument;

    view = view.defaultView || view.parentWindow || Jeeel._global;

    if ( ! (option instanceof Jeeel.Dom.Event.Option)) {
        option = Jeeel.Dom.Event.Option.prototype;
    }
        
    var ev;
    
    if (Jeeel._doc.createEvent) {
        ev = Jeeel._doc.createEvent(evType);
    } else if(Jeeel._doc.createEventObject) {
        ev = Jeeel._doc.createEventObject(evType);
    }
    
    switch (evType) {
        case this.Type.MOUSE_EVENT:
            option.initMouseEvent(ev, type, view);
            break;
            
        case this.Type.DRAG_EVENT:
            option.initDragEvent(ev, type, view);
            break;

        case this.Type.KEYBOARD_EVENT:
            option.initKeyboardEvent(ev, type, view);
            break;
            
        case this.Type.TOUCH_EVENT:
            option.initTouchEvent(ev, type, view);
            break;

        case this.Type.UI_EVENT:
            option.initUIEvent(ev, type, view);
            break;

        case this.Type.EVENT:
        default:
            option.initEvent(ev, type);
            break;
    }
        
    if (element.dispatchEvent) {  
        element.dispatchEvent(ev);
    }
    else if (element.fireEvent) {
        element.fireEvent("on" + type, ev);
    }
};

/**
 * イベントをストップする
 *
 * @param {Event} event イベント
 * @param {Boolean} [nonstopSelfEvent] イベントをそのまま実行するかどうか
 * @param {Boolean} [nonstopParentEvent] イベントをそのまま伝達するかどうか
 */
Jeeel.Dom.Event.stopEvent = function (event, nonstopSelfEvent, nonstopParentEvent) {
  
    if (event.preventDefault && ! nonstopSelfEvent) {
        event.preventDefault();
    }
    
    if (event.stopPropagation && ! nonstopParentEvent) {
        event.stopPropagation();
    }

    if ('returnValue' in event && ! nonstopSelfEvent) {
        event.returnValue = false;
    }

    if ('cancelBubble' in event && ! nonstopParentEvent) {
        event.cancelBubble = true;
    }
};

/**
 * マウス操作無効化イベント
 * 
 * @private
 */
Jeeel.Dom.Event._disableMouse = function () {
    Jeeel.Dom.Event.getEventObject().stop(false, true);

    return false;
};

/**
 * 指定したElementのマウスEventを無効化する
 * 
 * @param {Element} element 対象のElement
 */
Jeeel.Dom.Event.disableMouseEvent = function (element) {
    var f = this._disableMouse;
    
    element.onmousedown = f;
    element.onmouseup = f;
    element.onmouseover = f;
    element.ondrag = f;
    element.ondragstart = f;
    element.ondragend = f;
};

Jeeel.file.Jeeel.Dom.Event = ['Type', 'Listener', 'Manager', 'Option', 'Rollover'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Event, Jeeel.file.Jeeel.Dom.Event);

/**
 * イベントの種類の列挙体
 */
Jeeel.Dom.Event.Type = {
    
    /**
     * フォーカスが外れた時に発生
     *
     * @type String
     * @constant
     */
    BLUR: 'blur',
    
    /**
     * フォーカスが当たった時に発生
     *
     * @type String
     * @constant
     */
    FOCUS: 'focus',
    
    /**
     * 要素のサイズが変更された時に発生
     *
     * @type String
     * @constant
     */
    RESIZE: 'resize',
    
    /**
     * スクロールが行われた時に発生
     *
     * @type String
     * @constant
     */
    SCROLL: 'scroll',
    
    /**
     * フォーム要素の選択、入力内容が変更された時に発生
     *
     * @type String
     * @constant
     */
    CHANGE: 'change',
    
    /**
     * テキストが選択された時に発生
     *
     * @type String
     * @constant
     */
    SELECT: 'select',
    
    /**
     * フォームを送信しようとした時に発生
     *
     * @type String
     * @constant
     */
    SUBMIT: 'submit',
    
    /**
     * フォームがリセットされた時に発生
     *
     * @type String
     * @constant
     */
    RESET: 'reset',
    
    /**
     * 画像の読み込みを中断した時に発生
     *
     * @type String
     * @constant
     */
    ABORT: 'abort',
    
    /**
     * 画像の読み込み中にエラーが発生した時に発生
     *
     * @type String
     * @constant
     */
    ERROR: 'error',
    
    /**
     * ページや画像の読み込みが完了した時に発生
     *
     * @type String
     * @constant
     */
    LOAD: 'load',
    
    /**
     * ウィンドウを閉じた時、他のページに切り替えた時、ページをリロード（更新）した時に発生
     *
     * @type String
     * @constant
     */
    UNLOAD: 'unload',
    
    /**
     * ウィンドウを閉じた時、他のページに切り替えた時、ページをリロード（更新）する直前に発生
     *
     * @type String
     * @constant
     */
    BEFORE_UNLOAD: 'beforeunload',

    /**
     * postMessageを受け取った時に発生
     *
     * @type String
     * @constant
     */
    MESSAGE: 'message',
    
    /**
     * 要素やリンクをクリックした時に発生
     *
     * @type String
     * @constant
     */
    CLICK: 'click',
    
    /**
     * 要素をダブルクリックした時に発生
     *
     * @type String
     * @constant
     */
    DOUBLE_CLICK: 'dblclick',

    /**
     * 押していたキーをあげた時に発生
     *
     * @type String
     * @constant
     */
    KEY_UP: 'keyup',

    /**
     * キーを押した時に発生
     *
     * @type String
     * @constant
     */
    KEY_DOWN: 'keydown',

    /**
     * キーを押してる時に発生
     *
     * @type String
     * @constant
     */
    KEY_PRESS: 'keypress',

    /**
     * マウスが離れたした時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_OUT: 'mouseout',

    /**
     * マウスが離れたした時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_OVER: 'mouseover',

    /**
     * クリックしたマウスを上げた時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_UP: 'mouseup',

    /**
     * マウスでクリックした時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_DOWN: 'mousedown',

    /**
     * マウスを動かしている時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_MOVE: 'mousemove',
    
    /**
     * マウスのホイールを回した時に発生s
     * 
     * @type String
     * @constant
     */
    MOUSE_WHEEL: 'mousewheel',
    
    /**
     * コンテキストメニューを表示しようとした時に発生
     *
     * @type String
     * @constant
     */
    CONTEXT_MENU: 'contextmenu',
    
    /**
     * ドラッグ開始時に発生
     *
     * @type String
     * @constant
     */
    DRAG_START: 'dragstart',
    
    /**
     * ドラッグ終了時に発生
     *
     * @type String
     * @constant
     */
    DRAG_END: 'dragend',
    
    /**
     * ドラッグ要素がドロップ要素に入った時に発生
     *
     * @type String
     * @constant
     */
    DRAG_ENTER: 'dragenter',
    
    /**
     * ドラッグ要素がドロップ要素と重なっている間発生
     *
     * @type String
     * @constant
     */
    DRAG_OVER: 'dragover',
    
    /**
     * ドラッグ要素がドロップ要素から出た時に発生
     *
     * @type String
     * @constant
     */
    DRAG_LEAVE: 'dragleave',
    
    /**
     * ドラッグしている間継続して発生
     *
     * @type String
     * @constant
     */
    DRAG: 'drag',
    
    /**
     * ドロップした時に発生
     *
     * @type String
     * @constant
     */
    DROP: 'drop',
    
    /**
     * タッチパネル式の媒体で要素にタッチした時に発生
     *
     * @type String
     * @constant
     */
    TOUCH_START: 'touchstart',
    
    /**
     * タッチパネル式の媒体で要素にタッチしたまま動かした時に発生
     *
     * @type String
     * @constant
     */
    TOUCH_MOVE: 'touchmove',
    
    /**
     * タッチパネル式の媒体で要素にタッチした状態から離れた時に発生
     *
     * @type String
     * @constant
     */
    TOUCH_END: 'touchend',
    
    /**
     * タッチパネル式の媒体で要素にタッチ中に電話がかかってきら場合などにに発生
     *
     * @type String
     * @constant
     */
    TOUCH_CANCEL: 'touchcancel',
    
    /**
     * タッチパネル式の媒体で縦と横持ちを変えた時に発生
     *
     * @type String
     * @constant
     */
    ORIENTATION_CHANGE: 'orientationchange',
    
    /**
     * メディアの再生が開始された時に発生
     *
     * @type String
     * @constant
     */
    PLAY: 'play',
    
    /**
     * メディアが一時停止された時に発生
     *
     * @type String
     * @constant
     */
    PAUSE: 'pause',
    
    /**
     * メディアのリソースが終端に達したために再生が停止した時に発生
     *
     * @type String
     * @constant
     */
    ENDED: 'ended',
    
    /**
     * メディアのボリュームが変化及びミュート切り替え時に発生
     *
     * @type String
     * @constant
     */
    VOLUME_CHANGE: 'volumechange',
    
    /**
     * マウスイベントを示す
     *
     * @type String
     * @constant
     */
    MOUSE_EVENT: 'MouseEvent',
    
    /**
     * ドラッグイベントを示す
     *
     * @type String
     * @constant
     */
    DRAG_EVENT: 'DragEvent',
    
    /**
     * タッチイベントを示す
     *
     * @type String
     * @constant
     */
    TOUCH_EVENT: 'TouchEvent',
    
    /**
     * キーボードイベントを示す
     *
     * @type String
     * @constant
     */
    KEYBOARD_EVENT: 'KeyboardEvent',
    
    /**
     * UIイベントを示す
     *
     * @type String
     * @constant
     */
    UI_EVENT: 'UIEvent',

    /**
     * その他のイベントを示す
     *
     * @type String
     * @constant
     */
    EVENT: 'Event'
};

(function () {
    var wheel = 'on' + Jeeel.Dom.Event.Type.MOUSE_WHEEL;
    
    // FireFoxのホイールイベント
    if (Jeeel._doc && ! (wheel in Jeeel._global || wheel in Jeeel._doc)) {
        Jeeel.Dom.Event.Type.MOUSE_WHEEL = 'DOMMouseScroll';
    }
})();
/**
 * コンストラクタ
 * 
 * @class イベントリスナーを管理するクラス
 * @param {Element} element リスナー管理対象のElement
 */
Jeeel.Dom.Event.Listener = function (element) {
    this._element = element;
    
    this._tasks = {};
    
    this.listener = Jeeel.Function.simpleBind(this.listener, this);
};

Jeeel.Dom.Event.Listener.prototype = {
  
    /**
     * リスナー登録要素
     * 
     * @type Element
     * @private
     */
    _element: null,
    
    /**
     * タスクリスト
     * 
     * @type Hash
     * @private
     */
    _tasks: {},
    
    /**
     * Elementを保持しているかどうかを返す
     * 
     * @param {Element} elm 検索Element
     * @return {Boolean} 保持しているかどうか
     */
    hasElement: function (elm) {
        return this._element === elm;
    },
    
    /**
     * 登録を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Array} [args] コールバックに渡す引数のリスト(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
     */
    add: function (type, listener, thisArg, args) {
        type = this._getType(type);
        
        var lowerType = type.toLowerCase();
        
        if ( ! this._tasks[lowerType]) {
            this._tasks[lowerType] = [];
            this._setListener(type);
        }
        
        if ( ! args) {
            args = [];
        }
        
        var tasks = this._tasks[lowerType];
        
        Array.prototype.unshift.call(args, null, null);

        tasks[tasks.length] = {
            listener: listener, 
            thisArg: thisArg,
            useThis: Jeeel.Type.isSet(thisArg),
            args: args
        };
        
        tasks = null;
        
        return this;
    },
    
    /**
     * 削除を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     */
    remove: function (type, listener) {
        type = this._getType(type);
        
        var lowerType = type.toLowerCase();
        
        if ( ! this._tasks[lowerType]) {
            return this;
        }
        
        var tasks = this._tasks[lowerType],
            l = tasks.length,
            i = 0;
            
        if (l === 1) {
            delete this._tasks[lowerType];
            this._unsetListener(type);
            tasks = null;
            return this;
        }

        for (; i < l; i++) {
            if (tasks[i].listener === listener) {
                tasks.splice(i, 1);
                break;
            }
        }
        
        tasks = null;
        
        return this;
    },
    
    /**
     * 複数のElementに対してのイベントを上位Elementに委譲して登録を行う
     *
     * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Array} [args] コールバックに渡す引数のリスト(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
     */
    delegate: function (elementList, type, listener, thisArg, args) {
        type = this._getType(type);
        
        var lowerType = type.toLowerCase();
        
        elementList = new Jeeel.Dom.ElementOperator(elementList);

        var parent = elementList.getCommonParent();
        
        if (parent && (this._element === parent || this._element === parent.ownerDocument)) {
            if ( ! this._tasks[lowerType]) {
                this._tasks[lowerType] = [];
                this._setListener(type);
            }
            
            if ( ! args) {
                args = [];
            }
            
            var tasks = this._tasks[lowerType];
            
            Array.prototype.unshift.call(args, null, null);
            
            tasks[tasks.length] = {
                elementList: elementList.getAll(),
                listener: listener, 
                thisArg: thisArg,
                useThis: Jeeel.Type.isSet(thisArg),
                args: args
            };
            
            tasks = null;
        }
        
        return this;
    },
    
    /**
     *  複数のElementに対してのイベントを上位Elementに委譲してたものの削除を行う
     *
     * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     */
    undelegate: function (elementList, type, listener) {
        type = this._getType(type);
        
        var lowerType = type.toLowerCase();
        
        if ( ! this._tasks[lowerType]) {
            return this;
        }
        
        elementList = new Jeeel.Dom.ElementOperator(elementList);
        
        var parent = elementList.getCommonParent();
        
        if (this._element !== parent && this._element !== parent.ownerDocument) {
            return this;
        }
        
        var tasks = this._tasks[lowerType],
            l = tasks.length,
            i = 0;
            
        if (l === 1) {
            delete this._tasks[lowerType];
            this._unsetListener(type);
            tasks = null;
            return this;
        }

        for (; i < l; i++) {
            if (tasks[i].elementList && tasks[i].listener === listener) {
                tasks.splice(i, 1);
                break;
            }
        }
        
        tasks = null;
        
        return this;
    },
    
    /**
     * イベントから実際に呼ばれるリスナー
     * 
     * @param {Event} e イベントオブジェクト
     */
    listener: function (e) {
        e = new Jeeel.Dom.Event(e || Jeeel._global.event, this._element);
        
        var tasks = this._tasks[e.type],
            targets = e.bubblingTargets,
            task, args, i = 0,
            j, k, target, elmList, elm, brk;

        while(task = tasks[i++]) {
            args = task.args;
            elmList = task.elementList;
            
            args[0] = e;
            
            if (elmList) {
                brk = false;
                j = 0;
                
                while(target = targets[j++]) {
                    k = 0;
                    
                    while(elm = elmList[k++]) {
                        if (target === elm) {
                            if ( ! task.useThis) {
                                task.thisArg = target;
                            }
                            
                            args[1] = target;
                            task.listener.apply(task.thisArg, args);
                            brk = true;
                            break;
                        }
                    }
                    
                    if (brk) {
                        break;
                    }
                }
            } else {
                if ( ! task.useThis) {
                    task.thisArg = e.currentTarget;
                }
                
                args[1] = e.currentTarget;
                task.listener.apply(task.thisArg, args);
            }
            
            if ( ! task.useThis) {
                task.thisArg = null;
            }
            
            args[0] = args[1] = null;
        }
        
        // メモリリークを防ぐため
        tasks = task = targets = target = elmList = elm = e = args = null;
    },
    
    /**
     * イベントタイプを渡して変換する
     * 
     * @param {String} type イベントタイプ
     * @return {String} イベントタイプ
     */
    _getType: function (type) {},

    /**
     * 実際にリスナーを登録する
     * 
     * @param {String} type イベントタイプ
     * @private
     */
    _setListener: function (type) {},
    
    /**
     * 実際にリスナーを削除する
     * 
     * @param {String} type イベントタイプ
     * @private
     */
    _unsetListener: function (type) {}
};

(function () {
    var getType, add, remove;
    
    var isTouchPanelMobile = Jeeel.UserAgent.isAndroid()
                          || Jeeel.UserAgent.isIPhone()
                          || Jeeel.UserAgent.isIPad()
                          || Jeeel.UserAgent.isIPod();

    if (Jeeel._global && isTouchPanelMobile) {
        getType = function (type) {
            switch (type) {
                case Jeeel.Dom.Event.Type.MOUSE_DOWN:
                    type = Jeeel.Dom.Event.Type.TOUCH_START;
                    break;

                case Jeeel.Dom.Event.Type.MOUSE_MOVE:
                    type = Jeeel.Dom.Event.Type.TOUCH_MOVE;
                    break;

                case Jeeel.Dom.Event.Type.MOUSE_UP:
                    type = Jeeel.Dom.Event.Type.TOUCH_END;
                    break;

                default:
                    break;
            }
            
            return type;
        };
    } else {
        getType = function (type) {
            return type;
        };
    }
    
    if (Jeeel._global && Jeeel._global.addEventListener) {
        add = function (type) {
            this._element.addEventListener(type, this.listener, false);
        };
        remove = function (type) {
            this._element.removeEventListener(type, this.listener, false);
        };
    } else if (Jeeel._global && Jeeel._global.attachEvent) {
        add = function (type) {
            this._element.attachEvent("on" + type, this.listener);
        };
        remove = function (type) {
            this._element.detachEvent("on" + type, this.listener);
        };
    } else {
        add = remove = function (type) {
            Jeeel.errorDump('このブラウザはイベント登録に対応していません。');
        };
    }
    
    Jeeel.Dom.Event.Listener.prototype._getType = getType;
    Jeeel.Dom.Event.Listener.prototype._setListener = add;
    Jeeel.Dom.Event.Listener.prototype._unsetListener = remove;
    
    getType = add = remove = null;
})();
(function () {
    var instance;
    
    /**
     * コンストラクタ
     * 
     * @class 全てのイベントを管理するシングルトンクラス
     */
    Jeeel.Dom.Event.Manager = function () {
        if (instance) {
            return instance;
        }

        instance = this;
        
        this._listeners = [];
    };
    
    /**
     * インスタンスを取得する
     * 
     * @return {Jeeel.Dom.Event.Manager} インスタンス
     */
    Jeeel.Dom.Event.Manager.getInstance = function () {
        return (instance || new this());
    };
})();



Jeeel.Dom.Event.Manager.prototype = {
  
    /**
     * リスナー配列
     * 
     * @type Jeeel.Dom.Event.Listener[]
     * @private
     */
    _listeners: [],
    
    /**
     * イベントの登録を行う
     *
     * @param {Element} element HTML要素
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
     */
    addEventListener: function (element, type, listener, thisArg, var_args) {
        var args = Array.prototype.slice.call(arguments, 4, arguments.length);
        this._getListener(element).add(type, listener, thisArg, args);
        
        return this;
    },
    
    /**
     * イベントの削除を行う
     *
     * @param {Element} element HTML要素
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     */
    removeEventListener: function (element, type, listener) {
        this._getListener(element).remove(type, listener);
        
        return this;
    },
    
    /**
     * 複数のElementに対してのイベントを上位Elementに委譲して登録を行う
     *
     * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
     */
    delegate: function (elementList, type, listener, thisArg, var_args) {
        elementList = new Jeeel.Dom.ElementOperator(elementList);
        var args = Array.prototype.slice.call(arguments, 4, arguments.length);
        this._getListener(elementList.getCommonParent()).delegate(elementList, type, listener, thisArg, args);
        
        return this;
    },
    
    /**
     *  複数のElementに対してのイベントを上位Elementに委譲してたものの削除を行う
     *
     * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     */
    undelegate: function (elementList, type, listener) {
        elementList = new Jeeel.Dom.ElementOperator(elementList);
        this._getListener(elementList.getCommonParent()).undelegate(elementList, type, listener);
        
        return this;
    },
    
    /**
     * Listenerインスタンスを取得する
     * 
     * @param {Element} elm Element
     * @return {Jeeel.Dom.Event.Listener} Listenerインスタンス
     * @private
     */
    _getListener: function (elm) {
        var i, listener = this._listeners;
        
        for (i = listener.length; i--;) {
            if (listener[i].hasElement(elm)) {
                return listener[i];
            }
        }
        
        return listener[listener.length] = new Jeeel.Dom.Event.Listener(elm);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Event.Manager
};
/**
 * コンストラクタ
 * 
 * @class イベントの作成時のパラメータを管理するクラス
 */
Jeeel.Dom.Event.Option = function () {
    this._touches = [];
    this._targetTouches = [];
    this._changedTouches = [];
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Dom.Event.Option} 作成したインスタンス
 */
Jeeel.Dom.Event.Option.create = function () {
    return new this();
};

Jeeel.Dom.Event.Option.prototype = {
    _canBubble: true,
    _cancelable: true, 
    _viewArg: null, 
    _ctrlKeyArg: false, 
    _altKeyArg: false, 
    _shiftKeyArg: false, 
    _metaKeyArg: false, 
    _keyCodeArg: 0, 
    _charCodeArg: 0,
    _detail: 1,
    _screenX: 0,
    _screenY: 0,
    _clientX: 0,
    _clientY: 0,
    _button: 0,
    _relatedTarget: null,
    _touches: [],
    _targetTouches: [],
    _changedTouches: [],
    _scale: 1.0,
    _rotation: 0,
    _dataTransfer: null,
    
    setCanBubble: function (canBubble) {
        this._canBubble = !!canBubble;
        
        return this;
    },
    
    setCancelable: function (cancelable) {
        this._cancelable = !!cancelable;
        
        return this;
    },
    
    setViewArg: function (viewArg) {
        this._viewArg = viewArg;
        
        return this;
    },
    
    setCtrlKeyArg: function (ctrlKeyArg) {
        this._ctrlKeyArg = !!ctrlKeyArg;
        
        return this;
    },
    
    setAltKeyArg: function (altKeyArg) {
        this._altKeyArg = !!altKeyArg;
        
        return this;
    },
    
    setShiftKeyArg: function (shiftKeyArg) {
        this._shiftKeyArg = !!shiftKeyArg;
        
        return this;
    },
    
    setMetaKeyArg: function (metaKeyArg) {
        this._metaKeyArg = !!metaKeyArg;
        
        return this;
    },
    
    setKeyCodeArg: function (keyCodeArg) {
        this._keyCodeArg = +keyCodeArg;
        
        return this;
    },
    
    setCharCodeArg: function (charCodeArg) {
        this._charCodeArg = +charCodeArg;
        
        return this;
    },
    
    setDetail: function (detail) {
        this._detail = +detail;
        
        return this;
    },
    
    setScreen: function (x, y) {
        this._screenX = +x;
        this._screenY = +y;
        
        return this;
    },
    
    setClient: function (x, y) {
        this._clientX = +x;
        this._clientY = +y;
        
        return this;
    },
    
    setButton: function (button) {
        this._button = +button;
        
        return this;
    },
    
    setRelatedTarget: function (relatedTarget) {
        this._relatedTarget = relatedTarget;
        
        return this;
    },
    
    setTouches: function (touches) {
        this._touches = touches;
        
        return this;
    },
    
    setTargetTouches: function (targetTouches) {
        this._targetTouches = targetTouches;
        
        return this;
    },
    
    setChangedTouches: function (changedTouches) {
        this._changedTouches = changedTouches;
        
        return this;
    },
    
    setScale: function (scale) {
        this._scale = +scale;

        return this;
    },
    
    setRotation: function (rotation) {
        this._rotation = +rotation;
        
        return this;
    },
    
    setDataTransfer: function (dataTransfer) {
        this._dataTransfer = dataTransfer;
        
        return this;
    },
    
    getEventOption: function (type) {
        return [
            type,
            this._canBubble,
            this._cancelable
        ];
    },
    
    getMouseEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._detail,
            this._screenX,
            this._screenY,
            this._clientX,
            this._clientY,
            this._ctrlKeyArg,
            this._altKeyArg,
            this._shiftKeyArg,
            this._metaKeyArg,
            this._button,
            this._relatedTarget
        ];
    },
    
    getDragEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._detail,
            this._screenX,
            this._screenY,
            this._clientX,
            this._clientY,
            this._ctrlKeyArg,
            this._altKeyArg,
            this._shiftKeyArg,
            this._metaKeyArg,
            this._button,
            this._relatedTarget,
            this._dataTransfer
        ];
    },
    
    getKeyboardEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._ctrlKeyArg,
            this._altKeyArg,
            this._shiftKeyArg,
            this._metaKeyArg,
            this._keyCodeArg,
            this._charCodeArg
        ];
    },
    
    getTouchEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._detail,
            this._screenX,
            this._screenY,
            this._clientX,
            this._clientY,
            this._ctrlKeyArg,
            this._altKeyArg,
            this._shiftKeyArg,
            this._metaKeyArg,
            this._touches,
            this._targetTouches,
            this._changedTouches,
            this._scale,
            this._rotation
        ];
    },
    
    getUIEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._detail
        ];
    },
    
    initEvent: function (event, type) {
        if (event.initEvent) {
            event.initEvent.apply(event, this.getEventOption(type));
            return event;
        }
        
        event.type = type;
        event.cancelBubble = this._canBubble;
        
        return event;
    },
    
    initMouseEvent: function (event, type, view) {
        if (event.initMouseEvent) {
            event.initMouseEvent.apply(event, this.getMouseEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.screenX = this._screenX;
        event.screenY = this._screenY;
        event.clientX = this._clientX;
        event.clientY = this._clientY;
        event.ctrlKey = this._ctrlKeyArg;
        event.altKey = this._altKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.metaKey = this._metaKeyArg;
        event.button = this._button;
        event.relatedTarget = this._relatedTarget;
        
        return event;
    },
    
    initDragEvent: function (event, type, view) {
        if (event.initDragEvent) {
            event.initDragEvent.apply(event, this.getDragEventOption(type, view));
            return event;
        } else if (event.initMouseEvent) {
            event.initMouseEvent.apply(event, this.getDragEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.screenX = this._screenX;
        event.screenY = this._screenY;
        event.clientX = this._clientX;
        event.clientY = this._clientY;
        event.ctrlKey = this._ctrlKeyArg;
        event.altKey = this._altKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.metaKey = this._metaKeyArg;
        event.button = this._button;
        event.relatedTarget = this._relatedTarget;
        event.dataTransfer = this._dataTransfer;
        
        return event;
    },
    
    initKeyboardEvent: function (event, type, view) {
        if (event.initKeyboardEvent) {
            event.initKeyboardEvent.apply(event, this.getKeyboardEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.ctrlKey = this._ctrlKeyArg;
        event.altKey = this._altKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.metaKey = this._metaKeyArg;
        event.keyCode = this._keyCodeArg;
        event.charCode = this._charCodeArg;
        
        return event;
    },
    
    initTouchEvent: function (event, type, view) {
        if (event.initTouchEvent) {
            event.initTouchEvent.apply(event, this.getTouchEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.screenX = this._screenX;
        event.screenY = this._screenY;
        event.clientX = this._clientX;
        event.clientY = this._clientY;
        event.ctrlKey = this._ctrlKeyArg;
        event.altKey = this._altKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.metaKey = this._metaKeyArg;
        event.touches = this._touches;
        event.targetTouches = this._targetTouches;
        event.changedTouches = this._changedTouches;
        event.scale = this._scale;
        event.rotation = this._rotation;
        
        return event;
    },
    
    initUIEvent: function (event, type, view) {
        if (event.initUIEvent) {
            event.initUIEvent.apply(event, this.getUIEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.screenX = this._screenX;
        event.screenY = this._screenY;
        event.clientX = this._clientX;
        event.clientY = this._clientY;
        event.ctrlKey = this._ctrlKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.altKey = this._altKeyArg;
        
        return event;
    }
};
Jeeel.directory.Jeeel.Dom.Event.Rollover = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Event + 'Rollover/';
    }
};

/**
 * コンストラクタ
 * 
 * @class ロールバーに関するクラス
 */
Jeeel.Dom.Event.Rollover = function () {
    
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Dom.Event.Rollover} 作成したインスタンス
 */
Jeeel.Dom.Event.Rollover.create = function () {
    return new this();
};

Jeeel.Dom.Event.Rollover.prototype = {
  
    /**
     * ロールオーバーハンドラ
     * 
     * @type Function
     * @private
     */
    _on: null,
    
    /**
     * ロールアウトハンドラ
     * 
     * @type Function
     * @private
     */
    _off: null,
    
    /**
     * ロールオーバー時のハンドラを設定する
     * 
     * @param {Function} handler ハンドラ
     * @return {Jeeel.Dom.Event.Rollover} 自インスタンス
     */
    setRollover: function (handler) {
        this._on = handler;
        
        return this;
    },
    
    /**
     * ロールアウト時のハンドラを設定する
     * 
     * @param {Function} handler ハンドラ
     * @return {Jeeel.Dom.Event.Rollover} 自インスタンス
     */
    setRollout: function (handler) {
        this._off = handler;
        
        return this;
    },
    
    /**
     * ロールオーバーを指定したElementに適用する
     * 
     * @param {Element|Element[]} elements ElementまたはElementリスト
     * @return {Jeeel.Dom.Event.Rollover} 自インスタンス
     */
    rollover: function (elements) {
        if (Jeeel.Type.isElement(elements)) {
            elements = [elements];
        }
        
        if ( ! Jeeel.Type.isArray(elements)) {
            throw new Error('引数が間違っています。');
        }
        
        for (var i = elements.length; i--;) {
            
            elements[i].onmouseover = this._on;
            elements[i].onmouseout = this._off;
        }
        
        return this;
    }
};

Jeeel.file.Jeeel.Dom.Event.Rollover = ['Image'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Event.Rollover, Jeeel.file.Jeeel.Dom.Event.Rollover);

/**
 * コンストラクタ
 * 
 * @class イメージのロールオーバーに関するクラス
 */
Jeeel.Dom.Event.Rollover.Image = function () {

};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Dom.Event.Rollover.Image} 作成したインスタンス
 */
Jeeel.Dom.Event.Rollover.Image.create = function () {
    return new this();
};

Jeeel.Dom.Event.Rollover.Image.prototype = {
    _prefix: {
        on: '',
        off: ''
    },
    
    _suffix: {
        on: '_on',
        off: '_off'
    },
    
    /**
     * 先頭のロールオーバーパターンを設定する
     * 
     * @param {String} prefixOn ロールオーバー時の先頭パターン
     * @param {String} prefixOff ロールアウト時の先頭パターン
     * @return {Jeeel.Dom.Event.Rollover.Image} 自インスタンス
     */
    setPrefixPattern: function (prefixOn, prefixOff) {
        this._prefix = {
            on: prefixOn,
            off: prefixOff
        };
        
        return this;
    },
    
    /**
     * 後尾のロールオーバーパターンを設定する
     * 
     * @param {String} suffixOn ロールオーバー時の後尾パターン
     * @param {String} suffixOff ロールアウト時の後尾パターン
     * @return {Jeeel.Dom.Event.Rollover.Image} 自インスタンス
     */
    setSuffixPattern: function (suffixOn, suffixOff) {
        this._suffix = {
            on: suffixOn,
            off: suffixOff
        };
        
        return this;
    },
    
    /**
     * イメージのロールオーバーを行う
     * 
     * @param {Element|Element[]} elements イメージもしくはイメージリスト(内部に他のElementが入っていた場合無視する)
     * @return {Jeeel.Dom.Event.Rollover.Image} 自インスタンス
     */
    rollover: function (elements) {
        if (Jeeel.Type.isElement(elements)) {
            elements = [elements];
        }
        
        if ( ! Jeeel.Type.isArray(elements)) {
            throw new Error('引数が間違っています。');
        }
        
        var over, out;
        
        var regFilter = new Jeeel.Filter.RegularExpressionEscape();
        
        (function (pover, pout, sover, sout) {
            
            over = function () {
                var src = this.src;
                
                if (pout || pover) {
                    src = src.replace(new RegExp('/?' + regFilter.filter(pout) + '([^/]*)$'), '/' + pover + '$1');
                }
                
                if (sout || sover) {
                    src = src.replace(sout + '.', sover + '.');
                }
                
                this.src = src;
            };

            out = function () {
                var src = this.src;
                
                if (pover || pout) {
                    src = src.replace(new RegExp('/?' + regFilter.filter(pover) + '([^/]*)$'), '/' + pout + '$1');
                }
                
                if (sover || sout) {
                    src = src.replace(sover + '.', sout + '.');
                }
                
                this.src = src;
            };
        })(this._prefix.on, this._prefix.off, this._suffix.on, this._suffix.off);
        
        var reg = new RegExp('\\/?' + regFilter.filter(this._prefix.off) + '[^/]*' + regFilter.filter(this._suffix.off) + '\\.[^.]+$');
        
        for (var i = elements.length; i--;) {
            var element = elements[i];
            var tagName = element.tagName && element.tagName.toUpperCase();
            
            if (tagName === 'IMG' || tagName === 'INPUT' && element.type.toUpperCase() === 'IMAGE') {
                
                if ( ! element.src.match(reg)) {
                    continue;
                }
                
                elements[i].onmouseover = over;
                elements[i].onmouseout = out;
            }
        }
        
        return this;
    }
};
Jeeel.directory.Jeeel.Dom.Style = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Style/';
    }
};

/**
 * コンストラクタ
 * 
 * @class スタイルを扱うクラス
 * @param {Element} element スタイルの操作対象Element
 */
Jeeel.Dom.Style = function (element) {
    this._style = element && element.style || null;
    this._defaultDisplay = this.constructor.getDefaultDisplay(element && element.nodeName);
    
    if (element) {
        this._computedStyle = element.parentNode && Jeeel.Document.getComputedStyle(element) || null;
    }
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Style} style 操作スタイル
 * @return {Jeeel.Dom.Style} 作成したインスタンス
 */
Jeeel.Dom.Style.create = function (style) {
    return new this(style);
};

(function () {
    var cache = {};
    
    /**
     * 初期状態のdisplayの値を取得する
     * 
     * @param {String} nodeName 取得したいノード名
     * @return {String} 取得したdisplayの初期値
     */
    Jeeel.Dom.Style.getDefaultDisplay = function (nodeName) {
      
        if ( ! nodeName) {
            return 'inline';
        }
        
        if (nodeName in cache) {
            return cache[nodeName];
        }
        
        var elm = Jeeel.Document.createElement(nodeName);
        var body = Jeeel.Document.getBody();

        body.appendChild(elm);

        var display = Jeeel.Document.getComputedStyle(elm).display;

        body.removeChild(elm);

        // 任意にスタイルが設定されていた場合で且displayの値がnoneもしくは不明の場合はiframe内で再取得
        if (display === 'none' || display === '') {
            var iframe = Jeeel.Document.createElement('iframe');

            iframe.frameBorder = iframe.width = iframe.height = 0;

            body.appendChild(iframe);

            var iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
            iframeDoc.write((Jeeel.Document.getDocument().compatMode === 'CSS1Compat' ? '<!doctype html>' : '' ) + '<html><body>');
            iframeDoc.close();

            elm = iframeDoc.createElement(nodeName);

            iframeDoc.body.appendChild(elm);

            display = Jeeel.Document.getComputedStyle(elm).display;

            body.removeChild(iframe);
        }
        
        cache[nodeName] = display;

        return display;
    };
})();

Jeeel.Dom.Style.prototype = {
  
    /**
     * 操作対象スタイル
     * 
     * @type Style
     * @private
     */
    _style: null,
    
    /**
     * 計算済みスタイル
     * 
     * @type CSSStyleDeclaration
     * @private
     */
    _computedStyle: null,
    
    /**
     * デフォルトの表示状態(inlineかblock、もしくはnoneの可能性もある: head)
     * 
     * @type String
     * @private
     */
    _defaultDisplay: '',
    
    _oldDisplay: '',
    
    _animationQueue: [],
    
    /**
     * スタイルを取得する
     *
     * @param {String} style スタイル名
     * @return {String} スタイル値
     */
    getStyle: function (style) {
        style = Jeeel.String.toCamelCase(style);
        
        // まず通常のスタイルを参照し、存在しないスタイルは計算済みスタイルから参照する
        return this._style[style] || this._computedStyle[style];
    },

    /**
     * スタイルの設定を行う
     *
     * @param {String} style スタイル名
     * @param {String} value スタイル値
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    setStyle: function (style, value) {
        this._style[Jeeel.String.toCamelCase(style)] = value;

        return this;
    },
    
    /**
     * 複数のスタイルの設定を行う
     *
     * @param {Hash} styles スタイル名と値のペアリスト
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    setStyleList: function (styles) {
        var cssText = [];
        
        for (var style in styles) {
            cssText[cssText.length] = Jeeel.String.toHyphenation(style) + ': ' + styles[style] + ';';
        }
        
        this._style.cssText += '; ' + cssText.join('');
        
        return this;
    },
    
    /**
     * @ignore 未完成
     */
    animate: function (params, duration, easing, callback) {
        this._animationQueue[this._animation.length] = new this.constructor.Animation(this, params, duration, easing, callback);
        
        return this;
    },
    
    /**
     * @ignore 未完成
     */
    stop: function (clearQueue, gotoEnd) {
        
    },
    
    /**
     * 表示する
     * 
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    show: function () {
        var display = this._style.display;
        
        if (display !== '' && display !== 'none') {
            return this;
        } else if ( ! this._computedStyle) {
            this._style.display = this._defaultDisplay;
            
            return this;
        }
        
        if (this._oldDisplay) {
            this._style.display = this._oldDisplay;
            
            return this;
        }
        
        if (display === 'none') {
            display = this._style.display = '';
        }
        
        if (display === '' && this._computedStyle.display === 'none') {
            this._oldDisplay = this._style.display = this._defaultDisplay;
        } else {
            this._oldDisplay = this._computedStyle.display;
        }
        
        return this;
    },
    
    /**
     * 隠す
     * 
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    hide: function () {
        this._style.display = 'none';
        
        return this;
    },
    
    /**
     * 表示の切り替えをする
     * 
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    toggle: function () {
        return this._style.display === 'none' ? this.show() : this.hide();
    },
    
    /**
     * 指定座標に移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    shiftTo: function (x, y) {
        this.setStyle('left', x + 'px');
        return this.setStyle('top',  y + 'px');
    },
    
    /**
     * 不透明度を取得する
     * 
     * @return {Number} 不透明度(0.0～1.0)
     */
    getOpacity: function () {
        var style = this._computedStyle || this._style;
        
        if (Jeeel.Type.isSet(style.MozOpacity)) {
            return +(style.MozOpacity || 1.0);
        } else if (Jeeel.Type.isSet(style.opacity)) {
            return +(style.opacity || 1.0);
        } else if (Jeeel.Type.isSet(style.filter)) {
            return (style.filter.replace(/.*alpha\(.*opacity=([0-9]+).*\).*/, '$1') || 100) / 100;
        }
        
        return 1.0;
    },
    
    /**
     * 不透明度を設定する
     * 
     * @param {Number} opacity 不透明度(0.0～1.0)
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    setOpacity: function (opacity) {
        var style = this._style;
        
        if (Jeeel.Type.isSet(style.MozOpacity)) {
            style.MozOpacity = opacity;
        } else if (Jeeel.Type.isSet(style.opacity)) {
            style.opacity = opacity;
        } else if (Jeeel.Type.isSet(style.filter)) {
            style.zoom   = (style.zoom || 1);
            style.filter = 'alpha(opacity=' + (opacity * 100) + ')';
        }
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Style} style 操作スタイル
     */
    constructor: Jeeel.Dom.Style,
    
    _enqueueAnimate: function (animate) {
        
    },
    
    _dequeueAnimate: function () {
        
    }
};

Jeeel.file.Jeeel.Dom.Style = ['Animation'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style, Jeeel.file.Jeeel.Dom.Style);Jeeel.directory.Jeeel.Dom.Style.Animation = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Style + 'Animation/';
    }
};

/**
 * @ignore
 */
Jeeel.Dom.Style.Animation = function (style, params, duration, easing, callback) {
  
    this.step = Jeeel.Function.simpleBind(this.step, this);
    
    this._style = style;
    this._params = params;
    this._duration = this.constructor.Speed.getSpeed(duration);
    this._easing = easing;
    this._callback = callback;
    
    this.init();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Dom.Style.Animation} 作成したインスタンス
 */
Jeeel.Dom.Style.Animation.create = function (style, params, duration, easing, callback) {
    return new this(style, params, duration, easing, callback);
};

Jeeel.Dom.Style.Animation.prototype = {
    _style: null,
    _defaultParams: {},
    _params: {},
    _duration: null,
    _easing: null, 
    _callback: null,
    _timerId: null,
    _dt: 13,
    _tick: 0,
    
    setDuration: function (duration) {
        this._duration = this.constructor.Speed.getSpeed(duration);
        
        return this;
    },
    
    setEasing: function (easing) {
        this._easing = easing;
        
        return this;
    },
    
    setCallback: function (callback) {
        this._callback = callback;
        
        return this;
    },
    
    init: function () {
        if (this._timerId) {
            Jeeel.Window.clearInterval(this._timerId);
        }
        
        this._timerId = null;
        this._tick = 0;
        //パラメータの初期化
    },
    
    animate: function () {
        this.init();
        this.start();
        
        return this;
    },
    
    start: function () {
      
        if ( ! this._timerId) {
            Jeeel.Window.setInterval(this.step, this._dt);
        }
    },
    
    step: function () {
        
        if (this._tick > this._duration) {
            return this.stop(true);
        }
        
        this._tick += this._dt;
        
        
    },
    
    end: function () {
        if (this._callback) {
            this._callback();
        }
    },
    
    stop: function (goToEnd) {
        if (this._timerId) {
            Jeeel.Window.clearInterval(this._timerId);
            
            this._timerId = null;
        }
        
        if (goToEnd) {
            this.end();
        }
    },
    
    constructor: Jeeel.Dom.Style.Animation
};

Jeeel.file.Jeeel.Dom.Style.Animation = ['Speed', 'Easing'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style.Animation, Jeeel.file.Jeeel.Dom.Style.Animation);
Jeeel.Dom.Style.Animation.Speed = {
    
    getSpeed: function (duration) {
      
        // 数値で且正の値だった場合はそのまま返す
        if (duration > 0) {
            return duration;
        }
        
        duration = ('' + duration).toUpperCase();
        
        return (duration in this.SPEEDS ? this.SPEEDS[duration] : this.SPEEDS.DEFAULT);
    }
};

/**
 * 規定の速度を示す列挙体
 */
Jeeel.Dom.Style.Animation.Speed.SPEEDS = {
    /**
     * 遅い
     * 
     * @type Integer
     * @constant
     */
    SLOW: 600,
    
    /**
     * 早い
     * 
     * @type Integer
     * @constant
     */
    FAST: 200,
    
    /**
     * デフォルト
     * 
     * @type Integer
     * @constant
     */
    DEFAULT: 400
};
/**
 * イージング関数を保持するネームスペース
 * 
 * t: currentTime(経過時間: 秒)
 * b: beginningValue(初期値)
 * c: changeInValue(変動値)
 * d: duration(継続時間: 秒)
 */
Jeeel.Dom.Style.Animation.Easing = {
  
    /**
     * y = x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    linear: function (t, b, c, d) {
        return c * t / d + b; 
    },
    
    /**
     * y = -( cos(x * π) ) / 2 + 0.5
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    swing: function (t, b, c, d) {
        return ((-Math.cos(t * Math.PI) / 2) + 0.5) * c + b;
    },
    
    /**
     * y = x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeNone: function (t, b, c, d) {
        return c * t / d + b; 
    },
    
    /**
     * y = 2x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInQuad: function (t, b, c, d) {
        return c * (t /= d) * t + b;
    },
    
    easeOutQuad: function (t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
    },
    
    easeInOutQuad: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return c / 2 * t * t + b;
        }
        
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },
    
    /**
     * y = 3x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInCubic: function (t, b, c, d) {
        return c * (t /= d) * t * t + b;
    },
    
    easeOutCubic: function (t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
    },
    
    easeInOutCubic: function (t, b, c, d) {
        if ((t /= d / 2) < 1) { 
            return c / 2 * t * t * t + b;
        }
        
        return c / 2 * ((t -= 2) * t * t + 2) + b;
    },
    
    easeOutInCubic: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutCubic(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInCubic((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = 4x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInQuart: function (t, b, c, d) {
        return c * (t /= d) * t * t * t + b;
    },
    
    easeOutQuart: function (t, b, c, d) {
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    },
    
    easeInOutQuart: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return c / 2 * t * t * t * t + b;
        }
        
        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    },
    
    easeOutInQuart: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutQuart(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInQuart((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = 5x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInQuint: function (t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
    },

    easeOutQuint: function (t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    },
    
    easeInOutQuint: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return c / 2 * t * t * t * t * t + b;
        }
        
        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    },
    
    easeOutInQuint: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutQuint(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInQuint((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = -cos(x * n/2) + 1
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInSine: function (t, b, c, d) {
        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    },
    
    easeOutSine: function (t, b, c, d) {
        return c * Math.sin(t / d * (Math.PI / 2)) + b;
    },
    
    easeInOutSine: function (t, b, c, d) {
        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    },
    
    easeOutInSine: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutSine(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInSine((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = 2 ^ (10 * (x - 1)) : xが0の時はyも0
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInExpo: function (t, b, c, d) {
        return (t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001);
    },
    
    easeOutExpo: function (t, b, c, d) {
        return (t === d ? b + c : c * 1.001 * (-Math.pow(2, -10 * t / d) + 1) + b);
    },
    
    easeInOutExpo: function (t, b, c, d) {
        if (t === 0) {
            return b;
        } else if (t === d) {
            return b + c;
        } else if ((t /= d / 2) < 1) {
            return c / 2 * Math.pow(2, 10 * (t - 1)) + b - c * 0.0005;
        }
        
        return c / 2 * 1.0005 * (-Math.pow(2, -10 * --t) + 2) + b;
    },
    
    easeOutInExpo: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutExpo(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInExpo((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = -0.5(1 - x * x) + 1
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInCirc: function (t, b, c, d) {
        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    },
    
    easeOutCirc: function (t, b, c, d) {
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    },
    
    easeInOutCirc: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
        }
        
        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    },
    
    easeOutInCirc: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutCirc(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInCirc((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    easeInElastic: function (t, b, c, d, a, p) {
        var s;
        
        if (t === 0) {
            return b;  
        } else if ((t /= d) === 1) {
            return b + c;  
        } else if ( ! p) {
            p = d * 0.3;
        }
        
        if ( ! a || a < Math.abs(c)) { 
            a = c; 
            s = p / 4; 
        } else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }

        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    },
    
    easeOutElastic: function (t, b, c, d, a, p) {
        var s;
        
        if (t === 0) {
            return b;  
        } else if ((t /= d) === 1) {
            return b + c;  
        } else if ( ! p) {
            p = d * 0.3;
        }
        
        if ( ! a || a < Math.abs(c)) {
            a = c;
            s = p / 4; 
        } else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        
        return(a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p ) + c + b);
    },
    
    easeInOutElastic: function (t, b, c, d, a, p) {
        var s;
        
        if (t === 0) {
            return b;  
        } else if ((t /= d / 2) === 2) {
            return b + c;  
        } else if ( ! p) {
            p = d * (0.3 * 1.5);
        }
        
        if ( ! a || a < Math.abs(c)) { 
            a = c; 
            s = p / 4; 
        } else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        
        if (t < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        }
        
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
    },
    
    easeOutInElastic: function (t, b, c, d, a, p) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutElastic(t * 2, b, c / 2, d, a, p);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInElastic((t * 2) - d, b + c / 2, c / 2, d, a, p);
    },
    
    /**
     * y = x * x * ( 2.70158 * x - 1.70158 )
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @param {Number} [s] 反動などの強さ
     * @return {Number} 現在値
     */
    easeInBack: function (t, b, c, d, s) {
        if ( ! s) {
            s = 1.70158;
        }
        
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    
    easeOutBack: function (t, b, c, d, s) {
        if ( ! s) {
            s = 1.70158;
        }
        
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    
    easeInOutBack: function (t, b, c, d, s) {
        if ( ! s) {
            s = 1.70158;
        }
        
        if ((t /= d / 2) < 1) {
            return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
        }
        
        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
    },
    
    easeOutInBack: function (t, b, c, d, s) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutBack(t * 2, b, c / 2, d, s);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInBack((t * 2) - d, b + c / 2, c / 2, d, s);
    },
    
    easeInBounce: function (t, b, c, d) {
        return c - Jeeel.Dom.Style.Animation.Easing.easeOutBounce(d - t, 0, c, d) + b;
    },
    
    easeOutBounce: function (t, b, c, d) {
        if ((t /= d) < (1 / 2.75)) {
            return c * (7.5625 * t * t) + b;
        } else if (t < (2 / 2.75)) {
            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
        } else if (t < (2.5 / 2.75)) {
            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
        } else {
            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
        }
    },
    
    easeInOutBounce: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeInBounce(t * 2, 0, c, d) * 0.5 + b;
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    },
    
    easeOutInBounce: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutBounce(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInBounce(t * 2 - d, b + c / 2, c / 2, d);
    }
};
Jeeel.directory.Jeeel.Dom.Element = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Element/';
    }
};

/**
 * コンストラクタ
 *
 * @class Elementをラップして操作系を強化するクラス
 * @param {Element} element 対象Element
 */
Jeeel.Dom.Element = function (element) {
    this._element = element;
    this._style = new Jeeel.Dom.Style(element);
    this._searcher = new Jeeel.Dom.Core.Searcher(element);
    this._doc = new Jeeel.Dom.Document(element && element.ownerDocument || Jeeel._doc);
};

/**
 * インスタンスを作成する
 *
 * @param {Element} element 対象Element
 * @return {Jeeel.Dom.Element} 作成したインスタンス
 */
Jeeel.Dom.Element.create = function (element) {
    return new this(element);
};

/**
 * 指定したElementと任意のElementを交換する
 *
 * @param {Element} element 指定Element
 * @param {Element} replaceElement 交換Element
 * @return {Element} 挿入されていない方のElement
 */
Jeeel.Dom.Element.replace = function (element, replaceElement) {
    if ( ! element || ! element.parentNode || ! replaceElement) {
        return replaceElement;
    }

    var parent = element.parentNode;
    parent.replaceChild(replaceElement, element);
    return element;
};

Jeeel.Dom.Element.prototype = {

    /**
     * 基となるElement(この操作モジュールを保持するElement)
     *
     * @type Element
     * @private
     */
    _element: null,
    
    /**
     * 操作Document
     * 
     * @type Jeeel.Dom.Document
     * @private
     */
    _doc: null,
    
    /**
     * 検索インスタンス
     * 
     * @type Jeeel.Dom.Core.Searcher
     * @private
     */
    _searcher: null,
    
    /**
     * ElementのStyleラッパー
     * 
     * @type Jeeel.Dom.Style
     * @private
     */
    _style: null,

    /**
     * 基となるElementを取得する
     *
     * @return {Element} 取得したElement
     */
    getElement: function () {
        return this._element;
    },
    
    /**
     * このElementを所有しているDocumentを取得する
     * 
     * @return {Document} Document
     */
    getOwnerDocument: function () {
        return this._element.ownerDocument;
    },
    
    /**
     * このElementを所有しているWindowを取得する
     * 
     * @return {Window} Window
     */
    getOwnerWindow: function () {
        var dc = this.getOwnerDocument();
        return dc.defaultView || dc.parentWindow;
    },

    /**
     * このElement内から指定IDのHTML要素を取得する
     *
     * @param {String} id 検索ID
     * @return {Element} 取得したElement
     */
    getElementById: function (id) {
        return this._searcher.getElementById(id);
    },

    /**
     * このElement内から指定ClassのHTML要素を取得する
     *
     * @param {String|String[]} className 検索Class
     * @return {Element[]} 取得したElement配列
     */
    getElementsByClassName: function (className) {
        return this._searcher.getElementsByClassName(className);
    },
    
    /**
     * このElement内から指定NameのHTML要素を取得する
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする
     *
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch=false] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか
     * @return {Element[]} 取得したElement配列
     */
    getElementsByName: function (name, submitSearch) {
        return this._searcher.getElementsByName(name, submitSearch);
    },
    
    /**
     * このElement内から指定TagのHTML要素を取得する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Element[]} 取得したElement配列
     */
    getElementsByTagName: function (tagName) {
        return this._searcher.getElementsByTagName(tagName);
    },
    
    /**
     * このElement内から指定属性が指定値のHTML要素を取得する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByAttribute: function (attribute, value) {
        return this._searcher.getElementsByAttribute(attribute, value);
    },

    /**
     * このElement内から指定プロパティが指定値のHTML要素を取得する<br />
     * Elementのプロパティである事に注意
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value プロパティ値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByProperty: function (property, value) {
        return this._searcher.getElementsByProperty(property, value);
    },
    
    /**
     * このElement内部に絞り込みを掛ける<br />
     * 現在のHTML内に存在しない要素は取れない
     *
     * @param {String} selector CSSと同じ絞り込みセレクタ
     * @return {Element[]} 絞り込んだElement配列
     * @ignore
     */
    getElementsBySelector: function (selector) {
        return this._searcher.getElementsBySelector(selector);
    },
    
    /**
     * このElement内のHTML要素を指定範囲検索する
     * 
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {Function} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Element[]} 範囲検索に引っかかったElement配列
     * @see Jeeel.Dom.SearchOption
     */
    searchElementsByRange: function (rect, option) {},
    
    /**
     * このElementのIDを取得する
     *
     * @return {String} ID
     */
    getId: function () {
        return this._element.id;
    },
    
    /**
     * このElementのIDを設定する
     *
     * @param {String} id ID
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setId: function (id) {
        this._element.id = id;
        
        return this;
    },

    /**
     * このElementのNameを取得する
     *
     * @return {String} Name
     */
    getName: function () {
        return this._element.name;
    },
    
    /**
     * このElementのNameを設定する
     *
     * @param {String} name Name
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setName: function (name) {
        this._element.name = name;
        
        return this;
    },
    
    /**
     * このElementのTagNameを取得する
     *
     * @return {String} TagName
     */
    getTagName: function () {
        return this._element.nodeName.toLowerCase();
    },
    
    /**
     * このElement内のクラス名を全て取得する
     *
     * @return {String[]} クラス名のリスト
     */
    getClassNames: function () {},

    /**
     * クラス名を追加する
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    addClassName: function (className) {},

    /**
     * クラス名の削除を行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    removeClassName: function (className) {},

    /**
     * クラス名が存在していたら削除し、存在していなかったら追加を行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    toggleClassName: function (className) {},

    /**
     * クラス名を消去する
     *
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    clearClassName: function () {
        this._element.className = '';

        return this;
    },

    /**
     * 指定したクラス名を保持しているかどうかを返す
     *
     * @param {String} className クラス名
     * @return {Boolean} クラス名を保持していたかどうか
     */
    hasClassName: function (className) {},

    /**
     * 属性値を取得する
     *
     * @param {String} attribute 属性名
     * @return {String} 属性値
     */
    getAttribute: function (attribute) {
        return this._element.getAttribute(attribute);
    },

    /**
     * 属性値の設定を行う
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setAttribute: function (attribute, value) {
        this._element.setAttribute(attribute, value);

        return this;
    },
    
    /**
     * 属性値が設定されているかどうかを返す
     * 
     * @param {String} attribute 属性名
     * @return {Boolean} 属性値が設定されているかどうか
     */
    hasAttribute: function (attribute) {
        return this._element.getAttribute(attribute) !== null;
    },
    
    /**
     * 属性値の削除を行う
     *
     * @param {String} attribute 属性名
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    removeAttribute: function (attribute) {
        this._element.removeAttribute(attribute);

        return this;
    },

    /**
     * プロパティを取得する
     *
     * @param {String} property プロパティ名
     * @return {Mixied} プロパティ値
     */
    getProperty: function (property) {
        return this._element[property];
    },

    /**
     * プロパティの設定を行う
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value プロパティ値
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setProperty: function (property, value) {
        this._element[property] = value;

        return this;
    },

    /**
     * スタイルを取得する
     *
     * @param {String} style スタイル名
     * @return {String} スタイル値
     */
    getStyle: function (style) {
        return this._style.getStyle(style);
    },

    /**
     * スタイルの設定を行う
     *
     * @param {String} style スタイル名
     * @param {String} value スタイル値
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setStyle: function (style, value) {
        this._style.setStyle(style, value);

        return this;
    },
    
    /**
     * 複数のスタイルの設定を行う
     *
     * @param {Hash} styles スタイル名と値のペアリスト
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setStyleList: function (styles) {
        this._style.setStyleList(styles);

        return this;
    },
    
    /**
     * このElementの不透明度を取得する
     * 
     * @return {Number} 不透明度(0.0～1.0)
     */
    getOpacity: function () {
        return this._style.getOpacity();
    },
    
    /**
     * このElementの不透明度を設定する
     * 
     * @param {Number} opacity 不透明度(0.0～1.0)
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setOpacity: function (opacity) {
        this._style.setOpacity(opacity);
        
        return this;
    },
    
    /**
     * このElementの左上絶対軸座標を返す
     * 
     * @return {Jeeel.Object.Point} 左上の座標
     */
    getPosition: function () {
        var pos = new Jeeel.Object.Point(0, 0);
        var el = this._element;
        var body = this._doc.getBody();
        
        while (el) {
            pos.x += el.offsetLeft;
            pos.y += el.offsetTop;

            el = el.offsetParent;
        }
        
        el = this._element.parentNode;
        
        while (el && el !== body) {
            pos.x -= el.scrollLeft;
            pos.y -= el.scrollTop;

            el = el.parentNode;
        }
        
        return pos;
    },
    
    /**
     * このElementのサイズを取得する
     * 
     * @return {Jeeel.Object.Size} サイズ
     */
    getSize: function () {
        var elm = this._element;
        var style = elm.style;
        var clip  = elm.clip;
        
        var w = elm.offsetWidth
             || clip && clip.width
             || style && style.pixelWidth
             || 0;

        var h = elm.offsetHeight
             || clip && clip.height
             || style && style.pixelHeight
             || 0;

        return new Jeeel.Object.Size(+w, +h);
    },
    
    /**
     * このElementの左上絶対座標とサイズを併せ持った構造体を取得する
     * 
     * @return {Jeeel.Object.Rect} レクト
     */
    getRect: function () {
        return new Jeeel.Object.Rect(this.getPosition(), this.getSize());
    },
    
    /**
     * このElementのスクロール位置を取得する
     * 
     * @return {Jeeel.Object.Point} スクロール位置
     */
    getScrollPosition: function () {
        return new Jeeel.Object.Point(this._element.scrollLeft, this._element.scrollTop);
    },
    
    /**
     * このElementの親からの相対位置を取得する
     * 
     * @return {Jeeel.Object.Point} 親要素からの相対位置
     */
    getRelativePosition: function () {
        var el = this._element;
        var pos = new Jeeel.Object.Point(el.offsetLeft, el.offsetTop);
        
        var body = this._doc.getBody();
        
        el = el.parentNode;
        
        if (el && el !== body) {
            pos.x -= el.scrollLeft;
            pos.y -= el.scrollTop;
        }
        
        return pos;
    },

    /**
     * innerHtmlを取得する
     * 
     * @return {String} Html文字列
     */
    getHtml: function () {
        return this._element.innerHTML;
    },

    /**
     * innerHtmlの設定を行う
     *
     * @param {String} html Html文字列
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setHtml: function (html) {
        this._element.innerHTML = html;

        return this;
    },

    /**
     * Textを取得する<br />
     * TextNodeを全て結合して取り出す
     *
     * @return {String} Html文字列
     */
    getText: function () {},

    /**
     * Textの設定を行う<br />
     * innerHtml内にエスケープした文字列を代入する
     *
     * @param {String} text 設定文字列
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setText: function (text) {},
    
    /**
     * このElementの次のElementを取得する
     *
     * @param {Integer} [nextCount] いくつ次を参照するか
     * @return {Element} 取得したElement
     */
    getNextNode: function (nextCount) {
        if ( ! Jeeel.Type.isInteger(nextCount)) {
            nextCount = 1;
        } else if (nextCount < 0) {
            return null;
        }

        var children = this._element.parentNode.children;

        for (var i = 0, l = children.length - nextCount; i < l; i++) {
            if (children[i] === this._element){
                return children[i + nextCount];
            }
        }

        return null;
    },

    /**
     * このElementの前のElementを取得する
     *
     * @param {Integer} [prevCount] いくつ前を参照するか
     * @return {Element} 取得したElement
     */
    getPrevNode: function (prevCount) {
        if ( ! Jeeel.Type.isInteger(prevCount)) {
            prevCount = 1;
        } else if (prevCount < 0) {
            return null;
        }

        var children = this._element.parentNode.children;

        for (var i = prevCount, l = children.length; i < l; i++) {
            if (children[i] === this._element) {
                return children[i - prevCount];
            }
        }

        return null;
    },
    
    /**
     * このElementの親のElementを取得する
     *
     * @param {Integer} [parentCount] いくつ上階層の親を参照するか
     * @return {Element} 取得したElement
     */
    getParentNode: function (parentCount) {
        if ( ! Jeeel.Type.isInteger(parentCount)) {
            parentCount = 1;
        } else if (parentCount < 0) {
            return null;
        }
        
        var parent = this._element;

        while (parent && parentCount--) {
            parent = parent.parentNode;
        }

        return parent;
    },

    /**
     * このElementの子リストを取得する
     *
     * @return {Element[]} 取得したElementリスト
     */
    getChildren: function () {
        var children = this._element.children;
        var res = [];

        for (var i = 0, l = children.length; i < l; i++) {
            res[i] = children[i];
        }

        return res;
    },
    
    /**
     * このElementの階層の深さを返す<br />
     * documentが最上層となり数値0を返す<br />
     * なおdom上に存在しないElementについてはこの限りではない
     * 
     * @return {Integer} 階層の深さレベル
     */
    getHierarchy: function () {
        var h = 0;
        var parent = this._element.parentNode;
        
        while(parent) {
            parent = parent.parentNode;
            h++;
        }
        
        return h;
    },

    /**
     * このElementの前に追加Elementを挿入する
     *
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertBefore: function (addElement) {
        this._element.parentNode.insertBefore(addElement, this._element);
        return this;
    },

    /**
     * このElementの後に追加Elementを挿入する
     *
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertAfter: function (addElement) {
        var next = this.getNextNode();
        this._element.parentNode.insertBefore(addElement, next);
        return this;
    },

    /**
     * このElementの一番上に追加Elementを挿入する
     *
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertTop: function (addElement) {
        var first = this._element.firstChild;

        if (first) {
            this._element.insertBefore(addElement, first);
        } else {
            this._element.appendChild(addElement);
        }
        
        return this;
    },

    /**
     * このElementの一番下に追加Elementを挿入する
     *
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertBottom: function (addElement) {
        this._element.appendChild(addElement);
        return this;
    },

    /**
     * このElementの指定した子Elementの前に追加Elementを挿入する
     *
     * @param {Element} child このElement内の子Element
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertChildBefore: function (child, addElement) {
        this._element.insertBefore(child, addElement);
        return this;
    },

    /**
     * このElementの指定した子Elementの後に追加Elementを挿入する
     *
     * @param {Element} child このElement内の子Element
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertChildAfter: function (child, addElement) {
        var next = child.nextSibling;
        this._element.insertBefore(addElement, next);
        return this;
    },

    /**
     * このElementの指定したElementで囲う<br />
     * ただしElementをコピーされる
     *
     * @param {String|Element} wrap 囲みElement
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @ignore
     */
    wrapSelf: function (wrap) {
        if (Jeeel.Type.isElement(wrap)) {
            wrap = wrap.cloneNode(true);
        } else {
            wrap = this._doc.createElementList(wrap)[0];
        }

        var parent = this._element.parentNode;

        parent.replaceChild(wrap, this._element);
        wrap.appendChild(this._element);

        return this;
    },
    
    /**
     * このElementの子リストを指定要素で囲む<br />
     * 但し、要素を渡した場合その要素はコピーされる
     * 
     * @param {String|Element} wrap 子リストを囲むHTML文字列もしくはHTML要素
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @ignore
     */
    wrapInner: function (wrap) {
        if (Jeeel.Type.isElement(wrap)) {
            wrap = wrap.cloneNode(true);
        } else {
            wrap = this._doc.createElementList(wrap)[0];
        }
        
        if ( ! wrap) {
            return this;
        }
        
        var wrapOwner = wrap;
        
        while (wrap.firstChild) {
            wrap = wrap.firstChild;
        }
        
        var flag = this._doc.createDocumentFragment();
        
        while(this._element.firstChild) {
            flag.appendChild(this._element.firstChild);
        }
        
        wrap.appendChild(flag);
        
        this._element.appendChild(wrapOwner);
        
        return this;
    },

    /**
     * このElementの子供に追加する
     *
     * @param {Element|Element[]} child 追加子Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    appendChild: function (child) {
        if (Jeeel.Type.isArray(child)) {
            var tmp = this._doc.createDocumentFragment();
            
            for (var i = 0, l = child.length; i < l; i++) {
                tmp.appendChild(child[i]);
            }
            
            child = tmp;
        }

        this._element.appendChild(child);
        
        return this;
    },

    /**
     * このElementの子供を削除する
     *
     * @param {Element|Element[]} child 削除子Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    removeChild: function (child) {
        if (Jeeel.Type.isArray(child)) {
            var tmp = this._doc.createDocumentFragment();
            
            for (var i = 0, l = child.length; i < l; i++) {
                tmp.appendChild(child[i]);
            }
            
            child = tmp;
        }

        this._element.removeChild(child);

        return this;
    },
    
    /**
     * このElementの子供を全て削除する
     *
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    clearChildNodes: function () {
        var f, elm = this._element;

        while (f = elm.firstChild) {
            elm.removeChild(f);
        }

        return this;
    },

    /**
     * このElementの子リストにforeachをかける<br />
     * 但し対象は通常Nodeに限る(TextNode等は除外)<br />
     * 詳しくはJeeel.Hash.forEach参照
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Hash.forEach
     */
    each: function (eachMethod, thisArg) {
        Jeeel.Hash.forEach(this._element.children, eachMethod, thisArg);
        
        return this;
    },

    /**
     * このElementを複製する
     *
     * @param {Boolean} [isDeep] ディープコピーを行うかどうか
     * @return {Element} 複製したElement
     */
    clone: function (isDeep) {
        return this._element.cloneNode(isDeep);
    },

    /**
     * このElementを隠す
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    hide: function () {
        this._style.hide();
        
        return this;
    },

    /**
     * このElementを表示する
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    show: function () {
        this._style.show();
        
        return this;
    },
    
    /**
     * このElementの表示状態を切り替える
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    toggle: function () {
        this._style.toggle();
        
        return this;
    },
    
    /**
     * このElementを有効にする
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    enable: function () {
        this.removeAttribute('disabled');
        
        return this;
    },
    
    /**
     * このElementを無効にする
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    disable: function () {
        this.setAttribute('disabled', '1');
        
        return this;
    },
    
    /**
     * このElementを移動可能にする
     * 
     * @param {Element|Element[]} dispatchTargets このElement上でマウスを押し込むと移動を始める(デフォルトはこのElement)
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    movable: function (dispatchTargets) {},
    
    /**
     * このElementを移動不可能にする
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    immovable: function () {},
    
    /**
     * IE6のためのバグ回避を簡単に行うメソッド<br />
     * ダイアログの様なpositionを変えて、selectタグの下にもぐりこんでしまう場合に指定する
     * 
     * @param {Hash} [style] BGのiframeのスタイルをカスタムに指定するための値(基本は指定しない)
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setBackgroundIframe: function (style) {},
    
    /**
     * このElementを指定座標に移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    shiftTo: function (x, y) {
        this._style.shiftTo(x, y);
        
        return this;
    },
    
    scroll: function (x, y) {
        this._element.scrollLeft = x;
        this._element.scrollTop = y;
        
        return this;
    },
    
    /**
     * このElementを取り除く
     *
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    remove: function () {
        if ( ! this._element.parentNode) {
            return this;
        }
        
        var parent = this._element.parentNode;
        parent.removeChild(this._element);
        
        return this;
    },

    /**
     * このElementと任意のElementを交換する
     *
     * @param {Element} replaceElement 交換Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    replace: function (replaceElement) {
        var parent = this._element.parentNode;
        parent.replaceChild(replaceElement, this._element);
        return this;
    },

    /**
     * このElementを上に移動する
     *
     * @param {Integer} [upCount] 上に動かす距離
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    up: function (upCount) {
        var prev = this.getPrevNode(upCount);

        if (prev) {
            this._element.parentNode.insertBefore(this._element, prev);
        }
        
        return this;
    },

    /**
     * このElementを下に移動する
     *
     * @param {Integer} [downCount] 下に動かす距離
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    down: function (downCount) {
        if (Jeeel.Type.isInteger(downCount)) {
            downCount++;
        } else {
            downCount = 2;
        }

        var next = this.getNextNode(downCount);
        
        this._element.parentNode.insertBefore(this._element, next);
        
        return this;
    },

    /**
     * このElementとDom上のEleentの位置を入れ替える<br />
     * replaceメソッドはDom上のElementとDom外のElementの交換
     *
     * @param {Element} swapElement 交換対象のElement(同じDom上にあり階層関係に不一致がないことが条件)
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    swap: function (swapElement) {
        var thisParent = this._element.parentNode;
        var swapParent = swapElement.parentNode;
        var thisNext = this.getNextNode();
        var swapNext = Jeeel.Dom.Element.create(swapElement).getNextNode();

        if (thisParent) {
            thisParent.insertBefore(swapElement, thisNext);
        }

        if (swapParent) {
            swapParent.insertBefore(this._element, swapNext);
        }
        
        return this;
    },

    /**
     * このElementを一番上に移動する
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    upTop: function () {
        var first = this._element.parentNode.firstChild;

        this._element.parentNode.insertBefore(this._element, first);
        
        return this;
    },

    /**
     * このElementを一番下に移動する
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    downBottom: function () {
        this._element.parentNode.insertBefore(this._element, null);
        
        return this;
    },

    /**
     * このElementにイベントを追加する<br />
     * 引数はJeeel.Dom.Event, このElementになる
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    addEventListener: function (type, listener, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        Jeeel.Dom.Event.addEventListener(this._element, type, listener, thisArg);
        
        return this;
    },

    /**
     * イベントの削除を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    removeEventListener: function (type, listener) {
        Jeeel.Dom.Event.removeEventListener(this._element, type, listener);

        return this;
    },
    
    /**
     * このElementに設定されているイベントを任意のタイミングで実行する
     *
     * @param {String} type イベントタイプ
     * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @ignore 未完成
     */
    dispatchEvent: function (type, option) {
        Jeeel.Dom.Event.dispatchEvent(this._element, type, option);
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Element} element 対象Element
     * @constructor
     */
    constructor: Jeeel.Dom.Element,
    
    _init: function () {
        if ( ! Jeeel._doc) {
            delete this._init;
            return;
        }
        
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var txt = Jeeel.Dom.Node.TEXT_NODE;
        var div = (Jeeel.Document || Jeeel._doc).createElement('div');
        
        var _first, _option, _rect;
        var ef = new Jeeel.Filter.Html.Escape(true);
        var slice = Array.prototype.slice;
        
        function _searchRange(res, target) {
            var trect = Jeeel.Dom.Element.create(target).getRect();

            if ( ! _first && _option(_rect, trect)) {
                res[res.length] = target;
            }
            
            _first = false;

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    _searchRange(res, child);
                }

                child = child.nextSibling;
            }
        }
        
        function _searchTxt(res, target) {
            if (target.nodeType === txt) {
                res[res.length] = target.data;
            }

            var child = target.firstChild;

            while(child) {

                _searchTxt(res, child);

                child = child.nextSibling;
            }
        }
        
        var self = this;

        self.searchElementsByRange = function (rect, option) {
            if ( ! rect) {
                return [];
            }

            if ( ! option) {
                option = Jeeel.Dom.SearchOption.RANGE_OVERLAY;
            }
            
            _rect = rect;
            _option = option;

            var res = [];
            
            _searchRange(res, this._element);

            return res;
        };
        
        if (div.classList) {
            self.getClassNames = function () {
                return slice.call(this._element.classList);
            };
            
            self.addClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.add(className[i]);
                }
                
                return this;
            };
            
            self.removeClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.remove(className[i]);
                }

                return this;
            };
            
            self.toggleClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.toggle(className[i]);
                }

                return this;
            };
            
            self.hasClassName = function (className) {
                return this._element.classList.contains(className);
            };
            
        } else {
            self.getClassNames = function () {
                return this._element.className.split(/\s+/);
            };
            
            self.addClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var ec = this._element.className;
                
                for (var i = 0, l = className.length; i < l; i++) {
                    if ( ! className[i]) {
                        continue;
                    } else if(ec === className[i] || ec.search('\\b' + className[i] + '\\b') !== -1) {
                        continue;
                    }
                    
                    ec += (ec ? ' ' : '') + className[i];
                }
                
                this._element.className = ec;
                
                return this;
            };
            
            self.removeClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var ec = this._element.className;
                
                for (var i = 0, l = className.length; i < l; i++) {
                    if ( ! className[i]) {
                        continue;
                    }
                    
                    ec = ec.replace(new RegExp('\\b' + className[i] + '\\b\\s*','g'),'');
                }
                
                this._element.className = ec.replace(/\s+$/g, '');
                
                return this;
            };
            
            self.toggleClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }

                var classNames = this.getClassNames();

                for (var i = 0, l = className.length; i < l; i++) {
                    if (Jeeel.Type.inArray(className[i], classNames, true)) {
                        this.removeClassName(className[i]);
                    } else {
                        this.addClassName(className[i]);
                    }
                }

                return this;
            };
            
            self.hasClassName = function (className) {
                if ( ! className) {
                    return false;
                }
                
                var ec = this._element.className;
                
                return ec === className
                    || ec.search('\\b' + className + '\\b') !== -1;
            };
        }
        
        self.getText = function () {
            var res = [];

            _searchTxt(res, this._element);

            return res.join('');
        };
        
        self.setText = function (text) {
            this._element.innerHTML = ef.filter(text);

            return this;
        };
        
        if (Jeeel.UserAgent.isInternetExplorer6()) {
            self.setBackgroundIframe = function (style) {
                style = Jeeel.Hash.merge({
                    top     : 'auto', // auto == .currentStyle.borderTopWidth
                    left    : 'auto', // auto == .currentStyle.borderLeftWidth
                    width   : 'auto', // auto == offsetWidth
                    height  : 'auto', // auto == offsetHeight
                    opacity : true,
                    src     : 'javascript:false;'
                }, style || {});

                var prop = function (n){return n&&n.constructor==Number?n+'px':n;},
                    html = '<iframe class="jeeel-bgiframe"frameborder="0"tabindex="-1"src="'+style.src+'"'
                         + 'style="display:block;position:absolute;z-index:-1;'
                         + (style.opacity !== false?'filter:Alpha(Opacity=\'0\');':'')
                         + 'top:'+(style.top=='auto'?'expression(((parseInt(this.parentNode.currentStyle.borderTopWidth)||0)*-1)+\'px\')':prop(style.top))+';'
                         + 'left:'+(style.left=='auto'?'expression(((parseInt(this.parentNode.currentStyle.borderLeftWidth)||0)*-1)+\'px\')':prop(style.left))+';'
                         + 'width:'+(style.width=='auto'?'expression(this.parentNode.offsetWidth+\'px\')':prop(style.width))+';'
                         + 'height:'+(style.height=='auto'?'expression(this.parentNode.offsetHeight+\'px\')':prop(style.height))+';'
                         + '"/>';

                var child = this._element.firstChild;
                var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;

                while(child) {
                    if (child.nodeType === nodeType) {
                        if (child.tagName.toUpperCase() === 'IFRAME' && child.className === 'jeeel-bgiframe') {
                            return this;
                        }
                    }

                    child = child.nextSibling;
                }

                var elm = this._doc.createElementList(html)[0];

                return this.insertTop(elm);
            };
        } else {
            self.setBackgroundIframe = function (style) {
                return this;
            };
        }
        
        var moveCash = [];
        
        function _searchMoveCashIndex(self) {
            for (var i = 0, l = moveCash.length; i < l; i++) {
                if (self._element === moveCash[i].target) {
                    return i;
                }
            }
            
            return -1;
        }
        
        self.movable = function (dispatchTargets) {
            
            var i, l, cash, index = _searchMoveCashIndex(this);
            
            if ( ! dispatchTargets) {
                dispatchTargets = [this._element];
            } else if ( ! Jeeel.Type.isArray(dispatchTargets)) {
                dispatchTargets = [dispatchTargets];
            }
            
            if (index >= 0) {
                cash = moveCash[index];
                
                for (i = 0, l = cash.dispatch.length; i < l; i++) {
                    Jeeel.Dom.Event.removeEventListener(cash.dispatch[i], Jeeel.Dom.Event.Type.MOUSE_DOWN, cash.down, this);
                }
                
                for (i = 0, l = dispatchTargets.length; i < l; i++) {
                    Jeeel.Dom.Event.addEventListener(dispatchTargets[i], Jeeel.Dom.Event.Type.MOUSE_DOWN, cash.down, this);
                }
                
                cash.dispatch = dispatchTargets;
                
                return this;
            }
            
            cash = moveCash[moveCash.length] = {
                dispatch: dispatchTargets,
                target: this._element,
                position: '',
                point: null,
                down: function (ev) {
                    ev.stop();
                    
                    this._doc.addEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, cash.move, this)
                             .addEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, cash.up, this);
                             
                    cash.point = ev.getRelativeMousePoint(this._element);
                },
                move: function (ev) {
                    ev.stop();
                    
                    var p = ev.mousePoint;
                    
                    var top  = p.y - cash.point.y;
                    var left = p.x - cash.point.x;
                    
                    this.setStyleList({
                        top: top + 'px',
                        left: left + 'px'
                    });
                },
                up: function (ev) {
                    ev.stop();
                    
                    this._doc.removeEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, cash.move)
                             .removeEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, cash.up);
                }
            };
            
            for (i = 0, l = dispatchTargets.length; i < l; i++) {
                Jeeel.Dom.Event.addEventListener(dispatchTargets[i], Jeeel.Dom.Event.Type.MOUSE_DOWN, cash.down, this);
            }

            cash.position = this.getStyle('position');
            
            this.setStyle('position', 'absolute');
            
            return this;
        };
        
        self.immovable = function () {
            
            var index = _searchMoveCashIndex(this);
            
            if (index < 0) {
                return this;
            }
            
            var cash = moveCash[index];
            
            for (var i = 0, l = cash.dispatch.length; i < l; i++) {
                Jeeel.Dom.Event.removeEventListener(cash.dispatch[i], Jeeel.Dom.Event.Type.MOUSE_DOWN, cash.down, this);
            }
            
            this.setStyle('position', cash.position);
            
            moveCash.splice(index, 1);
            
            return this;
        };
 
        delete this._init;
    }
};

Jeeel.Dom.Element.prototype._init();

Jeeel.file.Jeeel.Dom.Element = ['Abstract', 'Textarea'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Element, Jeeel.file.Jeeel.Dom.Element);

/**
 * コンストラクタ
 * 
 * @abstractClass Elementクラスの抽象クラス
 * @ignore 未完成
 */
Jeeel.Dom.Element.Abstract = function () {};

Jeeel.Dom.Element.Abstract.prototype = {

    /**
     * 対象のElement
     * 
     * @type Element
     * @protected
     */
    _element: null,

    /**
     * 内部で使用しているHTML要素を取得する
     *
     * @return {Element} HTML要素
     */
    getElement: function () {
        return this._element;
    },

    /**
     * IDを取得する
     *
     * @return {String} ID
     */
    getId: function () {
        return this._element.id;
    },

    /**
     * IDを設定する
     *
     * @param {String} id ID
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    setId: function (id) {
        this._element.id = id;

        return this;
    },

    /**
     * このElement内のクラス名を全て取得する
     *
     * @return {String[]} クラス名のリスト
     */
    getClassNames: function () {},

    /**
     * クラス名を追加する
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    addClassName: function (className) {},

    /**
     * クラス名の削除を行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    removeClassName: function (className) {},

    /**
     * クラス名が存在していたら削除し、存在していなかったら追加を行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    toggleClassName: function (className) {},

    /**
     * クラス名を消去する
     *
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    clearClassName: function () {
        this._element.className = '';

        return this;
    },

    /**
     * 指定したクラス名を保持しているかどうかを返す
     *
     * @param {String} className クラス名
     * @return {Boolean} クラス名を保持していたかどうか
     */
    hasClassName: function (className) {},

    /**
     * Nameを取得する
     *
     * @return {String} Name
     */
    getName: function () {
        return this._element.name;
    },

    /**
     * Nameを設定する
     *
     * @param {String} name Name
     * @return {this} 自インスタンス
     */
    setName: function (name) {
        this._element.name = name;

        return this;
    },

    /**
     * TagNameを取得する
     *
     * @return {String} TagName
     */
    getTagName: function () {
        return this._element.tagName;
    },

    /**
     * スタイルを取得する
     *
     * @return {CSSStyleDeclaration} スタイル
     */
    getStyle: function () {
        return this._element.style;
    },

    /**
     * イベントリスナーをセットする
     *
     * @param {String} type イベントの種類(Jeeel.Dom.Event.Type参照)
     * @param {Function} listener 登録リスナー
     * @return {this} 自インスタンス
     */
    setEvent: function (type, listener) {
        this._element['on' + type] = listener;

        return this;
    },
    
    _init: function () {
      
        if ( ! Jeeel._doc) {
            delete this._init;
            return;
        }
        
        var div = (Jeeel.Document || Jeeel._doc).createElement('div');
        var slice = Array.prototype.slice;
        
        var self = this;
        
        if (div.classList) {
            self.getClassNames = function () {
                return slice.call(this._element.classList);
            };
            
            self.addClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.add(className[i]);
                }
                
                return this;
            };
            
            self.removeClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.remove(className[i]);
                }

                return this;
            };
            
            self.toggleClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.toggle(className[i]);
                }

                return this;
            };
            
            self.hasClassName = function (className) {
                return this._element.classList.contains(className);
            };
            
        } else {
            self.getClassNames = function () {
                return this._element.className.split(' ');
            };
            
            self.addClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var ec = this._element.className;
                
                for (var i = 0, l = className.length; i < l; i++) {
                    if ( ! className[i]) {
                        continue;
                    } else if(ec === className[i] || ec.search('\\b' + className[i] + '\\b') !== -1) {
                        continue;
                    }
                    
                    ec += (ec ? ' ' : '') + className[i];
                }
                
                this._element.className = ec;
                
                return this;
            };
            
            self.removeClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var ec = this._element.className;
                
                for (var i = 0, l = className.length; i < l; i++) {
                    if ( ! className[i]) {
                        continue;
                    }
                    
                    ec = ec.replace(new RegExp('\\b' + className[i] + '\\b\\s*','g'),'');
                }
                
                this._element.className = ec.replace(/\s+$/g, '');
                
                return this;
            };
            
            self.toggleClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }

                var classNames = this.getClassNames();

                for (var i = 0, l = className.length; i < l; i++) {
                    if (Jeeel.Type.inArray(className[i], classNames, true)) {
                        this.removeClassName(className[i]);
                    } else {
                        this.addClassName(className[i]);
                    }
                }

                return this;
            };
            
            self.hasClassName = function (className) {
                if ( ! className) {
                    return false;
                }
                
                var ec = this._element.className;
                
                return ec === className
                    || ec.search('\\b' + className + '\\b') !== -1;
            };
        }
        
        delete this._init;
    }
};

Jeeel.Dom.Element.Abstract.prototype._init();

/**
 * コンストラクタ
 *
 * @class テキストエリアを使いやすくするラッパークラス
 * @augments Jeeel.Dom.Element.Abstract
 * @param {Element} textarea テキストエリア
 * @ignore 未完成
 */
Jeeel.Dom.Element.Textarea = function (textarea) {
    Jeeel.Dom.Element.Abstract.call(this);
    
    this._element = textarea;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Element} textarea テキストエリア
 * @return {Jeeel.Dom.Element.Textarea} 作成したインスタンス
 */
Jeeel.Dom.Element.Textarea.create = function (textarea) {
    return new this(textarea);
};

Jeeel.Dom.Element.Textarea.prototype = {
  
    /**
     * テキストエリア内の文字列を得る
     *
     * @return {String} 取得した文字列
     */
    getText: function () {
        return this._element.value;
    },

    /**
     * テキストエリア内の文字列を設定する
     *
     * @param {String} text セットする文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    setText: function (text) {
        this._element.value = text;

        return this;
    },

    /**
     * テキストエリア内の文字列を前方検索する
     *
     * @param {String} search 検索文字列
     * @param {Integer} [from] 検索開始位置
     * @return {Integer} 検索結果(見つかった文字列の最初の位置見つからない場合は-1)
     */
    indexOf: function (search, from) {
        return this.getText().indexOf(search, from);
    },

    /**
     * テキストエリア内の文字列を後方検索する
     *
     * @param {String} search 検索文字列
     * @param {Integer} [from] 検索開始位置
     * @return {Integer} 検索結果(見つかった文字列の最初の位置見つからない場合は-1)
     */
    lastIndexOf: function (search, from) {
        return this.getText().lastIndexOf(search, from);
    },

    /**
     * テキストエリア内の文字列を置き換えたものを得る
     *
     * @param {RegExp} regexp 検索表現
     * @param {String} text 置き換える文字列
     * @return {String} 置き換え後の文字列
     */
    replace: function (regexp, text) {
        return this.getText().replace(regexp, text);
    },

    /**
     * テキストエリアの選択している開始位置を取得する
     *
     * @return {Integer} 選択している開始位置
     */
    getSelectionStart: function () {
        var start;

        if (Jeeel.UserAgent.isInternetExplorer()) {
            start = this._getIeSelection().start;
        } else {
            start = this._element.selectionStart;
        }

        return start;
    },

    /**
     * テキストエリアの選択している開始位置を設定する
     *
     * @param {Integer} start 設定開始位置
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    setSelectionStart: function (start) {
        this._element.selectionStart = start;

        return this;
    },

    /**
     * テキストエリアの選択している終了位置を取得する
     *
     * @return {Integer} 選択している終了位置
     */
    getSelectionEnd: function () {
        var end;

        if (Jeeel.UserAgent.isInternetExplorer()) {
            end = this._getIeSelection().end;
        } else {
            end = this._element.selectionEnd;
        }

        return end;
    },

    /**
     * テキストエリアの選択している終了位置を設定する
     *
     * @param {Integer} end 設定終了位置
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    setSelectionEnd: function (end) {
        this._element.selectionEnd = end;

        return this;
    },

    /**
     * テキストエリアの選択している終了位置を取得する
     *
     * @return {Integer} 選択している終了位置
     */
    getSelectionLength: function () {
        return this.getSelectionEnd() - this.getSelectionStart();
    },

    /**
     * テキストエリアの選択文字列を取得する
     *
     * @return {String} 選択文字列
     */
    getSelectedText: function () {
        var start = this.getSelectionStart();
        var end   = this.getSelectionEnd();

        var baseText = this.getText();

        return baseText.substring(start, end);
    },

    /**
     * テキストエリアの選択文字列を設定する
     *
     * @param {String} text 選択文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    setSelectedText: function (text) {
        var start = this.getSelectionStart();
        var end   = this.getSelectionEnd();

        this.replaceTo(start, end, text);

        this.setSelectionStart(start + text.length);
        this.setSelectionEnd(start + text.length);
    },

    /**
     * 指定した位置の文字列を指定文字列で置き換える
     *
     * @param {Integer} start 開始位置
     * @param {Integer} end 終了位置
     * @param {String} text 置き換える文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    replaceTo: function (start, end, text) {
        var baseText = this.getText();
        var length   = baseText.length;

        var aboveTxt = baseText.substr(0, start);
        var postTxt  = baseText.substr(end, length);

        this._element.value = aboveTxt + text + postTxt;

        return this;
    },

    /**
     * 現在選択している文字列の開始位置、または現在のカーソル位置に文字列を挿入する
     *
     * @param {String} text 挿入文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    insert: function (text) {
        var index = this.getSelectionStart();

        return this.insertTo(index, text);
    },

    /**
     * 指定した位置に文字列を挿入する
     *
     * @param {Integer} index 挿入位置
     * @param {String} text 挿入文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    insertTo: function (index, text) {
        var baseText = this.getText();
        var length   = baseText.length;

        var aboveTxt = baseText.substr(0, index);
        var postTxt  = baseText.substr(index, length);

        this._element.value = aboveTxt + text + postTxt;

        return this;
    },

    _getIeSelection: function () {
        this._element.focus();
        var range = Jeeel._doc.selection.createRange();
        var clone = range.duplicate();

        clone.moveToElementText(this._element);
        clone.setEndPoint('EndToEnd', range);
        
        var pos ={};

        pos.start = clone.text.length - range.text.length;
        pos.end = clone.text.length - range.text.length + range.text.length;
        
        return pos;
    }
};

Jeeel.Class.extend(Jeeel.Dom.Element.Textarea, Jeeel.Dom.Element.Abstract);

/**
 * コンストラクタ
 *
 * @class 複数のElementを一度に操作する特殊なクラス
 * @param {Hash} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
 */
Jeeel.Dom.ElementOperator = function (elementList) {
    elementList = this.constructor._flat(elementList);
    
    for (var i = 0, l = elementList.length; i < l; i++) {
        this[i] = elementList[i];
        elementList[i] = new Jeeel.Dom.Element(elementList[i]);
    }
    
    var self = this;

    self._elementList = elementList;
    self.length = elementList.length;

    if (arguments[1] instanceof this.constructor) {
        self._prev = arguments[1];
    }
};

/**
 * インスタンスを作成する
 *
 * @param {Hash} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
 * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
 */
Jeeel.Dom.ElementOperator.create = function (elementList) {
    return new this(elementList, arguments[1]);
};

/**
 * Elementのリスト上になるように成形する
 *
 * @param {Hash} elementList 元の要素
 * @return {Element[]} 変形後の要素
 * @protected
 */
Jeeel.Dom.ElementOperator._flat = (function (elementList) {
    var f = new Jeeel.Filter.Array.Unique(true, true);
    
    return function (elementList) {
        var res = this._flatExec(elementList);

        return f.filter(res);
    };
})();

/**
 * Jeeel.Dom.ElementOperator._flatで使用する内部メソッド
 *
 * @param {Hash} elementList 元の要素
 * @return {Element[]} 変形後の要素
 * @protected
 */
Jeeel.Dom.ElementOperator._flatExec = function (elementList) {

    if (Jeeel.Type.isElement(elementList)) {
        return [elementList];
    }
    else if (elementList instanceof this) {
        return elementList.getAll();
    }
    else if (elementList instanceof Jeeel.Dom.Element) {
        return [elementList.getElement()];
    }
    else if (elementList instanceof Jeeel.Net.Submit) {
        return [elementList.getForm()];
    }
    else if ( ! Jeeel.Type.isHash(elementList)) {
        return [];
    }
    else if ( ! Jeeel.Type.isArray(elementList)) {
        elementList = Jeeel.Hash.getValues(elementList);
    }

    var res = [];

    for (var i = 0, l = elementList.length; i < l; i++) {
        if (Jeeel.Type.isElement(elementList[i])) {
            res[res.length] = elementList[i];
        } else if (Jeeel.Type.isHash(elementList[i])) {
            var tmp = this._flatExec(elementList[i]);
            res = res.concat(tmp);
        }
    }

    return res;
};

Jeeel.Dom.ElementOperator.prototype = {

    /**
     * 絞り込みを掛ける前のインスタンス
     * 
     * @type Jeeel.Dom.ElementOperator
     * @protected
     */
    _prev: null,

    /**
     * 基となるElement(この操作モジュールを保持するElement)
     *
     * @type Jeeel.Dom.Element[]
     * @protected
     */
    _elementList: [],

    /**
     * 現在操作している要素数
     * 
     * @type Integer
     * @readOnly
     */
    length: 0,

    /**
     * 指定したインデックスの要素を取得する
     *
     * @param {Integer} index インデックス(負の数を指定すると後ろから参照する)
     * @return {Element} 取得要素
     */
    get: function (index) {
        if ( ! Jeeel.Type.isInteger(index) || this.length <= index) {
            return null;
        }

        if (0 > index) {
            index = this.length + index;
        }

        return this[index] || null;
    },

    /**
     * 全要素を取得する
     *
     * @return {Element[]} 全要素のリスト
     */
    getAll: function () {
        var res = [];
        
        for (var i = 0; i < this.length; i++) {
            res[i] = this[i];
        }
        
        return res;
    },

    /**
     * 指定したElementに対応するインデックスを取得する
     *
     * @param {Element} element 検索Element
     * @return {Integer} インデックス(見つからない場合は-1)
     */
    getIndex: function (element) {
        var res = -1;
        
        for (var i = 0; i < this.length; i++) {
            if (this[i] === element) {
                res = i;
            }
        }

        return res;
    },

    /**
     * 操作対象に新規にElementを追加する
     *
     * @param {Hash} element 追加するElementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    add: function (element) {
        element = this.constructor._flat(element);

        var skip = 0;

        for (var i = 0, l = element.length; i < l; i++) {

            var brk = false;

            for (var j = 0; j < this.length; j++) {
                if (element[i] === this[j]) {
                    skip++;
                    brk = true;
                    break;
                }
            }

            if (brk) {
                continue;
            }

            this[this.length + i - skip] = element[i];
            var tmp = new Jeeel.Dom.Element(element[i]);
            
            this._elementList[this._elementList.length] = tmp;
        }

        this.length = this._elementList.length;

        return this;
    },

    /**
     * 絞り込み動作を行う前の要素を操作対象に追加する
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    andSelf: function () {
        return this.add(this._prev);
    },

    /**
     * 直前の絞り込み動作を行う前の状態のインスタンスを返す
     *
     * @return {Jeeel.Dom.ElementOperator} 直前のインスタンス(ない場合は要素が空のインスタンス)
     */
    end: function () {
        return (this._prev ? this._prev : this.constructor.create());
    },

    /**
     * 指定要素の子リストにElementを追加する
     *
     * @param {Element} child 追加Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    appendChild: function (child, index) {
        if ( ! index) {
            index = 0;
        } else if ( ! (index in this._elementList)) {
            return this;
        }

        this._elementList[index].appendChild(this.constructor._flat(child));

        return this;
    },

    /**
     * 指定要素の子リストからElementを取り除く
     *
     * @param {Element} child 削除Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeChild: function (child, index) {
        if ( ! index) {
            index = 0;
        } else if ( ! (index in this._elementList)) {
            return this;
        }

        this._elementList[index].removeChild(this.constructor._flat(child));

        return this;
    },
    
    /**
     * 全ての要素の子供を全て削除する
     *
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    clearChildNodes: function () {
        return this._callMethod('clearChildNodes');
    },

    /**
     * 全ての要素それぞれを指定Elementで囲う<br />
     * それぞれを囲うElementはコピーされる
     *
     * @param {String|Element} wrapElement 囲いElement(Jeeel.Dom.ElementOperatorやJeeel.Dom.Elementでも可能)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @ignore
     */
    wrap: function (wrapElement) {
      
        if (Jeeel.Type.isString(wrapElement)) {
            wrapElement = Jeeel.Document.createElementList(wrapElement);
        }

        wrapElement = this.constructor._flat(wrapElement)[0];

        return this._callMethod('wrapSelf', [wrapElement]);
    },
    
    /**
     * 指定要素のIDを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} ID
     */
    getId: function (index) {
        return this._getCall(index, 'getId');
    },
    
    /**
     * IDを指定要素に設定する
     *
     * @param {String} id ID
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setId: function (id, index) {
        if ( ! index) {
            index = 0;
        } else if ( ! (index in this._elementList)) {
            return this;
        }
        
        this._elementList[index].setId(id);

        return this;
    },
    
    /**
     * 指定要素のNameを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} Name
     */
    getName: function (index) {
        return this._getCall(index, 'getName');
    },
    
    /**
     * Nameを全ての要素に設定する
     *
     * @param {String} name Name
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setName: function (name) {
        return this._callMethod('setName', [name]);
    },
    
    /**
     * 指定要素のTagNameを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} Name
     */
    getTag: function (index) {
        return this._getCall(index, 'getTagName');
    },

    /**
     * 指定要素のクラス名のリストを全て取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String[]} クラス名リスト
     */
    getClass: function (index) {
        return this._getCall(index, 'getClassNames') || [];
    },

    /**
     * クラス名を全ての要素に追加する
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addClass: function (className) {
        return this._callMethod('addClassName', [className]);
    },

    /**
     * 指定したクラス名を全ての要素から取り除く
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeClass: function (className) {
        return this._callMethod('removeClassName', [className]);
    },

    /**
     * 指定したクラス名が存在していたら削除し、<br />
     * 存在していなかったら追加を全ての要素に対して行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    toggleClass: function (className) {
        return this._callMethod('toggleClassName', [className]);
    },

    /**
     * 全ての要素のクラス名を消去する
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    clearClass: function () {
        return this._callMethod('clearClassName');
    },

    /**
     * 指定要素から属性取得する
     *
     * @param {String} attribute 属性名
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} 属性値
     */
    getAttr: function (attribute, index) {
        return this._getCall(index, 'getAttribute', [attribute]);
    },

    /**
     * 属性値を全ての要素に設定する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setAttr: function (attribute, value) {
        return this._callMethod('setAttribute', [attribute, value]);
    },
    
    /**
     * 属性値を全ての要素から削除する
     *
     * @param {String} attribute 属性名
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeAttr: function (attribute) {
        return this._callMethod('removeAttribute', [attribute]);
    },

    /**
     * 指定要素からプロパティを取得する
     *
     * @param {String} property プロパティ名
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Mixied} プロパティ値
     */
    getProp: function (property, index) {
        return this._getCall(index, 'getProperty', [property]);
    },

    /**
     * プロパティを全ての要素に設定する
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value プロパティ値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setProp: function (property, value) {
        return this._callMethod('setProperty', [property, value]);
    },

    /**
     * 指定要素からスタイルを取得する
     *
     * @param {String} css スタイル名
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} スタイル値
     */
    getCss: function (css, index) {
        return this._getCall(index, 'getStyle', [css]);
    },

    /**
     * スタイルを全ての要素に設定する
     *
     * @param {String} css スタイル名
     * @param {String} value スタイル値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setCss: function (css, value) {
        return this._callMethod('setStyle', [css, value]);
    },
    
    /**
     * 複数のスタイルを全ての要素に設定する
     *
     * @param {Hash} cssList スタイル名と値のペアリスト
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setCssList: function (cssList) {
        return this._callMethod('setStyleList', [cssList]);
    },
    
    /**
     * 指定要素から不透明度を取得する
     * 
     * @return {Number} 不透明度(0.0～1.0)
     */
    getOpac: function (index) {
        return this._getCall(index, 'getOpacity');
    },
    
    /**
     * 不透明度を全ての要素に設定する
     * 
     * @param {Number} opacity 不透明度(0.0～1.0)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setOpac: function (opacity) {
        return this._callMethod('setOpacity', [opacity]);
    },
    
    /**
     * 指定要素の左上絶対軸座標を返す
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Object.Point} 左上の座標
     */
    getPos: function (index) {
        return this._getCall(index, 'getPosition');
    },
    
    /**
     * 指定要素のサイズを取得する
     * 
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Object.Size} サイズ
     */
    getSize: function (index) {
        return this._getCall(index, 'getSize');
    },
    
    /**
     * 指定要素の左上絶対座標とサイズを併せ持った構造体を取得する
     * 
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Object.Rect} レクト
     */
    getRect: function (index) {
        return this._getCall(index, 'getRect');
    },

    /**
     * 指定要素のinnerHTMLを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} 取得HTML
     */
    getHtml: function (index) {
        return this._getCall(index, 'getHtml');
    },

    /**
     * 全ての要素のinnerHTMLに指定HTMLを書き込む
     *
     * @param {String} html 設定HTML
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setHtml: function (html) {
        return this._callMethod('setHtml', [html]);
    },

    /**
     * 指定要素のTextを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} 取得Text
     */
    getText: function (index) {
        return this._getCall(index, 'getText');
    },

    /**
     * 全ての要素にTextを書き込む<br />
     * その際innerHtmlが書き変わる
     *
     * @param {String} text 設定Text
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setText: function (text) {
        return this._callMethod('setText', [text]);
    },

    /**
     * 指定要素のvalueを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Mixied} 取得value
     */
    getVal: function (index) {
        return this.getProp('value', index);
    },

    /**
     * 全ての要素のvalueを取得する
     *
     * @return {Array} 取得value
     */
    getValAll: function () {
        var res = [];

        for (var i = 0; i < this.length; i++) {
            res[i] = this.getVal(i);
        }

        return res;
    },

    /**
     * 全ての要素のvalueに指定HTMLを書き込む
     *
     * @param {Mixied} value 設定値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setVal: function (value) {
        return this.setProp('value', value);
    },

    /**
     * 指定要素の内部に含まれているInputのリストを返す<br />
     * 名前が指定されており、送信される状態の要素のみ対象になる
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Hash} input,select,button,textareaのリスト(キーはそれぞれのname)
     */
    getInput: function (index) {},

    /**
     * 指定要素の内部に含まれているInput値のリストを返す<br />
     * 名前が指定されており、送信される状態の要素のみ対象になる
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Hash} input,select,button,textareaのリスト(キーはそれぞれのname)
     */
    getInputVal: function (index) {},
    
    /**
     * 全ての要素のElementの共通の親を返す<br />
     * ただし全てがDom上に存在しないと正しい値は取れない
     * 
     * @return {Node} 共通の親最上階層はDocument(Dom上に存在しない要素が居た場合はnullを返す)
     */
    getCommonParent: function () {},
    
    /**
     * 指定したクラス名を持つ要素のみを新規にインスタンス作成して返す
     *
     * @param {String|String[]} className 許可クラスリストもしくは許可クラス
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterClass: function (className) {
      
        if ( ! Jeeel.Type.isArray(className)) {
            className = [className];
        }

        var res = this._each(
            function () {
                var tmp = this.getClassNames();

                for (var i = 0, l = tmp.length; i < l; i++) {
                    if (Jeeel.Type.inArray(tmp[i], className)) {
                        return this;
                    }
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した名前の要素のみを新規にインスタンス作成して返す
     *
     * @param {String|String[]} name 許可名リストもしくは許可名
     * @param {Boolean} [submitSearch] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか(初期値はfalse)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterName: function (name, submitSearch) {},
    
    /**
     * 指定したタグの要素のみを新規にインスタンス作成して返す
     *
     * @param {String|String[]} tag 許可タグリストもしくは許可タグ
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterTag: function (tag) {
      
        if ( ! Jeeel.Type.isArray(tag)) {
            tag = [tag];
        }

        var res = this._each(
            function () {
                var tmp = this.getTagName();

                if (Jeeel.Type.inArray(tmp, tag)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 指定した属性がある値の要素のみを新規にインスタンス作成して返す
     *
     * @param {String} attribute 属性名
     * @param {String|String[]} value 許可値リストもしくは許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterAttr: function (attribute, value) {
        
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
      
        var res = this._each(
            function () {
                var tmp = this.getAttribute(attribute);

                if (Jeeel.Type.inArray(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 指定したプロパティがある値の要素のみを新規にインスタンス作成して返す
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value 許可値リストもしくは許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterProp: function (property, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getProperty(property);

                if (Jeeel.Type.inArray(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定したスタイルがある値の要素のみを新規にインスタンス作成して返す
     *
     * @param {String} css スタイル名
     * @param {String|String[]} value 許可値リストもしくは許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterCss: function (css, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getStyle(css);

                if (Jeeel.Type.inArray(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した範囲検索ひヒットした要素のみを新規にインスタンス作成して返す
     *
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {Function} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     * @see Jeeel.Dom.SearchOption
     */
    filterRange: function (rect, option) {
        var res = [], trect;
        
        if ( ! option) {
            option = Jeeel.Dom.SearchOption.RANGE_OVERLAY;
        }
      
        var res = this._each(
            function () {
                trect = this.getRect();

                if (option(rect, trect)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した要素のみを新規にインスタンス作成して返す
     *
     * @param {Hash} element 許可Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterElement: function (element) {
        element = this.constructor._flat(element);
        
        var res = [];
        
        for (var i = 0; i < this.length; i++) {
            if (Jeeel.Type.inArray(this[i], element)) {
                res[res.length] = this[i];
            }
        }

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定したクラス名を持つ要素を全て取り除き新規にインスタンス作成して返す
     *
     * @param {String|String[]} className 非許可クラスリストもしくは非許可クラス
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterClass: function (className) {
      
        if ( ! Jeeel.Type.isArray(className)) {
            className = [className];
        }

        var res = this._each(
            function () {
                var tmp = this.getClassNames();

                for (var i = 0, l = tmp.length; i < l; i++) {
                    if ( ! Jeeel.Type.inArray(tmp[i], className)) {
                        return this;
                    }
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した名前の要素を全て取り除き新規にインスタンス作成して返す
     *
     * @param {String|String[]} name 非許可名リストもしくは非許可名
     * @param {Boolean} [submitSearch] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか(初期値はfalse)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterName: function (name, submitSearch) {},
    
   /**
     * 指定したタグの要素を全て取り除き新規にインスタンス作成して返す
     *
     * @param {String|String[]} tag 許可タグリストもしくは許可タグ
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterTag: function (tag) {
      
        if ( ! Jeeel.Type.isArray(tag)) {
            tag = [tag];
        }

        var res = this._each(
            function () {
                var tmp = this.getTagName();

                if ( ! Jeeel.Type.inArray(tmp, tag)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 指定した属性がある値の要素を全て取り除き新規にインスタンスを作成して返す
     *
     * @param {String} attribute 属性名
     * @param {String|String[]} value 非許可値リストもしくは非許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterAttr: function (attribute, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getAttribute(attribute);

                if ( ! Jeeel.Type.inArray(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 指定したプロパティがある値の要素を全て取り除き新規にインスタンスを作成して返す
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value 非許可値リストもしくは非許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterProp: function (property, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getProperty(property);

                if ( ! Jeeel.Type.inArray(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定したスタイルがある値の要素を全て取り除き新規にインスタンスを作成して返す
     *
     * @param {String} css スタイル名
     * @param {String|String[]} value 非許可値リストもしくは非許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterCss: function (css, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getStyle(css);

                if ( !  Jeeel.Type.inArray(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した範囲検索ヒットした要素を全て取り除き新規にインスタンスを作成して返す
     *
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {Function} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     * @see Jeeel.Dom.SearchOption
     */
    revFilterRange: function (rect, option) {
        var res = [], trect;
        
        if ( ! option) {
            option = Jeeel.Dom.SearchOption.RANGE_OVERLAY;
        }
      
        var res = this._each(
            function () {
                trect = this.getRect();

                if ( ! option(rect, trect)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した要素を全て取り除き新規にインスタンス作成して返す
     *
     * @param {Hash} element 非許可Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterElement: function (element) {
        element = this.constructor._flat(element);

        var res = this._each(
            function () {
                var tmp = this.getElement();

                if ( ! Jeeel.Type.inArray(tmp, element)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * インデックスが偶数の要素のみを纏めて新規インスタンスとして返す
     *
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterEven: function () {
        var res = this._each(
            function (val, key) {

                if ((key & 1) === 1) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * インデックスが奇数の要素のみを纏めて新規インスタンスとして返す
     *
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterOdd: function () {
        var res = this._each(
            function (val, key) {

                if ((key & 1) === 0) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定したインデックスの要素を対象にElementラッパーを作成する
     *
     * @param {Integer} index インデックス(負の数を指定すると後ろから参照する)
     * @return {Jeeel.Dom.ElementOperator} 取得したElementラッパー
     */
    $GET: function (index) {
        return this.constructor.create(this.get(index), this);
    },

    /**
     * 全要素内の指定名のinput要素を対象にElementラッパーを作成する<br />
     * 名前が指定されており、送信される状態の要素のみ対象になる
     *
     * @param {String} [name] 名前を指定する場合は指定する
     * @return {Jeeel.Dom.ElementOperator} 取得したElementラッパー
     */
    $INPUT: function (name) {

        var res = [];

        for (var i = 0; i < this.length; i++) {
            var tmp = this.getInput(i);

            if (name) {
                tmp = tmp[name];
            }

            tmp = this.constructor._flat(tmp);
            res = res.concat(tmp);
        }

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定IDのHTML要素を取得する
     *
     * @param {String} id 検索ID
     * @return {Jeeel.Dom.ElementOperator} 取得したElementラッパー(取得できなかった場合はnull)
     */
    $ID: function (id) {
        if ( ! id) {
            return null;
        }

        var res = null;

        this._each(
            function () {
                var tmp = this.getElementById(id);

                if (tmp) {
                    res = tmp;
                    return Jeeel.Hash.FOR_EACH_EXIT;
                }
            }
        );

        return res && this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定ClassのHTML要素を取得する
     *
     * @param {String|String[]} className 検索Class
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $CLASS: function (className) {
        if ( ! className) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByClassName(className);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定NameのHTML要素を取得する
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする
     *
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか(初期値はfalse)
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $NAME: function (name, submitSearch) {
        if ( ! name) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByName(name, submitSearch);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定TagのHTML要素を取得する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $TAG: function (tagName) {
        if ( ! tagName) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByTagName(tagName);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定属性が指定値のHTML要素を取得する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $ATTR: function (attribute, value) {
        if ( ! attribute) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByAttribute(attribute, value);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定プロパティが指定値のHTML要素を取得する<br />
     * Elementのプロパティである事に注意
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value 指定値('*'を指定すると任意の値の意味になる)
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $PROP: function (property, value) {
        if ( ! property) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByProperty(property, value);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 全ての要素の子リストからHTML要素を指定範囲検索する
     *
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {String} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Jeeel.Dom.ElementOperator} 範囲検索に引っかかったElement配列ラッパー
     * @see Jeeel.Dom.SearchOption
     */
    $RANGE: function (rect, option) {
        if ( ! rect) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.searchElementsByRange(rect, option);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素内にforeachをかける<br />
     * その際foreachに渡される値はJeeel.Dom.ElementOperator型となる<br />
     * 詳しくはJeeel.Hash.forEach参照
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Hash.forEach
     */
    $EACH: function (eachMethod, thisArg) {
        var res = [];
        
        for (var i = 0; i < this.length; i++) {
            res[i] = new this.constructor(this[i]);
        }

        Jeeel.Hash.forEach(res, eachMethod, thisArg);
        
        return this;
    },

    /**
     * 全ての要素内にforeachをかける<br />
     * その際foreachに渡される値はElement型となる<br />
     * 詳しくはJeeel.Hash.forEach参照
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Hash.forEach
     */
    each: function (eachMethod, thisArg) {
        Jeeel.Hash.forEach(this.getAll(), eachMethod, thisArg);
        
        return this;
    },

    /**
     * 全ての要素をDom上から取り除く
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    remove: function () {
        return this._callMethod('remove');
    },

    /**
     * 全ての要素を隠す
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    hide: function () {
        return this._callMethod('hide');
    },

    /**
     * 全ての要素を表示する
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    show: function () {
        return this._callMethod('show');
    },
    
    /**
     * 全ての要素の表示状態を切り替える
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    toggle: function () {
        return this._callMethod('toggle');
    },
     
    /**
     * 全ての要素を有効にする
     * 
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    enable: function () {
        return this._callMethod('enable');
    },
    
    /**
     * 全ての要素を無効にする
     * 
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    disable: function () {
        return this._callMethod('disable');
    },
    
    /**
     * 全ての要素を指定座標に移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    shiftTo: function (x, y) {
        return this._callMethod('shiftTo', [x, y]);
    },

    /**
     * 全ての要素にクリックイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addClick: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.CLICK, callback, thisArg);
    },
    
    /**
     * 全ての要素にマウスダウンイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addMouseDown: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_DOWN, callback, thisArg);
    },
    
    /**
     * 全ての要素にマウスアップイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addMouseUp: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_UP, callback, thisArg);
    },
    
    /**
     * 全ての要素にマウスムーブイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addMouseMove: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_MOVE, callback, thisArg);
    },

    /**
     * 全ての要素にロードイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addLoad: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.LOAD, callback, thisArg);
    },

    /**
     * 全ての要素にマウスオーバーイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addOver: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_OVER, callback, thisArg);
    },

    /**
     * 全ての要素にマウスアウトイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addOut: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_OUT, callback, thisArg);
    },

    /**
     * 全ての要素にマウスホバーイベントの登録をする
     *
     * @param {Function} overCallback マウスオーバーイベントコールバック
     * @param {Function} outCallback マウスアウトイベントのコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addHover: function (overCallback, outCallback, thisArg) {

        this.addOver(overCallback, thisArg);
        return this.addOut(outCallback, thisArg);
    },
    
    /**
     * 全ての要素にイベントの登録をする
     *
     * @param {String} type イベントタイプ
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addEvent: function (type, callback, thisArg) {
        var thisArgVal = thisArg;
        
        this._each(
            function () {
                if ( ! Jeeel.Type.isSet(thisArg)) {
                    thisArgVal = Jeeel.Dom.ElementOperator.create(this);
                }
                
                this.addEventListener(type, callback, thisArgVal);
            }
        );

        return this;
    },

    /**
     * 全ての要素からクリックイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeClick: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.CLICK, callback);
    },
    
    /**
     * 全ての要素からマウスダウンイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeMouseDown: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_DOWN, callback);
    },
    
    /**
     * 全ての要素からマウスアップイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeMouseUp: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_UP, callback);
    },
    
    /**
     * 全ての要素からマウスムーブイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeMouseMove: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_MOVE, callback);
    },

    /**
     * 全ての要素からロードイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeLoad: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.LOAD, callback);
    },

    /**
     * 全ての要素からマウスオーバーイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeOver: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_OVER, callback);
    },

    /**
     * 全ての要素からマウスアウトイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeOut: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_OUT, callback);
    },

    /**
     * 全ての要素からマウスホバーイベントを削除する
     *
     * @param {Function} overCallback マウスオーバーイベントコールバック
     * @param {Function} outCallback マウスアウトイベントのコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeHover: function (overCallback, outCallback) {

        this.removeOver(overCallback);
        return this.removeOut(outCallback);
    },
    
    /**
     * 全ての要素からイベントを削除する
     *
     * @param {String} type イベントタイプ
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeEvent: function (type, callback) {
        return this._callMethod('removeEventListener', [type, callback]);
    },
    
    /**
     * 全ての要素に対してのイベントを上位Elementに委譲して登録を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    delegate: function (type, callback, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        Jeeel.Dom.Event.delegate(this, type, callback, thisArg);
        
        return this;
    },
    
    /**
     * 全ての要素に対してのイベントを上位Elementに委譲してたものの削除を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    undelegate: function (type, callback) {
        Jeeel.Dom.Event.undelegate(this, type, callback);

        return this;
    },
     
    /**
     * このElementに設定されているイベントを任意のタイミングで実行する
     *
     * @param {String} type イベントタイプ
     * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
     * @ignore 未完成
     */
    dispatchEvent: function (type, option) {
        return this._callMethod('dispatchEvent', [type, option]);
    },
    
    /**
     * このインスタンスの複製を作る
     *
     * @return {Jeeel.Dom.ElementOperator} 複製したインスタンス
     */
    clone: function () {
        return this.constructor.create(this._elementList, this._prev);
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Hash} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @constructor
     */
    constructor: Jeeel.Dom.ElementOperator,
    
    /**
     * メソッドの内部呼び出しを行う
     * 
     * @param {String} methodName メソッド名
     * @param {Array} [args] 引数を指定する場合に渡す
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @private
     */
    _callMethod: function (methodName, args) {
        this._each(
            function () {
                this[methodName].apply(this, args || []);
            }
        );

        return this;
    },
    
    /**
     * 戻り値を持ったメソッドの内部呼び出しを行う
     * 
     * @param {Integer} index 要素Index
     * @param {String} methodName メソッド名
     * @param {Array} [args] 引数を指定する場合に渡す
     * @return {Mixied} 戻り値
     * @private
     */
    _getCall: function (index, methodName, args) {
        if ( ! index) {
            index = 0;
        }
        
        if ( ! (index in this._elementList)) {
            return null;
        }
        
        var elm = this._elementList[index];
        
        return elm[methodName].apply(elm, args || []);
    },

    /**
     * 内部的にforeachを掛ける
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Hash} コールバックメソッド中に返した戻り値の配列
     * @private
     */
    _each: function (eachMethod, thisArg) {
        var tmp, res = [];
        
        var exit = Jeeel.Hash.FOR_EACH_EXIT;
        
        for (var i = 0, l = this.length; i < l; i++) {
            
            tmp = eachMethod.call(this._elementList[i], this._elementList[i], i);
            
            if (tmp === exit) {
                break;
            }
            
            res[res.length] = tmp;
        }
        
        return res;
    },
    
    _init: function () {
        var ief = new Jeeel.Filter.Html.Form(),
            ivf = new Jeeel.Filter.Html.FormValue(),
            ref = new Jeeel.Filter.RegularExpressionEscape(),
            auf = new Jeeel.Filter.Array.Unique(true, true);
        
        this.filterName = function (name, submitSearch) {
            if ( ! Jeeel.Type.isArray(name)) {
                name = [name];
            }

            var res;

            if (submitSearch) {
                for (var i = name.length; i--;) {
                    name[i] = new RegExp('^' + ref.filter(name[i]) + '(?:$|\\[)');
                }

                res = this._each(
                    function () {
                        var tmp = this.getName();

                        for (var i = name.length; i--;) {
                            if (tmp.match(name[i])) {
                                return this;
                            }
                        }
                    }
                );
            } else {
                res = this._each(
                    function () {
                        var tmp = this.getName();

                        if (Jeeel.Type.inArray(tmp, name)) {
                            return this;
                        }
                    }
                );
            }

            return this.constructor.create(res, this);
        };
        
        this.revFilterName = function (name, submitSearch) {
            if ( ! Jeeel.Type.isArray(name)) {
                name = [name];
            }

            var res;

            if (submitSearch) {
                for (var i = name.length; i--;) {
                    name[i] = new RegExp('^' + ref.filter(name[i]) + '(?:$|\\[)');
                }

                res = this._each(
                    function () {
                        var tmp =this.getName();

                        for (var i = name.length; i--;) {
                            if ( ! tmp.match(name[i])) {
                                return this;
                            }
                        }
                    }
                );
            } else {
                res = this._each(
                    function () {
                        var tmp = this.getName();

                        if ( ! Jeeel.Type.inArray(tmp, name)) {
                            return this;
                        }
                    }
                );
            }

            return this.constructor.create(res, this);
        };
        
        this.getInput = function (index) {
            if ( ! index) {
                index = 0;
            } else if ( ! (index in this._elementList)) {
                return {};
            }

            return ief.filter(this[index]);
        };
        
        this.getInputVal = function (index) {
            if ( ! index) {
                index = 0;
            } else if ( ! (index in this._elementList)) {
                return {};
            }

            return ivf.filter(this[index]);
        };
        
        this.getCommonParent = function () {
            var elms = this._elementList,
                min = -1,
                hirs = [],
                args = [],
                p, i, l;

            for (i = elms.length; i--;) {
                hirs[i] = elms[i].getHierarchy();

                if (min < 0 || min > hirs[i]) {
                    min = hirs[i];
                }
            }

            for (i = elms.length; i--;) {
                args[i] = elms[i].getParentNode(hirs[i] - min);
            }

            args = auf.filter(args);
            
            l = args.length;

            while(l > 1) {

                for (i = l; i--;) {
                    p = args[i].parentNode;

                    if (args[i].ownerDocument && ! p) {
                        return null;
                    }

                    args[i] = p;
                }

                args = auf.filter(args);
                
                l = args.length;
            }

            return args[0];
        };
        
        delete this._init;
    }
};

Jeeel.Dom.ElementOperator.prototype._init();
/**
 * 特殊検索に使用する列挙体
 */
Jeeel.Dom.SearchOption = {
    /**
     * 範囲に重なるものが対象
     * 
     * @param {Jeeel.Object.Rect} rect 検索範囲
     * @param {Jeeel.Object.Rect} targettRect 要素の範囲
     * @return {Boolean} 要素が検索範囲にマッチしたかどうか
     * @constant
     */
    RANGE_OVERLAY: function (rect, targettRect) {
        var s = rect.startPoint, e = rect.endPoint;
        var ts = targettRect.startPoint, te = targettRect.endPoint;

        return ! (ts.x <= s.x && te.x <= s.x || ts.x >= e.x && te.x >= e.x) && 
               ! (ts.y <= s.y && te.y <= s.y || ts.y >= e.y && te.y >= e.y);
    },
    
    /**
     * 範囲の内側にあるものが対象
     * 
     * @param {Jeeel.Object.Rect} rect 検索範囲
     * @param {Jeeel.Object.Rect} targettRect 要素の範囲
     * @return {Boolean} 要素が検索範囲にマッチしたかどうか
     * @constant
     */
    RANGE_INSIDE: function (rect, targettRect) {
        var s = rect.startPoint, e = rect.endPoint;
        var ts = targettRect.startPoint, te = targettRect.endPoint;

        return (s.x <= ts.x && ts.x <= e.x && s.x <= te.x && te.x <= e.x) &&
               (s.y <= ts.y && ts.y <= e.y && s.y <= te.y && te.y <= e.y);
    }
};Jeeel.directory.Jeeel.Net = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Net/';
    }
};

/**
 * ネット関連のネームスペース
 */
Jeeel.Net = {

};

Jeeel.file.Jeeel.Net = ['Submit', 'Ajax', 'Jsonp'];

if (Jeeel._extendMode.Net && Jeeel._global) {
    if (Jeeel._global.EventSource) {
        Jeeel.file.Jeeel.Net[Jeeel.file.Jeeel.Net.length] = 'Comet';
    }
    
    if (Jeeel._global.WebSocket) {
        Jeeel.file.Jeeel.Net[Jeeel.file.Jeeel.Net.length] = 'Socket';
    }
}

Jeeel._autoImports(Jeeel.directory.Jeeel.Net, Jeeel.file.Jeeel.Net);

/**
 * コンストラクタ
 *
 * @class フォームの操作及び送信を管理するクラス
 * @param {String|Element} form フォームを示すIDもしくはフォーム自身
 * @throws {Error} 指定したformがフォームのIDもしくはフォーム自身でなかった場合に発生
 */
Jeeel.Net.Submit = function (form) {
    if (Jeeel.Type.isString(form)) {
        form = Jeeel.Document.getElementById(form);
    }

    if ( ! form || ! form.nodeName || form.nodeName.toLowerCase() !== 'form') {
        throw new Error('指定されたIDまたはElementはform固有のものではありません。');
    }

    this._form = form;
    
    if (Jeeel.Type.isElement(arguments[1])) {
        this._pseudoForm = arguments[1];
    }
};

/**
 * インスタンスを作成する
 *
 * @param {String|Element} form フォームを示すIDもしくはフォーム自身
 * @return {Jeeel.Net.Submit} 作成したインスタンス
 */
Jeeel.Net.Submit.create = function (form) {
    return new this(form);
};

/**
 * 疑似フォームを設定し、新規フォームを介して値の設定や削除、送信を行う<br />
 * この機能を使うと指定した要素の中に含まれるinput等の値を設定・削除・送信を行う事が出来る
 * 
 * @param {String|Element} pseudoForm 疑似フォームを示すIDもしくは疑似フォーム自身(例えばdivタグやtrタグ等)
 * @param {String} [action] formのaction
 * @param {String} [method] formのmethod
 * @return {Jeeel.Net.Submit} 作成したインスタンス
 * @throws {Error} 指定したpseudoFormがIDもしくはElementではなかった場合に発生
 */
Jeeel.Net.Submit.createByPseudoForm = function (pseudoForm, action, method) {
    var newForm = Jeeel.Document.createElement('form');

    newForm.style.display = 'none';

    Jeeel.Document.appendToBody(newForm);
    
    if (Jeeel.Type.isString(pseudoForm)) {
        pseudoForm = Jeeel.Document.getElementById(pseudoForm);
    }
    
    if ( ! Jeeel.Type.isElement(pseudoForm)) {
        throw new Error('指定されたpseudoFormがIDもしくはElementではありません。');
    }
    
    var res = new this(newForm, pseudoForm);
    
    if (action) {
        res.setAction(action);
    }
    
    if (method) {
        res.setMethod(method);
    }
    
    return res.setRemoveFormAtExecute(true);
};

/**
 * formを新規作成して、インスタンスの作成を行う<br />
 * このメソッドを呼んだ場合formがbodyに追加され、<br />
 * executeメソッドが呼ばれた時にこのFormは削除される
 *
 * @param {String} [action] formのaction
 * @param {String} [method] formのmethod
 * @return {Jeeel.Net.Submit} 作成したインスタンス
 */
Jeeel.Net.Submit.newForm = function (action, method) {
    var newForm = Jeeel.Document.createElement('form');

    newForm.style.display = 'none';

    Jeeel.Document.appendToBody(newForm);

    var res = new this(newForm);
    
    if (action) {
        res.setAction(action);
    }
    
    if (method) {
        res.setMethod(method);
    }
    
    return res.setRemoveFormAtExecute(true);
};

/**
 * 指定したformを基に新規formを作成し、インスタンスの作成を行う<br />
 * 新規にformを作成した場合bodyに追加され、<br />
 * このインスタンスのexecuteメソッドが呼ばれた時に新規formは削除される
 *
 * @param {String|Element} form 基となるフォームを示すIDもしくはフォーム自身
 * @param {String|Element} [newForm] コピー先となるForm(指定しない場合は新規作成を行う)
 * @return {Jeeel.Net.Submit} 作成したインスタンス
 * @throws {Error} newFormを指定したにも関わらずフォームのIDもしくはフォーム自身でなかった場合に発生
 */
Jeeel.Net.Submit.copyBy = function (form, newForm) {

    var executeRemove = false;
    
    if (Jeeel.Type.isString(newForm)) {
        newForm = Jeeel.Document.getElementById(newForm);
    } else if ( ! Jeeel.Type.isElement(newForm)) {
        newForm = Jeeel.Document.createElement('form');
        newForm.style.display = 'none';
        executeRemove = true;
    }

    if ( ! newForm || ! newForm.nodeName || newForm.nodeName.toLowerCase() !== 'form') {
        throw new Error('引数newFormはform固有を示すものではありません。');
    }

    var base = new this(form);
    var res  = new this(newForm);

    res.setMethod(base.getMethod());
    res.setAction(base.getAction());
    res.setTarget(base.getTarget());
    res.setAll(base.getAll());

    Jeeel.Document.appendToBody(newForm);

    return res.setRemoveFormAtExecute(executeRemove);
};

/**
 * 名前がない要素の名前
 * 
 * @type String
 * @constant
 * @memberOf Jeeel.Net.Submit
 */
Jeeel.Net.Submit.UNKNOWN_NAME = '_UNKNOWN_';

/**
 * 上書き要素の名前
 * 
 * @type String
 * @constant
 * @memberOf Jeeel.Net.Submit
 */
Jeeel.Net.Submit.OVERWRITTEN_NAME = '_OVERWRITE_';

Jeeel.Net.Submit.prototype = {

    /**
     * フォーム
     * 
     * @type Element
     * @private
     */
    _form: null,
    
    /**
     * 疑似フォーム
     * 
     * @type Element
     * @private
     */
    _pseudoForm: null,
    
    /**
     * フォームをexecuteメソッドを呼び出した後削除するかどうか
     * 
     * @type Boolean
     * @private
     */
    _executeRemove: false,
    
    _getName: Jeeel._Object.JeeelFilter.getInputName,
    
    /**
     * formに値をセットするためメソッド
     * 
     * @param {String} key キー
     * @param {Mixied} val 値
     * @param {Mixied} input 値を保持させるInputElement
     * @param {Boolean} [toForm] フォームに対して優先的に埋め込むかどうか
     * @private
     */
    _set: function (key, val, input, toForm) {},
    
    /**
     * formに強制的に値をセットするためメソッド
     * 
     * @param {Hash} vals 値
     * @private
     */
    _setAllForm: function (vals) {},

    /**
     * formのactionをセットする
     *
     * @param {String} action formのaction
     * @return {Jeeel.Net.Submit} 自身のインスタンス
     */
    setAction: function (action) {
        this._form.action = action;

        return this;
    },

    /**
     * formのactionを取得する
     *
     * @return {String} formのaction
     */
    getAction: function () {
        return this._form.action;
    },

    /**
     * formのmethodをセットする
     *
     * @param {String} method formのmethod
     * @return {Jeeel.Net.Submit} 自身のインスタンス
     */
    setMethod: function (method) {
        this._form.method = method;

        return this;
    },

    /**
     * formのmethodを取得する
     *
     * @return {String} formのmethod
     */
    getMethod: function () {
        return this._form.method;
    },

    /**
     * formのtargetをセットする
     *
     * @param {String} target formのtarget
     * @return {Jeeel.Net.Submit} 自身のインスタンス
     */
    setTarget: function (target) {
        this._form.target = target;

        return this;
    },

    /**
     * formのtargetを取得する
     *
     * @return {String} formのtarget
     */
    getTarget: function () {
        return this._form.target;
    },

    /**
     * 保持しているフォームを取得する
     *
     * @return {Element} フォーム
     */
    getForm: function () {
        return this._form;
    },
    
    /**
     * 疑似フォームを取得する
     *
     * @return {Element} 疑似フォーム
     */
    getPseudoForm: function () {
        return this._pseudoForm;
    },

    /**
     * 保持しているフォームをDom上から取り除く
     *
     * @return {Jeeel.Net.Submit} 自身のインスタンス
     */
    removeForm: function () {
        Jeeel.Dom.Element.create(this._form).remove();

        return this;
    },
    
    /**
     * 保持しているフォームをexecute時にDom上から取り除くかどうかを取得する
     *
     * @return {Boolean} execute時に削除するかどうか
     */
    getRemoveFormAtExecute: function () {
        return this._executeRemove;
    },
    
    /**
     * 保持しているフォームをexecute時にDom上から取り除くかどうかを設定する
     *
     * @param {Boolean} enableRemove execute時に削除するかどうか
     * @return {Jeeel.Net.Submit} 自身のインスタンス
     */
    setRemoveFormAtExecute: function (enableRemove) {
        this._executeRemove = !!enableRemove;
        
        return this;
    },

    /**
     * 指定したキーの値のリストを取得する
     *
     * @param {String} key キー(name)
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    get: function (key, defaultValue) {
        var param = this.getAll();
        var names = this._getName('' + key);
        
        // 配列るキーの場合(a[b]やa[]の場合)
        if (names.length !== 1) {
            for (var i = 0, l = names.length - 1; i < l; i++) {
                param = param[names[i]];
            }
            
            key = names[l];
        }
        
        param = param[key];

        return (Jeeel.Type.isSet(param) ? param : defaultValue);
    },

    /**
     * form内の値を全て取得する<br />
     * その際checkedが付いていないradioボタンやcheckboxは無視される
     *
     * @return {Hash} 値のリスト
     */
    getAll: function () {},
    
    /**
     * 指定したキーのデフォルト値のリストを取得する
     *
     * @param {String} key キー(name)
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getDefault: function (key, defaultValue) {
        var param = this.getDefaultAll();
        var names = this._getName('' + key);
        
        // 配列るキーの場合(a[b]やa[]の場合)
        if (names.length !== 1) {
            for (var i = 0, l = names.length - 1; i < l; i++) {
                param = param[names[i]];
            }
            
            key = names[l];
        }
        
        param = param[key];

        return (Jeeel.Type.isSet(param) ? param : defaultValue);
    },
    
    /**
     * form内のデフォルト値を全て取得する<br />
     * その際checkedが付いていないradioボタンやcheckboxは無視される
     *
     * @return {Hash} 値のリスト
     */
    getDefaultAll: function () {},
    
    /**
     * 値をhiddenでセットする<br />
     * もし指定したキーが存在した場合は上書きを試みるが、値がHash形式だった場合は元の値を削除して新たに作る<br />
     * また、セレクトボックスのに対して一覧にない値を上書きしようとすると挙動がブラウザによって変わる場合があるので注意
     *
     * @param {String} key キー(inputタグのnameと同じ書式)
     * @param {Mixied} val 値
     * @return {Jeeel.Net.Submit} 自身のインスタンス
     */
    set: function (key, val) {
        var names = this._getName('' + key);
        
        // 配列るキーの場合(a[b]やa[]の場合)
        if (names.length !== 1) {
            var base = {}, obj = base;
            
            for (var i = 0, l = names.length - 1; i < l; i++) {
                obj[names[i]] = {};
                obj = obj[names[i]];
            }
            
            obj[names[l]] = val;
            
            key = names[0];
            val = base[key];
        }
        
        var input = this.getElementAll()[key];
        
        Jeeel.Dom.ElementOperator.create(this.getOverwrittenElements())
                               .filterName(key, true)
                               .remove();

        this._set(key, val, input);

        return this;
    },

    /**
     * 指定したHashをの内容を全てhidden形式で埋め込む<br />
     * keyが被った場合は全て上書きする
     * 
     * @param {Hash} vals 値
     * @return {Jeeel.Net.Submit} 自身のインスタンス
     */
    setAll: function (vals) {

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                this.set(key, val);
            }, this
        );

        return this;
    },

    /**
     * 指定キーの値を破棄する(この際指定キーのElementのnameが破棄される)<br />
     * その際checkedが付いていないradioボタンやcheckboxは無視される
     *
     * @param {String} key キー
     * @return {Jeeel.Net.Submit} 自インスタンス
     */
    unset: function (key) {
        Jeeel.Dom.ElementOperator.create([this.getElement(key), this.getOverwrittenElements()])
                               .filterName(key, true)
                               .removeAttr('name');
        
        return this;
    },

    /**
     * 指定キーの値を保持しているかどうかを返す<br />
     * その際checkedが付いていないradioボタンやcheckboxは無視される
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    has: function (key) {
        return Jeeel.Type.isSet(this.get(key));
    },

    /**
     * 指定したキーのinput要素を取得する(指定した名前が複数ある場合はリストになる)
     *
     * @param {String} key キー(name)
     * @return {Element|Hash} inputの要素
     */
    getElement: function (key) {
        var param = this.getElementAll();
        var names = this._getName('' + key);
        
        // 配列るキーの場合(a[b]やa[]の場合)
        if (names.length !== 1) {
            for (var i = 0, l = names.length - 1; i < l; i++) {
                param = param[names[i]];
            }
            
            key = names[l];
        }
        
        param = param[key];
        
        return param || null;
    },

    /**
     * form内の全てのinput要素を取得する<br />
     * その際radioボタンは常にリストになる
     * 
     * @return {Hash} input要素のリスト
     */
    getElementAll: function () {},

    /**
     * 検索対象にならなかった無名のinput要素を全て取得する
     *
     * @return {Element[]} input要素の配列
     */
    getUnknownElements: function () {},
    
    /**
     * 検索過程で上書きされてしまうinput要素を全て取得する
     * 
     * @return {Element[]} input要素の配列
     * @example
     * <form>
     *   <input type="" name="hoge" value="1" />
     *   <input type="" name="hoge" value="2" />
     *   <input type="" name="hoge[]" value="3" />
     *   <input type="" name="hoge[]" value="4" />
     * </form>
     * 上記のformの場合最初から2つのhogeの要素が取得される
     */
    getOverwrittenElements: function () {},
    
    /**
     * 指定キーのinput要素を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Net.Submit} 自インスタンス
     */
    unsetElement: function (key) {
        Jeeel.Dom.ElementOperator.create([this.getElement(key), this.getOverwrittenElements()])
                               .filterName(key, true)
                               .remove();
        
        return this;
    },
    
    /**
     * selectタグのoptionを指定した値に全て置き換える
     * 
     * @param {String} key selectタグのname
     * @param {Hash} options オプションの値に使う値と表示値のリスト({value1: text1, value2: text2, ...})
     * @return {Jeeel.Net.Submit} 自インスタンス
     */
    replaceSelectOptions: function (key, options) {
        var select = this.getElement(key),
            nodeName = select && select.nodeName;
        
        if ( ! nodeName || nodeName.toUpperCase() !== 'SELECT') {
            return this;
        } else if ( ! Jeeel.Type.isHash(options)) {
            return this;
        }
        
        select = new Jeeel.Dom.Element(select);
        
        var addOptions = [],
            txtFilter = Jeeel.Filter.Html.Escape.create(),
            val, option;
        
        for (val in options) {
            option = Jeeel.Document.createElement('option');
            option.value = val;
            option.innerHTML = txtFilter.filter(options[val]);
            
            addOptions[addOptions.length] = option;
        }
        
        select.clearChildNodes()
              .appendChild(addOptions);
        
        return this;
    },
    
    /**
     * フォームの送信を行う
     *
     * @return {Jeeel.Net.Submit} 自身のインスタンス
     */
    execute: function () {
        if (this._pseudoForm) {
            this._setAllForm(this.getAll());
        }
        
        this._form.submit();
        
        if (this._executeRemove) {
            this.removeForm();
        }

        return this;
    },

    /**
     * フォームの内容をJeeel.Net.Ajaxインスタンスに変換する
     *
     * @return {Jeeel.Net.Ajax} 変換後のインスタンス
     */
    toAjax: function () {
        var params = this.getAll();

        return Jeeel.Net.Ajax.create(this.getAction(), this.getMethod())
                           .setAll(params);
    },
    
    _init: function () {
        var uName = Jeeel.Net.Submit.UNKNOWN_NAME;
        var oName = Jeeel.Net.Submit.OVERWRITTEN_NAME;
        var fnvf = new Jeeel.Filter.Html.FormValue();
        var fdvf = new Jeeel.Filter.Html.FormValue(true);
        var fnef = new Jeeel.Filter.Html.Form();
        var fuef = new Jeeel.Filter.Html.Form(false, uName);
        var foef = new Jeeel.Filter.Html.Form(false, null, oName);
        var uef  = new Jeeel.Filter.Url.Escape();
        
        var self = this;
        
        self.getAll = function () {
            return fnvf.filter(this._pseudoForm || this._form);
        };
        
        self.getDefaultAll = function () {
            return fdvf.filter(this._pseudoForm || this._form);
        };
        
        self.getElementAll = function () {
            return fnef.filter(this._pseudoForm || this._form);
        };
        
        self.getUnknownElements = function () {
            var parm = fuef.filter(this._pseudoForm || this._form)[uName];

            return Jeeel.Hash.getValues(parm || []);
        };
        
        self.getOverwrittenElements = function () {
            return foef.filter(this._pseudoForm || this._form)[oName];
        };
        
        self._setAllForm = function (vals) {
            var inputs = fnef.filter(this._form);

            Jeeel.Hash.forEach(vals,
                function (val, key) {
                    this._set(key, val, inputs[key], true);
                }, this
            );

            return this;
        };
        
        self._set = function (key, val, input, toForm) {
            // inputがElementの場合
            if (Jeeel.Type.isElement(input)) {

                // valが単体の場合そのまま代入
                if ( ! Jeeel.Type.isHash(val)) {
                    input.value = uef.filter(val);
                } 

                // valが複数の場合inputと形式が一致しないためinputを削除してから値の設定を行う
                else {
                    Jeeel.Dom.ElementOperator.create(input).remove();

                    this._set(key, val, null, toForm);
                }
            } 
            // inputがHashの場合
            else if (input) {

                // valが単数の場合inputと形式が一致しないためinputを削除してから値の設定を行う
                if ( ! Jeeel.Type.isHash(val)) {
                    Jeeel.Dom.ElementOperator.create(input).remove();

                    this._set(key, val, null, toForm);

                    return;
                }

                // valが複数の場合それぞれのinputにコピーを再帰的に行っていく
                Jeeel.Hash.forEach(val, 
                    function (val, inputKey) {
                        this._set(key + '[' + inputKey + ']', val, input[inputKey], toForm);
                    }, this
                );

            } 
            // inputが存在しない場合
            else {

                // valを基にHiddenインスタンスを作成する
                input = Jeeel.Filter.Html.Hidden.create(key).filter(val);
                
                // Hiddenインスタンスの埋め込み先を決定する
                var owner = ! toForm && this._pseudoForm || this._form;

                // 作成したHiddenインスタンスを対象に埋め込む
                if (Jeeel.Type.isArray(input)) {
                    for (var i = 0; i < input.length; i++) {
                        owner.appendChild(input[i]);
                    }
                } else {
                    owner.appendChild(input);
                }
            }
        };
        
        delete this._init;
    }
};

Jeeel.Net.Submit.prototype._init();Jeeel.directory.Jeeel.Net.Ajax = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Net + 'Ajax/';
    }
};

/**
 * コンストラクタ
 * 
 * @class Ajaxの制御を行うクラス
 * @param {String} url Ajax対象URLの文字列
 * @param {String} [method] HTTPメソッド(getまたはpost、大文字小文字は問わない、初期値はPOST)
 * @throws {Error} urlが指定されていない場合に起こる
 */
Jeeel.Net.Ajax = function (url, method) {

    if ( ! Jeeel.Type.isString(url)) {
        throw new Error('URLを指定してください。');
    }

    this.setMethod(method);

    this._url = url;
    this._params = new Jeeel.Parameter();
    this._fields = new Jeeel.Parameter();
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} url Ajax対象URL文字列
 * @param {String} [method] HTTPメソッド(getまたはpost、大文字小文字は問わない、初期値はPOST)
 * @return {Jeeel.Net.Ajax} 作成したインスタンス
 */
Jeeel.Net.Ajax.create = function (url, method) {
    return new this(url, method);
};

/**
 * Ajaxのリクエストを作成する
 * 
 * @return {XMLHttpRequest} 作成したリクエスト(作成出来なかった場合はnullを返す)
 */
Jeeel.Net.Ajax.createXMLHttpRequest = function () {
    var obj = null, activeXIds =[
        'MAXM12.XMLHTTP.3.0',
        'MAXM12.XMLHTTP',
        'Microsoft.XMLHTTP'
    ];
    
    if (typeof XMLHttpRequest !== 'undefined') {
        obj = new XMLHttpRequest();
    } 
    else if (typeof ActiveXObject !== 'undefined') {
      
        // IE7以前の作成
        for (var i = 0, l = activeXIds.length; i < l; i++) {
            try {
                obj = new ActiveXObject(activeXIds[i]);
                break;
            } catch (e) {}
        }
    }
    
    return obj;
};

/**
 * 指定したURLのレスポンスをそのまま返す
 *
 * @param {String} url アクセスURL
 * @param {Hash} [parameter] URLに渡すPostパラメータを示す連想配列
 * @return {String|Object} サーバーからのレスポンス、異常終了時はstatu, statusText, responseのキーをもつオブジェクト
 * @throws {Error} Ajaxがサポートされていないと発生する
 */
Jeeel.Net.Ajax.serverResponse = function (url, parameter) {

    if ( ! Jeeel.Type.isHash(parameter)) {
        parameter = {};
    }

    var request = this.createXMLHttpRequest();
    var response;

    if (request) {
        var check = function () {
            if (request.readyState == 4 && request.status == 200) {
                response = request.responseText;
            } else if (request.readyState == 4) {
                response = {
                    status: request.status,
                    statusText: request.statusText,
                    response: request.responseText
                };
            }
        };

        request.open('POST', url, false);
        request.onreadystatechange = check;

        request.setRequestHeader('X-Requested-With' , 'XMLHttpRequest');
        request.setRequestHeader('X-Jeeel-Version' , Jeeel.VERSION);
        request.setRequestHeader('Accept' , 'text/javascript, text/html, application/xml, text/xml, */*');
        request.setRequestHeader('Content-Type' , 'application/x-www-form-urlencoded; charset=UTF-8');

        if (request.overrideMimeType &&
            (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
        {
            request.setRequestHeader('Connection' , 'close');
        }

        request.send(Jeeel.Parameter.create(parameter).toQueryString());
    } else {
        throw new Error('Ajaxがサポートされていません。');
    }

    if (response) {
        return response;
    }

    if (request.readyState == 4 && request.status == 200) {
        return request.responseText;
    }

    return {
        status: request.status,
        statusText: request.statusText,
        response: request.responseText
    };
};

Jeeel.Net.Ajax.prototype = {

    /**
     * Ajaxの際にサーバー側に渡すパラメータのハッシュを保持するJeeel.Parameter
     *
     * @type Jeeel.Parameter
     * @private
     */
    _params: null,

    /**
     * Ajaxの際にサーバー側に渡さずに戻り値に定義づけるパラメータのハッシュを保持するJeeel.Parameter
     *
     * @type Jeeel.Parameter
     * @private
     */
    _fields: null,

    /**
     * Ajax対象のURL
     *
     * @type String
     * @private
     */
    _url: '',

    /**
     * HTTPメソッド
     *
     * @type String
     * @private
     */
    _method: '',

    /**
     * 現在通信中かどうか
     *
     * @type Boolean
     * @private
     */
    _executing: false,

    /**
     * 非同期通信かどうか
     *
     * @type Boolean
     * @private
     */
    _asynchronous: true,
    
    /**
     * タイムアウト時間(ミリ秒)
     * 
     * @type Integer
     * @private
     */
    _timeoutTime: 0,
    
    /**
     * 並列接続時の動作ポリシー
     * 
     * @type Integer
     * @private
     */
    _collisionPolicy: 0,

    /**
     * 作成メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _create: null,

    /**
     * 完了メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _complete: null,

    /**
     * 成功メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _success: null,
    
    /**
     * 中止メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _abort: null,
    
    /**
     * タイムアウトメソッド
     * 
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _timeout: null,

    /**
     * 失敗メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _failure: null,

    /**
     * 部分受信メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _interactive: null,

    /**
     * 送信準備完了メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _loaded: null,

    /**
     * コネクションオープンメソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _loading: null,

    /**
     * XMLHttpRequest生成メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _uninitialized: null,

    /**
     * 例外メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Request request, Error error)
     * @private
     */
    _exception: null,
    
    /**
     * リクエスト
     *
     * @type Jeeel.Net.Ajax.Request
     * @private
     */
    _request: null,

    /**
     * 戻り値
     *
     * @type Jeeel.Net.Ajax.Response
     * @private
     */
    _response: null,

    /**
     * エラー
     *
     * @type Error
     * @private
     */
    _error: null,
    
    /**
     * Ajax対象のURLを取得する
     * 
     * @return {String} URL
     */
    getUrl: function () {
        return this._url;
    },

    /**
     * Ajax対象URLの設定
     *
     * @param {String} url Ajax対象URL
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     * @throws {Error} urlが文字列でない場合に起こる
     */
    setUrl: function (url) {
        if ( ! Jeeel.Type.isString(url)) {
            throw new Error('URLを指定してください。');
        }

        this._url = url;

        return this;
    },
    
    /**
     * HTTPメソッドの取得を行う
     * 
     * @return {String} HTTPメソッド
     */
    getMethod: function () {
        return this._method;
    },

    /**
     * HTTPメソッドの設定
     *
     * @param {String} method HTTPメソッド(getまたはpost、大文字小文字は問わない)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setMethod: function (method) {
        if ( ! Jeeel.Type.isString(method)) {
            method = 'POST';
        }
        
        method = method.toUpperCase();

        if (method !== 'GET' && method !== 'POST') {
            method = 'POST';
        }

        this._method = method;

        return this;
    },
    
    /**
     * 非同期通信化どうかを返す
     *
     * @return {Boolean} 自身のインスタンス
     */
    getAsynchronous: function () {
        return this._asynchronous;
    },

    /**
     * 非同期通信化どうかの設定
     *
     * @param {Boolean} asynchronous 非同期通信かどうか
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setAsynchronous: function (asynchronous) {
        this._asynchronous = !!asynchronous;

        return this;
    },
    
    /**
     * 非同期通信時のタイムアウトまでの時間を取得する
     * 
     * @return {Integer} タイムアウト時間、0で無制限(ミリ秒)
     */
    getTimeoutTime: function () {
        return this._timeoutTime;
    },
    
    /**
     * 非同期通信時のタイムアウトまでの時間を設定する
     * 
     * @param {Integer} time タイムアウト時間、0で無制限(ミリ秒)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setTimeoutTime: function (time) {
        this._timeoutTime = +time || 0;
        
        return this;
    },
    
    /**
     * コリジョンポリシーを取得する
     * 
     * @return {String} コリジョンポリシー
     */
    getCollisionPolicy: function () {
        return this._collisionPolicy;
    },
    
    /**
     * 並列リクエストをした場合の動作を設定する
     * 
     * @param {Integer} collisionPolicy コリジョンポリシー
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     * @see Jeeel.Net.Ajax.CollisionPolicy
     */
    setCollisionPolicy: function (collisionPolicy) {
        if (isNaN(collisionPolicy)) {
            collisionPolicy = this.constructor.CollisionPolicy.IGNORE;
        }
        
        if (collisionPolicy !== this.constructor.CollisionPolicy.CHANGE && collisionPolicy !== this.constructor.CollisionPolicy.IGNORE) {
            collisionPolicy = this.constructor.CollisionPolicy.IGNORE;
        }
        
        this._collisionPolicy = collisionPolicy;
        
        return this;
    },

    /**
     * 作成メソッドの登録
     *
     * @param {Function} callback 作成メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setCreateMethod: function (callback, thisArg) {
        this._create = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 完了メソッドの登録
     *
     * @param {Function} callback 完了メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setCompleteMethod: function (callback, thisArg) {
        this._complete = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 成功メソッドの登録
     *
     * @param {Function} callback 成功メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setSuccessMethod: function (callback, thisArg) {
        this._success = {func: callback, thisArg: thisArg};

        return this;
    },
    
    /**
     * アボートメソッドの登録
     *
     * @param {Function} callback アボートメソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setAbortMethod: function (callback, thisArg) {
        this._abort = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * タイムアウトメソッドの登録(アボートメソッドが最後に呼ばれう)
     *
     * @param {Function} callback タイムアウトメソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setTimeoutMethod: function (callback, thisArg) {
        this._timeout = {func: callback, thisArg: thisArg};

        return this;
    },
    
    /**
     * 失敗メソッドの登録
     *
     * @param {Function} callback 失敗メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setFailureMethod: function (callback, thisArg) {
        this._failure = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 部分受信メソッドの登録
     *
     * @param {Function} callback 部分受信メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setInteractiveMethod: function (callback, thisArg) {
        this._interactive = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 送信準備完了メソッドの登録
     *
     * @param {Function} callback 送信準備完了メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setLoadedMethod: function (callback, thisArg) {
        this._loaded = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * コネクションオープンメソッドの登録
     *
     * @param {Function} callback コネクションオープンメソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setLoadingMethod: function (callback, thisArg) {
        this._loading = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * XMLHttpRequest生成メソッドの登録
     *
     * @param {Function} callback XMLHttpRequest生成メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setUninitializedMethod: function (callback, thisArg) {
        this._uninitialized = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 例外メソッドの登録
     *
     * @param {Function} callback 例外メソッド<br />
     *                             コールバックメソッドに渡される引数はリクエスト, エラーとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Request request, Error error)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setExceptionMethod: function (callback, thisArg) {
        this._exception = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * Ajaxパラメータの全取得
     *
     * @return {Hash} 値リスト
     */
    getAll: function () {
        return this._params.getAll();
    },

    /**
     * Ajaxパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    get: function (key, defaultValue) {
        return this._params.get(key, defaultValue);
    },

    /**
     * Ajaxパラメータを総入れ替えする
     *
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     * @throws {Error} valsが配列式でない場合に起こる
     */
    setAll: function (vals) {

        if ( ! Jeeel.Type.isHash(vals)) {
            throw new Error('valsが配列・連想配列ではありあせん。');
        }

        this._params.setAll({});

        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                self._params.set(key, val);
            }
        );

        return this;
    },

    /**
     * Ajaxパラメータの設定
     *
     * @param {String} key キー
     * @param {Mixied} val 値
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    set: function (key, val) {
        this._params.set(key, val);

        return this;
    },
    
    /**
     * Ajaxパラメータの指定キーの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Net.Ajax} 自インスタンス
     */
    unset: function (key) {
        this._params.unset(key);

        return this;
    },

    /**
     * Ajaxパラメータの指定キーの値を保持しているかどうかを返す
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    has: function (key) {
        return this._params.has(key);
    },

    /**
     * レスポンスフィールドパラメータの全取得
     *
     * @return {Hash} 値リスト
     */
    getFieldAll: function () {
        return this._fields.getAll();
    },

    /**
     * レスポンスフィールドパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getField: function (key, defaultValue) {
        return this._fields.get(key, defaultValue);
    },

    /**
     * レスポンスフィールドパラメータを総入れ替えする
     *
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     * @throws {Error} valsが配列式でない場合に起こる
     */
    setFieldAll: function (vals) {

        if ( ! Jeeel.Type.isHash(vals)) {
            throw new Error('valsが配列・連想配列ではありあせん。');
        }

        this._fields.setAll({});

        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                self._fields.set(key, val);
            }
        );

        return this;
    },

    /**
     * レスポンスフィールドパラメータの設定
     *
     * @param {String} key キー
     * @param {Mixied} val 値
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setField: function (key, val) {
        this._fields.set(key, val);

        return this;
    },

    /**
     * レスポンスフィールドの指定キーの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Net.Ajax} 自インスタンス
     */
    unsetField: function (key) {
        this._fields.unset(key);

        return this;
    },

    /**
     * レスポンスフィールドの指定キーの値を保持しているかどうかを返す
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    hasField: function (key) {
        return this._fields.has(key);
    },
    
    /**
     * 通信中かどうかを取得する
     * 
     * @return {Boolean} 通信中かどうか
     */
    isExecuting: function () {
        return this._executing;
    },
    
    /**
     * 通信に使用したリクエストを取得する
     * 
     * @return {Jeeel.Net.Ajax.Request} リクエスト
     */
    getRequest: function () {
        return this._request;
    },
    
    /**
     * 前回の通信のレスポンスを取得する
     * 
     * @return {Jeeel.Net.Ajax.Response} レスポンス
     */
    getResponse: function () {
        return this._response;
    },
    
    /**
     * 通信中のエラーを取得する
     * 
     * @return {Error} エラー
     */
    getError: function () {
        return this._error;
    },

    /**
     * 実際にAjaxを実行する
     *
     * @return {Jeeel.Net.Ajax} 自インスタンス
     */
    execute: function () {
      
        // 通信中だった場合コリジョンポリシーに基づき動作を変える
        if (this._executing) {
            
            if (this._collisionPolicy === this.constructor.CollisionPolicy.IGNORE) {
                return this;
            } else {
                this.abort();
            }
        }
        
        var self = this;

        this._request = new this.constructor.Request(this._url, {
            method: this._method,
            parameters: this._params.toQueryString(),
            fields: this._fields.getAll(),
            asynchronous: this._asynchronous,
            timeout: this._timeoutTime,
            onCreate: function (response, jsonHeader) {
                self._callMethod('_create', [response, jsonHeader]);

                self._response  = null;
                self._executing = true;
            },
            onComplete: function (response, jsonHeader) {
                self._callMethod('_complete', [response, jsonHeader]);

                self._response  = response;
                self._executing = false;
            },
            onSuccess: function (response, jsonHeader){
                self._callMethod('_success', [response, jsonHeader]);
            },
            onFailure: function (response, jsonHeader){
                if (self._failure) {
                    self._callMethod('_failure', [response, jsonHeader]);
                } else {
                    Jeeel.errorHtmlDump('Failure', response.statusText + '(' + response.status + ')', response.responseText);
                }
            },
            onAbort: function (response, jsonHeader) {
                self._callMethod('_abort', [response, jsonHeader]);
            },
            onTimeout: function (response, jsonHeader) {
                self._callMethod('_timeout', [response, jsonHeader]);
            },
            onInteractive: function (response, jsonHeader) {
                self._callMethod('_interactive', [response, jsonHeader]);
            },
            onLoaded: function (response, jsonHeader) {
                self._callMethod('_loaded', [response, jsonHeader]);
            },
            onLoading: function (response, jsonHeader) {
                self._callMethod('_loading', [response, jsonHeader]);
            },
            onUninitialized: function (response, jsonHeader) {
                self._callMethod('_uninitialized', [response, jsonHeader]);
            },
            onException: function (request, error) {
                self._error     = error;
                self._executing = false;
                
                if (self._exception) {
                    self._callMethod('_exception', [request, error]);
                } else if ( ! Jeeel.errorHtmlDump('Exception', error.name, error.fileName + '(' + error.lineNumber + ')', error.message, request.transport.responseText)) {
                    throw error;
                }
            }
        });

        return this;
    },
    
    /**
     * 通信を中止する
     * 
     * @return {Jeeel.Net.Ajax} 自インスタンス
     */
    abort: function () {
        if (this._request && this._executing) {
            this._request.abort();
            this._executing = false;
        }
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {String} url Ajax対象URLの文字列
     * @param {String} [method] HTTPメソッド(getまたはpost、大文字小文字は問わない、初期値はPOST)
     * @constructor
     */
    constructor: Jeeel.Net.Ajax,
    
    /**
     * メソッドを呼び出す
     * 
     * @param {String} name メソッド名
     * @param {Array} [args] メソッドに引き渡す引数の配列
     */
    _callMethod: function (name, args) {
        if ( ! this[name]) {
            return;
        }
        
        this[name].func.apply(this[name].thisArg || this, args || []);
    }
};

Jeeel.file.Jeeel.Net.Ajax = ['Request', 'Response', 'CollisionPolicy'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Net.Ajax, Jeeel.file.Jeeel.Net.Ajax);

/**
 * コンストラクタ
 *
 * @class 実際にAjax通信を行うクラス
 * @param {String} url 対象URL
 * @param {Hash} options オプション
 */
Jeeel.Net.Ajax.Request = function (url, options) {
    var self = this;

    self.options = Jeeel.Hash.merge(self.options, options || {});

    self.options.method = self.options.method.toLowerCase();

    if (Jeeel.Type.isString(self.options.parameters)) {
        self.options.parameters = Jeeel.Filter.Url.QueryParameter.create().filter(self.options.parameters);
    }

    self.transport = Jeeel.Net.Ajax.createXMLHttpRequest();
    self.request(url);
};

/**
 * イベントを表す定数のリスト
 * 
 * @type String[]
 */
Jeeel.Net.Ajax.Request.Events = ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];

/**
 * 現在アクティブなRequestの数
 *
 * @type Integer
 */
Jeeel.Net.Ajax.Request.activeRequestCount = 0;

/**
 * レスポンスを処理するモジュール<br />
 * 追加登録することでデバッグ等を行える
 */
Jeeel.Net.Ajax.Request.responder = {

    /**
     * Requestが作成された場合に呼ばれる
     */
    onCreate: function () {
        Jeeel.Net.Ajax.Request.activeRequestCount++;
    },

    /**
     * Requestが終了した場合に呼ばれる
     */
    onComplete: function () {
        Jeeel.Net.Ajax.Request.activeRequestCount--;
    }
};

/**
 * レスポンスモジュールを呼び出す
 *
 * @param {String} methodName メソッド名
 * @param {Jeeel.Net.Ajax.Request} request アクセス中のRequest
 * @param {XMLHttpRequest} transport 基となるXMLHttpRequestオブジェクト
 * @param {Mixied} json Jsonを解析した後のオブジェクト
 */
Jeeel.Net.Ajax.Request.dispatch = function (methodName, request, transport, json) {
    var obj = Jeeel.Net.Ajax.Request.responder;

    if (Jeeel.Type.isFunction(obj[methodName])) {

        obj[methodName].call(obj, request, transport, json);
    }
};

Jeeel.Net.Ajax.Request.prototype = {

    /**
     * アクセスが終了したかどうか
     * 
     * @type Boolean
     */
    _complete: false,
    
    /**
     * タイムアウトID
     * 
     * @type Integer
     */
    _timeoutId: 0,
    
    /**
     * 作成時刻
     * 
     * @type Date 
     */
    createTimestamp: null,

    /**
     * ベースに使用するXMLHttpRequestオブジェクト
     *
     * @type XMLHttpRequest
     */
    transport: null,

    /**
     * アクセス時に使用するオプション
     *
     * @type Hash
     */
    options: {
        method:       'post',
        asynchronous: true,
        contentType:  'application/x-www-form-urlencoded',
        encoding:     'UTF-8',
        parameters:   '',
        evalJSON:     true,
        evalJS:       true,
        fields:       {},
        timeout:      0
    },

    /**
     * 現在のステータスを取得する
     *
     * @return {Integer} ステータス
     */
    getStatus: function () {
        try {
            return this.transport.status || 0;
        } catch (e) {
            return 0;
        }
    },

    /**
     * ヘッダを取得する
     *
     * @param {String} name ヘッダ名
     * @return {String} ヘッダ情報
     */
    getHeader: function (name) {
        try {
            return this.transport.getResponseHeader(name) || null;
        } catch (e) {
            return null;
        }
    },

    /**
     * レスポンスをJsonと見立ててオブジェクトに変換する
     *
     * @return {Mixied} 変換後のオブジェクト
     */
    evalResponse: function () {
        var json = this.transport.responseText || '';
        json = decodeURIComponent(json);
        try {
            return Jeeel.Json.decode(json);
        } catch (e) {
            this.dispatchException(e);
        }
    },

    /**
     * 実際にサーバーにアクセスを行う
     *
     * @param {String} url アクセスURL
     */
    request: function (url) {
        this.url = url;
        this.method = this.options.method;
        var params = Jeeel.Method.clone(this.options.parameters);

        if ( ! Jeeel.Type.inArray(this.method, ['get', 'post'])) {
            params['_method'] = this.method;
            this.method = 'post';
        }

        this.parameters = params;

        params = Jeeel.Parameter.create(params).toQueryString();

        if (params) {
            if (this.method == 'get') {
                this.url += (this.url.indexOf('?') > -1 ? '&' : '?') + params;
            } else if (/Konqueror|Safari|KHTML/.test(navigator.userAgent)) {
                params += '&_=';
            }
        }

        try {
            var response = new Jeeel.Net.Ajax.Response(this);

            if (this.options.onCreate){
                this.options.onCreate(response);
            }
            
            this.createTimestamp = new Date();

            Jeeel.Net.Ajax.Request.dispatch('onCreate', this, response);

            if (this.options.user && this.options.password) {
                this.transport.open(this.method.toUpperCase(), this.url, this.options.asynchronous, this.options.user, this.options.password);
            } else {
                this.transport.open(this.method.toUpperCase(), this.url, this.options.asynchronous);
            }

            if (this.options.asynchronous) {
                if (this.options.timeout) {
                    var self = this;
                    
                    this._timeoutId = setTimeout(function () {
                            var response = new Jeeel.Net.Ajax.Response(self);
                            
                            self.options.onTimeout(response, response.headerJSON);
                            self.abort();
                        }, this.options.timeout
                    );
                }
                
                Jeeel.Function.create(this.readyStateChange).bind(this).delay(1)();
            }

            this.transport.onreadystatechange = Jeeel.Function.create(this.onStateChange).bind(this);
            this.setRequestHeaders();

            this.body = (this.method == 'post' ? (this.options.postBody || params) : null);
            this.transport.send(this.body);

            /* Force Firefox to handle ready state 4 for synchronous requests */
            if ( ! this.options.asynchronous && this.transport.overrideMimeType) {
                this.onStateChange();
            }

        }
        catch (e) {
            this.dispatchException(e);
        }
    },
    
    /**
     * アクセスを中止する
     */
    abort: function () {
        
        if (this._complete) {
            return;
        }
        
        this.transport.abort();

        if (this.options.onAbort) {
            var response = new Jeeel.Net.Ajax.Response(this);
            this.options.onAbort(response, response.headerJSON);
        }
        
        clearTimeout(this._timeoutId);
    },

    /**
     * ステータスが変化されるたびに呼ばれるメソッド
     */
    onStateChange: function () {
        var readyState = this.transport.readyState;
        
        if (readyState > 1 && !((readyState == 4) && this._complete)) {
            this.readyStateChange(this.transport.readyState);
        }
    },
    
    /**
     * 通信が成功したかどうかを返す
     *
     * @return {Boolean} 通信が成功したかどうか
     */
    isSuccess: function () {
        var status = this.getStatus();
        return !status || (status >= 200 && status < 300);
    },

    /**
     * ステータスが変化するたびに呼ばれる
     * 
     * @param {String} readyState 現在のステートを表す文字列
     */
    readyStateChange: function (readyState) {
        var state = Jeeel.Net.Ajax.Request.Events[readyState];
        var response = new Jeeel.Net.Ajax.Response(this);

        if (state == 'Complete') {
            try {
                this._complete = true;
                (this.options['on' + response.status] ||
                 this.options['on' + (this.isSuccess() ? 'Success' : 'Failure')] ||
                 this.emptyFunction)(response, response.headerJSON);
            } catch (e) {
                this.dispatchException(e);
            }

            var contentType = response.getHeader('Content-type');
            if (this.options.evalJS == 'force'
                || (this.options.evalJS && this.isSameOrigin() && contentType
                    && contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
            {
                this.evalResponse();
            }
        }

        try {
            (this.options['on' + state] || this.emptyFunction)(response, response.headerJSON);
            Jeeel.Net.Ajax.Request.dispatch('on' + state, this, response, response.headerJSON);
        } catch (e) {
            this.dispatchException(e);
        }

        if (state == 'Complete') {
            this.transport.onreadystatechange = this.emptyFunction;
            clearTimeout(this._timeoutId);
        }
    },

    /**
     * ヘッダをセットする
     */
    setRequestHeaders: function () {
        var headers = {
            'X-Requested-With': 'XMLHttpRequest',
            'X-Jeeel-Version': Jeeel.VERSION,
            'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
        };

        if (this.method == 'post') {
            headers['Content-type'] = this.options.contentType +
            (this.options.encoding ? '; charset=' + this.options.encoding : '');

            if (this.transport.overrideMimeType &&
                (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
            {
                headers['Connection'] = 'close';
            }
        }

        if (typeof this.options.requestHeaders == 'object') {
            var extras = this.options.requestHeaders;

            if (Jeeel.Type.isFunction(extras.push)) {
                for (var i = 0, length = extras.length; i < length; i += 2) {
                    headers[extras[i]] = extras[i+1];
                }
            }
            else {
                for (var key in extras) {
                    headers[key] = extras[key];
                }
            }
        }

        for (var name in headers) {
            this.transport.setRequestHeader(name, headers[name]);
        }
    },

    /**
     * 現在のアクセスドメインと同等の場所へのアクセスかどうかを返す
     *
     * @return {Boolean} 現ドメインと同じプロトコル・ドメイン・ポートへのアクセスかどうか
     */
    isSameOrigin: function () {
        var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
        var tpl = Jeeel.Template.create();
        return !m || (m[0] == tpl.assignAll({
            protocol: location.protocol,
            domain: Jeeel._doc.domain,
            port: location.port ? ':' + location.port : ''
        }).fetchTemplate('#{protocol}//#{domain}#{port}'));
    },

    /**
     * エラーが発生した場合に処理するメソッド
     * 
     * @param {Error} error エラーオブジェクト
     */
    dispatchException: function (error) {

        if (this.options.onException) {
            this.options.onException(this, error);
        } else {
            throw error;
        }
    },

    /**
     * 何もしないメソッド
     */
    emptyFunction: function (){}
};

/**
 * コンストラクタ
 *
 * @class AjaxのResponseを表すクラス
 * @param {Jeeel.Net.Ajax.Request} request リクエスト
 */
Jeeel.Net.Ajax.Response = function (request) {

    var self = this;

    self.request = request;
    self.fields  = request.options.fields;
    var transport = self.transport = request.transport;
    var readyState = self.readyState = transport.readyState;

    if((readyState > 2 && ! Jeeel.UserAgent.isInternetExplorer()) || readyState == 4) {
        self.status       = self.getStatus();
        self.statusText   = self.getStatusText();
        self.responseText = (transport.responseText ? transport.responseText : '');
        self.headerJSON   = self._getHeaderJSON();
    }

    if(readyState == 4) {
        var xml = transport.responseXML;
        self.responseXML  = Jeeel.Type.isUndefined(xml) ? null : xml;
        self.responseJSON = self._getResponseJSON();
    }
};

Jeeel.Net.Ajax.Response.prototype = {

    /**
     * 現在の状態でのステータス
     *
     * @type Integer
     */
    status: 0,

    /**
     * 現在のステータスを示す文字列
     *
     * @type String
     */
    statusText: '',

    /**
     * テキストの戻り値
     *
     * @type String
     */
    responseText: null,

    /**
     * XMLの戻り値
     * 
     * @type XMLDocument
     */
    responseXML: null,

    /**
     * Jsonの戻り値
     *
     * @type Mixied
     */
    responseJSON: null,

    /**
     * リクエスト時に渡したフィールドパラメータ
     *
     * @type Hash
     */
    fields: null,
    
    /**
     * レスポンスフィールドパラメータの全取得
     *
     * @return {Hash} 値リスト
     */
    getFieldAll: function () {
        return this.fields;
    },

    /**
     * レスポンスフィールドパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getField: function (key, defaultValue) {
        return (Jeeel.Type.isSet(this.fields[key]) ? this.fields[key] : defaultValue);
    },

    /**
     * ヘッダを取得する<br />
     * エラーが起こった場合や存在しない場合はnullを返す
     *
     * @param {String} name ヘッダ名
     * @return {String} ヘッダ情報
     */
    getHeader: function (name) {
        try {
            return this.transport.getResponseHeader(name) || null;
        } catch (e) {
            return null;
        }
    },

    /**
     * ヘッダをそのまま取得する
     *
     * @param {String} name ヘッダ名
     * @return {String} ヘッダ情報
     */
    getResponseHeader: function (name) {
        return this.transport.getResponseHeader(name);
    },

    /**
     * ヘッダを全て取得する<br />
     * エラーが起こった場合や存在しない場合はnullを返す
     *
     * @return {String} ヘッダ情報
     */
    getAllHeaders: function () {
        try {
            return this.getAllResponseHeaders();
        } catch (e) {
            return null;
        }
    },

    /**
     * ヘッダを全てをそのまま取得する
     *
     * @return {String} ヘッダ情報
     */
    getAllResponseHeaders: function () {
        return this.transport.getAllResponseHeaders();
    },

    /**
     * 現在のステータスを取得する
     *
     * @return {Integer} ステータス
     */
    getStatus: function () {
        try {
            return this.transport.status || 0;
        } catch (e) {
            return 0;
        }
    },

    /**
     * 現在のステータスを示す文字列を取得する
     *
     * @return {Integer} ステータス文字列
     */
    getStatusText: function () {
        try {
            return this.transport.statusText || '';
        } catch (e) {
            return '';
        }
    },

    /**
     * 戻り値を強制的にJsonに変換して取得する<br />
     * 変換できなかった場合は空の連想配列になる
     *
     * @return {Mixied} 変換後のJsonオブジェクト(連想配列)
     */
    getResponseJSON: function () {
        var res;
        
        var options = this.request.options;
        
        try {
            res = Jeeel.Json.decode(decodeURIComponent(this.responseText), ( ! options.sanitizeJSON && this.request.isSameOrigin()));
        } catch (e) {
            res = {};
        }

        return res;
    },
    
    /**
     * 戻り値を強制的にXMLに変換して取得する<br />
     * 変換できなかった場合は空の連想配列になる
     *
     * @return {Jeeel.Dom.Xml} 変換後のXMLインスタンス
     */
    getResponseXML: function () {
        var res;

        try {
            res = new Jeeel.Dom.Xml(this.responseXML);
        } catch (e) {
            res = null;
        }

        return res;
    },
    
    /**
     * headerJsonを取得する
     *
     * @return {Mixied} Jsonを変換した後のオブジェクト
     * @protected
     */
    _getHeaderJSON: function () {
        var json = this.getHeader('X-JSON');
        
        if ( ! json) {
            return null;
        }

        json = decodeURIComponent(json);

        try {
            return Jeeel.Json.decode(json);
        } catch (e) {
            this.request.dispatchException(e);
        }
    },

    /**
     * 戻り値のJsonを取得する<br />
     * ただしヘッダにjson情報が書き込まれている必要がある
     *
     * @return {Mixied} Jsonを変換した後のオブジェクト
     * @protected
     */
    _getResponseJSON: function () {
        var options = this.request.options;

        if (!options.evalJSON || (options.evalJSON != 'force' &&
            (this.getHeader('Content-type') || '').indexOf('application/json') < 0) || this.responseText.match(/^\s*$/)) {
            return null;
        }

        try {
            return Jeeel.Json.decode(decodeURIComponent(this.responseText), ( ! options.sanitizeJSON && this.request.isSameOrigin()));
        } catch (e) {
            this.request.dispatchException(e);
        }
    }
};

/**
 * 並列リクエストをした時の動作ポリシー列挙体
 */
Jeeel.Net.Ajax.CollisionPolicy = {
  
    /**
     * 新しいリクエストを無視する
     *
     * @type Integer
     * @constant
     */
    IGNORE: 0,
    
    /**
     * 現在通信中のリクエストを破棄し新しいリクエストに置き換える
     *
     * @type Integer
     * @constant
     */
    CHANGE: 1
};(function () {
    var index = 0;
    
    /**
     * コンストラクタ
     * 
     * @class Jsonp通信の制御を行うクラス
     * @param {String} url Jsonp通信URL
     * @throws {Error} urlが指定されていない場合に起こる
     */
    Jeeel.Net.Jsonp = function (url) {
        if ( ! Jeeel.Type.isString(url)) {
            throw new Error('URLを指定してください。');
        }

        this._url = url;
        this._params = new Jeeel.Parameter();
        this._loaded = Jeeel.Function.simpleBind(this._loaded, this);

        this._id = index++;
    };
})();

/**
 * インスタンスの作成を行う
 * 
 * @param {String} url Jsonp通信URL
 * @return {Jeeel.Net.Jsonp} 作成したインスタンス
 * @throws {Error} urlが指定されていない場合に起こる
 */
Jeeel.Net.Jsonp.create = function (url) {
    return new this(url);
};

Jeeel.Net.Jsonp.prototype = {
  
    /**
     * インスタンスの固有ID
     * 
     * @type Integer
     * @private
     */
    _id: null,

    /**
     * Jsonp通信の際にサーバー側に渡すパラメータのハッシュを保持するJeeel.Parameter
     *
     * @type Jeeel.Parameter
     * @private
     */
    _params: null,

    /**
     * Jsonp通信URL
     *
     * @type String
     * @private
     */
    _url: '',
    
    /**
     * サーバー側で呼び出させるためのキャッシュキー
     * 
     * @type String
     * @private
     */
    _callbackKey: null,
    
    /**
     * Jsonp通信終了後のコールバック
     * 
     * @type Hash
     * @private
     */
    _loadCallback: null,
    
    /**
     * スクリプトタグ
     * 
     * @type Element
     * @private
     */
    _script: null,

    /**
     * Jsonp通信URLの設定
     *
     * @param {String} url Jsonp通信URL
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     * @throws {Error} urlが文字列でない場合に起こる
     */
    setUrl: function (url) {
        if ( ! Jeeel.Type.isString(url)) {
            throw new Error('URLを指定してください。');
        }

        this._url = url;

        return this;
    },
    
    /**
     * Jsonp通信時にサーバー側で呼び出すコールバックを設定する<br />
     * このコールバック設定を使用した場合グローバル関数を作成する必要は無くなる<br />
     * ただし、Jsonp通信が終了した時点でこのコールバックは無効になる
     * 
     * @param {String} callbackKey サーバー側でコールバックの名前を取得する際のキー
     * @param {Function} callback 実際に呼び出されるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     */
    setCallback: function (callbackKey, callback, thisArg) {
        
        this._callbackKey = callbackKey;
        
        Jeeel._jsp['f' + this._id] = function () {
            callback.apply(thisArg, arguments);
        };
        
        this._params.set(callbackKey, 'Jeeel._jsp.f' + this._id);
        
        return this;
    },
    
    /**
     * Jsonp通信終了後に呼び出すメソッドを設定する
     * 
     * @param {Function} callback 通信終了メソッド<br />
     *                             コールバックメソッドに渡される引数はJsonpを行ったスクリプトElementになる<br />
     *                             void callBack(Element script)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     */
    setLoadedMethod: function (callback, thisArg) {
        this._loadCallback = {func: callback, thisArg: thisArg};
        
        return this;
    },

    /**
     * Jsonpパラメータの全取得
     *
     * @return {Hash} 値リスト
     */
    getAll: function () {
        return this._params.getAll();
    },

    /**
     * Jsonpパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    get: function (key, defaultValue) {
        return this._params.get(key, defaultValue);
    },

    /**
     * Jsonpパラメータを総入れ替えする
     *
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     * @throws {Error} valsが配列式でない場合に起こる
     */
    setAll: function (vals) {

        if ( ! Jeeel.Type.isHash(vals)) {
            throw new Error('valsが配列・連想配列ではありあせん。');
        }

        this._params.setAll({});

        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                self._params.set(key, val);
            }
        );

        return this;
    },

    /**
     * Jsonpパラメータの設定
     *
     * @param {String} key キー
     * @param {Mixied} val 値
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     */
    set: function (key, val) {
        this._params.set(key, val);

        return this;
    },
    
    /**
     * Jsonpパラメータの指定キーの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     */
    unset: function (key) {
        this._params.unset(key);

        return this;
    },

    /**
     * Jsonpパラメータの指定キーの値を保持しているかどうかを返す
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    has: function (key) {
        return this._params.has(key);
    },

    /**
     * 実際にJsonp通信を実行する
     *
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     */
    execute: function () {
        var url = this._url + '?' + this._params.toQueryString();
        
        this._script = Jeeel.Loader.loadScript(url, this._loaded);
         
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Net.Jsonp,
    
    /**
     * 読み込み終了後に呼ばれるイベントメソッド
     */
    _loaded: function () {
        Jeeel.Dom.Element.create(this._script).remove();

        if (this._loadCallback) {
            this._loadCallback.func.call(this._loadCallback.thisArg || this, this._script);
        }
        
        if (this._callbackKey) {
            this._params.unset(this._callbackKey);
            
            delete Jeeel._jsp['f' + this._id];
        }

        this._script = null;
    }
};
/**
 * コンストラクタ
 * 
 * @class サーバーを監視する機能を管理するクラス(Server-Sent Events)
 * @param {String} [url] コネクションを張るURL
 * @example
 * サーバー側
 * サーバー側でアクセスするURLに以下のヘッダを設定
 * "Content-type: text/event-stream;"
 * 
 * レスポンスは行区切りでキーとペアで返す
 * data: [dataString] // レスポンスに載せるデータ
 * event: [customEventName] // カスタムイベントに使用するイベント名
 * retry: [nextAccessTimeout] // 次にアクセスするまでの時間(ミリ秒)
 * 
 * クライアント側
 * var c = new Jeeel.Net.Comet();
 * c.addResponseEvent(listener); // レスポンスが帰ってきた際のイベント登録
 * c.addErrorEvent(listener); // エラー時のイベント登録
 * 
 * c.open(URL);
 */
Jeeel.Net.Comet = function (url) {
    this._openEvent = Jeeel.Function.simpleBind(this._openEvent, this);
    this._messageEvent = Jeeel.Function.simpleBind(this._messageEvent, this);
    this._errorEvent = Jeeel.Function.simpleBind(this._errorEvent, this);
    this._customEvent = Jeeel.Function.simpleBind(this._customEvent, this);
        
    this._opens = [];
    this._messages = [];
    this._errors = [];
    this._customs = {};
    
    this.open(url);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} [url] コネクションを張るURL
 * @return {Jeeel.Net.Comet} 作成したインスタンス
 */
Jeeel.Net.Comet.create = function (url) {
    return new this(url);
};

Jeeel.Net.Comet.prototype = {
  
    /**
     * コネクション
     * 
     * @type EventSource
     * @private
     */
    _source: null,
    
    /**
     * オープンイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _opens: [],
    
    /**
     * メッセージイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _messages: [],
    
    /**
     * エラーイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _errors: [],
    
    /**
     * カスタムイベントリスト
     * 
     * @type Hash
     * @private
     */
    _customs: {},
    
    /**
     * オープンイベント
     * 
     * @private
     */
    _openEvent: function (e) {
        var evs = this._opens;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * メッセージイベント
     * 
     * @private
     */
    _messageEvent: function (e) {
        var evs = this._messages;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * エラーイベント
     * 
     * @private
     */
    _errorEvent: function (e) {
        var evs = this._errors;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * カスタムイベント
     * 
     * @private
     */
    _customEvent: function (e) {
        var evs = this._customs[e.type];
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * コネクションを張り終えた際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    addOpenEvent: function (listener) {
        this._opens.push(listener);

        return this;
    },
    
    /**
     * サーバーがレスポンスを返した際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    addResponseEvent: function (listener) {
        this._messages.push(listener);

        return this;
    },

    /**
     * サーバー側でイベント名を指定した場合に呼ばれる独自イベントの追加を行う<br >
     * その際レスポンスイベントは発生しない
     * 
     * @param {String} eventName イベント名
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    addCustomEvent: function (eventName, listener) {
        
        if ( ! (eventName in this._customs)) {
            this._customs[eventName] = [];
            
            if (this._source) {
                this._source.addEventListener(eventName, this._customEvent, false);
            }
        }
        
        this._customs[eventName].push(listener);
        
        return this;
    },
    
    /**
     * タスク内でエラーが発生した場合に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    addErrorEvent: function (listener) {
        this._errors.push(listener);

        return this;
    },
    
    /**
     * 新たにコネクションを張り直す<br />
     * その際前のコネクションは閉じられる
     * 
     * @param {String} url コネクションを張るURL
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    open: function (url) {
        
        if ( ! url) {
            return this;
        } else if (this._source) {
            this.close();
        }
        
        this._source = new EventSource(url);
        
        this._source.onopen = this._openEvent;
        this._source.onmessage = this._messageEvent;
        this._source.onerror = this._errorEvent;
        
        if (Jeeel.Hash.getCount(this._customs)) {
            for (var name in this._customs) {
                this._source.addEventListener(name, this._customEvent, false);
            }
        }
        
        return this;
    },
    
    /**
     * コネクションを閉じる
     * 
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    close: function () {
        
        if ( ! this._source) {
            return this;
        }
        
        for (var name in this._customs) {
            this._source.removeEventListener(name, this._customEvent, false);
        }
        
        this._source.close();
        
        this._source = null;
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     * @param {String} [url] コネクションを張るURL
     */
    constructor: Jeeel.Net.Comet
};

/**
 * コンストラクタ
 * 
 * @class 双方向通信の機能を管理するクラス
 * @param {String} [url] コネクションを張るURL
 */
Jeeel.Net.Socket = function (url) {
    this._openEvent = Jeeel.Function.simpleBind(this._openEvent, this);
    this._closeEvent = Jeeel.Function.simpleBind(this._closeEvent, this);
    this._messageEvent = Jeeel.Function.simpleBind(this._messageEvent, this);
    this._errorEvent = Jeeel.Function.simpleBind(this._errorEvent, this);
    
    this._opens = [];
    this._closes = [];
    this._messages = [];
    this._errors = [];
    
    this.open(url);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} [url] コネクションを張るURL
 * @return {Jeeel.Net.Socket} 作成したインスタンス
 */
Jeeel.Net.Socket.create = function (url) {
    return new this(url);
};

Jeeel.Net.Socket.prototype = {
  
    /**
     * ソケット
     * 
     * @type WebSocket
     * @private
     */
    _socket: null,
    
    /**
     * オープンイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _opens: [],
    
    /**
     * クローズイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _closes: [],
    
    /**
     * メッセージイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _messages: [],
    
    /**
     * エラーイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _errors: [],
    
    /**
     * オープンイベント
     * 
     * @private
     */
    _openEvent: function (e) {
        var evs = this._opens;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * クローズイベント
     * 
     * @private
     */
    _closeEvent: function (e) {
        var evs = this._closes;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * メッセージイベント
     * 
     * @private
     */
    _messageEvent: function (e) {
        var evs = this._messages;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * エラーイベント
     * 
     * @private
     */
    _errorEvent: function (e) {
        var evs = this._errors;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * コネクションを張り終えた際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    addOpenEvent: function (listener) {
        this._opens.push(listener);

        return this;
    },
    
    /**
     * コネクションを閉じた際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    addCloseEvent: function (listener) {
        this._closes.push(listener);

        return this;
    },
    
    /**
     * サーバー側からデータを受信した際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    addReceiveEvent: function (listener) {
        this._messages.push(listener);

        return this;
    },

    /**
     * タスク内でエラーが発生した場合に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    addErrorEvent: function (listener) {
        this._errors.push(listener);

        return this;
    },
    
    /**
     * サーバー側にデータを送信する
     * 
     * @param {String} content サーバー側に送るデータ
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    send: function (content) {
        if (this._socket.readyState === 1) {
            this._socket.send(content);
        }
        
        return this;
    },
    
    /**
     * 新たにコネクションを張り直す<br />
     * その際前のコネクションは閉じられる
     * 
     * @param {String} url コネクションを張るURL
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    open: function (url) {
        
        if ( ! url) {
            return this;
        } else if (this._socket) {
            this.close();
        }
        
        this._socket = new WebSocket(url);
        
        this._socket.onopen = this._openEvent;
        this._socket.onclose = this._closeEvent;
        this._socket.onmessage = this._messageEvent;
        this._socket.onerror = this._errorEvent;
        
        return this;
    },
    
    /**
     * コネクションを閉じる
     * 
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    close: function () {
        
        if ( ! this._socket) {
            return this;
        }
        
        this._socket.close();
        
        this._socket = null;
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     * @param {String} [url] コネクションを張るURL
     */
    constructor: Jeeel.Net.Socket
};

/**
 * コンストラクタ
 *
 * @class evalの遅延実行を可能にするクラス
 * @param {String} script 実行するスクリプト
 * @throws {Error} scriptが文字列でない場合に起こる
 */
Jeeel.Evaluator = function (script) {

    if ( ! Jeeel.Type.isString(script)) {
        throw new Error('実行スクリプトは必ず指定しなければなりません。');
    }

    /**
     * evalで解析するスクリプト文字列
     * 
     * @type String
     * @private
     */
    this._script = script;

    /**
     * 実行する際に必要な変数名と値のペアリスト
     * 
     * @type Hash
     * @private
     */
    this._params = {};
};

/**
 * インスタンスの作成
 *
 * @param {String} script 実行するスクリプト
 * @return {Jeeel.Evaluator} 作成したインスタンス
 */
Jeeel.Evaluator.create = function (script) {
    return new this(script);
};

/**
 * メソッドを呼び出せるようにした文字列を作成する
 *
 * @param {String} methodName メソッド名(window.setTimeout等でもよい)
 * @param {String[]|Primitive[]} params メソッドに渡す変数名(もしくは文字列以外の基本型)のリスト
 * @return {String} eval出来る形に形成した文字列
 */
Jeeel.Evaluator.createScriptMethod = function (methodName, params) {
    return methodName + '(' + params.join(', ') + ')';
};

Jeeel.Evaluator.prototype = {

    /**
     * evalする際に使用する変数をセットする
     *
     * @param {String} key 変数名
     * @param {Mixed} value 変数の値
     * @return {Jeeel.Evaluator} 自インスタンス
     */
    assign: function (key, value) {
        this._params[key] = Jeeel.Method.clone(value);

        return this;
    },

    /**
     * 指定した連想配列のキーを変数名として全てassignする
     *
     * @param {Hash} values 変数名と変数値のペアリスト
     * @return {Jeeel.Evaluator} 自インスタンス
     */
    assignAll: function (values) {
        if ( ! Jeeel.Type.isHash(values)) {
            throw new Error('valuesは必ず配列式でなければなりません。');
        }

        for (var key in values) {
            this.assign(key, values[key]);
        }

        return this;
    },

    /**
     * セットされた変数の値を破棄する
     *
     * @param {String} key 変数名
     * @return {Jeeel.Evaluator} 自インスタンス
     */
    clearAssign: function (key) {
        delete this._params[key];

        return this;
    },

    /**
     * セットされた変数の値をすべて破棄する
     *
     * @return {Jeeel.Evaluator} 自インスタンス
     */
    clearAssignAll: function () {
        this._params = {};

        return this;
    },

    /**
     * 実際にevalを実行する
     *
     * @return {Mixed} 実行結果
     */
    eval: function () {
        var $$__params = this._params;

        for (var key in $$__params) {

            eval('var '+key+' = $$__params[key];');
        }
        
        var $$__self = this;

        return (function () {
            return eval($$__self._script);
        })();
    }
};
/**
 * @class テンプレートを解析して文字列の置き換えを行うクラス
 * @param {RegExp} [pattern] 検索パターン
 */
Jeeel.Template = function (pattern) {
    /**
     * 実行する際に必要な変数名と値のペアリスト
     * 
     * @type Hash
     * @private
     */
    this._params = {};

    if (Jeeel.Type.isRegularExpression(pattern)) {
        this.pattern = pattern;
    }
};

/**
 * インスタンスの作成を行う
 *
 * @param {RegExp} [pattern] 検索パターン
 * @return {Jeeel.Template} 作成したインスタンス
 */
Jeeel.Template.create = function (pattern) {
    return new this(pattern);
};

Jeeel.Template.prototype = {

    /**
     * 検索するパターン<br />
     * デフォルトで#[NAME]
     *
     * @type RegExp
     * @readOnly
     */
    pattern: /(^|.|\r|\n)(#\[(.*?)\])/,
    
    /**
     * 実行する際に使用する変数をセットする
     *
     * @param {String} key 変数名
     * @param {Mixed} value 変数の値
     * @return {Jeeel.Template} 自インスタンス
     */
    assign: function (key, value) {
        this._params[key] = Jeeel.Method.clone(value);

        return this;
    },

    /**
     * 指定した連想配列のキーを変数名として全てassignする
     *
     * @param {Hash} values 変数名と変数値のペアリスト
     * @return {Jeeel.Template} 自インスタンス
     */
    assignAll: function (values) {
        if ( ! Jeeel.Type.isHash(values)) {
            throw new Error('valuesは必ず配列式でなければなりません。');
        }

        for (var key in values) {
            this.assign(key, values[key]);
        }

        return this;
    },

    /**
     * セットされた変数の値を破棄する
     *
     * @param {String} key 変数名
     * @return {Jeeel.Template} 自インスタンス
     */
    clearAssign: function (key) {
        delete this._params[key];

        return this;
    },

    /**
     * セットされた変数の値をすべて破棄する
     *
     * @return {Jeeel.Template} 自インスタンス
     */
    clearAssignAll: function () {
        this._params = {};

        return this;
    },

    /**
     * 指定した文字列をテンプレートして扱い文字列置換を行う
     *
     * @param {String} template テンプレート文字列
     * @return {String} 解析後の文字列
     */
    fetchTemplate: function (template) {

        var pattern = this.pattern;
        var match = pattern.exec(template);

        while(match) {
            template = template.replace(match[2], this._params[match[3]]);
            match = pattern.exec(template);
        }

        return template;
    },

    /**
     * 指定したファイル内容を解析し、文字列置換して返す
     *
     * @param {String} url ファイルを示すURL
     * @return {String} 解析後の文字列
     * @throws {Error} ファイルが見当たらないかサーバーエラー時に発生する
     */
    fetchFile: function (url) {
        var res = Jeeel.Net.Ajax.serverResponse(url);

        if ( ! Jeeel.Type.isString(res)) {
            throw new Error('ファイルが見当たらないかサーバーエラーを返しました。');
        }

        return this.fetchTemplate(res);
    }
};

/**
 * コンストラクタ
 *
 * @class タイマーを管理するクラス
 * @param {Function} func 一定時間毎に呼び出されるコールバック(関数内のthisはここで作成するインスタンスになる)
 * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数
 */
Jeeel.Timer = function (func, interval, var_args) {

    var limit = -1;

    if (func && Jeeel.Type.isInteger(func.limit)) {
        limit = func.limit;
    }

    var args = Array.prototype.slice.call(arguments, 2, arguments.length);

    if (arguments[0]) {
        var self = this;
        var baseFunc = func;
        arguments[0] = function () {

            if (self._limit >= 0 && self._limit <= self._count) {
                self.end();
                return;
            }

            self._lastResult = baseFunc.apply(self, args);
            
            self._count++;
        };
    }

    this._count = 0;
    this._limit = limit;
    this._args  = Array.prototype.slice.call(arguments);
    this._timer = this._setInterval.apply(null, arguments);
    this._enabled = true;
    this._lastResult = null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Function} func 一定時間毎に呼び出されるコールバック(関数内のthisはここで作成するインスタンスになる)
 * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数
 * @return {Jeeel.Timer} 作成したインスタンス
 */
Jeeel.Timer.create = function (func, interval, var_args) {
    return Jeeel.Function.toNative(Jeeel, 'Timer', true).apply(null, arguments);
};

/**
 * 指定した回数だけタイマーを回す
 *
 * @param {Function} func 一定時間毎に呼び出されるコールバック(関数内のthisはJeeel.Timerのインスタンスになる)
 * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
 * @param {Integer} limit タイマーを回す回数(マイナスを指定すると無制限になる)
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数には0から始まるタイマーが回った回数が渡される)
 * @return {Jeeel.Timer} 作成したインスタンス
 */
Jeeel.Timer.setLimitInterval = function (func, interval, limit, var_args) {
    var baseFunc = func;
    
    func = function () {
        if (arguments[0]) {
            arguments[0] = this._count;
        }

        return baseFunc.apply(this, arguments);
    };

    func.limit = limit;

    if (arguments[0]) {
        arguments[0] = func;
    }

    return Jeeel.Function.toNative(Jeeel, 'Timer', true).apply(null, arguments);
};

/**
 * 指定時間後にメソッドを実行する
 *
 * @param {Function} func コールバックメソッド
 * @param {Integer} delayTime コールバックを呼び出す遅延時間(ミリ秒)
 * @param {Mixied} var_args コールバックに渡す引数を可変的に渡す
 * @return {Integer} タイムアウトID
 */
Jeeel.Timer.setTimeout = function (func, delayTime, var_args) {
    var args = Array.prototype.slice.call(arguments, 2, arguments.length);

    var _func = function () {
        return func.apply(this, args);
    };

    return setTimeout(_func, delayTime);
};

/**
 * 指定時間後にセットしたメソッドの設定を解除する
 *
 * @param {Integer} timeoutId タイムアウトID
 */
Jeeel.Timer.clearTimeout = function (timeoutId) {
    clearTimeout(timeoutId);
};

Jeeel.Timer.prototype = {
    
    /**
     * タイマーが回った回数
     *
     * @type Integer
     * @private
     */
    _count: 0,

    /**
     * タイマーを回す回数(マイナスで無制限)
     *
     * @type Integer
     * @private
     */
    _limit: 0,
    
    /**
     * コンストラクタに引き渡された引数
     *
     * @type Arguments
     * @private
     */
    _args: null,
    
    /**
     * タイマーID
     *
     * @type Integer
     * @private
     */
    _timer: 0,

    /**
     * タイマーが有効かどうかを示す真偽値
     *
     * @type Boolean
     * @private
     */
    _enabled: true,

    /**
     * タイマーで実行されたコールバックの最後の戻り値
     *
     * @type Mixied
     * @private
     */
    _lastResult: null,

    /**
     * setIntervalを呼ぶ
     *
     * @return {Integer} タイマーID
     * @private
     */
    _setInterval: function (func, interval) {
        return Jeeel.Window.setInterval(func, interval);
    },

    /**
     * タイマーをスタートする
     *
     * @return {Jeeel.Timer} 自インスタンス
     */
    start: function () {
        if ( ! this._enabled) {
            this._timer   = this._setInterval.apply(null, this._args);
            this._enabled = true;
        }

        return this;
    },

    /**
     * タイマーをストップする
     *
     * @return {Jeeel.Timer} 自インスタンス
     */
    stop: function () {
        if (this._enabled) {
            Jeeel.Window.clearInterval(this._timer);
            this._enabled = false;
        }

        return this;
    },

    /**
     * タイマーを終了する<br />
     * このメソッドを呼んだ後のインスタンスに対して何をしても意味が無い
     */
    end: function () {
        this.stop();

        for (var key in this) {
            delete this[key];
        }
    },

    /**
     * タイマーで実行されたコールバックの最後の戻り値を取得する
     *
     * @return {Mixied} タイマーで実行されたコールバックの最後の戻り値
     */
    getLastResult: function () {
        return this._lastResult;
    },

    /**
     * タイマーが回った回数を取得する
     *
     * @return {Integer} タイマーが回った回数
     */
    getCount: function () {
        return this._count;
    },

    /**
     * タイマーが回っているかどうかを返す
     *
     * @return {Boolean} タイマーが回っているかどうか
     */
    isEnabled: function () {
        return this._enabled;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Function} func 一定時間毎に呼び出されるコールバック(関数内のthisはここで作成するインスタンスになる)
     * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数
     * @constructor
     */
    constructor: Jeeel.Timer
};
Jeeel.directory.Jeeel.DataStructure = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'DataStructure/';
    }
};

/**
 * データ構造
 */
Jeeel.DataStructure = {
    
};

Jeeel.file.Jeeel.DataStructure = ['Stack', 'Queue', 'Deque', 'List', 'Tree'];

Jeeel._autoImports(Jeeel.directory.Jeeel.DataStructure, Jeeel.file.Jeeel.DataStructure);
/**
 * コンストラクタ
 * 
 * @class スタックを扱うクラス
 */
Jeeel.DataStructure.Stack = function () {
    this._stack = [];
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Stack} 作成したインスタンス
 */
Jeeel.DataStructure.Stack.create = function () {
    return new this();
};

Jeeel.DataStructure.Stack.prototype = {
    
    /**
     * 内部スタック
     * 
     * @type Array
     * @private
     */
    _stack: [],
    
    /**
     * スタックに値を入れる
     * 
     * @param {Mixied} data 入れる値
     * @return {Jeeel.DataStructure.Stack} 自インスタンス
     */
    push: function (data) {
        this._stack.push(data);
        
        return this;
    },
    
    /**
     * スタックから値を取りだす
     * 
     * @return {Mixied} 取りだした値
     */
    pop: function () {
        return (+this._stack.length ? this._stack.pop() : null);
    },
    
    /**
     * スタックに入っている値を全て削除する
     * 
     * @return {Jeeel.DataStructure.Stack} 自インスタンス
     */
    clear: function () {
        this._stack = [];
        
        return this;
    },
    
    /**
     * スタックのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._stack.length;
    }
};

/**
 * コンストラクタ
 * 
 * @class キューを扱うクラス
 */
Jeeel.DataStructure.Queue = function () {
    this._queue = [];
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Queue} 作成したインスタンス
 */
Jeeel.DataStructure.Queue.create = function () {
    return new this();
};

Jeeel.DataStructure.Queue.prototype = {
    
    /**
     * 内部キュー
     * 
     * @type Array
     * @private
     */
    _queue: [],
    
    /**
     * キューに値を入れる
     * 
     * @param {Mixied} data 入れる値
     * @return {Jeeel.DataStructure.Queue} 自インスタンス
     */
    enqueue: function (data) {
        this._queue.push(data);
        
        return this;
    },
    
    /**
     * キューから値を取りだす
     * 
     * @return {Mixied} 取りだした値
     */
    dequeue: function () {
        return (+this._queue.length ? this._queue.shift() : null);
    },
    
    /**
     * キューに入っている値を全て削除する
     * 
     * @return {Jeeel.DataStructure.Queue} 自インスタンス
     */
    clear: function () {
        this._queue = [];
        
        return this;
    },
    
    /**
     * キューのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._queue.length;
    }
};

/**
 * コンストラクタ
 * 
 * @class デックを扱うクラス
 */
Jeeel.DataStructure.Deque = function () {
    this._deque = [];
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Deque} 作成したインスタンス
 */
Jeeel.DataStructure.Deque.create = function () {
    return new this();
};

Jeeel.DataStructure.Deque.prototype = {
    
    /**
     * 内部デック
     * 
     * @type Array
     * @private
     */
    _deque: [],
    
    /**
     * デックの前方に値を入れる
     *
     * @param {Mixied} data 入れる値
     * @return {Jeeel.DataStructure.Deque} 自インスタンス
     */
    pushFront: function (data) {
        this._deque.unshift(data);

        return this;
    },
    
    /**
     * デックの後方に値を入れる
     *
     * @param {Mixied} data 入れる値
     * @return {Jeeel.DataStructure.Deque} 自インスタンス
     */
    pushBack: function (data) {
        this._deque.push(data);

        return this;
    },

    /**
     * デックの前方から値を取りだす
     *
     * @return {Mixied} 取りだした値
     */
    popFront: function () {
        if (this._deque.length === 0) {
            return null;
        }
        
        return this._deque.shift();
    },

    /**
     * デックの後方から値を取りだす
     *
     * @return {Mixied} 取りだした値
     */
    popBack: function () {
        if (this._deque.length === 0) {
            return null;
        }
        
        return this._deque.pop();
    },
    
    /**
     * デックに入っている値を全て削除する
     * 
     * @return {Jeeel.DataStructure.Deque} 自インスタンス
     */
    clear: function () {
        this._deque = [];
        
        return this;
    },
    
    /**
     * デックのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._deque.length;
    }
};
Jeeel.directory.Jeeel.DataStructure.List = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.DataStructure + 'List/';
    }
};

/**
 * コンストラクタ
 * 
 * @class リストを扱うクラス
 */
Jeeel.DataStructure.List = function () {
    this._dummyNode = new this.constructor.Node(null);
    
    this._dummyNode._prev = this._dummyNode;
    this._dummyNode._next = this._dummyNode;
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.List} 作成したインスタンス
 */
Jeeel.DataStructure.List.create = function () {
    return new this();
};

Jeeel.DataStructure.List.prototype = {
    
    /**
     * 番兵ノード
     * 
     * @type Jeeel.DataStructure.List.Node
     * @private
     */
    _dummyNode: null,
    
    /**
     * データサイズ
     * 
     * @type Integer
     * @private
     */
    _size: 0,
    
    /**
     * 先頭ノードを取得する
     * 
     * @return {Jeeel.DataStructure.List.Node} 先頭ノード
     */
    getFirst: function () {
        return this._size && this._dummyNode._next || null;
    },

    /**
     * 後方ノードを取得する
     * 
     * @return {Jeeel.DataStructure.List.Node} 後方ノード
     */
    getLast: function () {
        return this._size && this._dummyNode._prev || null;
    },
    
    /**
     * 指定ノードの後に新しいノードを挿入する
     * 
     * @param {Jeeel.DataStructure.List.Node} node 起点ノード
     * @param {Jeeel.DataStructure.List.Node} newNode 追加ノード
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    insertAfter: function (node, newNode) {
        if ( ! node) {
            node = this._dummyNode;
        }
        
        newNode._next = node._next;
        newNode._prev = node;
        newNode._next._prev = newNode;
        node._next = newNode;
        
        this._size++;
        
        return this;
    },
    
    /**
     * 指定ノードの前に新しいノードを挿入する
     * 
     * @param {Jeeel.DataStructure.List.Node} node 起点ノード
     * @param {Jeeel.DataStructure.List.Node} newNode 追加ノード
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    insertBefore: function (node, newNode) {
        if ( ! node) {
            node = this._dummyNode;
        }
        
        newNode._next = node;
        newNode._prev = node._prev;
        newNode._prev._next = newNode;
        node._prev = newNode;
        
        this._size++;
        
        return this;
    },
    
    /**
     * ノードを追加する
     * 
     * @param {Jeeel.DataStructure.List.Node} node 追加ノード
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    appendNode: function (node) {
        return this.insertBefore(null, node);
    },
    
    /**
     * ノードを削除する
     * 
     * @param {Jeeel.DataStructure.List.Node} node 削除ノード
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    removeNode: function (node) {
        var prev = node._prev;
        var next = node._next;
        
        prev._next = next;
        next._prev = prev;
        
        delete node;
        
        this._size--;
        
        return this;
    },
    
    /**
     * データを追加する
     * 
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    appendData: function (data) {
        return this.insertBefore(null, new this.constructor.Node(data));
    },
    
    /**
     * 指定された関数を各要素に一度ずつ実行する
     *
     * @param {Function} callback void callback(Mixied data, Jeeel.DataStructure.List.Node node, Jeeel.DataStructure.List list)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    forEach: function (callback, thisArg) {
        var node = this._dummyNode._next;
        
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        while(node !== this._dummyNode) {
            callback.call(thisArg, node.getData(), node, this);
            
            node = node._next;
        }

        return this;
    },
    
    /**
     * インスタンスを配列に変換する
     * 
     * @return {Array} 変換後の配列
     */
    toArray: function () {
        var node = this._dummyNode._next;
        var arr  = [];
        
        while (node !== this._dummyNode) {
            arr[arr.length] = node.getData();
            
            node = node._next;
        }
        
        return arr;
    },
    
    /**
     * インスタンスを反転配列に変換する
     * 
     * @return {Array} 変換後の配列
     */
    toReverseArray: function () {
        var node = this._dummyNode._prev;
        var arr  = [];
        
        while (node !== this._dummyNode) {
            arr[arr.length] = node.getData();
            
            node = node._prev;
        }
        
        return arr;
    },
    
    /**
     * リストに入っている値を全て削除する
     * 
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    clear: function () {
        var node = this._dummyNode._next;
        
        // GCに必ず回収されるように全ての参照を切る
        while (node !== this._dummyNode) {
            delete node._prev;
            node = node._next;
        }
        
        this._dummyNode._prev = this._dummyNode;
        this._dummyNode._next = this._dummyNode;
        this._size = 0;
        
        return this;
    },
    
    /**
     * リストのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._size;
    },
   
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.DataStructure.List
};

Jeeel.file.Jeeel.DataStructure.List = ['Node'];

Jeeel._autoImports(Jeeel.directory.Jeeel.DataStructure.List, Jeeel.file.Jeeel.DataStructure.List);
/**
 * コンストラクタ
 * 
 * @class リスト内のノードを扱うクラス
 * @param {Mixied} data ノードが扱うデータ
 * @param {Jeeel.DataStructure.List.Node} [prev] 前方のノード
 * @param {Jeeel.DataStructure.List.Node} [next] 後方のノード
 */
Jeeel.DataStructure.List.Node = function (data, prev, next) {
    this._data = data;
    this._prev = prev || null;
    this._next = next || null;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Mixied} data ノードが扱うデータ
 * @param {Jeeel.DataStructure.List.Node} [prev] 前方のノード
 * @param {Jeeel.DataStructure.List.Node} [next] 後方のノード
 * @return {Jeeel.DataStructure.List.Node} 作成したインスタンス
 */
Jeeel.DataStructure.List.Node.create = function (data, prev, next) {
    return new this(data, prev, next);
};

Jeeel.DataStructure.List.Node.prototype = {
  
    /**
     * 前方ノード
     * 
     * @type Jeeel.DataStructure.List.Node
     * @private
     */
    _prev: null,
    
    /**
     * 後方ノード
     * 
     * @type Jeeel.DataStructure.List.Node
     * @private
     */
    _next: null,
    
    /**
     * データ
     * 
     * @type Mixied
     * @private
     */
    _data: null,
    
    /**
     * データを取得する
     * 
     * @return {Mixied} データ
     */
    getData: function () {
        return this._data;
    },
    
    /**
     * 前方ノードを取得する
     * 
     * @return {Jeeel.DataStructure.List.Node} 前方ノード
     */
    getPrevious: function () {
        return this._prev;
    },
    
    /**
     * 後方ノードを取得する
     * 
     * @return {Jeeel.DataStructure.List.Node} 後方ノード
     */
    getNext: function () {
        return this._next;
    },
      
    /**
     * コンストラクタ
     * 
     * @param {Mixied} data ノードが扱うデータ
     * @param {Jeeel.DataStructure.List.Node} [prev] このノードの前のノード
     * @param {Jeeel.DataStructure.List.Node} [next] このノードの次のノード
     * @constructor
     */
    constructor: Jeeel.DataStructure.List.Node,
    
    /**
     * ノード内のデータを返す
     * 
     * @return {Mixied} データ
     */
    valueOf: function () {
        return this._data;
    },
    
    /**
     * ノード内のデータを文字列変換して返す
     * 
     * @return {String} データ文字列
     */
    toString: function () {
        return (this._data || '' + this._data).toString();
    }
};Jeeel.directory.Jeeel.DataStructure.Tree = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.DataStructure + 'Tree/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 木構造を扱うクラス
 * @ignore 未完成
 */
Jeeel.DataStructure.Tree = function () {
    
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Tree} 作成したインスタンス
 */
Jeeel.DataStructure.Tree.create = function () {
    return new this();
};

Jeeel.DataStructure.Tree.prototype = {
  
    /**
     * ルートノード
     * 
     * @type Jeeel.DataStructure.Tree.Node
     * @private
     */
    _root: null,
    
    /**
     * ルートノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node} ルートノード
     */
    getRoot: function () {
        return this._root;
    },
    
    /**
     * データを追加する
     * 
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.Tree} 自インスタンス
     */
    appendData: function (data) {
        if ( ! this._root) {
            this._root = new this.constructor.Node(data);
            
            return this;
        }
        
        this._root.appendData(data);
        
        return this;
    },
    
    /**
     * ツリーのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._root.getSize();
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.DataStructure.Tree
};

Jeeel.file.Jeeel.DataStructure.Tree = ['Node', 'Binary'];

Jeeel._autoImports(Jeeel.directory.Jeeel.DataStructure.Tree, Jeeel.file.Jeeel.DataStructure.Tree);
/**
 * コンストラクタ
 * 
 * @class ツリー内のノードを扱うクラス
 * @param {Mixied} data ノードデータ
 * @param {Jeeel.DataStructure.Tree.Node} [parent] 親ノード
 */
Jeeel.DataStructure.Tree.Node = function (data, parent) {
    this._data = data;
    this._children = [];
    this._parent = parent || null;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Mixied} data ノードデータ
 * @param {Jeeel.DataStructure.Tree.Node} [parent] 親ノード
 * @return {Jeeel.DataStructure.Tree.Node} 作成したインスタンス
 */
Jeeel.DataStructure.Tree.Node.create = function (data, parent) {
    return new this(data, parent);
};

Jeeel.DataStructure.Tree.Node.prototype = {
  
    /**
     * 親ノード
     * 
     * @type Jeeel.DataStructure.Tree.Node
     * @private
     */
    _parent: null,
    
    /**
     * 子ノードリスト
     * 
     * @type Jeeel.DataStructure.Tree.Node[]
     * @private
     */
    _children: [],
    
    /**
     * データ
     * 
     * @type Mixied
     * @private
     */
    _data: null,
    
    /**
     * データを取得する
     * 
     * @return {Mixied} データ
     */
    getData: function () {
        return this._data;
    },
    
    /**
     * 親ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node} 親ノード
     */
    getParent: function () {
        return this._parent;
    },
    
    /**
     * 子ノードリストを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node[]} 子ノードリスト
     */
    getChildren: function () {
        return this._children;
    },
    
    /**
     * 最初に追加した子ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node} 最初の子ノード
     */
    getFirstChild: function () {
        return this._children[0] || null;
    },
    
    /**
     * 最後に追加した1子ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node} 最後の子ノード
     */
    getLastChild: function () {
        return this._children[this._children.length - 1] || null;
    },
    
    /**
     * データを追加する
     * 
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.Tree.Node} 自インスタンス
     */
    appendData: function (data) {
        this._children[this._children.length] = new this.constructor(data, this);
        
        return this;
    },
    
    /**
     * 子ノードの数を取得する
     * 
     * @return {Integer} 子ノードの数
     */
    getDegree: function () {
        return this._children.length;
    },
    
    /**
     * このノードに紐づく全てのデータ数を取得する
     * 
     * @return {Integer} データ数
     */
    getSize: function () {
        var size = 1;
        
        for (var i = this._children.length; i--;) {
            size += this._children[i].getSize();
        }
        
        return size;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Mixied} data ノードデータ
     * @param {Jeeel.DataStructure.Tree.Node} [parent] 親ノード
     * @constructor
     */
    constructor: Jeeel.DataStructure.Tree.Node,
    
    /**
     * ノード内のデータを返す
     * 
     * @return {Mixied} データ
     */
    valueOf: function () {
        return this._data;
    },
    
    /**
     * ノード内のデータを文字列変換して返す
     * 
     * @return {String} データ文字列
     */
    toString: function () {
        return (this._data || '' + this._data).toString();
    }
};Jeeel.directory.Jeeel.DataStructure.Tree.Binary = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.DataStructure.Tree + 'Binary/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 二分木を扱うクラス
 * @augments Jeeel.DataStructure.Tree
 */
Jeeel.DataStructure.Tree.Binary = function () {
    Jeeel.DataStructure.Tree.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Tree.Binary} 作成したインスタンス
 */
Jeeel.DataStructure.Tree.Binary.create = function () {
    return new this();
};

Jeeel.DataStructure.Tree.Binary.prototype = {
    
    /**
     * データを追加する
     * 
     * @param {Integer} order オーダー
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.Tree.Binary} 自インスタンス
     */
    appendData: function (order, data) {
        if ( ! this._root) {
            this._root = new this.constructor.Node(order, data);
            
            return this;
        }
        
        this._root.appendData(order, data);
        
        return this;
    },
    
    /**
     * オーダーからノードを検索する
     * 
     * @param {Integer} order オーダー
     * @return {Jeeel.DataStructure.Tree.Node} 取得ノード
     */
    search: function (order) {
        return this._root && this._root.search(order);
    },
    
    /**
     * オーダーからデータを検索する
     * 
     * @param {Integer} order オーダー
     * @return {Mixied} 取得データ
     */
    searchData: function (order) {
        return this._root && this._root.searchData(order);
    }
};

Jeeel.Class.extend(Jeeel.DataStructure.Tree.Binary, Jeeel.DataStructure.Tree);

Jeeel.file.Jeeel.DataStructure.Tree.Binary = ['Node', 'Order'];

Jeeel._autoImports(Jeeel.directory.Jeeel.DataStructure.Tree.Binary, Jeeel.file.Jeeel.DataStructure.Tree.Binary);

/**
 * コンストラクタ
 * 
 * @class ツリー内のノードを扱うクラス
 * @param {Integer} order オーダー
 * @param {Mixied} data ノードデータ
 * @param {Jeeel.DataStructure.Tree.Binary.Node} [parent] 親ノード
 */
Jeeel.DataStructure.Tree.Binary.Node = function (order, data, parent) {
    Jeeel.DataStructure.Tree.Node.call(this, data, parent);
    
    this._order = order;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Integer} order オーダー
 * @param {Mixied} data ノードデータ
 * @param {Jeeel.DataStructure.Tree.Binary.Node} [parent] 親ノード
 * @return {Jeeel.DataStructure.Tree.Binary.Node} 作成したインスタンス
 */
Jeeel.DataStructure.Tree.Binary.Node.create = function (order, data, parent) {
    return new this(order, data, parent);
};

Jeeel.DataStructure.Tree.Binary.Node.prototype = {
    
    /**
     * 検索及びデータ追加に使用するオーダー
     * 
     * @type Integer
     * @private
     */
    _order: 0,
    
    /**
     * 右の子ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Binary.Node} 右の子ノード
     */
    getRightChild: function () {
        return this._children[1] || null;
    },
    
    /**
     * 左の子ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Binary.Node} 左の子ノード
     */
    getLeftChild: function () {
        return this._children[0] || null;
    },
    
    /**
     * データを追加する
     * 
     * @param {Integer} order オーダー
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.Tree.Node} 自インスタンス
     */
    appendData: function (order, data) {

        if (order < this._order) {
            if (this._children[0]) {
                this._children[0].appendData(order, data);
            } else {
                this._children[0] = new this.constructor(order, data, this);
            }
        } else {
            if (this._children[1]) {
                this._children[1].appendData(order, data);
            } else {
                this._children[1] = new this.constructor(order, data, this);
            }
        }

        return this;
    },
    
    /**
     * オーダーからノードを検索する
     * 
     * @param {Integer} order オーダー
     * @return {Jeeel.DataStructure.Tree.Node} 取得ノード
     */
    search: function (order) {
        if (this._order === order) {
            return this;
        } else if (this._order < order) {
            return this._children[0] && this._children[0].search(order) || null;
        } else {
            return this._children[1] && this._children[1].search(order) || null;
        }
    },
    
    /**
     * オーダーからデータを検索する
     * 
     * @param {Integer} order オーダー
     * @return {Mixied} 取得データ
     */
    searchData: function (order) {
        var node = this.search(order);
        
        return node && node.getData();
    }
};

Jeeel.Class.extend(Jeeel.DataStructure.Tree.Binary.Node, Jeeel.DataStructure.Tree.Node);

/**
 * 二分木の内部の並び順の列挙体
 */
Jeeel.DataStructure.Tree.Binary.Order = {
    LEFT_LESS: 0
};Jeeel.directory.Jeeel.Object = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Object/';
    }
};

/**
 * 汎用オブジェクト関連のネームスペース
 */
Jeeel.Object = {

};

Jeeel.file.Jeeel.Object = ['Item', 'Point', 'Size', 'Rect', 'Color', 'Date', 'Fraction', 'Font', 'Technical'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Object, Jeeel.file.Jeeel.Object);

/**
 * コンストラクタ
 *
 * @class キーと値のペアを保持するクラス
 * @param {String} key キー
 * @param {Mixied} value 値
 */
Jeeel.Object.Item = function (key, value) {

    /**
     * キー
     *
     * @type String
     */
    this.key = key;

    /**
     * 値
     * 
     * @type Mixied
     */
    this.value = value;
};

Jeeel.Object.Item.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Item} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Item(this.key, this.value);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Item} item 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (item) {
        return this.key === item.key
            && this.value === item.value;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return this.key + '=' + this.value;
    }
};

/**
 * コンストラクタ
 *
 * @class 座標を扱うクラス
 * @param {Integer} x X座標
 * @param {Integer} y Y座標
 */
Jeeel.Object.Point = function (x, y) {

    /**
     * X座標
     *
     * @type Integer
     */
    this.x = x;

    /**
     * Y座標
     *
     * @type Integer
     */
    this.y = y;
};

Jeeel.Object.Point.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Point} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Point(this.x, this.y);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Point} point 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (point) {
        return this.x === point.x
            && this.y === point.y;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return '(' + this.x + ', ' + this.y + ')';
    }
};

/**
 * コンストラクタ
 *
 * @class サイズを扱うクラス
 * @param {Integer} width 幅
 * @param {Integer} height 高さ
 */
Jeeel.Object.Size = function (width, height) {

    /**
     * 幅
     *
     * @type Integer
     */
    this.width = width;

    /**
     * 高さ
     *
     * @type Integer
     */
    this.height = height;
};

Jeeel.Object.Size.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Size} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Size(this.width, this.height);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Size} size 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (size) {
        return this.width === size.width
            && this.height === size.height;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return this.width + ' × ' + this.height;
    }
};

/**
 * コンストラクタ
 *
 * @class 四角形扱うクラス
 * @param {Integer} x 左辺のX座標
 * @param {Integer} y 上辺のY座標
 * @param {Integer} width 幅
 * @param {Integer} height 高さ
 */
Jeeel.Object.Rect = function (x, y, width, height) {};

/**
 * コンストラクタ
 *
 * @class 四角形扱うクラス
 * @param {Jeeel.Object.Point} startPoint 四角形の左上端の座標
 * @param {Jeeel.Object.Point} endPoint 四角形の右下端の座標
 */
Jeeel.Object.Rect = function (startPoint, endPoint) {};

/**
 * コンストラクタ
 *
 * @class 四角形扱うクラス
 * @param {Jeeel.Object.Point} point 四角形の左上端の座標
 * @param {Jeeel.Object.Size} size 四角形の幅と高さ
 */
Jeeel.Object.Rect = function (point, size) {
    
    var rect = [];

    switch (arguments.length) {
        case 2:
            if (arguments[1] instanceof Jeeel.Object.Point) {
                rect[0] = Math.min(arguments[0].x, arguments[1].x);
                rect[1] = Math.min(arguments[0].y, arguments[1].y);
                rect[2] = Math.abs(arguments[1].x - arguments[0].x);
                rect[3] = Math.abs(arguments[1].y - arguments[0].y);
                point = new Jeeel.Object.Point(rect[0], rect[1]);
                size  = new Jeeel.Object.Size(rect[2], rect[3]);
            } else {
                rect[0] = point.x;
                rect[1] = point.y;
                rect[2] = size.width;
                rect[3] = size.height;
                point = new Jeeel.Object.Point(rect[0], rect[1]);
                size  = new Jeeel.Object.Size(rect[2], rect[3]);
            }
            break;

        case 4:
            rect[0] = arguments[0];
            rect[1] = arguments[1];
            rect[2] = arguments[2];
            rect[3] = arguments[3];
            point = new Jeeel.Object.Point(rect[0], rect[1]);
            size  = new Jeeel.Object.Size(rect[2], rect[3]);
            break;

        default:
            throw new Error('引数の数が違います。');
            break;
    }

    /**
     * X座標
     *
     * @type Integer
     */
    this.x = rect[0];

    /**
     * Y座標
     *
     * @type Integer
     */
    this.y = rect[1];

    /**
     * 幅
     *
     * @type Integer
     */
    this.width = rect[2];

    /**
     * 高さ
     *
     * @type Integer
     */
    this.height = rect[3];

    /**
     * 左上端の座標
     *
     * @type Jeeel.Object.Point
     */
    this.point = point;

    /**
     * 四角形の幅と高さ
     *
     * @type Jeeel.Object.Size
     */
    this.size = size;
    
    /**
     * 始点(左上端の座標)
     * 
     * @type Jeeel.Object.Point
     */
    this.startPoint = point;
    
    /**
     * 終点(右下端の座標)
     * 
     * @type Jeeel.Object.Point
     */
    this.endPoint = new Jeeel.Object.Point(this.x + this.width, this.y + this.height);
};

Jeeel.Object.Rect.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Rect} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Rect(this.x, this.y, this.width, this.height);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Rect} rect 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (rect) {
        return this.x === rect.x
            && this.y === rect.y
            && this.width === rect.width
            && this.height === rect.height;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return '(' + this.x + ', ' + this.y + ', ' + this.width + ', ' + this.height + ')';
    }
};


Jeeel.directory.Jeeel.Object.Color = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Object + 'Color/';
    }
};

/**
 * コンストラクタ
 *
 * @class 色を扱うクラス
 * @param {Mixied} color 色を表す値
 */
Jeeel.Object.Color = function (color) {
    var rgb, hsl;
    
    if (color instanceof this.constructor.Rgb) {
        rgb = color;
        hsl = this.constructor.rgbToHsl(rgb);
    } else if (color instanceof this.constructor.Hsl) {
        hsl = color;
        rgb = this.constructor.hslToRgb(hsl);
    }
    
    this._rgb = rgb;
    this._hsl = hsl;
};

/**
 * RGBから色を作成する
 *
 * @param {String} rgbString RGBを示す文字列(先頭に#や0xが付いていても良い)<br />
 *                            1色につき1桁もしくは2桁
 * @return {Jeeel.Object.Color} 作成したインスタンス
 */
Jeeel.Object.Color.createRgbString = function (rgbString) {
    return new this(new this.Rgb(rgbString));
};

/**
 * RGBから色を作成する
 *
 * @param {Integer} red 赤
 * @param {Integer} green 緑
 * @param {Integer} blue 青
 * @param {Number} [alpha] アルファ
 * @return {Jeeel.Object.Color} 作成したインスタンス
 */
Jeeel.Object.Color.createRgb = function (red, green, blue, alpha) {
    if ( ! alpha && alpha !== 0) {
        alpha = 1;
    }
    
    return new this(new this.Rgb(red, green, blue, alpha));
};

/**
 * HSLから色を作成する
 *
 * @param {Integer} hue 色相
 * @param {Number} saturation 彩度
 * @param {Number} luminance 輝度
 * @param {Number} [alpha] アルファ
 * @return {Jeeel.Object.Color} 作成したインスタンス
 */
Jeeel.Object.Color.createHsl = function (hue, saturation, luminance, alpha) {
    if ( ! alpha && alpha !== 0) {
        alpha = 1;
    }
    
    return new this(new this.Hsl(hue, saturation, luminance, alpha));
};

/**
 * RGBからHSLを計算する
 * 
 * @param {Integer} red 赤
 * @param {Integer} green 緑
 * @param {Integer} blue 青
 * @return {Hash} hue: 色相, saturation: 彩度, luminance: 輝度
 */
Jeeel.Object.Color.calculateHsl = function (red, green, blue) {
    var r = (red & 255) / 255;
    var g = (green & 255) / 255;
    var b = (blue & 255) / 255;

    var max, min,
        h, l, s;
    
    max = r > g ? r : g > b ? g : b;
    min = r < g ? r : g < b ? g : b;
    
    l = (max + min) / 2;

    if (max === min) {
        s = 0;
        h = 0;
    } else {
        var sub = max - min;
        
        if (l <= 0.5) {
            s = sub / (max + min);
        } else {
            s = sub / (2 - sub);
        }

        var cr = (max - r) / sub;
        var cg = (max - g) / sub;
        var cb = (max - b) / sub;

        switch (max) {
            case r:
                h = cb - cg;
                break;

            case g:
                h = 2 + cr - cb;
                break;

            case b:
                h = 4 + cg - cr;
                break;
                
            default:
                break;
        }

        h = 60 * h;

        if (h < 0) {
            h += 360;
        }
    }
    
    return {hue: h, saturation: s, luminance: l};
};

/**
 * RGBインスタンスをHSLインスタンスに変換する
 * 
 * @param {Jeeel.Object.Color.Rgb} rgb RGBインスタンス
 * @return {Jeeel.Object.Color.Hsl} 変換後のインスタンス
 */
Jeeel.Object.Color.rgbToHsl = function (rgb) {
    var hsl = this.calculateHsl(rgb.red, rgb.green, rgb.blue);

    return new Jeeel.Object.Color.Hsl(hsl.hue, hsl.saturation, hsl.luminance);
};

/**
 * HSLからRGBを計算する
 * 
 * @param {Integer} hue 色相
 * @param {Number} saturation 彩度
 * @param {Number} luminance 輝度
 * @return {Hash} red: 赤, green: 緑, blue: 青
 */
Jeeel.Object.Color.calculateRgb = function (hue, saturation, luminance) {
    var h = Jeeel.Number.limit(hue, 0, 360);
    var s = Jeeel.Number.limit(saturation, 0, 1);
    var l = Jeeel.Number.limit(luminance, 0, 1);
    
    var max, min;
    var list = [];

    if (l <= 0.5) {
        max = l * (1 + s);
    } else {
        max = l * (1 - s) + s;
    }

    min = 2 * l - max;

    if (s === 0) {
        list[0] = list[1] = list[2] = l;
    } else {
        var hVal = h + 120;
        var sub = max - min;
        
        if (hVal >= 360) {
            hVal = hVal - 360;
        }

        for (var i = 0; i < 3; i++) {

            if (hVal < 60) {
                list[i] = min + sub * hVal / 60;
            } else if(hVal < 180) {
                list[i] = max;
            } else if(hVal < 240) {
                list[i] = min + sub * (240 - hVal) / 60;
            } else {
                list[i] = min;
            }

            if (i === 0) {
                hVal = h;
            } else if(i === 1) {
                hVal = h - 120;

                if (hVal < 0) {
                    hVal = hVal + 360;
                }
            }
        }
    }

    return {red: list[0] * 255, green: list[1] * 255, blue: list[2] * 255};
};

/**
 * HSLインスタンスをRGBインスタンスに変換する
 * 
 * @param {Jeeel.Object.Color.Hsl} hsl HSLインスタンス
 * @return {Jeeel.Object.Color.Rgb} 変換後のインスタンス
 */
Jeeel.Object.Color.hslToRgb = function (hsl) {
    var rgb = this.calculateRgb(hsl.hue, hsl.saturation, hsl.luminance);

    return new Jeeel.Object.Color.Rgb(rgb.red, rgb.green, rgb.blue);
};

Jeeel.Object.Color.prototype = {
  
    /**
     * RGB形式の色を扱うオブジェクト
     * 
     * @type Jeeel.Object.Color.Rgb
     * @private
     */
    _rgb: null,
    
    /**
     * HSL形式の色を扱うオブジェクト
     * 
     * @type Jeeel.Object.Color.Hsl
     * @private
     */
    _hsl: null,
    
    /**
     * RGBインスタンスに変換する
     * 
     * @return {Jeeel.Object.Color.Rgb} RGBインスタンス
     */
    toRgb: function () {
        return this._rgb;
    },
    
    /**
     * HSLインスタンスに変換する
     * 
     * @return {Jeeel.Object.Color.Hsl} RGBインスタンス
     */
    toHsl: function () {
        return this._hsl;
    },
    
    /**
     * アルファブレンドを行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color ブレンドする色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    alphaBlend: function (color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }

        var destColor   = this._rgb;
        var sourceColor = color.toRgb();

        var res;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);

        if (alpha === 0) {
            res = new this.constructor(destColor.clone());
        }
        else if (alpha === 0xFF || dstA === 0) {
            res = new this.constructor(sourceColor.clone());
        }
        else if (dstA === 0xFF) {
            res = this.constructor.createRgb(
                ((sourceColor.red - dstR) * alpha >> 8) + dstR, 
                ((sourceColor.green - dstG) * alpha >> 8) + dstG, 
                ((sourceColor.blue - dstB) * alpha >> 8) + dstB, 
                1
            );
        }
        else {
            dstA = ((0xFF - alpha) * dstA >> 8) & 0xFF;

            res = (alpha + dstA) & 0xFF;

            res = this.constructor.createRgb(
                (sourceColor.red   * alpha + dstR * dstA) / res, 
                (sourceColor.green * alpha + dstG * dstA) / res, 
                (sourceColor.blue  * alpha + dstB * dstA) / res, 
                res / 0xFF
            );
        }
        
        alpha = parseInt(res._rgb.alpha * 0xFF);

        if (alpha === 0) {
            res = this.constructor.createRgb(0, 0, 0, 0);
        }
        else if (alpha !== 0xFF) {
            res = this.constructor.createRgb(
                res._rgb.red * alpha >> 8, 
                res._rgb.green * alpha >> 8, 
                res._rgb.blue * alpha >> 8, 
                alpha / 0xFF
            );
        }

        return res;
    },
    
    /**
     * 加算合成を行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 加算する色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    addBlend: function (color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }
        
        var destColor   = this._rgb;
        var sourceColor = color.toRgb();
        
        var res;
        var srcR = sourceColor.red;
        var srcG = sourceColor.green;
        var srcB = sourceColor.blue;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        var tmp;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);
        
        if (alpha === 0) {
            res = destColor.clone();
        }
        else if (alpha === 0xFF && dstA === 0xFF) {
            res = this.constructor.createRgb(
                ((tmp = srcR + dstR) > 0xFF ? 0xFF : tmp), 
                ((tmp = srcG + dstG) > 0xFF ? 0xFF : tmp), 
                ((tmp = srcB + dstB) > 0xFF ? 0xFF : tmp), 
                1
            );
        }
        else {
            res = this.constructor.createRgb(
                (((tmp = (srcR * alpha + dstR * dstA) >> 8)) > 0xFF ? 0xFF : tmp), 
                (((tmp = (srcG * alpha + dstG * dstA) >> 8)) > 0xFF ? 0xFF : tmp), 
                (((tmp = (srcB * alpha + dstB * dstA) >> 8)) > 0xFF ? 0xFF : tmp), 
                dstA / 0xFF
            );
        }

        return res;
    },
    
    /**
     * 減算合成を行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 減算する色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    subBlend: function(color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }
        
        var destColor   = this._rgb;
        var sourceColor = color.toRgb();
        
        var res;
        var srcR = sourceColor.red;
        var srcG = sourceColor.green;
        var srcB = sourceColor.blue;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        var tmp;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);

        if (alpha === 0) {
            res = destColor.clone();
        }
        else if (alpha === 0xFF && dstA === 0xFF) {
            res = this.constructor.createRgb(
                ((tmp = dstR - srcR) < 0 ? 0 : tmp),
                ((tmp = dstG - srcG) < 0 ? 0 : tmp),
                ((tmp = dstB - srcB) < 0 ? 0 : tmp),
                1
            );
        }
        else {
            res = this.constructor.createRgb(
                ((tmp = (dstR * dstA - srcR * alpha) >> 8) < 0 ? 0 : tmp),
                ((tmp = (dstG * dstA - srcG * alpha) >> 8) < 0 ? 0 : tmp),
                ((tmp = (dstB * dstA - srcB * alpha) >> 8) < 0 ? 0 : tmp),
                dstA / 0xFF
            );
        }

        return res;
    },
    
    /**
     * 乗算合成を行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 乗算する色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    mulBlend: function (color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }
        
        var destColor   = this._rgb;
        var sourceColor = color.toRgb();
        
        var res;
        var srcR = sourceColor.red;
        var srcG = sourceColor.green;
        var srcB = sourceColor.blue;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);

        if (alpha === 0) {
            res = destColor.clone();
        }
        else if (alpha === 0xFF && dstA === 0xFF) {
            res = this.constructor.createRgb(
                (srcR * dstR >> 8),
                (srcG * dstG >> 8),
                (srcB * dstB >> 8),
                1
            );
        }
        else {
            res = this.constructor.createRgb(
                ((dstR * dstA >> 8) * (0xFF + ((srcR - 0xFF) * alpha >> 8)) >> 8),
                ((dstG * dstA >> 8) * (0xFF + ((srcG - 0xFF) * alpha >> 8)) >> 8),
                ((dstB * dstA >> 8) * (0xFF + ((srcB - 0xFF) * alpha >> 8)) >> 8),
                dstA / 0xFF
            );
        }

        return res;
    },
    
    /**
     * 除算合成を行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 除算する色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    divBlend: function (color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }
        
        var destColor   = this._rgb;
        var sourceColor = color.toRgb();
        
        var res;
        var srcR = sourceColor.red;
        var srcG = sourceColor.green;
        var srcB = sourceColor.blue;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);

        if (alpha === 0) {
            res = destColor.clone();
        }
        else if (alpha === 0xFF && dstA === 0xFF) {
            res = this.constructor.createRgb(
                ((dstR << 8) / (srcR + 1)),
                ((dstG << 8) / (srcG + 1)),
                ((dstB << 8) / (srcB + 1)),
                1
            );
        }
        else {
            res = this.constructor.createRgb(
                ((dstR * dstA) / ((0xFF + ((srcR - 0xFF) * alpha >> 8)) + 1)),
                ((dstG * dstA) / ((0xFF + ((srcG - 0xFF) * alpha >> 8)) + 1)),
                ((dstB * dstA) / ((0xFF + ((srcB - 0xFF) * alpha >> 8)) + 1)),
                dstA / 0xFF
            );
        }

        return res;
    },
    
    /**
     * コンストラクタ
     *
     * @param {Mixied} color 色を表す値
     * @constructor
     */
    constructor: Jeeel.Object.Color
};

Jeeel.file.Jeeel.Object.Color = ['Rgb', 'Hsl'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Object.Color, Jeeel.file.Jeeel.Object.Color);
/**
 * コンストラクタ
 *
 * @class RGB形式の色を扱うクラス
 * @param {String} rgbString RGBを示す文字列(先頭に#や0xが付いていても良い)<br />
 *                            1色につき1桁もしくは2桁
 */
Jeeel.Object.Color.Rgb = function (rgbString) {};

/**
 * コンストラクタ
 *
 * @class RGB形式の色を扱うクラス
 * @param {Integer} red 赤
 * @param {Integer} green 緑
 * @param {Integer} blue 青
 */
Jeeel.Object.Color.Rgb = function (red, green, blue) {};

/**
 * コンストラクタ
 *
 * @class RGB形式の色を扱うクラス
 * @param {Integer} red 赤
 * @param {Integer} green 緑
 * @param {Integer} blue 青
 * @param {Number} alpha アルファ
 */
Jeeel.Object.Color.Rgb = function (red, green, blue, alpha) {
  
    switch (arguments.length) {
        case 1:
            var rgbString = '' + arguments[0];
            
            rgbString = rgbString.replace(/^(#|0x)/, '');
            
            if (rgbString.match(/^rgb\(/)) {
                rgbString = rgbString.replace('rgb(', '').replace(')', '').replace(/ /g, '');
                
                var rgb = rgbString.split(',');
                
                red   = +rgb[0];
                green = +rgb[1];
                blue  = +rgb[2];
            } else {
                if (rgbString.length != 3 && rgbString.length != 6) {
                    throw new Error('rgb文字列の長さが不自然です。');
                } else if ( ! Jeeel.Type.isHexadecimalNumber(rgbString)) {
                    throw new Error('rgb文字列の形式が正しくありません。');
                }

                if (rgbString.length == 3) {
                    red   = ('0x' + rgbString.charAt(0)) * 17;
                    green = ('0x' + rgbString.charAt(1)) * 17;
                    blue  = ('0x' + rgbString.charAt(2)) * 17;
                } else {
                    red   = +('0x' + rgbString.substr(0, 2));
                    green = +('0x' + rgbString.substr(2, 2));
                    blue  = +('0x' + rgbString.substr(4, 2));
                }
            }
            
            alpha = 1;
            break;

        case 3:
            red   = +red;
            green = +green;
            blue  = +blue;
            alpha = 1;
            break;
            
        case 4:
            red   = +red;
            green = +green;
            blue  = +blue;
            alpha = +alpha;
            break;

        default:
            throw new Error('引数の数が違います。');
            break;
    }

    /**
     * 赤
     *
     * @type Integer
     */
    this.red = Math.round(red) & 255;

    /**
     * 緑
     *
     * @type Integer
     */
    this.green = Math.round(green) & 255;
    
    /**
     * 青
     *
     * @type Integer
     */
    this.blue = Math.round(blue) & 255;
    
    /**
     * アルファ
     *
     * @type Number
     */
    this.alpha = Jeeel.Number.limit(alpha, 0, 1);
};

Jeeel.Object.Color.Rgb.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Color.Rgb} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Color.Rgb(this.red, this.green, this.blue);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Color.Rgb} item 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (item) {
        return this.red === item.red
            && this.green === item.green
            && this.blue === item.blue;
    },
    
    /**
     * RGB文字列に変換する
     * 
     * @param {String} [prefix] 接頭辞
     * @return {String} 小文字の16進数を接続した6桁+接頭辞の文字列
     */
    toRgbString: function (prefix) {
        var i, rgb =[this.red.toString(16), this.green.toString(16), this.blue.toString(16)];
        
        for (i = 3; i--;) {
            if (rgb[i].length < 2) {
                rgb[i] = '0' + rgb[i];
            }
        }
        
        return (prefix || '') + rgb.join('');
    },
    
    /**
     * RGBA文字列に変換する
     * 
     * @return {String} RGBA形式に変換した文字列
     */
    toRgbaString: function () {
        return 'rgba('
             + this.red
             + ', '
             + this.green
             + ', '
             + this.blue
             + ', '
             + this.alpha
             + ')';
    },

    /**
     * 文字列に変換する
     *
     * @param {Boolean} [toFunction] 関数表記に変換する時に指定
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function (toFunction) {
        if (toFunction) {
            return 'rgb('
                 + this.red
                 + ', '
                 + this.green
                 + ', '
                 + this.blue
                 + ')';
        }

        return this.toRgbString('#');
    }
};

/**
 * コンストラクタ
 *
 * @class HSL形式の色を扱うクラス
 * @param {Integer} hue 色相
 * @param {Number} saturation 彩度
 * @param {Number} luminance 輝度
 */
Jeeel.Object.Color.Hsl = function (hue, saturation, luminance) {};

/**
 * コンストラクタ
 *
 * @class HSL形式の色を扱うクラス
 * @param {Integer} hue 色相
 * @param {Number} saturation 彩度
 * @param {Number} luminance 輝度
 * @param {Number} alpha アルファ
 */
Jeeel.Object.Color.Hsl = function (hue, saturation, luminance, alpha) {
  
    switch (arguments.length) {
        case 3:
            hue        = +hue;
            saturation = +saturation;
            luminance  = +luminance;
            alpha      = 1;
            break;
            
        case 4:
            hue        = +hue;
            saturation = +saturation;
            luminance  = +luminance;
            alpha      = +alpha;
            break;

        default:
            throw new Error('引数の数が違います。');
            break;
    }
    
    /**
     * 色相(0～360)
     *
     * @type Integer
     */
    this.hue = Math.round(hue > 360 && (hue % 360) || hue);

    /**
     * 彩度(0.0～1.0)
     *
     * @type Number
     */
    this.saturation = Jeeel.Number.limit(saturation, 0, 1);
    
    /**
     * 輝度(0.0～1.0)
     *
     * @type Number
     */
    this.luminance = Jeeel.Number.limit(luminance, 0, 1);
    
    /**
     * アルファ(0.0～1.0)
     *
     * @type Number
     */
    this.alpha = Jeeel.Number.limit(alpha, 0, 1);
};

Jeeel.Object.Color.Hsl.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Color.Hsl} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Color.Hsl(this.hue, this.saturation, this.luminance);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Color.Hsl} item 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (item) {
        return this.hue === item.hue
            && this.saturation === item.saturation
            && this.luminance === item.luminance;
    },

    /**
     * 文字列に変換する
     *
     * @param {Boolean} [toHSLA] アルファ値を加えた値に変換する時に指定
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function (toHSLA) {
        var s = Math.round(this.saturation * 100);
        var l = Math.round(this.luminance * 100);
        
        if (toHSLA) {
            return 'hsla('
                 + this.hue
                 + ', '
                 + s + '%'
                 + ', '
                 + l + '%'
                 + ', '
                 + this.alpha
                 + ')';
        }
        
        return 'hsl('
             + this.hue
             + ', '
             + s + '%'
             + ', '
             + l + '%'
             + ')';
    }
};

/**
 * コンストラクタ
 *
 * @class 日付関係に関する操作を手助けするクラス
 * @param {Date|String|Integer|Jeeel.Object.Date} [date] 基となるDateオブジェクトやDateString(省略は現時刻)
 */
Jeeel.Object.Date = function (date) {

    if (Jeeel.Type.isString(date)) {
        date = new Date(date.replace(/-/g, '/'));
    } else if (Jeeel.Type.isInteger(date)) {
        date = new Date(date);
    } else if (date instanceof Jeeel.Object.Date) {
        date = new Date(date.getTime());
    }

    if ( ! Jeeel.Type.isDate(date)) {
        date = new Date();
    }

    this._date = date;
    
    this._refreshProperty();
    
    this._timestamp = new Date();
};

/**
 * インスタンスの作成を行う
 *
 * @param {Date|String|Integer|Jeeel.Object.Date} [date] 基となるDateオブジェクトやDateString(省略は現時刻)
 * @return {Jeeel.Object.Date} 作成したインスタンス
 */
Jeeel.Object.Date.create = function (date) {
    return new this(date);
};

/**
 * 指定した日付からインスタンスの作成を行う(全省略は現時刻)
 *
 * @param {Integer} [year] 年
 * @param {Integer} [month] 月
 * @param {Integer} [day] 日
 * @param {Integer} [hour] 時
 * @param {Integer} [minute] 分
 * @param {Integer} [second] 秒
 * @param {Integer} [millisecond] ミリ秒
 * @return {Jeeel.Object.Date} 作成したインスタンス
 */
Jeeel.Object.Date.createDate = function (year, month, day, hour, minute, second, millisecond) {
    var i, l = arguments.length;
    
    for (i = 0; i < l; i++) {
        if (Jeeel.Type.isEmpty(arguments[i])) {
            arguments[i] = null;
        }
    }

    if (Jeeel.Type.isSet(month)) {
        arguments[1]--;
    } else if (Jeeel.Type.isSet(year)) {
        arguments[1] = 0;
        l++;
    }
    
    return new this(Jeeel.Function.toNative(Jeeel._global, 'Date', true).apply(null, arguments));
};

/**
 * 指定した日付が存在するかどうかチェックする
 *
 * @param {Digit} year 年
 * @param {Digit} [month] 月
 * @param {Digit} [day] 日
 * @param {Digit} [hour] 時
 * @param {Digit} [minute] 分
 * @param {Digit} [second] 秒
 * @param {Digit} [millisecond] ミリ秒
 * @return {Boolean} 日付が存在するかどうか
 */
Jeeel.Object.Date.checkDate = function (year, month, day, hour, minute, second, millisecond) {
    var date = this.createDate.apply(this, arguments);

    return date.year === +year
        && date.month === (+month || 1)
        && date.date === (+day || 1)
        && date.hour === (+hour || 0)
        && date.minute === (+minute || 0)
        && date.second === (+second || 0)
        && date.millisecond === (+millisecond || 0);
};

/**
 * 指定した日付文字列を1970年1月1日0時0分0秒(UTC)からの経過ミリ秒に変換する
 * 
 * @param {String} dateString 日付文字列
 * @return {Integer} 経過ミリ秒
 */
Jeeel.Object.Date.parse = function (dateString) {
    return Date.parse((dateString || '').replace(/-/g, '/'));
};

/**
 * ミリ秒を日に換算し変換する
 * 
 * @param {Integer} time ミリ秒
 * @return {Number} 日
 */
Jeeel.Object.Date.timeToDate = function (time) {
    return time / 86400000;
};

/**
 * ミリ秒を時に換算し変換する
 * 
 * @param {Integer} time ミリ秒
 * @return {Number} 時
 */
Jeeel.Object.Date.timeToHour = function (time) {
    return time / 3600000;
};

/**
 * ミリ秒を分に換算し変換する
 * 
 * @param {Integer} time ミリ秒
 * @return {Number} 分
 */
Jeeel.Object.Date.timeToMinute = function (time) {
    return time / 60000;
};

/**
 * ミリ秒を秒に換算し変換する
 * 
 * @param {Integer} time ミリ秒
 * @return {Number} 分
 */
Jeeel.Object.Date.timeToSecond = function (time) {
    return time / 1000;
};

/**
 * 曜日と曜日を表す数値のペアリスト
 *
 * @type String[]
 * @constant
 */
Jeeel.Object.Date.DAYS = ['日', '月', '火', '水', '木', '金', '土'];

Jeeel.Object.Date.prototype = {

    /**
     * 基となるDateオブジェクト
     *
     * @type Date
     */
    _date: null,

    /**
     * このインスタンスを作成した日付
     *
     * @type Date
     */
    _timestamp: null,
    
    /**
     * 年
     * 
     * @type Integer
     */
    year: 0,
    
    /**
     * 月(1～12)
     * 
     * @type Integer
     */
    month: 0,
    
    /**
     * 日
     * 
     * @type Integer
     */
    date: 0,
    
    /**
     * 時
     * 
     * @type Integer
     */
    hour: 0,
    
    /**
     * 分
     * 
     * @type Integer
     */
    minute: 0,
    
    /**
     * 秒
     * 
     * @type Integer
     */
    second: 0,
    
    /**
     * ミリ秒
     * 
     * @type Integer
     */
    millisecond: 0,
    
    /**
     * 1970年1月1日0時0分0秒(UTC)からの経過ミリ秒
     * 
     * @type Integer
     */
    time: 0,
    
    /**
     * Dateオブジェクトを取得する
     * 
     * @return {Date} 取得したDateオブジェクト
     */
    getDateObject: function () {
        return this._date;
    },
    
    /**
     * 年を取得する
     * 
     * @return {Integer} 年
     */
    getYear: function () {
        return this._date.getFullYear();
    },
    
    /**
     * 月を取得する
     * 
     * @return {Integer} 月(1～12)
     */
    getMonth: function () {
        return this._date.getMonth() + 1;
    },
    
    /**
     * 日を取得する
     * 
     * @return {Integer} 日
     */
    getDate: function () {
        return this._date.getDate();
    },
    
    /**
     * 時を取得する
     * 
     * @return {Integer} 時
     */
    getHour: function () {
        return this._date.getHours();
    },
    
    /**
     * 分を取得する
     * 
     * @return {Integer} 分
     */
    getMinute: function () {
        return this._date.getMinutes();
    },
    
    /**
     * 秒を取得する
     * 
     * @return {Integer} 秒
     */
    getSecond: function () {
        return this._date.getSeconds();
    },
    
    /**
     * ミリ秒を取得する
     * 
     * @return {Integer} ミリ秒
     */
    getMillisecond: function () {
        return this._date.getMilliseconds();
    },
    
    /**
     * 1970年1月1日0時0分0秒(UTC)からの経過ミリ秒を取得する(オフセットを考慮)
     * 
     * @return {Integer} 経過ミリ秒
     */
    getTime: function () {
        return this._date.getTime();
    },
    
    /**
     * 1970年1月1日0時0分0秒(UTC)からの経過ミリ秒を取得する(オフセットを無視)
     * 
     * @return {Integer} 経過ミリ秒
     */
    getUtcTime: function () {
        return Date.UTC(this.year, this.month - 1, this.date, this.hour, this.minute, this.second, this.millisecond);
    },
    
    /**
     * 曜日を示す数を取得する
     * 
     * @return {Integer} 曜日を示す数(0～6)
     */
    getDay: function () {
        return this._date.getDay();
    },
    
    /**
     * 曜日名を取得する
     *
     * @return {String} 曜日の短縮名(日,月,火,...等)
     */
    getDayName: function () {
        return this.constructor.DAYS[this._date.getDay()];
    },

    /**
     * 作成時からの経過時間を返す
     *
     * @return {Integer} 作成時からの経過時間(ミリ秒)
     */
    getElapsedTime: function () {
        var now  = new Date();
        return now.getTime() - this._timestamp.getTime();
    },
    
    /**
     * 作成時からの経過時間を設定する
     *
     * @param {Integer} time 作成時からの経過時間(ミリ秒)
     * @return {Jeeel.Object.Date} 自インスタンス
     */
    setElapsedTime: function (time) {
        var now  = new Date();

        this._timestamp.setTime(now.getTime() - time);
        
        return this;
    },

    /**
     * 作成時からの経過時間を加味して新しくインスタンスを作成する
     *
     * @return {Jeeel.Object.Date} 新しく作成したインスタンス
     */
    getInstanceAddElapsedTime: function () {
        var time = this.getElapsedTime();

        return Jeeel.Object.Date.create(this.time + time);
    },
    
    /**
     * この週の日のリストを取得する<br />
     * 週は日曜から土曜となるように返す<br />
     * なお週なので前の月や次の月の日付が紛れる事がある
     * 
     * @return {Integer[]} 日リスト
     */
    getDatesOfWeek: function () {
        var date = new Date(this.year, this._date.getMonth(), this.date - this.getDay());
        var res  = [];

        do {
            res[res.length] = date.getDate();

            date.setDate(date.getDate() + 1);
        } while(date.getDay() !== 0);

        return res;
    },

    /**
     * この月の日のリストを取得する
     *
     * @return {Integer[]} 日リスト
     */
    getDatesOfMonth: function () {
        var month = this._date.getMonth();
        var date  = new Date(this.year, month, 1);
        var res   = [];

        while(date.getMonth() === month) {
            res[res.length] = date.getDate();

            date.setDate(date.getDate() + 1);
        }

        return res;
    },

    /**
     * Unix関連で良く使用されるUnixTimeを取得する
     *
     * @return {Integer} UnixTime(秒)
     */
    getUnixTime: function () {
        return Math.floor(this.time / 1000);
    },
    
    /**
     * 日付を加算する
     * 
     * @param {Integer} [year] 年
     * @param {Integer} [month] 月
     * @param {Integer} [day] 日
     * @param {Integer} [hour] 時
     * @param {Integer} [minute] 分
     * @param {Integer} [second] 秒
     * @param {Integer} [millisecond] ミリ秒
     * @return {Jeeel.Object.Date} 自インスタンス
     */
    add: function (year, month, day, hour, minute, second, millisecond) {
        var list = ['FullYear', 'Month', 'Date', 'Hours', 'Minutes', 'Seconds', 'Milliseconds'];
        
        for (var i = 0, l = Math.min(arguments.length, list.length); i < l; i++) {
            var setter = 'set' + list[i];
            var getter = 'get' + list[i];
            
            this._date[setter](this._date[getter]() + (+arguments[i]));
        }
        
        return this._refreshProperty();
    },
    
    /**
     * 日付を減算する
     * 
     * @param {Integer} [year] 年
     * @param {Integer} [month] 月
     * @param {Integer} [day] 日
     * @param {Integer} [hour] 時
     * @param {Integer} [minute] 分
     * @param {Integer} [second] 秒
     * @param {Integer} [millisecond] ミリ秒
     * @return {Jeeel.Object.Date} 自インスタンス
     */
    sub: function (year, month, day, hour, minute, second, millisecond) {
        var list = ['FullYear', 'Month', 'Date', 'Hours', 'Minutes', 'Seconds', 'Milliseconds'];
        
        for (var i = 0, l = Math.min(arguments.length, list.length); i < l; i++) {
            var setter = 'set' + list[i];
            var getter = 'get' + list[i];
            
            this._date[setter](this._date[getter]() - (+arguments[i]));
        }
        
        return this._refreshProperty();
    },
    
    /**
     * この日付から指定した日付に時間経過した場合に発生するイベントの追加を行う<br />
     * この日付より後の実行日付でなければ登録は無効化される
     * 
     * @param {Function} listener 登録メソッド(引数には自インスタンス、実行日付インスタンス、任意の引数)
     * @param {Jeeel.Object.Date} date 実行日付を示すオブジェクト
     * @param {Mixied} var_args 登録メソッドに引き渡す引数
     * @return {Jeeel.Object.Date} 自インスタンス
     * @example 
     * var date1 = Jeeel.Object.Date.createDate(2010, 5, 6, 22, 10);
     * var date2 = Jeeel.Object.Date.createDate(2010, 5, 7, 22, 10);
     * 
     * date1.addTimeoutEvent(
     *     function (baseDate, execDate, name) {
     *         alert(name + 'さん ' + baseDate.toString('Y-m-d H:i:s') + 'から、' + execDate.toString('Y-m-d H:i:s') + 'へ時間経過しました。');
     *     }, 
     *     date2,
     *     'Ken'
     * );
     * 
     * // date1が作成されてから丸一日経った時間にイベントが実行される
     * // Kenさん 2011-05-06 22:10:00から、2011-05-07 22:10:00に時間経過しました。
     */
    addTriggerDateEvent: function (listener, date, var_args) {
        if ( ! (date instanceof Jeeel.Object.Date) || this >= date) {
            return this;
        }
        
        var _listener = function () {
            listener.apply(null, arguments);
        };
        
        var args = Array.prototype.slice.call(arguments, 2, arguments.length);
        
        args.unshift(
            _listener,
            date - (this + this.getElapsedTime()),
            this,
            date
        );
        
        if (args[1] <= 0) {
            args[1] = 1;
        }
        
        Jeeel.Timer.setTimeout.apply(null, args);
        
        return this;
    },

    /**
     * SQL等でよく使用されるDate形式の文字列に変換する
     *
     * @return {String} Date形式の文字列
     */
    toSqlDate: function () {
        return this.year + '-'
             + this._getNum(this.month) + '-'
             + this._getNum(this.date);
    },

    /**
     * SQL等でよく使用されるDateTime形式の文字列に変換する
     *
     * @return {String} DateTime形式の文字列
     */
    toSqlDateTime: function () {
        return this.year + '-'
             + this._getNum(this.month) + '-'
             + this._getNum(this.date) + ' '
             + this._getNum(this.hour) + ':'
             + this._getNum(this.minute) + ':'
             + this._getNum(this.second);
    },
    
    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Date} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Date(this);
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Date|String|Integer|Jeeel.Object.Date} [date] 基となるDateオブジェクトやDateString(省略は現時刻)
     * @constructor
     */
    constructor: Jeeel.Object.Date,

    /**
     * 指定したフォーマットに従って文字列変換する<br />
     * フォーマットはphpのdateフォーマットと同等である<br />
     * なお一部は日本語化されており、英語での表記は出ないので注意
     *
     * @param {String} [format] フォーマット(省略時はDateTime形式になる)
     * @return {String} 変換後の文字列
     */
    toString: function (format) {

        if ( ! Jeeel.Type.isString(format)) {
            format = 'Y-m-d H:i:s';
        }

        var year     = this.year;
        var month    = this.month;
        var date     = this.date;
        var hour     = this.hour;
        var minute   = this.minute;
        var second   = this.second;
        var unixTime = this.getUnixTime();
        var day      = this._date.getDay();

        var lastDate = (new Date(year, month, 0)).getDate();

        var halfHour = hour % 12;
        var amString = (hour < 12 ? 'am' : 'pm');

        if (halfHour == 0) {
            halfHour = 12;
        }

        /**
         * @ignore
         */
        var formatList = {
            d: this._getNum(date),
            D: this.constructor.DAYS[day],
            j: date,
            l: this.constructor.DAYS[day] + '曜日',
            N: (day == 0 ? 7 : day),
            w: day,
            m: this._getNum(month),
            n: month,
            t: lastDate,
            Y: year,
            y: year.toString().substr(2, 4),
            a: amString,
            A: amString.toUpperCase(),
            g: halfHour,
            G: hour,
            h: this._getNum(halfHour),
            H: this._getNum(hour),
            i: this._getNum(minute),
            s: this._getNum(second),
            U: unixTime
        };

        for (var key in formatList) {
            var reg = new RegExp(key, 'g');
            
            format = format.replace(reg, formatList[key]);
        }

        return format;
    },

    /**
     * 現在の時刻を表すミリ秒を返す<br />
     * 1970年1月1日0時0分0秒(UTC)からの経過ミリ秒
     *
     * @return {Integer} 取得した経過ミリ秒
     */
    valueOf: function () {
        return this.time;
    },
    
    /**
     * 数値を二桁にフォーマットする
     * 
     * @param {Integer} num 数値
     * @return {String} フォーマット後の値
     * @private
     */
    _getNum: function (num) {
        num = '' + num;

        if (num.length < 2) {
            num = '0' + num;
        }

        return num;
    },
    
    /**
     * プロパティを更新する
     * 
     * @return {Jeeel.Object.Date} 自インスタンス
     * @private
     */
    _refreshProperty: function () {
        this.year  = this.getYear();
        this.month = this.getMonth();
        this.date  = this.getDate();
        this.hour  = this.getHour();
        this.minute = this.getMinute();
        this.second = this.getSecond();
        this.millisecond = this.getMillisecond();
        this.time = this.getTime();
        
        return this;
    }
};

/**
 * コンストラクタ
 * 
 * @class 分数を管理するクラス
 * @param {Number|String} numeric 分数化する数値もしくは数値文字列
 */
Jeeel.Object.Fraction = function (numeric){};

/**
 * コンストラクタ
 * 
 * @class 分数を管理するクラス
 * @param {Integer} numerator 分子
 * @param {Integer} denominator 分母
 */
Jeeel.Object.Fraction = function (numerator, denominator) {
  
    switch (arguments.length) {
        case 1:
            var numeric = Jeeel.String.trim('' + arguments[0]);

            var pidx = numeric.lastIndexOf('.');
            denominator = 1;

            if (pidx + 1) {
                denominator = Math.pow(10, numeric.length - pidx - 1);
            }

            numerator = +(numeric.replace('.', ''));
            break;

        case 2:
            break;

        default:
            throw new Error('引数の数が違います。');
            break;
    }
    
    /**
     * 分子
     * 
     * @type Integer
     */
    this.numerator = +numerator;
    
    /**
     * 分母
     * 
     * @type Integer
     */
    this.denominator = +denominator;
};

Jeeel.Object.Fraction.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Fraction} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Fraction(this.numerator, this.denominator);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Fraction} fraction 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (fraction) {
        return this.numerator === fraction.numerator
            && this.denominator === fraction.denominator;
    },
    
    /**
     * 約分を行う
     * 
     * @return {Jeeel.Object.Fraction} 自インスタンス
     */
    reduce: function () {
        var gcd = Jeeel.Number.getGcd(this.numerator, this.denominator);
        
        this.numerator /= gcd;
        this.denominator /= gcd;
        
        return this;
    },
    
    /**
     * 通分を行う
     * 
     * @param {Jeeel.Object.Fraction} fraction 通分対象の分数インスタンス
     * @return {Jeeel.Object.Fraction} 自インスタンス
     */
    reduceCommonDenominator: function (fraction) {
        var commonNum = Jeeel.Number.getLcm(this.denominator, fraction.denominator) / this.denominator;
        
        this.numerator *= commonNum;
        this.denominator *= commonNum;
        
        return this;
    },
    
    /**
     * 分数を足し合わせる
     * 
     * @param {Jeeel.Object.Fraction} fraction 足し合わせる分数インスタンス
     * @return {Jeeel.Object.Fraction} 自インスタンス
     */
    add: function (fraction) {
        fraction = fraction.clone().reduceCommonDenominator(this);
        
        this.reduceCommonDenominator(fraction);
        
        this.numerator += fraction.numerator;
        
        return this;
    },
    
    /**
     * 分数を差し引く
     * 
     * @param {Jeeel.Object.Fraction} fraction 差し引く分数インスタンス
     * @return {Jeeel.Object.Fraction} 自インスタンス
     */
    sub: function (fraction) {
        fraction = fraction.clone().reduceCommonDenominator(this);
        
        this.reduceCommonDenominator(fraction);
        
        this.numerator -= fraction.numerator;
        
        return this;
    },
    
    /**
     * 分数を掛け合わせる
     * 
     * @param {Jeeel.Object.Fraction} fraction 掛け合わせる分数インスタンス
     * @return {Jeeel.Object.Fraction} 自インスタンス
     */
    mul: function (fraction) {
        this.numerator *= fraction.numerator;
        this.denominator *= fraction.denominator;
        
        return this;
    },
    
    /**
     * 分数を割る
     * 
     * @param {Jeeel.Object.Fraction} fraction 割る分数インスタンス
     * @return {Jeeel.Object.Fraction} 自インスタンス
     */
    div: function (fraction) {
        this.numerator *= fraction.denominator;
        this.denominator *= fraction.numerator;
        
        return this;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return this.numerator + ' / ' + this.denominator;
    },
    
    /**
     * 数値に変換する
     * 
     * @return {Number} 数値に変換した自インスタンス
     */
    valueOf: function () {
        return this.numerator / this.denominator;
    }
};
/**
 * コンストラクタ
 * 
 * @class フォントを扱うクラス
 * @param {String[]} family フォントの種類
 * @param {String} [size] フォントのサイズ
 * @param {String} [weight] フォントの太さ
 * @param {String} [style] フォントスタイル
 * @param {String} [height] フォントの高さ
 * @param {String} [variant] スモールキャピタル
 */
Jeeel.Object.Font = function (family, size, weight, style, height, variant) {
    
    if (Jeeel.Type.isString(family)) {
        family = [family];
    }
    
    if ( ! Jeeel.Type.isArray(family)) {
        throw new Error('引数の型が違います。');
    }
    
    for (var i = family.length; i--;) {
        if ( ! Jeeel.Type.isString(family[i])) {
            throw new Error('引数の型が違います。');
        } else if (family[i].match(/^'.*'$/)) {
            continue;
        }
        
        family[i] = "'" + family[i] + "'";
    }
    
    /**
     * フォント名
     * 
     * @type String[]
     */
    this.family = family;
  
    /**
     * フォントサイズ
     * 
     * @type String
     */
    this.size = size || 'medium';
    
    /**
     * フォントの太さ
     * 
     * @type String
     */
    this.weight = weight || 'normal';
    
    /**
     * フォントスタイル
     * 
     * @type String
     */
    this.style = style || 'normal';
    
    /**
     * フォントの高さ
     * 
     * @type String
     */
    this.height = height || 'normal';
    
    /**
     * スモールキャピタル
     * 
     * @type String
     */
    this.variant = variant || 'normal';
};

Jeeel.Object.Font.prototype = {
    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Font} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Font(this.family, this.size, this.weight, this.style, this.height, this.variant);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Font} font 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (font) {
        return this.family.join('') === font.family.join('')
            && this.size === font.size
            && this.weight === font.weight
            && this.style === font.style
            && this.height === font.height
            && this.variant === font.variant;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return this.style + ' '
             + this.variant + ' '
             + this.weight + ' '
             + this.size + '/'
             + this.height + ' '
             + this.family.join(',');
    }
};
Jeeel.directory.Jeeel.Object.Technical = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Object + 'Technical/';
    }
};

/**
 * Jeeel内部で使用している特殊クラスを保持するネームスペース
 */
Jeeel.Object.Technical = {

};

Jeeel.file.Jeeel.Object.Technical = ['LineIndex'];

if (Jeeel._debugMode) {
    Jeeel.file.Jeeel.Object.Technical[Jeeel.file.Jeeel.Object.Technical.length] = 'Trace';
    Jeeel.file.Jeeel.Object.Technical[Jeeel.file.Jeeel.Object.Technical.length] = 'Information';
}

Jeeel._autoImports(Jeeel.directory.Jeeel.Object.Technical, Jeeel.file.Jeeel.Object.Technical);

/**
 * コンストラクタ
 *
 * @class Jeeel.Stringで行数とインデックスを表す構造体
 * @param {Hash} lineIndex
 * @param {Integer} lineIndex.line
 * @param {Integer} lineIndex.index
 */
Jeeel.Object.Technical.LineIndex = function (lineIndex) {
    var self = this;

    self.line  = lineIndex.line;
    self.index = lineIndex.index;
};

Jeeel.Object.Technical.LineIndex.prototype = {
  
    /**
     * 行番号
     *
     * @type Integer
     */
    line : false,

    /**
     * 行文字列のインデックス
     *
     * @type Integer
     */
    index : false
};

/**
 * コンストラクタ
 *
 * @class メソッドのトレースを保持する構造体
 * @param {Function} func 対象の関数
 */
Jeeel.Object.Technical.Trace = function (func) {
    var self = this;
    self.args = Array.prototype.slice.call(func.arguments, 0, func.arguments.length);
    self.name = (func[Jeeel.Debug.Debugger.INFORMATION_NAME] || {}).name || func.name;
    self.func = func;
};

Jeeel.Object.Technical.Trace.prototype = {

    /**
     * 引数配列
     *
     * @type Array
     */
    args: [],

    /**
     * 関数名
     *
     * @type String
     */
    name: '',

    /**
     * 関数詳細
     *
     * @type Function
     */
    func: ''
};

/**
 * コンストラクタ
 *
 * @class オブジェクトの情報を保持する構造体
 * @param {String} name オブジェクト名
 * @param {Mixied} parent 親オブジェクト
 */
Jeeel.Object.Technical.Information = function (name, parent) {
    var self = this;
    self.name = name;
    self.parent = parent;
};

Jeeel.Object.Technical.Information.prototype = {

    /**
     * オブジェクト名
     *
     * @type String
     */
    name: '',

    /**
     * オブジェクトの親
     *
     * @type Mixied
     */
    parent: ''
};

/**
 * コンストラクタ
 * 
 * @class 配列・連想配列に対して操作を行うクラス
 * @param {Hash} [params] 入力パラメータ
 * @throws {Error} paramsを指定してかつが配列式でない場合に起こる
 */
Jeeel.Parameter = function (params) {

    if ( ! params) {
        params = {};
    } else if ( ! Jeeel.Type.isHash(params)) {
        throw new Error('paramsには配列式が使えなければなりません。');
    }

    this._params = params;
};

/**
 * インスタンスの作成
 *
 * @param {Hash} [params] 入力パラメータ
 * @return {Jeeel.Parameter} 作成したインスタンス
 * @throws {Error} paramsを指定してかつが配列式でない場合に起こる
 */
Jeeel.Parameter.create = function (params) {
    return new this(params);
};

Jeeel.Parameter.prototype = {

    /**
     * パラメータ
     *
     * @type Hash
     * @private
     */
    _params: null,

    /**
     * エラー
     *
     * @type Hash
     * @private
     */
    _errors: null,

    /**
     * ストレージ
     *
     * @type Jeeel.Storage.Abstract
     * @private
     */
    _storage: null,
    
    /**
     * 指定したキーの値を取得する
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 取得値
     */
    get: function (key, defaultValue) {
        if ( ! (key in this._params)) {
            return defaultValue;
        } else {
            return this._params[key];
        }
    },

    /**
     * Hashの最初の値を取得する
     *
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 取得値
     */
    getOne: function (defaultValue) {
        var result;

        Jeeel.Hash.forEach(this._params,
            function (val) {

                result = val;

                return Jeeel.Hash.FOR_EACH_EXIT;
            }
        );

        if (Jeeel.Type.isEmpty(result)) {
            return defaultValue;
        }

        return result;
    },

    /**
     * 全ての値を返す
     *
     * @return {Hash} 取得値
     */
    getAll: function () {
        return this._params;
    },

    /**
     * 現インスタンスの配列に値を保存する
     *
     * @param {String} key 保存する値を示すキー
     * @param {Mixed} val 保存する値
     * @return {Jeeel.Parameter} 自インスタンス
     */
    set: function (key, val) {
        this._params[key] = val;

        return this;
    },

    /**
     * 現インスタンスに保存していた配列を置き換える
     *
     * @param {Hash} params 新たに保持する配列
     * @return {Jeeel.Parameter} 自インスタンス
     * @throws {Error} paramsが配列式でない場合に起こる
     */
    setAll: function (params) {
        if ( ! Jeeel.Type.isHash(params)) {
           throw new Error('paramsには配列式が使えなければなりません。');
        }

        this._params = params;

        return this;
    },

    /**
     * 現在保持している内部値のキーのリストを作成して取得する
     * 
     * @return {String[]} キーのリスト
     */
    getKeys: function () {
        return Jeeel.Hash.getKeys(this._params);
    },

    /**
     * 現在保持している内部値のリストを作成して取得する
     *
     * @return {Array} キーのリスト
     */
    getValues: function () {
        return Jeeel.Hash.getValues(this._params);
    },
    
    /**
     * 指定したキーの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Parameter} 自インスタンス
     */
    unset: function (key) {
        delete this._params[key];

        return this;
    },

    /**
     * 指定したキーの値を保持しているかどうかを返す
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    has: function (key) {
        return key in this._params;
    },

    /**
     * パラメータにフィルターを掛けた値を新しくインスタンスとして返す
     *
     * @param {Jeeel.Filter.Abstract} filter Jeeel.Filter.Abstractを継承したクラスのフィルター
     * @param {String|String[]} keys 指定キーの要素のみを対象とする
     * @return {Jeeel.Parameter} フィルターを掛けた新しいインスタンス
     */
    filter: function (filter, keys) {
        var value;

        if (keys) {
            value = this.filterEach(filter, keys).getAll();
        }
        else {
            value = filter.filter(this.getAll());
        }

        if ( ! Jeeel.Type.isHash(value)) {
            value = [value];
        }

        return Jeeel.Parameter.create(value);
    },

    /**
     * フィルターを配列の各要素にそれぞれ掛けていく
     *
     * @param {Jeeel.Filter.Abstract} innerFilter 内部フィルター
     * @param {String[]} [keys] 操作許可キーリスト(初期値は全て)
     * @return {Jeeel.Parameter} フィルターを掛けた新しいインスタンス
     */
    filterEach: function (innerFilter, keys) {
        var filter = Jeeel.Filter.Each.create(innerFilter, keys);

        return this.filter(filter);
    },

    /**
     * 現インスタンスの内部値を文字列として結合し返す
     *
     * @param {String} [separator] 連結時の区切り文字列
     * @param {String[]} [keys] 連結するキーのリスト
     * @return {String} 結合後の値
     */
    join: function (separator, keys) {
        return this.filter(Jeeel.Filter.Join.create(separator, keys)).getOne('');
    },

    /**
     * バリデートを掛ける
     *
     * @param {Jeeel.Validator.Abstract} validator Jeeel.Validator.Abstractを継承したクラスのバリデータ
     * @return {Jeeel.Parameter} 自インスタンス
     */
    validate: function (validator) {
        if (this._errors === null) {
            this._errors = {};
        }

        this.setErrors(validator.validate(this.getAll()));

        return this;
    },

    /**
     * isVaildをバリデートしなければ通過できないようにする
     *
     * @return {Jeeel.Parameter} 自インスタンス
     */
    taint: function () {
        if (Jeeel.Type.isEmptyHash(this._errors)) {
            this._errors = null;
        }

        return this;
    },

    /**
     * isVaildをバリデートしなくても通過できるようにする
     *
     * @return {Jeeel.Parameter} 自インスタンス
     */
    unTaint: function () {
        this._errors = {};

        return this;
    },

    /**
     * エラーを全て返す
     *
     * @return {Hash} エラーのリスト
     */
    getErrors: function () {
        return this._errors;
    },

    /**
     * エラーを全て変更する
     *
     * @param {Hash} errors エラーのリスト
     * @return {Jeeel.Parameter} 自インスタンス
     */
    setErrors: function (errors) {
        this._errors = errors;

        return this;
    },

    /**
     * エラーをセットする
     *
     * @param {String} key エラーのキー
     * @param {Mixed} val エラーの内容
     * @return {Jeeel.Parameter} 自インスタンス
     */
    setError: function (key, val) {
        this._errors[key] = val;

        return this;
    },

    /**
     * エラーの追加を行う
     *
     * @param {String} key エラーのキー
     * @param {Mixed} val エラーの内容
     * @return {Jeeel.Parameter} 自インスタンス
     */
    addError: function (key, val) {
        if ( ! (key in this._errors)) {
            this._errors[key] = [];
        }
        else if ( ! Jeeel.Type.isArray(this._errors[key])) {
            this._errors[key] = [this._errors[key]];
        }

        this._errors[key].push(val);

        return this;
    },

    /**
     * バリーデータを全て通過したかどうかを返す
     *
     * @return {Boolean} 通過ならばtrueそれ以外はfalseを返す
     */
    isValid: function () {
        if (this._errors === null) {
            return false;
        }

        for (var key in this.getErrors()) {
            return false;
        }

        return true;
    },

    /**
     * keyで指定された値をとりだし、Jeeel.Parameterのインスタンスとして返す<br />
     * 取り出した値が配列ではなかった場合、かわりにdefaultが使われる<br />
     * defaultが配列ではなかった場合、[default]が使われる<br />
     * defaultが指定されなかった（またはnullだった)場合、[]が使われる
     *
     * @param {String} key 取りだす要素のキー
     * @param {Mixed} [defaultValue] デフォルト値
     * @return {Jeeel.Parameter} 取りだした要素を含んだインスタンス
     */
    getElement: function (key, defaultValue) {
        var val = this.get(key, null);

        if (val === null) {
            val = [];
        }

        if ( ! Jeeel.Type.isHash(val) && Jeeel.Type.isSet(defaultValue)) {

            if ( ! Jeeel.Type.isHash(defaultValue)) {
                defaultValue = [defaultValue];
            }

            val = defaultValue;
        }

        return Jeeel.Parameter.create(val);
    },

    /**
     * keysで指定された部分集合をJeeel.Parameterのインスタンスとして返す。<br />
     * defaultは、キーが存在しなかった場合のデフォルト値として使われる。<br />
     * defaultが配列array(x => y, ...) だった場合、キーxのデフォルトにyが適用される。<br />
     * defaultが配列で、キー '*' => z を持つ場合、すべてのキーのデフォルトにzが適用される。<br />
     * defaultが配列で、キー a => v を持ち、aが配列だった場合、<br />
     *     aで指定された全てのキーのデフォルトに、vが適用される<br />
     * '*' => z と 'x' => y が指定された場合、yが優先される<br />
     * defaultが配列ではなかった場合、すべてのキーに対して、defaultが適用される。<br />
     * defaultが指定されない場合、部分集合に含まれない。
     *
     * @param {String|String[]} keys 部分集合を表す複数のキー
     * @param {Mixed} [defaultValue] キーが存在しなかった場合のデフォルト値
     * @return {Jeeel.Parameter} 部分集合を持ったインスタンス
     */
    getSubset: function (keys, defaultValue) {
        return this.filter(Jeeel.Filter.Subset.create(keys, defaultValue));
    },

    /**
     * 現インスタンス内部の値をシリアライズして返す<br />
     * その際指定したキーの値のみをシリアライズ出来、<br />
     * かつその内部の部分配列をシリアライズ出来る
     *
     * @param {String} [key] 指定キー
     * @param {String|String[]} [subset] 部分配列を指定するキーリスト
     * @return {String} Json化した内部値
     */
    serialize: function (key, subset) {
        var params = (key ? this.getElement(key) : this);
        params = (subset ? params.getSubset(subset) : params);

        return Jeeel.Json.encode(params.getAll());
    },

    /**
     * Jeeel.Storage.Abstractを継承したストレージをセットする
     *
     * @param {Jeeel.Storage.Abstract} storage ストレージ
     * @return {Jeeel.Parameter} 自インスタンス
     */
    setStorage: function (storage) {
        this._storage = storage;

        return this;
    },

    /**
     * ストレージを取得する
     *
     * @return {Jeeel.Storage.Abstract} 取得したストレージ
     * @throws {Error} ストレージがセットされていない場合に投げられる
     */
    getStorage: function () {
        if ( ! this._storage) {
            throw new Error('ストレージがセットされていません。');
        }

        return this._storage;
    },


    /**
     * ストレージにパラメータを保存する
     *
     * @param {Jeeel.Storage.Abstract} [storage] 任意のストレージを使う場合に指定
     * @return {Jeeel.Parameter} 自インスタンス
     * @throws {Error} ストレージを指定せず、ストレージがセットされていない場合に投げられる
     */
    save: function (storage) {
        if ( ! storage) {
            storage = this.getStorage();
        }

        storage.save(this.getAll());

        return this;
    },

    /**
     * ストレージからパラメータを読み込む
     *
     * @param {Jeeel.Storage.Abstract} [storage] 任意のストレージを使う場合に指定
     * @return {Jeeel.Parameter} 自インスタンス
     * @throws {Error} ストレージを指定せず、ストレージがセットされていない場合に投げられる
     */
    load: function (storage) {
        if ( ! storage) {
            storage = this.getStorage();
        }

        this.setAll(storage.load());

        return this;
    },

    /**
     * 内部の保持値をGetパラメータ用の値に変更して返す<br />
     * Getパラメータの先頭に?はつかない
     *
     * @return {String} Getパラメータを示す文字列
     */
    toQueryString: function () {
        return Jeeel.Filter.Url.QueryString.create().filter(this._params);
    },

    /**
     * 内部要素にforeachをかける<br />
     * 詳しくはJeeel.Hash.forEach参照
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Jeeel.Parameter} 自インスタンス
     * @see Jeeel.Hash.forEach
     */
    each: function (eachMethod, thisArg) {
        Jeeel.Hash.forEach(this._params, eachMethod, thisArg);
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Hash} [params] 入力パラメータ
     * @constructor
     */
    constructor: Jeeel.Parameter
};
Jeeel.directory.Jeeel.Validator = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Validator/';
    }
};

/**
 * バリデータに関するネームスペース
 */
Jeeel.Validator = {

    /**
     * コンストラクタ
     *
     * @abstractClass バリデータクラスを作る際の抽象クラス
     */
    Abstract: function () {}
};

Jeeel.Validator.Abstract.prototype = {

    /**
     * ヘルパーを作成して返す
     * 
     * @param {Mixied} val バリデートを掛ける対象値
     * @return {Jeeel.Validator.Helper} 作成したヘルパー
     * @protected
     */
    _createHelper: function (val) {
        return Jeeel.Validator.Helper.create(val);
    },

    /**
     * 指定した値に対してバリデートを掛ける
     *
     * @param {Mixied} val バリデートを掛ける値
     * @return {Hash} エラーを保持した連想配列リスト
     */
    validate: function (val) {
        var errors =  this._validate(val);

        return errors;
    },

    /**
     * バリデートの内部メソッド<br />
     * 必ずオーバーライドしなければならない
     *
     * @param {Mixied} val バリデートを掛ける値
     * @return {Hash} エラーを保持した連想配列リスト
     * @protected
     * @abstract
     */
    _validate: function (val) {
        throw new Error('_validateメソッドが実装されていません。');
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Validator.Abstract
};

Jeeel.file.Jeeel.Validator = ['Helper'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Validator, Jeeel.file.Jeeel.Validator);

/**
 * コンストラクタ
 *
 * @class バリデートの助けを行うクラス
 * @param {Mixied} val バリデートを掛ける対象値
 * @param {Function|Function[]} [plugins] メソッドリスト
 */
Jeeel.Validator.Helper = function (val, plugins) {

    if ( ! Jeeel.Type.isObject(plugins)) {
        plugins = {};
    }

    this._value = val;
    this._errors = [];

    var notValidator = ['isValid', 'hasErrors', 'hasError', 'getErrors', 'getFirstError'];
    
    for (var name in plugins) {
        
        if (Jeeel.Type.inArray(name, notValidator)) {
            continue;
        }

        this[name] = plugins[name];
    }

    var self = this;

    for (var property in this) {

        if (property[0] === '_' || Jeeel.Type.inArray(property, notValidator)) {
            continue;
        } else if (Jeeel.Type.keyExists(property, plugins)) {
            this[property] = (function (_property, method) {
                return function () {
                    var args = [self._value];
                    
                    for (var i = 0, l = arguments.length; i < l; i++) {
                        args.push(arguments[i]);
                    }

                    var res  = method.apply(self, args);

                    if (res === false) {
                        self._errors[self._errors.length] = _property;
                    }

                    return self;
                };
            })(property, this[property]);
        } else {
            this[property] = (function (_property, method) {
                return function () {
                    var res = method.apply(self, arguments);

                    if (res === false) {
                        self._errors[self._errors.length] = _property;
                    }

                    return self;
                };
            })(property, this[property]);
        }
    }
};

/**
 * インスタンスの作成を行う
 *
 * @param {Mixied} val バリデートを掛ける対象値
 * @return {Jeeel.Validator.Helper} 作成したインスタンス
 */
Jeeel.Validator.Helper.create = function (val) {
    return new this(val, this.getPlugins());
};

/**
 * プラグインの追加
 *
 * @param {String} name メソッド名
 * @param {Function} method メソッド(メソッドは最初の引数にバリデートする値その後は任意の引数となる)<br />
 *                           Boolean method(Mixied value, ...)
 * @throws {Error} methodがメソッドではない場合に発生
 */
Jeeel.Validator.Helper.setPlugin = function (name, method) {
    if ( ! Jeeel.Type.isFunction(method)) {
        throw new Error('指定した引数がメソッドではありません。');
    }

    if (Jeeel.Type.isEmpty(this._plugins)) {
        this._plugins = {};
    }

    this._plugins[name] = method;
};

/**
 * プラグインの設定
 *
 * @param {Function[]} methods メソッドの連想配列(メソッドは最初の引数にバリデートする値その後は任意の引数となる)<br />
 *                              Boolean method(Mixied value, ...)
 * @throws {Error} methodsがメソッドまたはメソッドリストではない場合に発生
 */
Jeeel.Validator.Helper.setPlugins = function (methods) {

    if ( ! Jeeel.Type.isObject(methods)) {
        throw new Error('指定した引数がメソッドリストではありません。');
    }

    for (var name in methods) {
        if (Jeeel.Type.isFunction(methods[name])) {
            throw new Error('指定した引数にメソッド以外のものが含まれています。');
        }
    }

    /**
     * プラグイン
     *
     * @type Function[]
     * @private
     */
    this._plugins = methods;
};

/**
 * プラグインを取得
 *
 * @return {Function[]} メソッド連想配列
 */
Jeeel.Validator.Helper.getPlugins = function () {
    if (Jeeel.Type.isEmpty(this._plugins)) {
        return {};
    }

    return this._plugins;
};

Jeeel.Validator.Helper.prototype = {

    /**
     * バリデートを掛ける値
     * 
     * @type Mixied
     * @private
     */
    _value: null,

    /**
     * エラー保持配列
     *
     * @type String[]
     * @private
     */
    _errors: [],

    /**
     * バリデートを通過したかどうかを返す
     *
     * @return {Boolean} バリデータが通過したならばtrueそれ以外はfalseを返す
     */
    isValid: function () {
        return ! this.hasErrors();
    },

    /**
     * エラーが存在するかどうかを返す
     *
     * @return {Boolean} エラーがあったらtrueそれ以外はfalseを返す
     */
    hasErrors: function () {
        return !!this._errors.length;
    },

    /**
     * 指定したメソッドのエラーがあるかどうかを返す
     *
     * @param {String} name エラーがあったかどうかを調べるメソッド名
     * @return {Boolean} エラーがあったらtrueそれ以外はfalseを返す
     */
    hasError: function (name) {
        return Jeeel.Type.inArray(name, this._errors);
    },
    
    /**
     * エラーリストを取得する
     * 
     * @return {String[]} エラーの出たメソッド名のリスト
     */
    getErrors: function () {
        return this._errors;
    },

    /**
     * 最初のエラーを返す
     *
     * @return {String} エラーが起こったメソッド名
     * @throws {Error} エラーがそもそも存在しない場合に発生する
     */
    getFirstError: function () {
        if ( ! this.hasErrors()) {
            throw new Error('エラーが存在しません。');
        }

        return this._errors[0];
    },

    /**
     * 値が文字列で英数字のみで構成されているかどうかを調べる
     * 
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    alnum: function () {
        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        return (this._value.match(/^[0-9a-zA-Z]*$/) ? true : false);
    },

    /**
     * 値が文字列でアルファベットのみで構成されているかどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    alpha: function () {
        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        return (this._value.match(/^[a-zA-Z]*$/) ? true : false);
    },

    /**
     * 値がminからmaxまでの整数値(文字列整数値でも可)であるかどうかを調べる
     *
     * @param {Integer} min 最小値
     * @param {Integer} max 最大値
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    between: function (min, max) {
        if ( ! Jeeel.Type.isDigit(this._value)) {
            return false;
        }

        var digit = +this._value;

        return (min <= digit && digit <= max);
    },

    /**
     * 値が整数値か整数文字列かどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    digits: function () {
        return Jeeel.Type.isDigit(this._value);
    },

    /**
     * 値が文字列でメール形式であるかどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    email: function () {
        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        return (this._value.match(/^[_a-zA-Z0-9-]+([\.\+_a-zA-Z0-9-]+)*@[a-zA-Z0-9]([_a-zA-Z0-9-])*(\.[_a-zA-Z0-9-]+)*(\.[_a-zA-Z0-9-]{2,})+$/i) ? true : false);
    },

    /**
     * 値が文字列で郵便番号形式であるかどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    zipcode: function () {
        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        return (this._value.match(/^[0-9]{3}-?[0-9]{4}$/) ? true : false);
    },

    /**
     * 値が空(null, undefined, 空文字)でないかどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    notEmpty: function () {
        return !(Jeeel.Type.isEmpty(this._value) || this._value === '');
    },

    /**
     * 値がmin文字からmax文字までの文字数であるかどうかを調べる
     *
     * @param {Integer} min 最小値
     * @param {Integer} max 最大値
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    length: function (min, max) {

        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        var length = this._value.length;

        return (min <= length && length <= max);
    }
};
Jeeel.directory.Jeeel.Storage = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Storage/';
    }
};

/**
 * ストレージ関連のネームスペース
 */
Jeeel.Storage = {

    /**
     * コンストラクタ
     *
     * @class ストレージクラスを作る際の抽象クラス
     */
    Abstract: function () {}
};

Jeeel.Storage.Abstract.prototype = {

    /**
     * ストレージにパラメータの保存を行う
     *
     * @param {Mixed} params 保存値
     * @return {Jeeel.Storage.Abstract} 自インスタンス
     * @throws {Error} メソッドが実装されていない場合に発生
     * @abstract
     */
    save: function (params) {
        throw new Error('saveメソッドが実装されていません。');
    },

    /**
     * ストレージからパラメータの読み込みを行う
     *
     * @return {Mixed} 読み込み値
     * @return {Jeeel.Storage.Abstract} 自インスタンス
     * @throws {Error} メソッドが実装されていない場合に発生
     * @abstract
     */
    load: function () {
        throw new Error('loadメソッドが実装されていません。');
    }
};

Jeeel.file.Jeeel.Storage = ['Session', 'Object'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Storage, Jeeel.file.Jeeel.Storage);
Jeeel.directory.Jeeel.Storage.Session = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Storage + 'Session/';
    }
};

/**
 * Session関連を扱うストレージのネームスペース
 */
Jeeel.Storage.Session = {

};

Jeeel.file.Jeeel.Storage.Session = ['Abstract', 'Cookie', 'Name'];

if (Jeeel._extendMode.WebStorage && Jeeel._global && Jeeel._global.sessionStorage && Jeeel._global.localStorage) {
    Jeeel.file.Jeeel.Storage.Session[Jeeel.file.Jeeel.Storage.Session.length] = 'WebStorage';
}

Jeeel._autoImports(Jeeel.directory.Jeeel.Storage.Session, Jeeel.file.Jeeel.Storage.Session);

/**
 * コンストラクタ
 *
 * @abstractClass ストレージセッションクラスを作る際の抽象クラス
 * @augments Jeeel.Storage.Abstract
 */
Jeeel.Storage.Session.Abstract = function () {
    Jeeel.Storage.Abstract.call(this);
};

Jeeel.Storage.Session.Abstract.prototype = {
    
    /**
     * セッションインスタンス
     * 
     * @type Jeeel.Session.Abstract
     * @private
     */
    _session: null,
    
    /**
     * セッション名
     * 
     * @type String
     * @private
     */
    _name: null,

    /**
     * Sessionの保存期間を取得する
     *
     * @return {Integer} 保存期間(秒)
     */
    getExpires: function () {
        return this._session.getExpires();
    },

    /**
     * Sessionの保存期間を設定する<br />
     * マイナスを指定すると無制限になる
     *
     * @param {Integer} expires 保存期間(秒)
     * @return {Jeeel.Storage.Session.Abstract} 自インスタンス
     */
    setExpires: function (expires) {

        this._session.setExpires(expires);

        return this;
    },

    /**
     * Sessionの読み込み許可をするドメインを取得する
     *
     * @return {String} 読み込み可能ドメイン
     */
    getDomain: function () {
        return this._session.getDomain();
    },

    /**
     * Sessionの読み込み許可をするドメインを設定する
     *
     * @param {String} domain 読み込み可能ドメイン
     * @return {Jeeel.Storage.Session.Abstract} 自インスタンス
     */
    setDomain: function (domain) {

        this._session.setDomain(domain);

        return this;
    },

    /**
     * Sessionの読み込み可能パスを取得する
     *
     * @return {String} 読み込み可能パス
     */
    getPath: function () {
        return this._session.getPath();
    },

    /**
     * Sessionの読み込み可能パスを設定する
     *
     * @param {String} path 読み込み可能パス
     * @return {Jeeel.Storage.Session.Abstract} 自インスタンス
     */
    setPath: function (path) {
        this._session.setPath(path);

        return this;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Session.Abstract, Jeeel.Storage.Abstract);
/**
 * コンストラクタ
 *
 * @class クッキーのセッションを扱ってストレージを模すクラス
 * @augments Jeeel.Storage.Session.Abstract
 * @param {String} name 読み込み・保存時の名前
 * @throws {Error} nameを文字列で指定しなかった場合に発生
 */
Jeeel.Storage.Session.Cookie = function (name) {

    if ( ! Jeeel.Type.isString(name)) {
        throw new Error('nameは必ず指定しなければなりません。');
    }
    
    Jeeel.Storage.Session.Abstract.call(this);
    
    this._name = name;
    this._session = Jeeel.Session.Cookie.create();
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name 読み込み・保存時の名前
 * @return {Jeeel.Storage.Session.Cookie} 作成したインスタンス
 */
Jeeel.Storage.Session.Cookie.create = function (name) {
    return new this(name);
};

Jeeel.Storage.Session.Cookie.prototype = {
    
    /**
     * クッキーに値を保存する
     *
     * @param {Hash} params 保存する値のリスト
     */
    save: function (params) {

        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        this._session.set(this._name, params).save();
    },
    
    /**
     * クッキーの値を読み込む
     *
     * @return {Hash} 読み込んだ結果値
     */
    load: function () {
        var params = this._session.load().get(this._name);

        if ( ! Jeeel.Type.isSet(params)) {
            params = {};
        }

        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        return params;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Session.Cookie, Jeeel.Storage.Session.Abstract);

/**
 * コンストラクタ
 *
 * @class ネームのセッションを扱ってストレージを模すクラス(但しサーバー側には干渉しない、またドメインが変わっても参照できるため重要な情報保持には向かない)<br />なおこのクラスはwindow.nameを使用している
 * @augments Jeeel.Storage.Session.Abstract
 * @param {String} name 読み込み・保存時の名前
 * @throws {Error} nameを文字列で指定しなかった場合に発生
 */
Jeeel.Storage.Session.Name = function (name) {

    if ( ! Jeeel.Type.isString(name)) {
        throw new Error('nameは必ず指定しなければなりません。');
    }
    
    Jeeel.Storage.Session.Abstract.call(this);

    this._name = name;
    this._session = Jeeel.Session.Name.create();
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name 読み込み・保存時の名前
 * @return {Jeeel.Storage.Session.Name} 作成したインスタンス
 */
Jeeel.Storage.Session.Name.create = function (name) {
    return new this(name);
};

Jeeel.Storage.Session.Name.prototype = {
    
    /**
     * 値を保存する
     *
     * @param {Hash} params 保存する値のリスト
     */
    save: function (params) {
        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        this._session.set(this._name, params).save();
    },
    
    /**
     * 保存した値を読み込む
     *
     * @return {Hash} 読み込んだ結果値
     */
    load: function () {
        var params = this._session.get(this._name);

        if ( ! Jeeel.Type.isSet(params)) {
            params = {};
        }

        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        return params;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Session.Name, Jeeel.Storage.Session.Abstract);

/**
 * コンストラクタ
 *
 * @class ウェブストレージのセッションを扱ってストレージを模すクラス(但しサーバー側には干渉しない、またドメイン・プロトコル・ポート番号で制御されるため異なるドメイン間等ではデータのやりとりは出来ない)<br />なおこのクラスはwindow.localStorageを使用している
 * @augments Jeeel.Storage.Session.Abstract
 * @param {String} name 読み込み・保存時の名前
 * @param {Boolean} [isPersistent] データの永続化をするかどうか(ブラウザを閉じてもアクセス出来るか)
 * @throws {Error} nameを文字列で指定しなかった場合に発生
 */
Jeeel.Storage.Session.WebStorage = function (name, isPersistent) {

    if ( ! Jeeel.Type.isString(name)) {
        throw new Error('nameは必ず指定しなければなりません。');
    }
    
    Jeeel.Storage.Session.Abstract.call(this);
    
    this._session = Jeeel.Session.WebStorage.create(isPersistent, Jeeel.Storage.Session.WebStorage.STORAGE_NAME);
    this._name = name;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name 読み込み・保存時の名前
 * @param {Boolean} [isPersistent] データの永続化をするかどうか(ブラウザを閉じてもアクセス出来るか)
 * @return {Jeeel.Storage.Session.WebStorage} 作成したインスタンス
 */
Jeeel.Storage.Session.WebStorage.create = function (name, isPersistent) {
    return new this(name, isPersistent);
};

/**
 * localStorageに保存する際のキー
 *
 * @type String
 * @constant
 */
Jeeel.Storage.Session.WebStorage.STORAGE_NAME = 'Jeeel-Storage-Session-WebStorage-Name';

Jeeel.Storage.Session.WebStorage.prototype = {
  
    /**
     * 値を保存する
     *
     * @param {Hash} params 保存する値のリスト
     */
    save: function (params) {
        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        this._session.set(this._name, params).save();
    },
    
    /**
     * 保存した値を読み込む
     *
     * @return {Hash} 読み込んだ結果値
     */
    load: function () {
        var params = this._session.get(this._name);

        if ( ! Jeeel.Type.isSet(params)) {
            params = {};
        }

        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        return params;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Session.WebStorage, Jeeel.Storage.Session.Abstract);

(function () {
    var defaultName = '@JEEEL@';
    var index = 1;
    var instances = {};
    
    /**
     * コンストラクタ
     * 
     * @class Objectストレージ、Objectに対して疑似的に保存を行うクラス(Jeeel.Parameterと合わせても使えるが基本単独で使う)
     * @augments Jeeel.Storage.Abstract
     * @param {Object} object 疑似保存対象のObject(IEでElement指定の場合は何も無いが、その他の場合はプロパティが拡張させるので注意、その際のキーはJeeel.UNIQUE_IDが使用される)
     * @param {String} [name] ネームスペースを指定する場合に指定
     * @see Jeeel.UNIQUE_ID
     */
    Jeeel.Storage.Object = function (object, name) {
        
        var uniqueId = object.uniqueID || object[Jeeel.UNIQUE_ID];
        
        if ( ! uniqueId) {
            object[Jeeel.UNIQUE_ID] = uniqueId = index++;
        }
        
        if ( ! name) {
            name = defaultName;
        }
        
        if (instances[name] && instances[name][uniqueId]) {
            return instances[name][uniqueId];
        } else if ( ! (this instanceof Jeeel.Storage.Object)) {
            return new Jeeel.Storage.Object(object, name);
        }
        
        Jeeel.Storage.Abstract.call(this);
        
        if ( ! instances[name]) {
            instances[name] = {};
        }
        
        instances[name][uniqueId] = this;
        this._params = {};
    };
})();

/**
 * インスタンスの作成を行う
 * 
 * @param {Object} object 疑似保存対象のObject(IEでElement指定の場合は何も無いが、その他の場合はプロパティが拡張させるので注意、その際のキーはJeeel.UNIQUE_IDが使用される)
 * @param {String} [name] ネームスペースを指定する場合に指定
 * @return {Jeeel.Storage.Object} 作成したインスタンス
 * @see Jeeel.UNIQUE_ID
 */
Jeeel.Storage.Object.create = function (object, name) {
    return new this(object, name);
};

Jeeel.Storage.Object.prototype = {

    /**
     * Domの疑似保存先ストレージ
     * 
     * @type Hash
     * @private
     */
    _params: {},
    
    /**
     * データの保存を行う
     * 
     * @param {Hash} params 保存データ
     * @return {Jeeel.Storage.Object} 自インスタンス
     */
    save: function (params) {
        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }
        
        for (var key in params) {
            this._params[key] = params[key];
        }
        
        return this;
    },

    /**
     * データの読み込みを行う
     * 
     * @return {Hash} 読み込んだデータ
     */
    load: function () {
        var key, res = {};
        
        for (key in this._params) {
            res[key] = this._params[key];
        }
        
        return res;
    },
    
    /**
     * データを一つだけ保存する
     * 
     * @param {String} key 保存キー
     * @param {Mixed} value 保存値
     * @return {Jeeel.Storage.Object} 自インスタンス
     */
    saveData: function (key, value) {
        this._params[key] = value;
        
        return this;
    },
    
    /**
     * データを一つだけ読み込む
     * 
     * @param {String} key 読み込みキー
     * @return {Mixed} 読み込んだデータ
     */
    loadData: function (key) {
        return this._params[key];
    },
    
    /**
     * データを全て破棄する
     * 
     * @return {Jeeel.Storage.Object} 自インスタンス
     */
    clear: function () {
        this._params = {};
        
        return this;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Object, Jeeel.Storage.Abstract);

/**
 * ネームスペースに関するモジュール
 * @ignore
 */
Jeeel.Namespace = {
  
    /**
     * 指定したネームスペースを作成する<br />
     * その際存在するネームスペースは再利用される
     * 
     * @param {String} namespace ネームスペース(例: Jeeel.AppやJeeel)
     * @param {Object} [object] ネームスペースに追加するオブジェクト値(ネームスペースが未定義時にしか意味が無い)
     * @return {Object} ネームスペース
     */
    create: function (namespace, object) {
        var names = namespace.split('.');
        var parent = Jeeel._global;

        for (var i = 0, l = names.length - 1; i <= l; i++) {
            if ( ! (names[i] in parent)) {

                if (i == l) {
                    parent[names[i]] = object || {};
                } else {
                    parent[names[i]] = {};
                }
            }

            parent = parent[names[i]];
        }

        return parent;
    },
    
    /**
     * ネームスペースをグローバルに引き上げる<br />
     * その際末尾の値がオブジェクトだった場合は全て短かいされ
     * 
     * @param {String} namespace ネームスペース(例: Jeeel.AppやJeeel)
     * @return {Jeeel.Namespace} 自クラス
     */
    use: function (namespace) {
    
        var names = namespace.split('.');
        var parent = Jeeel._global;

        for (var i = 0, l = names.length - 1; i < l; i++) {
            if ( ! (names[i] in parent)) {
                throw new Error('指定したネームスペースは存在しません。');
            }

            parent = parent[names[i]];
        }

        if (i !== 0) {
            Jeeel._global[names[i]] = parent[names[i]];
        }
        
        return this;
    }
};
Jeeel.directory.Jeeel.External = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'External/';
    }
};

/**
 * 外部との連携に関するネームスペース
 */
Jeeel.External = {

};

Jeeel.file.Jeeel.External = ['CallActionScript'];

Jeeel._autoImports(Jeeel.directory.Jeeel.External, Jeeel.file.Jeeel.External);

/**
 * Flash内のActionScript関数を呼び出す
 *
 * @param {String} flashName embedタグのname
 * @param {String} methodName 呼び出す関数名
 * @param {Mixied} var_args 呼び出す際に渡す引数の可変引数
 * @return {Mixied} ActionScript側からの戻り値
 */
Jeeel.External.callActionScript = function (flashName, methodName, var_args) {
    var flash = Jeeel._doc[flashName];
    
    if ( ! flash || ! flash[methodName]) {
        Jeeel.errorDump('ActionScript Call Error');
        return null;
    }
    
    var method = flash[methodName];
    var args = Array.prototype.slice.call(arguments, 2, arguments.length);
    
    if (method.apply) {
        return method.apply(flash, args);
    }

    return Jeeel.Function.toNative(flash, methodName).apply(null, args);
};

(function () {
  
    // 遅延実行待ちのメソッド
    var deferredQueue = [];
    
    /**
     * コンストラクタ
     * 
     * @class 遅延実行を管理するクラス
     */
    Jeeel.Deferred = function () {
        this.reset();
    };
    
    /**
     * インスタンスの作成を行う
     * 
     * @return {Jeeel.Deferred} 作成したインスタンス
     */
    Jeeel.Deferred.create = function () {
        return new this();
    };
    
    /**
     * デフォルトのメソッド成功時の挙動
     * 
     * @param {Mixied} [x] 引数
     */
    Jeeel.Deferred.success = function (x) {
        return x;
    };

    /**
     * デフォルトのメソッド失敗時の挙動
     * 
     * @param {Mixied} [x] 引数
     */
    Jeeel.Deferred.error = function (x) {
        throw x;
    };

    /**
     * 指定したメソッドを遅延実行する
     * 
     * @param {Function} callback 遅延実行対象のメソッド
     * @return {Jeeel.Deferred} 作成したインスタンス
     */
    Jeeel.Deferred.next = function (callback) {
        var df = new this();
        
        if ( ! deferredQueue[0]) {
            var id = setTimeout(function () {
              
                var dq = deferredQueue.shift();

                if (deferredQueue[0]) {
                    id = setTimeout(arguments.callee, 0);
                    
                    deferredQueue[0]._canceller = function () {
                        clearTimeout(id);
                    };
                }
                
                dq.call();
            }, 0);

            df._canceller = function () {
                clearTimeout(id);
            };
        }
        
        deferredQueue[deferredQueue.length] = function () {
            df.call();
        };

        if (callback) {
            df._callback.success = callback;
        }

        return df;
    };
    
    /**
     * 待ちキューのサイズを取得する
     * 
     * @return {Integer} 待ちキューのサイズ
     */
    Jeeel.Deferred.getQueueSize = function () {
        return deferredQueue.length;
    };
})();

Jeeel.Deferred.prototype = {
    
    /**
     * 成功・失敗の時に呼ばれるコールバック
     * 
     * @type Hash
     * @private
     */
    _callback: null,
    
    /**
     * キャンセル時に呼ばれるメソッド
     * 
     * @type Function
     * @private
     */
    _canceller: null,
    
    /**
     * 次に実行されるメソッドのキュー
     * 
     * @type Function[]
     */
    _next: null,
    
    /**
     * 初期状態に戻す
     * 
     * @return {Jeeel.Deferred} 自インスタンス
     */
    reset: function () {
        this._next = null;

        this._callback = {
            success: this.constructor.success,
            error: this.constructor.error
        };
        
        return this;
    },
    
    /**
     * 遅延実行を執行する
     * 
     * @param {Mixied} [val] 引数
     * @return {Jeeel.Deferred} 自インスタンス
     */
	  call: function (val) {
        return this._dispatch("success", val);
    },
    
    /**
     * 遅延実行を途中キャンセルする
     * 
     * @return {Jeeel.Deferred} 自インスタンス
     */
    cancel: function () {
        (this._canceller || function () {})();
        
        return this.reset();
    },
    
    /**
     * 次のメソッドを呼ぶ
     * 
     * @param {Function} nextCallback 次のメソッド
     * @return {Jeeel.Deferred} 新規インスタンス
     */
    next: function (nextCallback) {
        return this._push('success', nextCallback);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Deferred,
    
    _dispatch: function (p, v) {
        var next = "success";
        
        try {
            v = this._callback[p].call(this, v);
        } catch (e) {
            next = "error";
            v = e;
        }
        
        if (v instanceof this.constructor) {
            v._next = this._next;
        } else {
            if (this._next) {
                this._next._dispatch(next, v);
            }
        }
        
        return this;
    },
    
    _push: function (p, f) {
        this._next = new this.constructor();
        this._next._callback[p] = f;
        
        return this._next;
    }
};
Jeeel.directory.Jeeel.Framework = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Framework/';
    }
};

/**
 * 大規模アプリケーション開発を円滑にするための汎用クラス等を保持するネームスペース<br />
 * 現在試用段階であり、使用する際は削除・変更が頻繁にある事に注意
 */
Jeeel.Framework = {
    
};

Jeeel.file.Jeeel.Framework = ['Net', 'Event', 'EventDispatcher', 'Layer', 'Mvc'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework, Jeeel.file.Jeeel.Framework);
Jeeel.directory.Jeeel.Framework.Net = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Framework + 'Net/';
    }
};

/**
 * ネット関連のネームスペース
 */
Jeeel.Framework.Net = {

};

Jeeel.file.Jeeel.Framework.Net = ['Connect'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework.Net, Jeeel.file.Jeeel.Framework.Net);

/**
 * コンストラクタ
 * 
 * @class サーバーコネクトのプロトタイプ
 */
Jeeel.Framework.Net.Connect = function () {
    
};

Jeeel.Framework.Net.Connect.prototype = {
    
    /**
     * 並列接続時の動作ポリシー
     * 
     * @type Integer
     * @protected
     */
    _collisionPolicy: 0,
    
    /**
     * タイムアウト時間(ミリ秒)
     * 
     * @type Integer
     * @protected
     */
    _timeout: 60000,
    
    /**
     * HTTPメソッド
     * 
     * @type String
     * @protected
     */
    _method: 'POST',
    
    /**
     * Ajaxインスタンス
     * 
     * @type Jeeel.Net.Ajax
     * @protected
     */
    _ajax: null,
    
    /**
     * 並列リクエストをした場合の動作を設定する
     * 
     * @param {Integer} collisionPolicy コリジョンポリシー
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     * @see Jeeel.Net.Ajax.CollisionPolicy
     */
    setCollisionPolicy: function (collisionPolicy) {
        this._collisionPolicy = collisionPolicy;
        
        return this;
    },
    
    /**
     * リクエストのタイムアウトまでの時間を設定する(デフォルトは60秒)
     * 
     * @param {Integer} time タイムアウト時間、0で無制限(ミリ秒)
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     */
    setTimeoutTime: function (time) {
        this._timeout = time;
        
        return this;
    },
    
    /**
     * HTTPメソッドを設定する
     * 
     * @param {String} [method] HTTPメソッド(POSTもしくはGET、大文字小文字は問わない)
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     */
    setMethod: function (method) {
        this._method = method;
        
        return this;
    },
    
    /**
     * サーバーに接続する
     * 
     * @param {String} url 接続URL
     * @param {Hash} [params] 送信データのリスト
     * @param {Function} [success] 成功時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
     * @param {Function} [failure] 失敗時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
     * @param {Function} [timeout] タイムアウト時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     */
    connect: function (url, params, success, failure, timeout) {
        this._ajax = new Jeeel.Net.Ajax(url, this._method);
        
        this._ajax.setAll(params || {})
                  .setTimeoutTime(this._timeout)
                  .setCollisionPolicy(this._collisionPolicy)
                  .setSuccessMethod(success || this.update, this)
                  .setFailureMethod(failure || this.recover, this)
                  .setTimeoutMethod(timeout || this.abanbon, this)
                  .setCompleteMethod(function () {
                      this._ajax = null;
                  }, this)
                  .execute();
        
        return this;
    },
    
    /**
     * 現在の通信を中止させる
     * 
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     */
    abort: function () {
        if (this._ajax) {
            this._ajax.abort();
        }
        
        return this;
    },
    
    /**
     * 接続成功時に通常呼ばれるコールバック(内部のthisは自インスタンスになる)
     * 
     * @param {Jeeel.Net.Ajax.Response} response レスポンス
     * @abstract
     */
    update: function (response) {
        
    },
    
    /**
     * タイムアウト時に通常呼ばれるコールバック(内部のthisは自インスタンスになる)
     * 
     * @param {Jeeel.Net.Ajax.Response} response レスポンス
     * @abstract
     */
    abanbon: function (response) {
        
    },
    
    /**
     * エラー時に通常呼ばれるコールバック(内部のthisは自インスタンスになる)
     * 
     * @param {Jeeel.Net.Ajax.Response} response レスポンス
     * @abstract
     */
    recover: function (response) {
        
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Net.Connect
};Jeeel.directory.Jeeel.Framework.Event = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Framework + 'Event/';
    }
};

/**
 * コンストラクタ
 * 
 * @class イベントを管理するクラス<br />
 *         イベントの伝播は最上層からキャプチャリング段階に入り発生地点までたどる<br />
 *         発生地点でターゲティング段階になり、バブリング段階になって最上層に向かって上っていく<br />
 *         最後にフォーリング段階になり発生地点から最下層まで全ての要素に伝播していく
 * @param {String} type イベントタイプ
 * @param {Boolean} [bubbles=true] バブリング処理をするかどうか(上位伝播)
 * @param {Boolean} [falls] フォーリング処理をするかどうか(下位伝播)
 * @param {Boolean} [cancelable] デフォルト動作をキャンセル出来るかどうか(存在しない場合や出来ない場合がfalse)
 */
Jeeel.Framework.Event = function (type, bubbles, falls, cancelable) {
    this._type = type;
    this._bubbles = !!(bubbles === false ? bubbles : bubbles || true);
    this._falls = !!falls;
    this._cancelable = !!cancelable;
    this._captureTargets = [];
};

Jeeel.Framework.Event.prototype = {
  
    /**
     * イベントタイプ
     * 
     * @type String
     * @protected
     */
    _type: '',
    
    /**
     * 上階層の要素にバブリングフローをするかどうか
     * 
     * @type Boolean
     * @protected
     */
    _bubbles: true,
    
    /**
     * 下階層の要素にフォーリングフローするかどうか
     * 
     * @type Boolean
     * @protected
     */
    _falls: false,
    
    /**
     * デフォルトの動作をキャンセル出来るかどうか
     * 
     * @type Boolean
     * @protected
     */
    _cancelable: false,
    
    /**
     * デフォルトの挙動をキャンセルしたかどうか
     * 
     * @type Boolean
     * @protected
     */
    _cancelDefault: false,
    
    /**
     * イベントのハンドリングをキャンセルしたかどうか
     * 
     * @type Boolean
     * @protected
     */
    _cancelHandle: false,
    
    /**
     * イベントの伝播をキャンセルしたかどうか
     * 
     * @type Boolean
     * @protected
     */
    _cancelFlow: false,
    
    /**
     * イベントフェーズ
     * 
     * @type Integer
     * @protected
     */
    _phase: 1,
    
    /**
     * キャプチャ段階で使用する対象リスト
     * 
     * @type Object[]
     * @protected
     */
    _captureTargets: [],
    
    /**
     * イベント発生対象
     * 
     * @type Object
     * @protected
     */
    _target: null,
    
    /**
     * イベントハンドリング対象
     * 
     * @type Object
     * @protected
     */
    _currentTarget: null,
    
    /**
     * イベントタイプを取得する
     * 
     * @return {String} イベントタイプ
     */
    getType: function () {
        return this._type;
    },
    
    /**
     * バブリング処理をするかどうかを返す
     * 
     * @return {Boolean} バブリング処理をするかどうか
     */
    getBubbles: function () {
        return this._bubbles;
    },
    
    /**
     * フォーリング段階をするかどうかを返す
     * 
     * @return {Boolean} フォーリング処理をするかどうか
     */
    getFalls: function () {
        return this._falls;
    },
    
    /**
     * 現在のイベントフェーズを示す定数を取得する
     * 
     * @return {Integer} イベントフェーズ定数
     */
    getEventPhase: function () {
        return this._phase;
    },
    
    /**
     * イベント発生対象を取得する
     * 
     * @return {Object} イベント発生対象
     */
    getTarget: function () {
        return this._target;
    },
    
    /**
     * イベントハンドリング対象を取得する
     * 
     * @return {Object} イベントハンドリング対象
     */
    getCurrentTarget: function () {
        return this._currentTarget;
    },
    
    /**
     * イベントのデフォルトの動作がキャンセル出来るかどうかを返す
     * 
     * @return {Boolean} キャンセル出来るかどうか
     */
    isCancelable: function () {
        return this._cancelable;
    },
    
    /**
     * デフォルトの挙動がキャンセルされたかどうかを返す
     * 
     * @return {Boolean} キャンセルされたかどうか
     */
    isDefaultPrevented: function () {
        return this._cancelDefault;
    },
    
    /**
     * イベントのデフォルトの動作をキャンセルする<br />
     * デフォルトの挙動のキャンセルが許可されていない場合は無意味
     * 
     * @return {Jeeel.Framework.Event} 自インスタンス
     */
    preventDefault: function () {
        if (this._cancelable) {
            this._cancelDefault = true;
        }
        
        return this;
    },
    
    /**
     * イベントの伝播を止める
     * 
     * @return {Jeeel.Framework.Event} 自インスタンス
     */
    stopPropagation: function () {
        this._cancelFlow = true;
        
        return this;
    },
    
    /**
     * イベントの伝播とハンドリングを止める
     * 
     * @return {Jeeel.Framework.Event} 自インスタンス
     */
    stopImmediatePropagation: function () {
        this._cancelFlow = this._cancelHandle = true;
        
        return this;
    },
    
    /**
     * イベントの伝播、ハンドリング、デフォルトの挙動全てを停止する
     * 
     * @return {Jeeel.Framework.Event} 自インスタンス
     */
    stop: function () {
        this._cancelDefault = this._cancelFlow = this._cancelHandle = true;
        
        return this;
    },
    
    /**
     * 複製を行う
     * 
     * @param {Boolean} [dispatchable] ディスパッチ済みのインスタンスを複製した際にディスパッチ出来るようにするかどうか
     * @return {Jeeel.Framework.Event} 複製したインスタンス
     */
    clone: function (dispatchable) {
        var instance = new this.constructor(this._type, this._bubbles, this._cancelable);
        
        for (var key in this) {
            if ( ! Jeeel.Type.isFunction(this[key])) {
                instance[key] = this[key];
            }
        }
        
        for (var i = this._captureTargets.length; i--;) {
            instance._captureTargets[i] = this._captureTargets[i];
        }
        
        if (dispatchable) {
            instance._phase = 1;
            instance._target = null;
        }
        
        return instance;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Event
};

Jeeel.file.Jeeel.Framework.Event = ['Phase', 'Type'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework.Event, Jeeel.file.Jeeel.Framework.Event);

/**
 * イベントフェーズの列挙体
 * 
 * @enum {Integer}
 */
Jeeel.Framework.Event.Phase = {
  
    /**
     * キャプチャ段階
     * 
     * @type Integer
     * @constant
     */
    CAPTURING: 1,
    
    /**
     * ターゲット段階
     * 
     * @type Integer
     * @constant
     */
    TARGETING: 2,
    
    /**
     * バブリング段階
     * 
     * @type Integer
     * @constant
     */
    BUBBLING: 3,
    
    /**
     * フォーリング段階
     * 
     * @type Integer
     * @constant
     */
    FALLING: 4
};
/**
 * イベントタイプの列挙体
 * 
 * @enum {String}
 */
Jeeel.Framework.Event.Type = {
  
    /**
     * レイヤーオブジェクトがaddChildで追加された時に発生する
     * 
     * @type String
     * @constant
     */
    ADDED: 'Added',
    
    /**
     * レイヤーオブジェクトがremoveChildで削除された時に発生する
     * 
     * @type String
     * @constant
     */
    REMOVED: 'Removed'
};
/**
 * コンストラクタ
 * 
 * @class イベントのハンドリング、ディスパッチを行うクラス
 */
Jeeel.Framework.EventDispatcher = function () {
    this._eventHandlers = {};
};

Jeeel.Framework.EventDispatcher.prototype = {
    
    /**
     * 登録イベントハンドラー
     * 
     * @type Hash
     * @private
     */
    _eventHandlers: {},
    
    /**
     * イベントの登録を行う
     * 
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録リスナー
     * @param {Boolean} [useCapture] キャプチャ段階でリスナーを呼び出すかどうか
     * @param {Mixied} [thisArg] イベントリスナー内でthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Framework.Event、２つ目以降に任意引数)
     * @return {Jeeel.Framework.EventDispatcher} 自インスタンス
     */
    addEventListener: function (type, listener, useCapture, thisArg, var_args) {
        if ( ! this._eventHandlers[type]) {
            this._eventHandlers[type] = [];
        }
        
        useCapture = !!useCapture;
        
        var handlers = this._eventHandlers[type];
        
        for (var i = handlers.length; i--;) {
            if (handlers[i].listener === listener && handlers[i].useCapture === useCapture) {
                return this;
            }
        }
        
        var args = Array.prototype.slice.call(arguments, 4, arguments.length);
        
        args.unshift(null);
          
        handlers[handlers.length] = {
            listener: listener,
            useCapture: useCapture,
            thisArg: thisArg,
            args: args
        };
        
        return this;
    },
    
    /**
     * イベントの削除を行う
     * 
     * @param {String} type イベントタイプ
     * @param {Function} listener 削除リスナー
     * @param {Boolean} [useCapture] キャプチャ段階でリスナーを呼び出すかどうか
     * @return {Jeeel.Framework.EventDispatcher} 自インスタンス
     */
    removeEventListener: function (type, listener, useCapture) {
        var handlers = this._eventHandlers[type];
        
        if ( ! handlers) {
            return this;
        }
        
        useCapture = !!useCapture;
        
        for (var i = handlers.length; i--;) {
            if (handlers[i].listener === listener && handlers[i].useCapture === useCapture) {
                handlers.splice(i, 1);
                break;
            }
        }
        
        return this;
    },
    
    /**
     * 指定したイベントタイプのイベントが登録されているかどうかを返す
     * 
     * @param {String} type イベントタイプ
     * @return {Boolean} 登録されているかどうか
     */
    hasEventListener: function (type) {
        return !!(this._eventHandlers[type] && this._eventHandlers[type].length);
    },
    
    /**
     * イベントを発生させる
     * 
     * @param {Jeeel.Framework.Event} event 発生対象のEvent
     * @return {Jeeel.Framework.EventDispatcher} 自インスタンス
     */
    dispatchEvent: function (event) {
        if (event._target) {
            throw new Error('eventは既にディスパッチ済みのEventオブジェクトです。');
        }
        
        event._target = this;
        
        event._captureTargets.push(this);
        
        return this._flowEvent(event);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.EventDispatcher,
    
    /**
     * 他のディスパッチャーで発生したイベントを疑似フローさせる
     * 
     * @param {Jeeel.Framework.Event} event 疑似フロー対象のEvent
     * @return {Jeeel.Framework.EventDispatcher} 自インスタンス
     * @final
     * @protected
     */
    _flowEvent: function (event) {
        if (event._cancelFlow) {
            return this;
        }
        
        var phase = event.getEventPhase();
        
        this._callListener(event, phase === Jeeel.Framework.Event.Phase.CAPTURING);
        
        switch (phase) {
            case Jeeel.Framework.Event.Phase.CAPTURING:
                var capture = event._captureTargets.pop();
                
                if (capture === event._target) {
                    event._phase = Jeeel.Framework.Event.Phase.TARGETING;
                } else if (capture === this) {
                    capture = event._captureTargets.pop();
                    
                    if (capture === event._target) {
                        event._phase = Jeeel.Framework.Event.Phase.TARGETING;
                    }
                }
                
                capture._flowEvent(event);
                break;
                
            case Jeeel.Framework.Event.Phase.TARGETING:
                if (event.getBubbles() || event.getFalls()) {
                    if (event.getBubbles()) {
                        event._phase = Jeeel.Framework.Event.Phase.BUBBLING;
                        this._flowBubblingPhaseEvent(event);
                    }
                    
                    if (event.getFalls()) {
                        event._phase = Jeeel.Framework.Event.Phase.FALLING;
                        this._flowFallingPhaseEvent(event);
                    }
                } else {
                    event._cancelFlow = true;
                }
                
                break;
            
            case Jeeel.Framework.Event.Phase.BUBBLING:
                if (event.getBubbles()) {
                    this._flowBubblingPhaseEvent(event);
                }
                break;
                
            case Jeeel.Framework.Event.Phase.FALLING:
                if (event.getFalls()) {
                    this._flowFallingPhaseEvent(event);
                }
                break;
                
            default:
                throw new Error('フェーズの状態が不明です。');
                break;
        }
        
        return this;
    },
    
    /**
     * イベントをバブリングする
     * 
     * @param {Jeeel.Framework.Event} event バブリング対象のEvent
     * @protected
     * @abstract
     */
    _flowBubblingPhaseEvent: function (event) {
        
    },
    
    /**
     * イベントをフォーリングする
     * 
     * @param {Jeeel.Framework.Event} event フォーリング対象のEvent
     * @protected
     * @abstract
     */
    _flowFallingPhaseEvent: function (event) {
        
    },
    
    /**
     * このインスタンスに定義されているリスナーを呼び出す
     * 
     * @param {Jeeel.Framework.Event} event Eventオブジェクト
     * @param {Boolean} useCapture キャプチャ段階でのリスナーをキャッチするかどうか
     * @final
     * @protected
     */
    _callListener: function (event, useCapture) {
        if (event._cancelHandle) {
            return this;
        }
        
        var handlers = this._eventHandlers[event.getType()];
        
        if ( ! handlers) {
            return this;
        }
        
        event._currentTarget = this;
        
        var cloneHandlers = handlers.concat();
        
        for (var i = 0, l = cloneHandlers.length; i < l; i++) {
            
            if (cloneHandlers[i].useCapture === useCapture) {
                cloneHandlers[i].args[0] = event;
                
                cloneHandlers[i].listener.apply(cloneHandlers[i].thisArg, cloneHandlers[i].args);
                
                cloneHandlers[i].args[0] = null;

                if (event._cancelHandle) {
                    break;
                }
            }
        }
        
        return this;
    }
};
/**
 * コンストラクタ
 * 
 * @class 階層構造のオブジェクトを管理するクラス
 * @augments Jeeel.Framework.EventDispatcher
 */
Jeeel.Framework.Layer = function () {
    Jeeel.Framework.EventDispatcher.call(this);
    
    this._children = [];
};

Jeeel.Framework.Layer.prototype = {
    
    /**
     * 親レイヤー
     * 
     * @type Jeeel.Framework.Layer
     * @protected
     */
    _parent: null,
    
    /**
     * 子レイヤーリスト
     * 
     * @type Jeeel.Framework.Layer[]
     * @protected
     */
    _children: [],
    
    /**
     * 子レイヤーを追加する
     * 
     * @param {Jeeel.Framework.Layer} child 子レイヤー
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    addChild: function (child) {
        this._children[this._children.length] = child;
        
        child._refreshRelationship(this);
        
        return this;
    },
    
    /**
     * 子レイヤーを削除する
     * 
     * @param {Jeeel.Framework.Layer} child 子レイヤー
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    removeChild: function (child) {
        for (var i = this._children.length; i--;) {
            if (this._children[i] === child) {
                this._children.splice(i, 1);
                child._refreshRelationship();
                break;
            }
        }

        return this;
    },
    
    /**
     * 指定したインデックスの子レイヤーを削除する
     * 
     * @param {Integer} index インデックス
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    removeChildAt: function (index) {
        if (this._children[index]) {
            var child = this._children[index];
            
            this._children.splice(index, 1);
            
            child._refreshRelationship();
        }
        
        return this;
    },
    
    /**
     * 全ての子レイヤーを削除する
     * 
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    removeChildren: function () {
        for (var i = this._children.length; i--;) {
            this._children[i]._refreshRelationship();
        }
        
        this._children.splice(0, this._children.length);
        
        return this;
    },
    
    /**
     * 親レイヤーを取得する
     * 
     * @return {Jeeel.Framework.Layer} 親レイヤー
     */
    getParent: function () {
        return this._parent;
    },
    
    /**
     * 子レイヤーリストを取得する
     * 
     * @return {Jeeel.Framework.Layer[]} 子レイヤーリスト
     */
    getChildren: function () {
        return this._children;
    },
    
    /**
     * 指定したインデックスの子レイヤーを取得する
     * 
     * @param {Integer} index インデックス
     * @return {Jeeel.Framework.Layer} 子レイヤー
     */
    getChildAt: function (index) {
        return this._children[index] || null;
    },
    
    /**
     * 子レイヤーの数を取得する
     * 
     * @return {Integer} 子レイヤーの数
     */
    getChildSize: function () {
        return this._children.length;
    },
    
    /**
     * イベントを発生させる
     * 
     * @param {Jeeel.Framework.Event} event 発生対象のEvent
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    dispatchEvent: function (event) {
        if ( ! (event instanceof Jeeel.Framework.Event)) {
            throw new Error('eventが指定されていません。');
        } else if (event._target) {
            throw new Error('eventは既にディスパッチ済みのEventオブジェクトです。');
        }
        
        event._target = this;
        
        var layer = this;
        var captureTargets = event._captureTargets;
        
        while (layer) {
            captureTargets[captureTargets.length] = layer;
            layer = layer._parent;
        }
        
        captureTargets[captureTargets.length - 1]._flowEvent(event);
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Layer,
    
    /**
     * ディスパッチされたイベントのフローを親レイヤーに伝える
     * 
     * @param {Jeeel.Framework.Event} event フロー対象のEvent
     * @return {Jeeel.Framework.Layer} 自インスタンス
     * @protected
     */
    _flowBubblingPhaseEvent: function (event) {
        // 上位伝播対象でイベントがキャンセルしていない場合に親レイヤーに伝播する
        if (this._parent && event.getBubbles() && ! event._cancelFlow) {
            this._parent._flowEvent(event);
        }
    },
    
    /**
     * ディスパッチされたイベントのフローを子レイヤーに伝える
     * 
     * @param {Jeeel.Framework.Event} event フォーリング対象のEvent
     * @return {Jeeel.Framework.Layer} 自インスタンス
     * @protected
     */
    _flowFallingPhaseEvent: function (event) {
        // 下位伝播対象でイベントがキャンセルしていない場合に子レイヤーに伝播する
        if (event.getFalls() && ! event._cancelFlow) {
            for (var i =  this._children.length; i--;) {
                this._children[i]._flowEvent(event);
            }
        }
    },
    
    /**
     * 親に追加された時に呼び出される(デフォルトの挙動)
     * 
     * @abstract
     * @protected
     */
    _onAddedThis: function (parent) {
        
    },
    
    /**
     * 親から削除された時に呼び出される(デフォルトの挙動)
     * 
     * @abstract
     * @protected
     */
    _onRemovedThis: function (parent) {
        
    },
    
    /**
     * 親子関係の更新する
     * 
     * @param {Jeeel.Framework.Layer} parent 親レイヤー
     * @final
     * @protected
     */
    _refreshRelationship: function (parent) {
        var event;
        
        if ( ! parent) {
            parent = this._parent;
            this._parent = null;
            
            event = new Jeeel.Framework.Event(Jeeel.Framework.Event.Type.REMOVED, true, false, true);
            
            this.dispatchEvent(event);
            
            if ( ! event.isDefaultPrevented()) {
                this._onRemovedThis(parent);
            }
            return;
        } else if (this._parent) {
            this._parent.removeChild(this);
        }
        
        this._parent = parent;
        
        event = new Jeeel.Framework.Event(Jeeel.Framework.Event.Type.ADDED, true, false, true);
        
        this.dispatchEvent(event);
        
        if ( ! event.isDefaultPrevented()) {
            this._onAddedThis(parent);
        }
    }
};

Jeeel.Class.extend(Jeeel.Framework.Layer, Jeeel.Framework.EventDispatcher);
Jeeel.directory.Jeeel.Framework.Mvc = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Framework + 'Mvc/';
    }
};

/**
 * MVCモデル関連のネームスペース
 */
Jeeel.Framework.Mvc = {
    
};

Jeeel.file.Jeeel.Framework.Mvc = ['Model', 'View', 'Controller'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework.Mvc, Jeeel.file.Jeeel.Framework.Mvc);

/**
 * コンストラクタ
 * 
 * @class モデルのプロトタイプ
 * @augments Jeeel.Framework.Net.Connect
 */
Jeeel.Framework.Mvc.Model = function () {
    Jeeel.Framework.Net.Connect.call(this);
    
    this._state = {};
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Framework.Mvc.Model} 作成したインスタンス
 */
Jeeel.Framework.Mvc.Model.create = function () {
    return new this();
};

Jeeel.Framework.Mvc.Model.prototype = {
    
    /**
     * モデルのステータス(配列もしくは連想配列)
     * 
     * @type Hash
     * @protected
     */
    _state: {},
    
    /**
     * このモデルを管理するコントローラ
     * 
     * @type Jeeel.Framework.Mvc.Controller
     * @protected
     */
    _controller: null,
    
    /**
     * ステータスを取得する
     * 
     * @return {Hash} ステータス
     */
    getState: function () {
        return this._state;
    },
    
    /** 
     * ステータスを設定する
     * 
     * @param {Hash} state ステータス
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    setState: function (state) {},
    
    /**
     * モデルの初期化を行い、登録してあるビューに通知する
     * 
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    init: function () {
        this._state = {};
        return this.notify();
    },
    
    /**
     * サーバー接続後に呼び出される
     * 
     * @param {Jeeel.Net.Ajax.Response} response レスポンス
     */
    update: function (response) {
        var res;
        
        try {
            res = Jeeel.Json.decode(decodeURIComponent(response.responseText));
        } catch (e) {}
        
        if ( ! Jeeel.Type.isHash(res)) {
            this.recover(response);
        } else {
            this._state = res;
            this.notify();
        }
    },
        
    /**
     * コントローラを紐付ける
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    attach: function (controller) {
        if (this._controller) {
            this._controller.setModel(null);
        }
        
        this._controller = controller;
        
        return this;
    },
    
    /**
     * コントローラとの紐付けを解除する
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    detach: function (controller) {
        if (this._controller === controller) {
            this._controller = null;
        }
        
        return this;
    },
    
    /**
     * ビューへの通知を行う
     * 
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    notify: function () {
        this._controller.update();
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Mvc.Model
};

/**
 * ステータスをサーバーから取得し設定する
 * 
 * @param {String} url 取得先URL
 * @param {Hash} [params] 送信データのリスト
 * @param {Function} [success] 成功時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
 * @param {Function} [failure] 失敗時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
 * @param {Function} [timeout] タイムアウト時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
 * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
 */
Jeeel.Framework.Mvc.Model.prototype.setState = function (url, params, success, failure, timeout) {
    var state = url;
    
    if (Jeeel.Type.isString(url) || arguments.length > 1) {
        return this.connect(url, params, success, failure, timeout);
    }
    
    if ( ! Jeeel.Type.isHash(state)) {
        throw new Error('stateがHashではありません。');
    }

    this._state = state;
    
    return this;
};

Jeeel.Class.extend(Jeeel.Framework.Mvc.Model, Jeeel.Framework.Net.Connect);

/**
 * コンストラクタ
 * 
 * @class ビューのプロトタイプ(Elementのラッパー要素の代わりでもある)
 * @augments Jeeel.Framework.Layer
 * @param {Element|String} element このビューが扱うElement
 * @param {Boolean} [useAutoAdd] このビューのオーナーコントローラが親コントローラに追加された時に、<br />
 *                                自動的にこのビューのElementを親コントローラのビューに追加するかどうか
 * @throws {Error} elementがHTML要素かIDで無かった場合に発生
 */
Jeeel.Framework.Mvc.View = function (element, useAutoAdd) {
    if (Jeeel.Type.isString(element)) {
        element = Jeeel.Document.getElementById(element);
    }
    
    if ( ! Jeeel.Type.isElement(element)) {
        throw new Error('このビューに対するElementを指定して下さい。');
    }
    
    this._element = element;
    this._useAutoAdd = !!useAutoAdd;
    
    Jeeel.Framework.Layer.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Element|String} element このビューが扱うElement
 * @param {Boolean} [useAutoAdd] このビューのオーナーコントローラが親コントローラに追加された時に、<br />
 *                                自動的にこのビューのElementを親コントローラのビューに追加するかどうか
 * @return {Jeeel.Framework.Mvc.View} 作成したインスタンス
 * @throws {Error} elementがHTML要素かIDで無かった場合に発生
 */
Jeeel.Framework.Mvc.View.create = function (element, useAutoAdd) {
    return new this(element, useAutoAdd);
};

Jeeel.Framework.Mvc.View.prototype = {
    
    /**
     * このビューを管理するコントローラ
     * 
     * @type Jeeel.Framework.Mvc.Controller
     * @protected
     */
    _controller: null,
    
    /**
     * このビューに関連付けられているElement
     * 
     * @type Element
     * @protected
     */
    _element: null,
    
    /**
     * Dom上に自動追加するかどうか
     * 
     * @type Boolean
     * @protected
     */
    _useAutoAdd: false,
    
    /**
     * このビューに関連付けられているElementを取得する
     * 
     * @return {Element} 関連付けElement
     */
    getElement: function () {
        return this._element;
    },
    
    /**
     * 子ビューを追加する<br />
     * この追加でコントローラ管理されているビューを追加するとElement間の追加しか行われない
     * 
     * @param {Jeeel.Framework.Mvc.View} child 追加要素
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    addChild: function (child) {
      
        if ( ! child._controller) {
            Jeeel.Framework.Layer.prototype.addChild.call(this, child);
        }
        
        if (child._useAutoAdd) {
            this._element.appendChild(child._element);
        }
        
        return this;
    },
    
    /**
     * 子ビューを削除する<br />
     * この削除でコントローラ管理されているビューを削除するとElement間の削除しか行われない
     * 
     * @param {Jeeel.Framework.Mvc.View} child 削除要素
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    removeChild: function (child) {
      
        if ( ! child._controller) {
            Jeeel.Framework.Layer.prototype.removeChild.call(this, child);
        }
        
        if (child._useAutoAdd) {
            this._element.removeChild(child._element);
        }
        
        return this;
    },
    
    /**
     * このビューのElementへイベントの登録を行う
     * 
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録リスナー
     * @param {Mixied} [thisArg] イベントリスナー内でthisに相当する値(デフォルトはこのインスタンス)
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Eventで固定)
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    addDomEventListener: function (type, listener, thisArg, var_args) {
        var args = Array.prototype.slice.call(arguments, 0, arguments.length);
        
        args.unshift(this._element);
        
        if ( ! thisArg) {
            args[3] = this;
        }
        
        Jeeel.Dom.Event.addEventListener.apply(Jeeel.Dom.Event, args);
        
        return this;
    },
    
    /**
     * このビューのElementからイベントの削除を行う
     * 
     * @param {String} type イベントタイプ
     * @param {Function} listener 削除リスナー
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    removeDomEventListener: function (type, listener) {
        Jeeel.Dom.Event.removeEventListener(this._element, type, listener);
        
        return this;
    },
    
    /**
     * コントローラを紐付ける
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    attach: function (controller) {
        if (this._controller) {
            this._controller.removeView(this);
        }
        
        this._controller = controller;
        
        return this;
    },
    
    /**
     * コントローラとの紐付けを解除する
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    detach: function (controller) {
        if (this._controller === controller) {
            this._controller = null;
        }
        
        return this;
    },
    
    /**
     * コントローラが親コントローラに追加された時に呼び出される<br />
     * デフォルトでは親コントローラのビューにaddChildされる
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @param {Jeeel.Framework.Mvc.Controller} parentController 親コントローラ
     */
    onControllerAdded: function (controller, parentController) {
        if ( ! this._useAutoAdd) {
            return;
        }
        
        var parentView = parentController.getView();
        
        if (parentView) {
            parentView.addChild(this);
        }
    },
    
    /**
     * コントローラが親コントローラから削除された時に呼び出される<br />
     * デフォルトでは親コントローラのビューからremoveChildされる
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @param {Jeeel.Framework.Mvc.Controller} parentController 親コントローラ
     */
    onControllerRemoved: function (controller, parentController) {
        if ( ! this._useAutoAdd) {
            return;
        }
        
        var parentView = parentController.getView();
        
        if (parentView) {
            parentView.removeChild(this);
        }
    },
    
    /**
     * モデルが変化した際にコントローラから呼び出される<br />
     * デフォルトでは子ビュー全てのupdateメソッドを呼び出す
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    update: function (controller) {
        for (var i = 0, l = this._children.length; i < l; i++) {
            this._children[i].update(controller);
        }
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Element|String} element このビューが扱うElement
     * @constructor
     */
    constructor: Jeeel.Framework.Mvc.View
};

Jeeel.Class.extend(Jeeel.Framework.Mvc.View, Jeeel.Framework.Layer);

/**
 * コンストラクタ
 * 
 * @class コントローラのプロトタイプ<br />
 *         役割はそれぞれ、モデルが通信・計算・ステータス保持、<br />
 *         ビューが描画・構成・HTML要素とのやりとり、<br />
 *         コントローラが制御・イベントリスナ・カスタムイベントディスパッチなどとなる<br />
 *         なおコントローラとビューはLayerを継承しており、子供にそれぞれコントローラ、ビューを持つ事が出来る<br />
 *         また、EventDispatcherも継承しているのでイベントの制御も可能であり、<br />
 *         子に追加された時や削除された時はデフォルトでイベントがディスパッチされるようになっている
 * @augments Jeeel.Framework.Layer
 */
Jeeel.Framework.Mvc.Controller = function () {
    Jeeel.Framework.Layer.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Framework.Mvc.Controller} 作成したインスタンス
 */
Jeeel.Framework.Mvc.Controller.create = function () {
    return new this();
};

Jeeel.Framework.Mvc.Controller.prototype = {
  
    /**
     * このコントローラに紐づくモデル
     * 
     * @type Jeeel.Framework.Mvc.Model
     * @protected
     */
    _model: null,
    
    /**
     * このコントローラに紐づくビュー
     * 
     * @type Jeeel.Framework.Mvc.View
     * @protected
     */
    _view: null,
    
    /**
     * ビューへの通知を行う
     * 
     * @return {Jeeel.Framework.Mvc.Controller} 自インスタンス
     */
    update: function () {
        this._view.update(this);
        
        return this;
    },
    
    /**
     * モデルを取得する
     * 
     * @return {Jeeel.Framework.Mvc.Model} モデル
     */
    getModel: function () {
        return this._model;
    },
    
    /**
     * モデルを設定する
     * 
     * @param {Jeeel.Framework.Mvc.Model} model モデル
     * @return {Jeeel.Framework.Mvc.Controller} 自インスタンス
     */
    setModel: function (model) {
        if (this._model) {
            this._model.detach(this);
        }
        
        this._model = model;
        
        if (model) {
            model.attach(this);
        }
        
        return this;
    },
    
    /**
     * ビューを取得する
     * 
     * @return {Jeeel.Framework.Mvc.View} ビュー
     */
    getView: function () {
        return this._view;
    },
    
    /**
     * ビューを設定する
     * 
     * @param {Jeeel.Framework.Mvc.View} view ビュー
     * @return {Jeeel.Framework.Mvc.Controller} 自インスタンス
     */
    setView: function (view) {
        if (this._view) {
            this._view.detach(this);
        }
        
        this._view = view;
        
        if (view) {
            view.attach(this);
        }
        
        return this;
    },
       
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Mvc.Controller,
    
    /**
     * 親に追加された時に呼び出される(デフォルトの挙動)
     * 
     * @protected
     */
    _onAddedThis: function (parent) {
        this._view.onControllerAdded(this, parent);
    },
    
    /**
     * 親から削除された時に呼び出される(デフォルトの挙動)
     * 
     * @protected
     */
    _onRemovedThis: function (parent) {
        this._view.onControllerRemoved(this, parent);
    }
};

Jeeel.Class.extend(Jeeel.Framework.Mvc.Controller, Jeeel.Framework.Layer);

Jeeel.directory.Jeeel.Config = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Config/';
    }
};

(function () {
    
    var cash = {};
    var creating = false;
    
    /**
     * コンストラクタ
     * 
     * @class 簡易設定ファイルを管理するクラス(for-inでループも可能)
     * @param {Jeeel.Dom.Xml} xml 軽量ファイルを読み込んだXMLインスタンス
     * @example
     * コンフィグファイルの書式例
     * -----------------------------------------------------
     * <?xml version="1.0" encoding="UTF-8"?>
     * <config>
     *   <url>http://Jeeel.co.jp/test.js</url>
     *   <enable>1</enable>
     * </config>
     * -----------------------------------------------------
     * 
     * // 上記のファイルを読み込む
     * var conf = Jeeel.Config.load(url);
     * 
     * conf.url => http://Jeeel.co.jp/test.js
     * conf.enable => 1
     * 
     * var vals = [];
     * 
     * for (var key in conf) {
     *     vals[vals.length] = {name: key, value: conf[key]};
     * }
     * 
     * vals => [{name: 'url', value: 'http://Jeeel.co.jp/test.js'}, {name: 'enable', value: '1'}]
     */
    Jeeel.Config = function (xml) {
        
        if (creating) {
            this._init(xml);
        } else {
          
            if ( ! (xml instanceof Jeeel.Dom.Xml)) {
                throw new Error('xmlがJeeel.Dom.Xmlインスタンスではありません。');
            }
            
            creating = true;
            
            this._init(xml.config);
            
            creating = false;
        }
    };
    
    /**
     * コンフィグファイルの読み込みを行う<br />
     * キャッシングも行い同じコンフィグへのアクセスは早くなる
     * 
     * @param {String} url コンフィグへのURL
     * @return {Jeeel.Config} コンフィグ
     */
    Jeeel.Config.load = function(url) {
        if (cash[url]) {
            return cash[url];
        }
        
        return cash[url] = new this(Jeeel.Dom.Xml.load(url));
    };
})();

Jeeel.Config.prototype = {
    
    /**
     * 初期化
     * 
     * @param {Jeeel.Dom.Xml.Node[]|Jeeel.Dom.Xml.Node} node ノード
     * @private
     */
    _init: function (node) {
        delete this._init;
        
        if ( ! (node instanceof Jeeel.Dom.Xml.Node)) {
            
            if (node.length !== 1) {
                throw new Error('コンフィグの同階層に同じ名前の要素が存在します。');
            }
            
            node = node[0];
        }
        
        if (node.getNamespace()) {
            throw new Error('コンフィグに名前空間が使用されています。');
        }
        
        var setProperty = false;
        
        for (var key in node) {
            var property = node[key];
            
            if ( ! (key in Jeeel.Dom.Xml.Node.prototype) && property) {
                this[key] = new Jeeel.Config(property);
                setProperty = true;
            }
        }
        
        if ( ! setProperty) {
            var value = node.getValue() || '';
            
            this.valueOf = function () {
                return value;
            };
        }
    }
};Jeeel.directory.Jeeel.Util = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Util/';
    }
};

/**
 * ユーティル関連のネームスペース
 */
Jeeel.Util = {

};

Jeeel.file.Jeeel.Util = ['Prefecture'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Util, Jeeel.file.Jeeel.Util);
/**
 * 都道府県に関するモジュール
 */
Jeeel.Util.Prefecture = {
    /**
     * 都道府県のIDと都道府県名のペアリスト
     *
     * @type Hash
     * @private
     * @constant
     */
    _assoc : {
        1 : '北海道',
        2 : '青森県',
        3 : '岩手県',
        4 : '宮城県',
        5 : '秋田県',
        6 : '山形県',
        7 : '福島県',
        8 : '茨城県',
        9 : '栃木県',
        10 : '群馬県',
        11 : '埼玉県',
        12 : '千葉県',
        13 : '東京都',
        14 : '神奈川県',
        15 : '新潟県',
        16 : '富山県',
        17 : '石川県',
        18 : '福井県',
        19 : '山梨県',
        20 : '長野県',
        21 : '岐阜県',
        22 : '静岡県',
        23 : '愛知県',
        24 : '三重県',
        25 : '滋賀県',
        26 : '京都府',
        27 : '大阪府',
        28 : '兵庫県',
        29 : '奈良県',
        30 : '和歌山県',
        31 : '鳥取県',
        32 : '島根県',
        33 : '岡山県',
        34 : '広島県',
        35 : '山口県',
        36 : '徳島県',
        37 : '香川県',
        38 : '愛媛県',
        39 : '高知県',
        40 : '福岡県',
        41 : '佐賀県',
        42 : '長崎県',
        43 : '熊本県',
        44 : '大分県',
        45 : '宮崎県',
        46 : '鹿児島県',
        47 : '沖縄県'
    },

    /**
     * 都道府県のIDと都道府県名のペアリストを返す
     *
     * @return {Hash} 都道府県のIDと都道府県名のペアリスト
     */
    getAssoc : function () {
        return this._assoc;
    },

    /**
     * 都道府県IDから都道府県名を得る
     *
     * @param {Integer} prefectureId 都道府県ID
     * @return {String} 都道府県名
     */
    getName : function (prefectureId) {
        if ( ! (prefectureId in this._assoc)) {
            throw new Error('存在しない都道府県IDです。');
        }

        return this._assoc[prefectureId];
    }
};
Jeeel.directory.Jeeel.Gui = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Gui/';
    }
};

/**
 * GUI関連のネームスペース
 */
Jeeel.Gui = {
    
};

Jeeel.file.Jeeel.Gui = ['Abstract', 'Tooltip', 'ColorPicker', 'Scrollbar', 'Calendar', 'Mouse'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Gui, Jeeel.file.Jeeel.Gui);

Jeeel.Gui.Abstract = function () {
    
};

Jeeel.Gui.Abstract.prototype = {
    /**
     * デフォルトのスタイルを記述した文字列
     * 
     * @type String
     */
    _defaultStyle: '',
    
    /**
     * 現在の読み込みスタイルのタグ
     * 
     * @type Element
     */
    _styleTag: null,
    
    /**
     * ユーザースタイルの読み込みを行う
     * 
     * @param {String} url CSSのURL
     * @return {Jeeel.Gui.Abstract} 自インスタンス
     */
    loadStyle: function (url) {
        Jeeel.Dom.Element.create(this._styleTag).remove();
        
        this._styleTag = Jeeel.Loader.loadStyle(url);
        
        return this;
    },
    
    /**
     * デフォルトのスタイルに戻す
     * 
     * @return {Jeeel.Gui.Abstract} 自インスタンス
     */
    resetStyle: function () {
        Jeeel.Dom.Element.create(this._styleTag).remove();
        
        this._styleTag = Jeeel.Loader.addStyle(this._defaultStyle);
        
        return this;
    }
};

/**
 * コンストラクタ
 * 
 * @class ツールチップを管理するクラス
 * @augments Jeeel.Gui.Abstract
 * @param {Element} [target] ツールチップ表示対象のElement
 * @param {String} [text] 設定するテキスト
 */
Jeeel.Gui.Tooltip = function (target, text) {
    Jeeel.Gui.Abstract.call(this);
    
    this._init(target, text);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Element} [target] ツールチップ表示対象のElement
 * @param {String} [text] 設定するテキスト
 * @return {Jeeel.Gui.Tooltip} 作成したインスタンス
 */
Jeeel.Gui.Tooltip.create = function (target, text) {
    return new this(target, text);
};

/**
 * ツールチップ全インスタンス共通のスタイルを定義する
 */
Jeeel.Gui.Tooltip.initStyle = function () {
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    var style = 'div.' + this.CLASS.TOOLTIP + ' {\n'
              + '  position: absolute;\n'
              + '  width: auto;\n'
              + '  height: auto;\n'
              + '  box-shadow: 5px 5px 3px #444;\n'
              + '  -moz-box-shadow: 5px 5px 3px #444;\n'
              + '  -webkit-box-shadow: 5px 5px 3px #444;\n'
              + '}\n'
              + 'div.' + this.CLASS.TOOLTIP + ' div.' + this.CLASS.TEXT_CONTENT + ' {\n'
              + '  padding: 2px;\n'
              + '  font-size: 12px;\n'
              + '  font-weight: normal;\n'
              + '  color: #000;\n'
              + '  border: 1px solid #000000;\n'
              + '  background-color: #FFFFE1;\n'
              + '}\n';
            
    if (Jeeel.UserAgent.isInternetExplorer()) {
        style += 'div.' + this.CLASS.TOOLTIP + ' {\n'
               + '  z-index: 3;\n'
               + '}\n'
               + 'div.' + this.CLASS.TOOLTIP + ' div.' + this.CLASS.TEXT_CONTENT + ' {\n'
               + '  position: relative;\n'
               + '  z-index: 4;\n'
               + '}\n'
               + 'div.' + this.CLASS.TOOLTIP + ' div.' + this.CLASS.IE_SHADOW_BOX + ' {\n'
               + '  display: block;\n'
               + '  position: absolute;\n'
               + '  z-index: 2;\n'
               + '  top: 2px;\n'
               + '  left: 2px;\n'
               + '  right: -2px;\n'
               + '  bottom: -2px;\n'
               + '  filter: progid:DXImageTransform.Microsoft.Blur(pixelradius=3);\n'
               + '  -ms-filter: "progid:DXImageTransform.Microsoft.Blur(pixelradius=3)";\n'
               + '  background-color: #444;\n'
               + '}\n';
    } else {
        style += 'div.' + this.CLASS.TOOLTIP + ' div.' + this.CLASS.IE_SHADOW_BOX + ' {\n'
               + '  display: none;\n'
               + '}\n';
    }

    this._styleTag = Jeeel.Loader.addStyle(style);
};

/**
 * ツールチップのクラス名
 */
Jeeel.Gui.Tooltip.CLASS = {
    TOOLTIP: 'jeeel-gui-tooltip',
    IE_SHADOW_BOX: 'jeeel-gui-tooltip-ie-shadow-box',
    TEXT_CONTENT: 'jeeel-gui-tooltip-text-content'
};

/**
 * ツールチップの作成個数
 * 
 * @type Integer
 */
Jeeel.Gui.Tooltip.createLength = 0;

Jeeel.Gui.Tooltip.prototype = {
  
    /**
     * ツールチップ
     * 
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _tooltip: null,
    
    /**
     * ツールチップ文字列コンテント
     * 
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _textContent: null,
    
    /**
     * ツールチップの表示対象
     * 
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _target: null,
    
    /**
     * タイムアウトID
     * 
     * @type Integer
     * @private
     */
    _timeOutId: null,
    
    /**
     * ツールチップにテキストを設定する
     * 
     * @param {String} text 設定するテキスト
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    setText: function (text) {
        this._textContent.setText(text);
        
        return this;
    },
    
    /**
     * ツールチップにHTMLを設定する
     * 
     * @param {String} html 設定するHTML
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    setHtml: function (html) {
        this._textContent.setHtml(html);
        
        return this;
    },
    
    /**
     * ツールチップが表示される対象を設定する
     * 
     * @param {Element} target 対象のElement
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    setTarget: function (target) {
        if (this._target) {
            this._target.removeOut(this.hide)
                        .removeMouseMove(this._show);
        }
        
        this._target = Jeeel.Dom.ElementOperator.create(target);
        
        this._target.addOut(this.hide, this)
                    .addMouseMove(this._show, this);
        
        return this;
    },
    
    /**
     * ツールチップを表示する
     * 
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    show: function () {
        this._tooltip.show();
        
        return this;
    },
    
    /**
     * ツールチップを隠す
     * 
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    hide: function () {
        Jeeel.Timer.clearTimeout(this._timeOutId);
        
        this._tooltip.hide();
        
        return this;
    },
    
    /**
     * ツールチップを削除する
     */
    remove: function () {
        if (this._target) {
            this._target.removeOut(this.hide)
                        .removeMouseMove(this._show);
        }
        
        this.hide();
        this._tooltip.remove();
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Element} [target] ツールチップ表示対象のElement
     * @param {String} [text] 設定するテキスト
     */
    constructor: Jeeel.Gui.Tooltip,
    
    /**
     * ツールチップを対象の要素上に表示する
     * 
     * @param {Jeeel.Dom.Event} e イベントオブジェクト
     */
    _show: function (e) {
        this.hide();
        
        var pos = e.mousePoint;
        var self = this;
        
        this._timeOutId = Jeeel.Timer.setTimeout(
            function () {
                self._tooltip.shiftTo(pos.x, pos.y + 20);
                self.show();
            }, 800
        );
    },
    
    /**
     * ツールチップの初期化を行う
     */
    _init: function (target, text) {
        var index = this.constructor.createLength;
        
        this.constructor.initStyle();
        
        var tip = Jeeel.Document.createElement('div');
        var textContent = Jeeel.Document.createElement('div');
        var ieShadowBox = Jeeel.Document.createElement('div');

        tip.id = this.constructor.CLASS.TOOLTIP + '-' + index;
        tip.className = this.constructor.CLASS.TOOLTIP;
        
        textContent.className = this.constructor.CLASS.TEXT_CONTENT;
        ieShadowBox.className = this.constructor.CLASS.IE_SHADOW_BOX;
        
        tip.appendChild(textContent);
        tip.appendChild(ieShadowBox);

        this._textContent = new Jeeel.Dom.ElementOperator(textContent);
        this._tooltip = new Jeeel.Dom.ElementOperator(tip);
        this._tooltip.hide();
        
        if (target) {
            this.setTarget(target);
        }
        
        if (text) {
            this.setText(text);
        }
        
        Jeeel.Document.appendToBody(tip);
        
        this.constructor.createLength++;
        
        this._styleTag = this.constructor._styleTag;
    }
};

Jeeel.Class.extend(Jeeel.Gui.Tooltip, Jeeel.Gui.Abstract);

/**
 * コンストラクタ
 * 
 * @class カラーピッカーを扱うクラス
 * @augments Jeeel.Gui.Abstract
 * @param {Element} [appendTarget] 追加場所(デフォルトはbody)
 */
Jeeel.Gui.ColorPicker = function (appendTarget) {
    Jeeel.Gui.Abstract.call(this);
    
    this._init(appendTarget);
};

/**
 * インスタンスを作成する
 * 
 * @param {Element} [appendTarget] 追加場所(デフォルトはbody)
 * @return {Jeeel.Gui.ColorPicker} 作成したインスタンス
 */
Jeeel.Gui.ColorPicker.create = function (appendTarget) {
    return new this(appendTarget);
};

/**
 * カラーピッカー全インスタンス共通のスタイルを定義する
 */
Jeeel.Gui.ColorPicker.initStyle = function () {
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    Jeeel.UserAgent.enableVml(true);
    
    var className = this.CLASS.COLOR_PICKER;
    var style = 'div.' + className + ' {\n'
              + '  position: absolute;\n'
              + '  z-index: 10;\n'
              + '  width: auto;\n'
              + '  height: auto;\n'
              + '  border: 1px solid #666666;\n'
              + '  background-color: #DDDDDD;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.COLOR_PALLET + ' {\n'
              + '  position: absolute;\n'
              + '  border-left: 1px solid black;\n'
              + '  border-top: 1px solid black;\n'
              + '  border-right: 1px solid white;\n'
              + '  border-bottom: 1px solid white;\n'
              + '  padding: 0;\n'
              + '  margin: 0;\n'
              + '  cursor: pointer;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.COLOR_PALLET + ' div.' + this.CLASS.COLOR_INDICATOR + ' {\n'
              + '  background-color: transparent;\n'
              + '  border: 1px solid white;\n'
              + '  position: absolute;\n'
              + '  left: 0px;\n'
              + '  top: 0px;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.LUMINANCE_BAR + ' {\n'
              + '  border-left: 1px solid black;\n'
              + '  border-top: 1px solid black;\n'
              + '  border-right: 1px solid white;\n'
              + '  border-bottom: 1px solid white;\n'
              + '  padding: 0;\n'
              + '  margin: 0;\n'
              + '  position: absolute;\n'
              + '  cursor: pointer;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.LUMINANCE_BAR + ' div.' + this.CLASS.LUMINANCE_INDICATOR + ' {\n'
              + '  background-color: transparent;\n'
              + '  border-top: 1px solid #888888;\n'
              + '  border-bottom: 1px solid #ffffff;\n'
              + '  position: absolute;\n'
              + '  height: 5px;\n'
              + '  left: 0px;\n'
              + '  top: 0px;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.LUMINANCE_BAR + ' div.' + this.CLASS.LUMINANCE_INDICATOR + ' div {\n'
              + '  background-color: transparent;\n'
              + '  border-top: 1px solid #ffffff;\n'
              + '  border-bottom: 1px solid #888888;\n'
              + '  height: 3px;\n'
              + '  width: 100%;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' {\n'
              + '  position: absolute;\n'
              + '  overflow: hidden;\n'
              + '  height: ' + this.STYLE.FOOTER_HEIGHT + 'px;\n'
              + '  font-size: 0px;\n'
              + '  font-family: Arial, sans-serif;\n'
              + '  white-space: nowrap;\n'
              + '  padding: 4px 0 2px 2px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input {\n'
              + '  font-size: 11px;\n'
              + '  vertical-align: middle;\n'
              + '  padding: 0;\n'
              + '  margin: 0;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input.' + this.CLASS.COLOR_DISPLAY + ' {\n'
              + '  width: 30px;\n'
              + '  margin-right: 3px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input.' + this.CLASS.COLOR_TEXT_DISPLAY + ' {\n'
              + '  width: 50px;\n'
              + '  margin-right: 3px;\n'
              + '  padding-left: 3px;\n'
              + '  border-top-width: 1px;\n'
              + '  border-right-width: 1px;\n'
              + '  border-bottom-width: 1px;\n'
              + '  border-left-width: 1px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input.' + this.CLASS.OK_BUTTON + ' {\n'
              + '  margin: 0 3px 0 2px;\n'
              + '  padding-left: 2px;\n'
              + '  padding-right: 2px;\n'
              + '  font-size: 10px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input.' + this.CLASS.CLOSE_BUTTON + ' {\n'
              + '  padding-left: 2px;\n'
              + '  padding-right: 2px;\n'
              + '  font-size: 10px;\n'
              + '}';

    this._styleTag = Jeeel.Loader.addStyle(style);
};

/**
 * スタイル定義に使う定数
 */
Jeeel.Gui.ColorPicker.STYLE = {
    COLOR_PICKER_PADDING: 5,
    BORDER_WIDTH: 1,
    LUMINANCE_BAR_WIDTH: 15,
    LUMINANCE_BAR_LEFT_MARGIN: 10,
    FOOTER_HEIGHT: 24
};

/**
 * カラーピッカーのクラス名
 */
Jeeel.Gui.ColorPicker.CLASS = {
    COLOR_PICKER: 'jeeel-gui-color-picker',
    TABLE: 'jeeel-gui-color-picker-table',
    COLOR_PALLET: 'jeeel-gui-color-picker-color-pallet',
    LUMINANCE_BAR: 'jeeel-gui-color-picker-luminance-bar',
    COLOR_INDICATOR: 'jeeel-gui-color-picker-color-indicator',
    LUMINANCE_INDICATOR: 'jeeel-gui-color-picker-luminance-indicator',
    FOOTER: 'jeeel-gui-color-picker-footer',
    COLOR_DISPLAY: 'jeeel-gui-color-picker-color-display',
    COLOR_TEXT_DISPLAY: 'jeeel-gui-color-picker-color-text-display',
    OK_BUTTON: 'jeeel-gui-color-picker-ok-button',
    CLOSE_BUTTON: 'jeeel-gui-color-picker-close-button'
};

/**
 * カラーピッカーの作成個数
 * 
 * @type Integer
 */
Jeeel.Gui.ColorPicker.createLength = 0;

Jeeel.Gui.ColorPicker.prototype = {
    _target: null,
    _callback: null,
    _color: null,
    _size: {
        width: 150, 
        height: 150,
        grid: 1,
        gridie: 2
    },
    
    _colorPicker: null,
    
    _resizing: false,
    
    _items: null,
    
    /**
     * OKボタンを押した際に呼び出されるメソッドをセットする
     * 
     * @param {Function} callback void callback(Jeeel.Object.Color color, String colorText)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    setCallback: function (callback, thisArg) {
        this._resetTarget();
        
        this._callback = {func: callback, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * このインスタンスを紐付けるターゲットをセットする(コールバックの設定はキャンセルされる)
     * 
     * @param {Element} commonTarget 対象のElement(他の引数を指定しない場合このElementが他の引数と共通になる)
     * @param {Element} [textTarget] Textの値を受け取り専用のElement<br />
     *                                nullを渡すと省略と同じ意味になり、<br />
     *                                falseを渡せばTextの値の受け取りが無くなる
     * @param {Element} [bgTarget] BGカラー受け取り専用のElement<br />
     *                              nullを渡すと省略と同じ意味になり、<br />
     *                              falseを渡せばBGカラーの値の受け取りが無くなる
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    setTarget: function (commonTarget, textTarget, bgTarget) {
      
        this._resetTarget();
      
        this._target = {
            click: commonTarget,
            text: Jeeel.Type.isEmpty(textTarget) && commonTarget || textTarget,
            bg: Jeeel.Type.isEmpty(bgTarget) && commonTarget || bgTarget
        };
        
        Jeeel.Dom.ElementOperator.create(commonTarget).addClick(this._toggle, this);
        
        this._callback = {
            func: function (color, colorText) {
                var rgb = color.toRgb();
                var hsl = color.toHsl();
                
                if (this._target.bg) {
                    this._target.bg.style.backgroundColor = rgb.toString();
                }
                
                if (this._target.text && 'value' in this._target.text) {
                    this._target.text.value = colorText;
                    
                    if (this._target.bg === this._target.text) {
                        var fontColor;

                        if (hsl.luminance < 0.6) {
                            fontColor = '#ffffff';
                        } else {
                            fontColor = '#000000';
                        }

                        this._target.text.style.color = fontColor;
                    }
                }
            },
            
            thisArg: this
        };
        
        return this;
    },
    
    /**
     * カラーテキストの編集を許可するかどうかを設定する(カラーテキストの編集を可能にすると選択した色ではない文字列が帰ってくる可能性がある)
     * 
     * @param {Boolean} editable
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    editableColorText: function (editable) {
        this._items.colorTextDisplay.readOnly = !editable;
        
        return this;
    },
    
    /**
     * カラーピッカーを表示する
     * 
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    show: function () {
        if (this._resizing) {
            return this;
        }
        
        this._showElement(this._colorPicker, 3);
        
        return this;
    },

    /**
     * カラーピッカーを非表示にする
     * 
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    hide: function () {
        if (this._resizing) {
            return this;
        }
      
        this._hideElement(this._colorPicker, 3);
        
        return this;
    },
    
    /**
     * 指定の位置にカラーピッカーを移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    move: function (x, y) {
        var sty = this._colorPicker.style;
        
        sty.top = y + 'px';
        sty.left = x + 'px';
        
        return this;
    },
    
    /**
     * カラーピッカーの表示非表示を切り替える
     * 
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    toggle: function () {
        return this._colorPicker.style.display === 'none' ? this.show() : this.hide();
    },
    
    /**
     * 指定したカラーに設定する
     *
     * @param {Jeeel.Object.Color} color カラー
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    setColor: function (color) {
        this._color = color;
        
        this._drawLuminanceBar();
        this._updateSelectedColorInfo();
        this._updateIndicator();
        
        return this;
    },

    /**
     * 選択したカラーを取得する
     *
     * @return {Jeeel.Object.Color} カラー
     */
    getColor: function () {
        return this._color;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Gui.ColorPicker,
    
    _toggle: function (ev, elm) {
        
        var rect = Jeeel.Dom.Element.create(elm).getRect();
        
        this.move(rect.endPoint.x + 10, rect.y);
        
        this.toggle();
    },
    
    _resetTarget: function () {
        if ( ! this._target) {
            return;
        }
        
        Jeeel.Dom.ElementOperator.create(this._target.click).removeClick(this._toggle);
        
        this._target = null;
    },
    
    _showElement: function (elm, speed) {
        speed = +speed || 0;
        
        var s = elm.style;
        
        if (speed < 0) {
            speed = 0;
        } else if (speed > 5) {
            speed = 5;
        }
        
        if (speed == 0) {
            s.display = "";
            return;
        }
        
        var width = parseInt(s.width);
        var height = parseInt(s.height);
        s.width = "0px";
        s.height = "0px";
        s.display = "";
        var w = 0;
        var h = 0;
        var self = this;
        
        var scaleUp = function () {
            self._resizing = true;
            w += ( width * speed / 50 );
            h += ( height * speed / 50 );

            if (w > width) { 
                w = width; 
            }
            
            if (h > height) { 
                h = height; 
            }

            s.width = w + "px";
            s.height = h + "px";

            if (w < width || h < height) {
                setTimeout(scaleUp, 10);
            } else {
                s.display = "";
                s.width = width + "px";
                s.height = height + "px";
                self._resizing = false;
            }
        };
        
        scaleUp();
    },
    
    _hideElement: function (elm, speed) {
        speed = +speed || 0;
        
        if (speed < 0) {
            speed = 0;
        } else if (speed > 5) {
            speed = 5;
        }
        
        if (speed == 0) {
            elm.style.display = "none";
            return;
        }
        
        var s = elm.style;
        var width = parseInt(s.width);
        var height = parseInt(s.height);
        var w = width;
        var h = height;
        var self = this;
        
        var scaleDown = function () {
            self._resizing = true;

            w -= ( width * speed / 50 );
            h -= ( height * speed / 50 );

            if (w < 0) { 
                w = 0; 
            }
            
            if (h < 0) {
                h = 0; 
            }

            s.width = w + "px";
            s.height = h + "px";

            if (w > 0 || h > 0) {
                setTimeout(scaleDown, 10);
            } else {
                s.display = "none";
                s.width = width + "px";
                s.height = height + "px";
               self._resizing = false;
            }
        };
        
        scaleDown();
    },

    _selectColor: function (ev, elm) {
        this.hide();
        
        if (this._callback) {
            this._callback.func.call(this._callback.thisArg || this, this._color, this._items.colorTextDisplay.value);
        }
    },
    
    _selectButtonSwitch: function (e, elm) {
        if (elm === this._items.okButton) {
            this._selectColor(e, elm);
        } else  {
            this.hide();
        }
    },
    
    _mouseDownSwitch: function (e, elm) {
        if (elm === this._items.colorPallet) {
            this._palletMouseDown(e, elm);
        } else  {
            this._luminanceMouseDown(e, elm);
        }
    },
    
    _mouseMoveSwitch: function (e, elm) {
        if (elm === this._items.colorPallet) {
            this._palletMouseMove(e, elm);
        } else  {
            this._luminanceMouseMove(e, elm);
        }
    },
    
    _mouseUpSwitch: function (e, elm) {
        if (elm === this._items.colorPallet) {
            this._palletMouseCancel(e, elm);
        } else  {
            this._luminanceMouseCancel(e, elm);
        }
    },
    
    _palletMouseDown: function (ev, elm) {
        if (this._items.colorIndicatorEnableMove) {
            return;
        }
        
        this._items.colorIndicatorEnableMove = true;
        
        this._palletMouseMove(ev, elm);
    },
    
    _palletMouseMove: function (ev, elm) {
        ev.stop();
        
        if ( ! this._items.colorIndicatorEnableMove) {
            return;
        }
        
        var cindStyle = this._items.colorIndicator.style;
        var size = this._size;
        var p = ev.getRelativeMousePoint(this._items.colorPallet);
        var x = p.x - 2;
        var y = p.y - 2;
        
        if (x < 0) {
            x = 0;
        } else if (x > size.width) {
            x = size.width;
        }
        
        if (y < 0) {
            y = 0;
        } else if (y > size.height) {
            y = size.height;
        }
        
        cindStyle.left = x + 'px';
        cindStyle.top = y + 'px';
        
        var hsl = this._color.toHsl();
        var h = x * 359 / size.width;
        var s = 1 - y / size.height;
        
        this._color = Jeeel.Object.Color.createHsl(h, s, hsl.luminance);
        
        this._drawLuminanceBar();
        
        this._updateSelectedColorInfo();
    },
    
    _palletMouseCancel: function (ev, elm) {
        if (this._items.colorIndicatorEnableMove) {
            this._palletMouseMove(ev, elm);
            this._items.colorIndicatorEnableMove = false;
        }
    },
    
    _luminanceMouseDown: function (ev, elm) {
        if (this._items.luminanceIndicatorEnableMove) {
            return;
        }
        
        this._items.luminanceIndicatorEnableMove = true;
        
        this._luminanceMouseMove(ev, elm);
    },
    
    _luminanceMouseMove: function (ev, elm) {
        ev.stop();
        
        if ( ! this._items.luminanceIndicatorEnableMove) {
            return;
        }
        
        var lind = this._items.luminanceIndicator;
        var size = this._size;
        var p = ev.getRelativeMousePoint(this._items.luminanceBar);
        var y = p.y - 2;
        
        if (y < 0) {
            y = 0;
        } else if (y > size.height) {
            y = size.height;
        }
        
        lind.style.top = y + 'px';
        
        var hsl = this._color.toHsl();
        var l = 1 - y / size.height;
        
        this._color = Jeeel.Object.Color.createHsl(hsl.hue, hsl.saturation, l);
        
        this._updateSelectedColorInfo();
    },
    
    _luminanceMouseCancel: function (ev, elm) {
        this._items.luminanceIndicatorEnableMove = false;
    },
    
    _mouseCancel: function (ev, elm) {
        this._palletMouseCancel(ev, elm);
        this._luminanceMouseCancel(ev, elm);
        
        ev.stop();
    },
    
    _updateSelectedColorInfo: function () {
        var cd = this._items.colorDisplay;
        var ctd = this._items.colorTextDisplay;
        var ctxt = this._color.toRgb().toString();
        
        cd.style.backgroundColor = ctxt;
        ctd.value = ctxt;
    },
    
    _hslToRgbCss: function (hsl) {
        var rgb = Jeeel.Object.Color.calculateRgb(hsl.h, hsl.s, hsl.l);
        
        rgb = [
            (rgb.red & 255).toString(16),
            (rgb.green & 255).toString(16),
            (rgb.blue & 255).toString(16)
        ];

        for (var i = 3; i--;) {
            if (rgb[i].length < 2) {
                rgb[i] = '0' + rgb[i];
            }
        }
        
        return '#' + rgb.join('');
    },
    
    _updateIndicator: function () {
        var hsl = this._color.toHsl();

        var cindStyle = this._items.colorIndicator.style;
        var lindStyle = this._items.luminanceIndicator.style;
        var lumiStyle = this._items.luminanceBar.style;
        
        // plette indicator
        var paletteW = this._size.width;
        var paletteH = this._size.height;
        
        cindStyle.left = (paletteW * hsl.hue / 360 - 5 / 2) + "px";
        cindStyle.top  = (paletteH * (1 - hsl.saturation) - 5 / 2) + "px";
        
        // bar indicator
        lindStyle.top = (parseInt(lumiStyle.height) * (1 - hsl.luminance) - 7 / 2) + "px";
    },
    
    _drawPallet: function () {
        var canvas = Jeeel.Document.createElement('canvas');
        
        if (canvas && canvas.getContext) {
            this._drawPaletteByCanvas(canvas);
        } else if(Jeeel._doc.uniqueID) {
            this._drawPaletteByVml();
        }
    },
    
    _drawPaletteByCanvas: function (canvas) {
        var el = this._items.colorPallet;
        var p = this._size;
        var w = p.width;
        var h = p.height;
        canvas.style.margin = "0px";
        canvas.style.padding = "0px";
        canvas.width = w;
        canvas.height = h;
        el.appendChild(canvas);
        
        var ctx = canvas.getContext('2d');
        var hsl = {};
        hsl.l = 0.5;
        var gridw = p.grid;
        
        for (var x = 0; x < w; x += p.grid) {
            hsl.h = 359 * ( x / w );
            var grad  = ctx.createLinearGradient(0, 0, 0, h);
            
            for (var i = 0; i <= 10; i++) {
                hsl.s = 1 - ( i / 10 );
                var c = this._hslToRgbCss(hsl);
                grad.addColorStop(i/10, c);
            }
            
            ctx.fillStyle = grad;
            ctx.fillRect(x, 0, gridw, h);
        }
    },
    
    _drawPaletteByVml: function () {
        var el = this._items.colorPallet;
        var p = this._size;
        var w = p.width;
        var h = p.height;
        var hsl = {l: 0.5};
        var vml = [];
        var gridw = p.gridie + 2;
        
        for (var x = 0; x < w; x += p.gridie) {
            hsl.h = 359 * ( x / w );
            hsl.s = 0;
            
            var c1 = this._hslToRgbCss(hsl);

            hsl.s = 1;
            
            var c2 = this._hslToRgbCss(hsl);

            vml[vml.length] = '<v:rect style="left:' + x + 'px; top:0px; width:' + gridw + 'px; height:' + h + 'px; position:absolute;" filled="true" stroked="false">';
            vml[vml.length] = '<v:fill type="gradient" color="' + c1 + '" color2="' + c2 + '" colors="';
            
            for (var i = 1; i <= 9; i++) {
                hsl.s = i / 10;

                var c = this._hslToRgbCss(hsl);
                vml[vml.length] = (i*10) + '% ' + c;

                if(i != 9) {
                    vml[vml.length] = ',';
                }
            }
            
            vml[vml.length] = '" /></v:rect>';
        }
        
        el.innerHTML = vml.join('');
    },
    
    _drawLuminanceBar: function () {
        var el = this._items.luminanceBarWrapper;
        var bind = this._items.luminanceIndicator;

        el.clearChildNodes();
        
        var canvas = Jeeel.Document.createElement('canvas');
        
        if (canvas && canvas.getContext) {
            this._drawLuminanceBarByCanvas(canvas);
        } else if(Jeeel._doc.uniqueID) {
            this._drawLuminanceBarByVml();
        }
        
        el.appendChild(bind);
    },
    
    _drawLuminanceBarByCanvas: function (canvas) {
        var el = this._items.luminanceBar;
        var w = 15;
        var h = this._size.height;
        canvas.style.margin = "0px";
        canvas.style.padding = "0px";
        canvas.width = w;
        canvas.height = h;
        
        el.appendChild(canvas);
        
        var ctx = canvas.getContext('2d');
        var hsl = this._color.toHsl();
        hsl = {h: hsl.hue, s: hsl.saturation, l: hsl.luminance};
        var grad  = ctx.createLinearGradient(0, 0, 0, h);
        
        for (var i = 0; i <= 10; i++) {
            hsl.l = 1 - ( i / 10 );
            
            var c = this._hslToRgbCss(hsl);
            
            grad.addColorStop(i / 10, c);
        }
        
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
    },
    
    _drawLuminanceBarByVml: function () {
        var el = this._items.luminanceBar;
        var w = 15;
        var h = this._size.height;
        var hsl = this._color.toHsl();
        hsl = {h: hsl.hue, s: hsl.saturation, l: hsl.luminance};

        hsl.l = 0;

        var c1 = this._hslToRgbCss(hsl);

        hsl.l = 1;

        var c2 = this._hslToRgbCss(hsl);

        var vml = [];
        vml[vml.length] = '<v:rect style="left:-1px; top:0px; width:' + w + 'px; height:' + h + 'px; position:absolute;" filled="true" stroked="false">';
        vml[vml.length] = '<v:fill type="gradient" color="' + c1 + '" color2="' + c2 + '" colors="';
        
        for (var i = 1; i <= 9; i++) {
            hsl.l = i / 10;

            vml[vml.length] = (i * 10) + '% ' + this._hslToRgbCss(hsl) + (i !== 9 ? ',' : '');
        }
        
        vml[vml.length] = '" /></v:rect>';
        
        el.innerHTML = vml.join('');
    },
    
    _eventStop: function (e) {
        e.stop();
    },
    
    /**
     * 初期化を行う
     */
    _init: function (appendTarget) {
        var index = this.constructor.createLength;
        
        this.constructor.initStyle();

        var p = this._size;

        var colorPicker = Jeeel.Document.createElement('div');
        colorPicker.className = this.constructor.CLASS.COLOR_PICKER;
        colorPicker.id = this.constructor.CLASS.COLOR_PICKER + '-' + index;

        this._colorPicker = colorPicker;
        
        var colorPallet = Jeeel.Document.createElement('div');
        var luminanceBar = Jeeel.Document.createElement('div');
        var footer = Jeeel.Document.createElement('div');

        colorPallet.className = this.constructor.CLASS.COLOR_PALLET;
        luminanceBar.className = this.constructor.CLASS.LUMINANCE_BAR;
        footer.className = this.constructor.CLASS.FOOTER;

        this._color = Jeeel.Object.Color.createHsl(180, 0.5, 0.5);
        var borderBothWidth = this.constructor.STYLE.BORDER_WIDTH * 2;
        
        Jeeel.Dom.Element.create(colorPallet).setStyleList({
            width: p.width + 'px',
            height: p.height + 'px',
            top: '0px',
            left: '0px'
        });
        
        Jeeel.Dom.Element.create(luminanceBar).setStyleList({
            width: this.constructor.STYLE.LUMINANCE_BAR_WIDTH + 'px',
            height: p.height + 'px',
            top: '0px',
            left: p.width + this.constructor.STYLE.LUMINANCE_BAR_LEFT_MARGIN + 'px'
        });
        
        var footerWidth = p.width
                        + borderBothWidth
                        + this.constructor.STYLE.LUMINANCE_BAR_LEFT_MARGIN
                        + this.constructor.STYLE.LUMINANCE_BAR_WIDTH
                        + borderBothWidth;
        
        Jeeel.Dom.Element.create(footer).setStyleList({
            width: footerWidth + 'px',
            left: this.constructor.STYLE.COLOR_PICKER_PADDING + 'px',
            top: p.height + this.constructor.STYLE.COLOR_PICKER_PADDING * 2 + borderBothWidth + 'px'
        });
        
        var pickerWidth = footerWidth
                        + this.constructor.STYLE.COLOR_PICKER_PADDING
                        + this.constructor.STYLE.COLOR_PICKER_PADDING;
        
        var pickerHeight = p.height
                         + borderBothWidth
                         + this.constructor.STYLE.FOOTER_HEIGHT
                         + this.constructor.STYLE.COLOR_PICKER_PADDING * 3;
                      
        Jeeel.Dom.Element.create(colorPicker).setStyleList({
            width: pickerWidth + 'px',
            height: pickerHeight + 'px'
        });
        
        this._items = {
            colorPallet: colorPallet,
            luminanceBar: luminanceBar,
            luminanceBarWrapper: new Jeeel.Dom.Element(luminanceBar)
        };
        
        var colorDisplay = Jeeel.Document.createElement('input');
        var colorTextDisplay = Jeeel.Document.createElement('input');
        var okButton = Jeeel.Document.createElement('input');
        var closeButton = Jeeel.Document.createElement('input');
        
        colorDisplay.className = this.constructor.CLASS.COLOR_DISPLAY;
        colorTextDisplay.className = this.constructor.CLASS.COLOR_TEXT_DISPLAY;
        okButton.className = this.constructor.CLASS.OK_BUTTON;
        closeButton.className = this.constructor.CLASS.CLOSE_BUTTON;
        
        colorDisplay.type = colorTextDisplay.type = 'text';
        okButton.type = closeButton.type = 'button';
        
        colorDisplay.disabled = true;
        
        colorTextDisplay.maxLength = 7;
        
        var ctxt = this._color.toRgb().toString();
        colorDisplay.style.backgroundColor = ctxt;
        colorTextDisplay.value = ctxt;
        
        okButton.value = ' O K ';
        closeButton.value = 'Close';
        
        footer.appendChild(colorDisplay);
        footer.appendChild(colorTextDisplay);
        footer.appendChild(okButton);
        footer.appendChild(closeButton);
        
        this._items.okButton = okButton;
        this._items.colorDisplay = colorDisplay;
        this._items.colorTextDisplay = colorTextDisplay;
        
        var colorIndicator = Jeeel.Document.createElement('div');
        var luminanceIndicator = Jeeel.Document.createElement('div');
        var luminanceInnerIndicator = Jeeel.Document.createElement('div');
        
        colorIndicator.className = this.constructor.CLASS.COLOR_INDICATOR;
        luminanceIndicator.className = this.constructor.CLASS.LUMINANCE_INDICATOR;
        
        luminanceIndicator.appendChild(luminanceInnerIndicator);
        
        var ieQuirks = !!(Jeeel._doc.uniqueID && Jeeel._doc.compatMode == "BackCompat");
        
        Jeeel.Dom.Element.create(colorIndicator).setStyleList({
            width: ieQuirks ? "5px" : "3px",
            height: ieQuirks ? "5px" : "3px"
        });
        
        Jeeel.Dom.Element.create(luminanceIndicator).setStyleList({
            width: this.constructor.STYLE.LUMINANCE_BAR_WIDTH + 'px'
        });
        
        this._items.colorIndicator = colorIndicator;
        this._items.luminanceIndicator = luminanceIndicator;
        
        this._items.colorIndicatorEnableMove = false;
        this._items.luminanceIndicatorEnableMove = false;
        
        Jeeel.Dom.ElementOperator.create(colorPicker)
               .addEvent(Jeeel.Dom.Event.Type.CLICK, this._eventStop, this)
               .addEvent(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._mouseCancel, this);

        var body = Jeeel.Document.createElement('div');
        
        Jeeel.Dom.Element.create(body).setStyleList({
            width: p.width + borderBothWidth + this.constructor.STYLE.LUMINANCE_BAR_LEFT_MARGIN + this.constructor.STYLE.LUMINANCE_BAR_WIDTH + 'px',
            height: p.height + 'px',
            left: this.constructor.STYLE.COLOR_PICKER_PADDING + this.constructor.STYLE.BORDER_WIDTH + 'px',
            top: this.constructor.STYLE.COLOR_PICKER_PADDING + this.constructor.STYLE.BORDER_WIDTH + 'px',
            position: 'absolute',
            overflow: 'hidden',
            padding: '0',
            margin: '0'
        });

        body.appendChild(colorPallet);
        body.appendChild(luminanceBar);
        
        colorPicker.appendChild(body);
        colorPicker.appendChild(footer);
               
        Jeeel.Dom.ElementOperator.create([colorPallet, luminanceBar])
               .delegate(Jeeel.Dom.Event.Type.MOUSE_DOWN, this._mouseDownSwitch, this)
               .delegate(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._mouseMoveSwitch, this)
               .delegate(Jeeel.Dom.Event.Type.MOUSE_UP, this._mouseUpSwitch, this);
        
        Jeeel.Dom.ElementOperator.create([okButton, closeButton])
               .delegate(Jeeel.Dom.Event.Type.CLICK, this._selectButtonSwitch, this);
        
        Jeeel.Function.create(this._initFinish).bind(this).delay(15)(appendTarget);

        this.constructor.createLength++;
    },
    
    _initFinish: function (appendTarget) {
        Jeeel.Dom.Element.create(this._colorPicker).hide().setBackgroundIframe();

        this._drawPallet();
        this._drawLuminanceBar();
        this._updateIndicator();

        if (appendTarget) {
            Jeeel.Dom.Element.create(appendTarget).appendChild(this._colorPicker);
        } else {
            Jeeel.Document.appendToBody(this._colorPicker);
        }

        this._items.colorPallet.appendChild(this._items.colorIndicator);
        
        this._styleTag = this.constructor._styleTag;
    }
};

Jeeel.Class.extend(Jeeel.Gui.ColorPicker, Jeeel.Gui.Abstract);
Jeeel.directory.Jeeel.Gui.Scrollbar = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Gui + 'Scrollbar/';
    }
};

/**
 * スクロールバー関連のネームスペース
 */
Jeeel.Gui.Scrollbar = {
    
};

Jeeel.file.Jeeel.Gui.Scrollbar = ['Vertical', 'Horizontal'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Gui.Scrollbar, Jeeel.file.Jeeel.Gui.Scrollbar);

/**
 * コンストラクタ
 * @class 垂直スクロールバーを単体で扱うクラス
 * @augments Jeeel.Gui.Abstract
 */
Jeeel.Gui.Scrollbar.Vertical = function () {
    this._init();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Gui.Scrollbar.Vertical} 作成したインスタンス
 */
Jeeel.Gui.Scrollbar.Vertical.create = function () {
    return new this();
};

Jeeel.Gui.Scrollbar.Vertical.MIN_HEIGHT = 30;

Jeeel.Gui.Scrollbar.Vertical.CLASS = {
    SCROLLBAR: 'jeeel-gui-scrollbar-vertical',
    INNER: 'jeeel-gui-scrollbar-vertical-inner'
};

/**
 * 垂直スクロールバー全インスタンス共通のスタイルを定義する
 */
Jeeel.Gui.Scrollbar.Vertical.initStyle = function () {
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    var className = this.CLASS.SCROLLBAR;
    var style = 'div.' + className + ' {\n'
              + '  position: relative;\n'
              + '  width: 18px;\n'
              + '  height: 100px;\n'
              + '  cursor: pointer;\n'
              + '  margin-top: -1px;\n'
              + '  border: 1px #EEEDE5 solid;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.INNER + ' {\n'
              + '  position: absolute;\n'
              + '  width: 16px;\n'
              + '  height: 60px;\n'
              + '  background-color: #C2D5FC;\n'
              + '  text-align: center;\n'
              + '  line-height: 60px;\n'
              + '  color: #666;\n'
              + '  overflow: hidden;\n'
              + '  border: 1px #FFFFFF solid;\n'
              + '  cursor: pointer;\n'
              + '  font-size: 16px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.INNER + ':hover {\n'
              + '  background-color: #D6E7FF;\n'
              + '}';

    this._styleTag = Jeeel.Loader.addStyle(style);
};

Jeeel.Gui.Scrollbar.Vertical.prototype = {
    _scrollbarHeight: 100,
    _innerHeight: 200,
    _barHeight: 60,
    _barTopMax: 38,
    _scrollDy: 1,
    _scrollTop: 0,
    _scrollTopMax: 100,
    _scrollDelta: 20,
    
    _scrollbar: null,
    _innerBar: null,
    
    _scrollHandlers: [],
    _scrollable: false,
    _startPoint: null,
    
    /**
     * スクロールバーHTML要素を返す
     * 
     * @return {Element} スクロールバー
     */
    getScrollbar: function () {
        return this._scrollbar;
    },
    
    /**
     * スクロールイベントを登録する
     * 
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Eventで固定)
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    addScrollEvent: function (listener, thisArg, var_args) {
        var args = Array.prototype.slice.call(arguments, 2, arguments.length);
        
        args.unshift(null);
        
        this._scrollHandlers[this._scrollHandlers.length] = {
            listener: listener,
            thisArg: thisArg || this,
            args: args
        };
        
        return this;
    },
    
    /**
     * このスクロールバーに対応するコンテナの高さを設定する
     * 
     * @param {Integer} height 高さ
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    setContainerHeight: function (height) {
        this._innerHeight = +height;
        
        this._innerBar.style.height = this._innerHeight + 'px';
        
        return this._resize();
    },
    
    /**
     * このスクロールバーに対応するコンテナの高さを取得する
     * 
     * @return {Integer} 高さ
     */
    getContainerHeight: function () {
        return this._innerHeight;
    },
    
    /**
     * スクロールバー自体の高さを設定する
     * 
     * @param {Integer} height 高さ
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    setScrollHeight: function (height) {
        this._scrollbarHeight = +height;
        
        this._scrollbar.style.height = (this._scrollbarHeight + 1) + 'px';
        
        return this._resize();
    },
    
    /**
     * スクロールバー自体の高さを取得する
     * 
     * @return {Integer} 高さ
     */
    getScrollHeight: function () {
        return this._scrollbarHeight;
    },
    
    /**
     * スクロールのトップ座標を設定する
     * 
     * @param {Number} top トップ座標
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    setScrollTop: function (top) {
        top = Jeeel.Number.limit(+top, 0, this._scrollTopMax);

        var barTop = top / this._scrollDy;
        
        this._scrollTop = top;
        this._innerBar.style.top = barTop + 'px';
        
        return this;
    },
    
    /**
     * スクロールのトップ座標を取得する
     * 
     * @return {Number} トップ座標
     */
    getScrollTop: function () {
        return this._scrollTop;
    },
    
    /**
     * スクロールバーをスクロールする
     * 
     * @param {Number} [delta] スクロール量(1に対して1ホイール分に相当する, +で上に、-で下に進む)
     * @param {Boolean} [doDispatch] スクロールイベントを発生させるかどうか
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    scroll: function (delta, doDispatch) {
        this.setScrollTop(this._scrollTop + (this._scrollDelta * -delta) || 0);
        
        doDispatch && this._callHandlers(null);
        
        return this;
    },
    
    /**
     * スクロール可能かどうかを返す
     * 
     * @param {Boolean} [isUp] 方向が上かどうか
     * @return {Boolean} スクロール可能かどうか
     */
    canScroll: function (isUp) {
        return isUp ? this.canScrollUp() : this.canScrollDown();
    },
    
    /**
     * 上にスクロールが可能かどうかを返す
     * 
     * @return {Boolean} 上にスクロール可能かどうか
     */
    canScrollUp: function () {
        return this._scrollTop > 0;
    },
    
    /**
     * 下にスクロールが可能かどうかを返す
     * 
     * @return {Boolean} 下にスクロール可能かどうか
     */
    canScrollDown: function () {
        return this._scrollTop < this._scrollTopMax;
    },
    
    _resize: function () {
        var barHeight = this._scrollbarHeight / this._innerHeight * this._scrollbarHeight;

        if (barHeight < this.constructor.MIN_HEIGHT) {
            barHeight = this.constructor.MIN_HEIGHT;
        }
        
        this._barTopMax = this._scrollbarHeight - barHeight;
        this._scrollTopMax = this._innerHeight - this._scrollbarHeight;
        this._scrollDy = this._scrollTopMax / this._barTopMax;
        this._scrollDelta = barHeight * this._scrollDy / 3;
        
        this._barHeight = barHeight;
        this._innerBar.style.height = barHeight + 'px';
        this._innerBar.style.lineHeight = barHeight + 'px';
        
        return this;
    },
    
    _onClick: function (event) {
        event.stop();
        
        if (this._scrollable || event.target !== this._scrollbar) {
            return;
        }
        
        var op = (event.getRelativeMousePoint(this._innerBar).y < 0 ? -1 : 1);
        
        this.setScrollTop(this._scrollTop + op * this._barHeight * this._scrollDy);
        
        this._callHandlers(event);
    },
    
    _onScroll: function (event) {
        if (this._scrollable) {
            return;
        }
        
        var op = (event.mouseWheel > 0 ? -1 : 1);
        var up = op < 0;
        
        if (this.canScroll(up)) {
            event.stop();
            
            this.setScrollTop(this._scrollTop + op * this._scrollDelta);

            this._callHandlers(event);
        }
    },
    
    _onMouseDown: function (event) {
        event.stop();
        
        this._scrollable = true;
        
        this._startPoint = event.getRelativeMousePoint(this._innerBar);
    },
    
    _onMouseMove: function (event) {
        if ( ! this._scrollable) {
            return;
        }
        
        event.stop();
        
        var top = event.getRelativeMousePoint(this._scrollbar).y
                - this._startPoint.y;
              
        top = Jeeel.Number.limit(top, 0, this._barTopMax);
        
        this._innerBar.style.top = top + 'px';
        this.setScrollTop(top * this._scrollDy);
        
        this._callHandlers(event);
    },
    
    _onMouseUp: function (event) {
        if (this._scrollable) {
            event.stop();

            this._scrollable = false;
        }
    },
    
    _callHandlers: function (event) {
        for (var i = 0, l = this._scrollHandlers.length; i < l; i++) {
            var listener = this._scrollHandlers[i].listener;
            var thisArg  = this._scrollHandlers[i].thisArg;
            var args     = this._scrollHandlers[i].args;
            
            args[0] = event;
            
            listener.apply(thisArg, args);
            
            args[0] = null;
        }
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Gui.Scrollbar.Vertical,
    
    _init: function () {
        this.constructor.initStyle();
        var scrollbar = Jeeel.Document.createElement('div');
        var inner = Jeeel.Document.createElement('div');
        
        this._scrollHandlers = [];
        
        scrollbar.className = this.constructor.CLASS.SCROLLBAR;
        inner.className = this.constructor.CLASS.INNER;
        
        inner.innerHTML = '▒';
        
        this._scrollbar = scrollbar;
        this._innerBar = inner;
        
        this._scrollbar.appendChild(this._innerBar);
        
        Jeeel.Dom.Event.addEventListener(this._scrollbar, Jeeel.Dom.Event.Type.CLICK, this._onClick, this);
        Jeeel.Dom.Event.addEventListener(this._scrollbar, Jeeel.Dom.Event.Type.MOUSE_WHEEL, this._onScroll, this);
        Jeeel.Dom.Event.addEventListener(this._innerBar, Jeeel.Dom.Event.Type.MOUSE_DOWN, this._onMouseDown, this);
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._onMouseMove, this);
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, this._onMouseUp, this);
    }
};

Jeeel.Class.extend(Jeeel.Gui.Scrollbar.Vertical, Jeeel.Gui.Abstract);

/**
 * コンストラクタ
 * @class 水平スクロールバーを単体で扱うクラス
 * @augments Jeeel.Gui.Abstract
 */
Jeeel.Gui.Scrollbar.Horizontal = function () {
    this._init();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Gui.Scrollbar.Horizontal} 作成したインスタンス
 */
Jeeel.Gui.Scrollbar.Horizontal.create = function () {
    return new this();
};

Jeeel.Gui.Scrollbar.Horizontal.MIN_WIDTH = 30;

Jeeel.Gui.Scrollbar.Horizontal.CLASS = {
    SCROLLBAR: 'jeeel-gui-scrollbar-horizontal',
    INNER: 'jeeel-gui-scrollbar-horizontal-inner'
};

/**
 * 水平スクロールバー全インスタンス共通のスタイルを定義する
 */
Jeeel.Gui.Scrollbar.Horizontal.initStyle = function () {
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    var className = this.CLASS.SCROLLBAR;
    var style = 'div.' + className + ' {\n'
              + '  position: relative;\n'
              + '  width: 100px;\n'
              + '  height: 18px;\n'
              + '  cursor: pointer;\n'
              + '  margin-left: -1px;\n'
              + '  border: 1px #EEEDE5 solid;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.INNER + ' {\n'
              + '  position: absolute;\n'
              + '  width: 60px;\n'
              + '  height: 16px;\n'
              + '  background-color: #C2D5FC;\n'
              + '  text-align: center;\n'
              + '  color: #666;\n'
              + '  overflow: hidden;\n'
              + '  border: 1px #FFFFFF solid;\n'
              + '  cursor: pointer;\n'
              + '  font-size: 16px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.INNER + ':hover {\n'
              + '  background-color: #D6E7FF;\n'
              + '}';

    this._styleTag = Jeeel.Loader.addStyle(style);
};

Jeeel.Gui.Scrollbar.Horizontal.prototype = {
    _scrollbarWidth: 100,
    _innerWidth: 200,
    _barWidth: 60,
    _barLeftMax: 38,
    _scrollDx: 1,
    _scrollLeft: 0,
    _scrollLeftMax: 100,
    _scrollDelta: 20,
    
    _scrollbar: null,
    _innerBar: null,
    
    _scrollHandlers: [],
    _scrollable: false,
    _startPoint: null,
    
    /**
     * スクロールバーHTML要素を返す
     * 
     * @return {Element} スクロールバー
     */
    getScrollbar: function () {
        return this._scrollbar;
    },
    
    /**
     * スクロールイベントを登録する
     * 
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Eventで固定)
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    addScrollEvent: function (listener, thisArg, var_args) {
        var args = Array.prototype.slice.call(arguments, 2, arguments.length);
        
        args.unshift(null);
        
        this._scrollHandlers[this._scrollHandlers.length] = {
            listener: listener,
            thisArg: thisArg || this,
            args: args
        };
        
        return this;
    },
    
    /**
     * このスクロールバーに対応するコンテナの幅を設定する
     * 
     * @param {Integer} width 幅
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    setContainerWidth: function (width) {
        this._innerWidth = +width;
        
        this._innerBar.style.width = this._innerWidth + 'px';
        
        return this._resize();
    },
    
    /**
     * このスクロールバーに対応するコンテナの幅を取得する
     * 
     * @return {Integer} 幅
     */
    getContainerWidth: function () {
        return this._innerWidth;
    },
    
    /**
     * スクロールバー自体の幅を設定する
     * 
     * @param {Integer} width 幅
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    setScrollWidth: function (width) {
        this._scrollbarWidth = +width;
        
        this._scrollbar.style.width = (this._scrollbarWidth + 1) + 'px';
        
        return this._resize();
    },
    
    /**
     * スクロールバー自体の幅を取得する
     * 
     * @return {Integer} 幅
     */
    getScrollWidth: function () {
        return this._scrollbarWidth;
    },
    
    /**
     * スクロールのレフト座標を設定する
     * 
     * @param {Number} left レフト座標
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    setScrollLeft: function (left) {
        left = Jeeel.Number.limit(+left, 0, this._scrollLeftMax);

        var barLeft = left / this._scrollDx;
        
        this._scrollLeft = left;
        this._innerBar.style.left = barLeft + 'px';
        
        return this;
    },
    
    /**
     * スクロールのレフト座標を取得する
     * 
     * @return {Number} レフト座標
     */
    getScrollLeft: function () {
        return this._scrollLeft;
    },
    
    /**
     * スクロールバーをスクロールする
     * 
     * @param {Number} [delta] スクロール量(1に対して1ホイール分に相当する, +で左に、-で右に進む)
     * @param {Boolean} [doDispatch] スクロールイベントを発生させるかどうか
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    scroll: function (delta, doDispatch) {
        this.setScrollLeft(this._scrollLeft + (this._scrollDelta * -delta) || 0);
        
        doDispatch && this._callHandlers(null);
        
        return this;
    },
    
    /**
     * スクロール可能かどうかを返す
     * 
     * @param {Boolean} [isLeft] 方向が左かどうか
     * @return {Boolean} スクロール可能かどうか
     */
    canScroll: function (isLeft) {
        return isLeft ? this.canScrollLeft() : this.canScrollRight();
    },
    
    /**
     * 左にスクロールが可能かどうかを返す
     * 
     * @return {Boolean} 左にスクロール可能かどうか
     */
    canScrollLeft: function () {
        return this._scrollLeft > 0;
    },
    
    /**
     * 右にスクロールが可能かどうかを返す
     * 
     * @return {Boolean} 右にスクロール可能かどうか
     */
    canScrollRight: function () {
        return this._scrollLeft < this._scrollLeftMax;
    },
    
    _resize: function () {
        var barWidth = this._scrollbarWidth / this._innerWidth * this._scrollbarWidth - 2;

        if (barWidth < this.constructor.MIN_WIDTH) {
            barWidth = this.constructor.MIN_WIDTH;
        }
        
        this._barLeftMax = this._scrollbarWidth - barWidth - 2;
        this._scrollLeftMax = this._innerWidth - this._scrollbarWidth;
        this._scrollDx = this._scrollLeftMax / this._barLeftMax;
        this._scrollDelta = barWidth * this._scrollDx / 3;
        
        this._barWidth = barWidth;
        this._innerBar.style.width = barWidth + 'px';
        
        return this;
    },
    
    _onClick: function (event) {
        event.stop();
        
        if (this._scrollable || event.target !== this._scrollbar) {
            return;
        }
        
        var op = (event.getRelativeMousePoint(this._innerBar).x < 0 ? -1 : 1);
        
        this.setScrollLeft(this._scrollLeft + op * this._barWidth * this._scrollDx);
        
        this._callHandlers(event);
    },
    
    _onScroll: function (event) {
        if (this._scrollable) {
            return;
        }
        
        var op = (event.mouseWheel > 0 ? -1 : 1);
        var lf = op < 0;
          
        if (this.canScroll(lf)) {
            event.stop();
            
            this.setScrollLeft(this._scrollLeft + op * this._scrollDelta);

            this._callHandlers(event);
        }
    },
    
    _onMouseDown: function (event) {
        event.stop();
        
        this._scrollable = true;
        
        this._startPoint = event.getRelativeMousePoint(this._innerBar);
    },
    
    _onMouseMove: function (event) {
        if ( ! this._scrollable) {
            return;
        }
        
        event.stop();
        
        var left = event.getRelativeMousePoint(this._scrollbar).x
                - this._startPoint.x;
              
        left = Jeeel.Number.limit(left, 0, this._barLeftMax);
        
        this._innerBar.style.left = left + 'px';
        this.setScrollLeft(left * this._scrollDx);
        
        this._callHandlers(event);
    },
    
    _onMouseUp: function (event) {
        if (this._scrollable) {
            event.stop();

            this._scrollable = false;
        }
    },
    
    _callHandlers: function (event) {
        for (var i = 0, l = this._scrollHandlers.length; i < l; i++) {
            var listener = this._scrollHandlers[i].listener;
            var thisArg  = this._scrollHandlers[i].thisArg;
            var args     = this._scrollHandlers[i].args;
            
            args[0] = event;
            
            listener.apply(thisArg, args);
            
            args[0] = null;
        }
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Gui.Scrollbar.Horizontal,
    
    _init: function () {
        this.constructor.initStyle();
        var scrollbar = Jeeel.Document.createElement('div');
        var inner = Jeeel.Document.createElement('div');
        
        this._scrollHandlers = [];
        
        scrollbar.className = this.constructor.CLASS.SCROLLBAR;
        inner.className = this.constructor.CLASS.INNER;
        
        inner.innerHTML = '▒';
        
        this._scrollbar = scrollbar;
        this._innerBar = inner;
        
        this._scrollbar.appendChild(this._innerBar);
        
        Jeeel.Dom.Event.addEventListener(this._scrollbar, Jeeel.Dom.Event.Type.CLICK, this._onClick, this);
        Jeeel.Dom.Event.addEventListener(this._scrollbar, Jeeel.Dom.Event.Type.MOUSE_WHEEL, this._onScroll, this);
        Jeeel.Dom.Event.addEventListener(this._innerBar, Jeeel.Dom.Event.Type.MOUSE_DOWN, this._onMouseDown, this);
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._onMouseMove, this);
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, this._onMouseUp, this);
    }
};

Jeeel.Class.extend(Jeeel.Gui.Scrollbar.Horizontal, Jeeel.Gui.Abstract);

/**
 * コンストラクタ
 * @class カレンダーを扱うクラス
 * @param {Boolean} [multiSelect] 日付複数選択するかどうか
 * @ignore 未完成
 */
Jeeel.Gui.Calendar = function (multiSelect) { 
    Jeeel.Gui.Abstract.call(this);
    
    this._init(multiSelect);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Boolean} [multiSelect] 日付複数選択するかどうか
 * @return {Jeeel.Gui.Calendar} 作成したインスタンス
 */
Jeeel.Gui.Calendar.create = function (multiSelect) {
    return new this(multiSelect);
};

Jeeel.Gui.Calendar.CLASS = {
    CALENDAR: 'jeeel-gui-calendar',
    HEADER: 'jeeel-gui-header',
    BODY: 'jeeel-gui-body',
    FOOTER: 'jeeel-gui-footer',
    BUTTON: 'jeeel-gui-button',
    POPUPABLE: 'jeeel-gui-popupable',
    DRAG: 'jeeel-gui-drag',
    HELP: 'jeeel-gui-help',
    CLOSE: 'jeeel-gui-close',
    DECISION: 'jeeel-gui-decision',
    TITLE: 'jeeel-gui-title',
    MESSAGE: 'jeeel-gui-message',
    HIGHLIGHT: 'jeeel-gui-highlight',
    ACTIVE: 'jeeel-gui-active',
    TABLE: 'jeeel-gui-table',
    TABLE_HEADER: 'jeeel-gui-table-header',
    TABLE_HEADER_TITLE: 'jeeel-gui-table-header-title',
    TABLE_HEADER_WEEK: 'jeeel-gui-table-header-week',
    TABLE_DATA: 'jeeel-gui-table-data',
    
    DAYS: [
        'jeeel-gui-calendar-day-sunday',
        'jeeel-gui-calendar-day-monday',
        'jeeel-gui-calendar-day-tuesday',
        'jeeel-gui-calendar-day-wednesday',
        'jeeel-gui-calendar-day-thursday',
        'jeeel-gui-calendar-day-friday',
        'jeeel-gui-calendar-day-saturday'
    ],
    
    TODAY: 'jeeel-gui-calendar-today',
    WEEK: 'jeeel-gui-calendar-week',
    DATE: 'jeeel-gui-calendar-date',
    SELECT: 'jeeel-gui-calendar-date-select',
    
    DATE_OPERATOR: 'jeeel-gui-date-operator',
    DATE_OPERATOR_PREV: 'jeeel-gui-date-operator-prev',
    DATE_OPERATOR_NEXT: 'jeeel-gui-date-operator-next',
    DATE_OPERATOR_TODAY: 'jeeel-gui-date-operator-today'
};

Jeeel.Gui.Calendar._initStyle = function () {
        
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    var classNames = Jeeel.Gui.Calendar.CLASS;

    var css = '.' + classNames.CALENDAR + ' {\n'
            + '  width: 200px;\n'
            + '  height: auto;\n'
            + '  background-color: white;\n'
            + '  border: black 1px solid;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' {\n'
            + '  border-spacing: 0;\n'
            + '  width: 100%;\n'
            + '  height: 100%;\n'
            + '  font-size: 16px;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' .' + classNames.TABLE_HEADER_WEEK + ' {\n'
            + '  background-color: #BBDDFF;\n'
            + '  border-right: black 1px solid;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' * {\n'
            + '  border: 0;\n'
            + '  color: black;\n'
            + '  margin: 0;\n'
            + '  padding: 0;\n'
            + '  text-align: center;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BUTTON + ' {\n'
            + '  text-align: center;\n'
            + '  cursor: pointer;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + '.' + classNames.POPUPABLE + ' .' + classNames.DRAG + ' {\n'
            + '  cursor: move;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' {\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' tr {\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' th {\n'
            + '  width: 17px;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' .' + classNames.DATE_OPERATOR + ' td {\n'
            + '  background-color: #467AA7;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' .' + classNames.DATE_OPERATOR + ' td:hover {\n'
            + '  background-color: #80B0DA;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' .' + classNames.TABLE_HEADER + ' {\n'
            + '  background-color: #BBDDFF;\n'
            + '  font-weight: bold;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' .' + classNames.TABLE_HEADER + ' th {\n'
            + '  border-bottom: black 1px solid;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' .' + classNames.DAYS[0] + ' {\n'
            + '  color: #E33;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' .' + classNames.DAYS[6] + ' {\n'
            + '  color: #33E;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' .' + classNames.TODAY + ' {\n'
            + '  border: 1px solid black;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' {\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' tr {\n'
            + '  height: 18px;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.TABLE_HEADER + ' {\n'
            + '  font-weight: bold;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.TABLE_DATA + ' {\n'
            + '  text-align: center;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + '.' + classNames.HIGHLIGHT + ' td.' + classNames.ACTIVE + ' {\n'
            + '  background-color: #DEF;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + '.' + classNames.HIGHLIGHT + ' td.' + classNames.ACTIVE + '.' + classNames.SELECT + ' {\n'
            + '  background-color: #EBCBD3;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + '.' + classNames.HIGHLIGHT + ' td.' + classNames.TABLE_HEADER_WEEK + ' {\n'
            + '  background-color: #80B0DA;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + ' .' + classNames.TABLE_DATA + '.' + classNames.ACTIVE + '.' + classNames.HIGHLIGHT + ' {\n'
            + '  background-color: #80B0DA;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + ' .' + classNames.TABLE_DATA + '.' + classNames.ACTIVE + '.' + classNames.SELECT + ' {\n'
            + '  background-color: #F9A7A7;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + ' .' + classNames.TABLE_DATA + '.' + classNames.ACTIVE + '.' + classNames.SELECT + '.' + classNames.HIGHLIGHT + ' {\n'
            + '  background-color: #BDACC1;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.FOOTER + ' {\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.FOOTER + ' tr td {\n'
            + '  border-top: black 1px solid;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.FOOTER + ' .' + classNames.MESSAGE + ' {\n'
            + '  vertical-align: middle;\n'
            + '  font-size: 13px;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.FOOTER + ' .' + classNames.DECISION + ' {\n'
            + '  vertical-align: middle;\n'
            + '  font-size: 15px;\n'
            + '}\n';

    this._defaultStyle = css;
    this._styleTag = Jeeel.Loader.addStyle(css);
};

Jeeel.Gui.Calendar.prototype = {
    
    /**
     * ポップアップ可能かどうか
     * 
     * @type Boolean
     * @private
     */
    _popupable: false,
    
    /**
     * 日付複数選択するかどうか
     * 
     * @type Boolean
     * @private
     */
    _multiSelect: false,
    
    /**
     * 日付の選択が決定した場合のコールバック
     * 
     * @type Function
     * @private
     */
    _okCallback: null,
    
    /**
     * カレンダーの要素
     * 
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _calendar: null,
   
    /**
     * 現在表示の日付
     * 
     * @type Jeeel.Object.Date
     * @private
     */
    _date: null,
    
    /**
     * 現在選択中の日付リスト
     * 
     * @type Jeeel.Object.Date[]
     * @private
     */
    _selectDates: [],
    
    _dragData: {
        enable: false
    },
    
    /**
     * 現在の選択済みの日付を取得する
     * 
     * @return {Jeeel.Object.Date} 日付
     */
    getSelectedDate: function () {
        return this._selectDates[0] || null;
    },
    
    /**
     * 現在の選択済みの日付リストを取得する
     * 
     * @return {Jeeel.Object.Date[]} 日付リスト
     */
    getSelectedDates: function () {
        return this._selectDates;
    },
    
    /**
     * 指定した日付を選択する
     * 
     * @param {Jeeel.Object.Date|Date|String|Integer} date 日付を示す値
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    selectDate: function (date) {
        var tmp = new Jeeel.Object.Date(date);
        
        this._selectDates[this._selectDates.length] = Jeeel.Object.Date.createDate(tmp.year, tmp.month, tmp.date);
        
        return this._refreshSelected();
    },
    
    /**
     * 指定した年月日を選択する
     * 
     * @param {Integer} year 年
     * @param {Integer} month 月
     * @param {Integer} day 日
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    selectYmd: function (year, month, day) {
        this._selectDates[this._selectDates.length] = Jeeel.Object.Date.createDate(year, month, day);

        return this._refreshSelected();
    },
    
    /**
     * 表示中の日付を指定した日付に変更する
     * 
     * @param {Jeeel.Object.Date|Date|String|Integer} date 日付を示す値
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeDate: function (date) {
        var prev = this._date;
        
        var tmp = new Jeeel.Object.Date(date);
        
        this._date = Jeeel.Object.Date.createDate(tmp.year, tmp.month, tmp.date);
        
        return this._redraw(prev);
    },
    
    /**
     * 表示中の日付を指定した年月日に変更する
     * 
     * @param {Integer} year 年
     * @param {Integer} month 月
     * @param {Integer} day 日
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeYmd: function (year, month, day) {
         var prev = this._date;
         
        this._date = Jeeel.Object.Date.createDate(year, month, day);
        
        return this._redraw(prev);
    },
    
    /**
     * 表示中の日付を今日に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeToday: function () {
        return this.changeDate();
    },
    
    /**
     * 表示中の日付を前月に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changePrevMonth: function () {
        return this.changeYmd(this._date.year, this._date.month - 1, 1);
    },
    
    /**
     * 表示中の日付を翌月に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeNextMonth: function () {
        return this.changeYmd(this._date.year, this._date.month + 1, 1);
    },
    
    /**
     * 表示中の日付を前年に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changePrevYear: function () {
        return this.changeYmd(this._date.year - 1, this._date.month, 1);
    },
    
    /**
     * 表示中の日付を翌年に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeNextYear: function () {
        return this.changeYmd(this._date.year + 1, this._date.month, 1);
    },
    
    /**
     * カレンダーを表示する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    show: function () {
        
        this._calendar.show();
        
        return this;
    },
    
    /**
     * カレンダーを非表示にする
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    hide: function () {
        
        this._calendar.hide();
        
        return this;
    },
    
    /**
     * 日付選択を決定した際に呼ばれるコールバックを設定する
     * 
     * @param {Function} callback コールバック
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    setDecisionCallback: function (callback) {
        
        if ( ! Jeeel.Type.isFunction(callback)) {
            throw new Error('callbackが関数ではありません。');
        }
        
        this._okCallback = callback;
        
        return this;
    },
    
    /**
     * カレンダーの要素を取得する
     * 
     * @return {Element} カレンダー要素
     */
    getCalendarElement: function () {
        return this._calendar.get(0);
    },
    
    /**
     * ポップアップの有効・無効を設定する
     * 
     * @param {Boolean} enable ポップアップ化を有効にするかどうか
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    enablePopup: function (enable) {
        var pos = (enable ? 'absolute' : '');
        var zi  = (enable ? '100' : '');
        
        this._calendar.setCss('position', pos)
                      .setCss('z-index', zi);
        
        if (enable) {
            this._calendar.addClass(this.constructor.CLASS.POPUPABLE)
                          .$CLASS(this.constructor.CLASS.CLOSE)
                          .setCss('visibility', 'visible');
        } else {
            this._calendar.removeClass(this.constructor.CLASS.POPUPABLE)
                          .$CLASS(this.constructor.CLASS.CLOSE)
                          .setCss('visibility', 'hidden');
        }
        
        this._popupable = !!enable;

        return this;
    },
    
    /**
     * このElementを指定座標に移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    shiftTo: function (x, y) {
        this._calendar.shiftTo(x, y);
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Boolean} [multiSelect] 日付複数選択するかどうか
     * @constructor
     */
    constructor: Jeeel.Gui.Calendar,
    
    _refreshSelected: function () {
        
        if ( ! this._multiSelect) {
            this._selectDates = [this._selectDates[this._selectDates.length - 1]];
            this._ok();
            this._redraw(this._date);
            
            return this;
        }
        
        var len = this._selectDates.length,
            res = [];
        
        outerLoop: for (var i = 0; i < len; i++) {
            
            var resLen = res.length;
            
            for (var j = 0; j < resLen; j++) {
                if (res[j].year === this._selectDates[i].year && res[j].month === this._selectDates[i].month && res[j].date === this._selectDates[i].date) {
                    res.splice(j, 1);
                    break outerLoop;
                }
            }
            
            res[resLen] = this._selectDates[i];
        }
        
        this._selectDates = res;
        
        return this._redraw(this._date);
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _selectDate: function (ev) {
        var target = Jeeel.Dom.Element.create(ev.bubblingTargets[0]);
        
        if (target.hasClassName(this.constructor.CLASS.DATE)) {
            var date = +target.getText();
            
            if (date) {
                this.selectYmd(this._date.year, this._date.month, date);
            }
        }
    },
    
    _resetState: function () {
        this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('日付を選択してください');
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _changeState: function (ev) {
        var target = Jeeel.Dom.Element.create(ev.bubblingTargets[0]);
        var txt, highlightTarget;
        
        if (target.hasClassName(this.constructor.CLASS.DRAG)) {
            
            txt = this._popupable ? 'ドラッグ可能' : '日付を選択してください';
            
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText(txt);
        }
        else if (target.hasClassName(this.constructor.CLASS.HELP)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('ヘルプ');
        }
        else if (target.hasClassName(this.constructor.CLASS.CLOSE)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('キャンセル');
        }
        else if (target.hasClassName(this.constructor.CLASS.DATE)) {
            
            var date = +target.getText();
            
            if (date) {
                highlightTarget = target;
                
                date = Jeeel.Object.Date.createDate(this._date.year, this._date.month, date);
                
                txt = date.toString('m月d日(D)');
                
                if (target.hasClassName(this.constructor.CLASS.TODAY)) {
                    txt += '(今日)';
                }
                
                this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText(txt);
            } else {
                this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('日付を選択してください');
            }
        } 
        else if (target.hasClassName(this.constructor.CLASS.DATE_OPERATOR_TODAY)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('今日');
        }
        else if (target.hasClassName(this.constructor.CLASS.DATE_OPERATOR_NEXT)) {
            var nt = target.getText();
            
            txt = '翌' + ((nt === '>') ? '月' : '年');
            
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText(txt);
        }
        else if (target.hasClassName(this.constructor.CLASS.DATE_OPERATOR_PREV)) {
            var pt = target.getText();
            
            txt = '前' + ((pt === '<') ? '月' : '年');
          
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText(txt);
        } 
        else if (target.hasClassName(this.constructor.CLASS.TABLE_HEADER_WEEK)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('日付を選択してください');
        } 
        else if (target.hasClassName(this.constructor.CLASS.TABLE_HEADER_TITLE)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('日付を選択してください');
        }
        
        this._highlight(highlightTarget);
    },
    
    _highlight: function (date) {
        this._calendar.$CLASS(this.constructor.CLASS.HIGHLIGHT).removeClass(this.constructor.CLASS.HIGHLIGHT);
        
        if (date) {
            Jeeel.Dom.Element.create(date.addClassName(this.constructor.CLASS.HIGHLIGHT).getParentNode())
                             .addClassName(this.constructor.CLASS.HIGHLIGHT);
        }
    },
    
    _cancel: function () {
        this._selectDates = [];
        
        this.hide();
        this._redraw(this._date);
    },
    
    _ok: function () {
        if (this._popupable) {
            this.hide();
        }
        
        if (this._okCallback) {
            this._okCallback(this);
        }
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _drag: function (ev) {
        if ( ! this._dragData.enable) {
            return;
        }
        
        ev.stop();
        
        var bpoint = this._dragData.point;
        var apoint = ev.mousePoint;
        
        var top  = apoint.y - bpoint.y;
        var left = apoint.x - bpoint.x;
        
        this._calendar.setCss('top', top + 'px')
                      .setCss('left', left + 'px');
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _dragOn: function (ev) {
        this._dragData.enable = true;
        this._dragData.point = ev.getRelativeMousePoint(this._calendar.get(0));
        
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._drag, this)
                      .addEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, this._dragOff, this);
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _dragOff: function (ev) {
        this._dragData.enable = false;
        
        Jeeel.Document.removeEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._drag)
                      .removeEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, this._dragOff);
    },
    
    _isSelected: function (year, month, day) {
        for (var i = 0, l = this._selectDates.length; i < l; i++) {
            
            var date = this._selectDates[i];
            
            if (date.year == year && date.month == month && date.date == day) {
                return true;
            }
        }
        
        return false;
    },
    
    _redraw: function (prevDate) {
        var today   = Jeeel.Object.Date.createDate();
        var toMonth = Jeeel.Object.Date.createDate(this._date.year, this._date.month, 1);
        
        if (toMonth.year !== today.year || toMonth.month !== today.month) {
            today = null;
        }
        
        var dates = toMonth.getDatesOfMonth();
        var l = Jeeel.Object.Date.DAYS.length;
        var title = this._calendar.$CLASS(this.constructor.CLASS.TITLE);
        var body = this._calendar.$CLASS(this.constructor.CLASS.WEEK);
        
        title.setText(toMonth.toString('Y年m月'));
        
        var mi = -toMonth.getDay();
        
        for (var i = 0; i < 6; i++) {
            var weekTr = body.$GET(i);
            var week = weekTr.$CLASS(this.constructor.CLASS.DATE);
            
            var hide = true;
            
            for (var w = 0; w < l; w++) {
                var date = week.$GET(w);
                var txt  = dates[mi] || '';
                
                date.setText(txt);
                
                if (today && today.date == txt) {
                    date.addClass(this.constructor.CLASS.TODAY);
                } else {
                    date.removeClass(this.constructor.CLASS.TODAY);
                }
                
                if (this._isSelected(toMonth.year, toMonth.month, txt)) {
                    date.addClass(this.constructor.CLASS.SELECT);
                } else {
                    date.removeClass(this.constructor.CLASS.SELECT);
                }
                
                if (txt) {
                    hide = false;
                    date.addClass(this.constructor.CLASS.ACTIVE);
                } else {
                    date.removeClass(this.constructor.CLASS.ACTIVE);
                }
                
                mi++;
            }
            
            if (hide) {
                weekTr.hide();
            } else {
                weekTr.show();
            }
        }
        
        return this;
    },
    
    /**
     * Elementの作成を行う
     * 
     * @param {String} tagName 作成タグ名
     * @return {Jeeel.Dom.ElementOperator} 作成タグのラッパー
     */
    _createElm: function (tagName) {
        var tag = Jeeel.Document.createElement(tagName);
        
        return Jeeel.Dom.ElementOperator.create(tag);
    },
    
    _init: function (multiSelect) {
        
        if (multiSelect) {
            this._multiSelect = true;
        }
      
        var calendar = this._createElm('table');
        var header   = this._createElm('thead');
        var body     = this._createElm('tbody');
        var footer   = this._createElm('tfoot');
        
        calendar.addClass(this.constructor.CLASS.TABLE)
                .appendChild(header)
                .appendChild(body)
                .appendChild(footer);
                
        header.addClass(this.constructor.CLASS.HEADER);
        body.addClass(this.constructor.CLASS.BODY);
        footer.addClass(this.constructor.CLASS.FOOTER);
        
        var topBar = this._createElm('tr');
        var title = this._createElm('td');
        var help   = this._createElm('td');
        var close  = this._createElm('td');

        title.addClass([this.constructor.CLASS.DRAG, this.constructor.CLASS.TITLE])
             .setProp('colSpan', 6);
             
        help.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.HELP])
            .setCss('visibility', 'hidden');
            
        close.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.CLOSE])
             .addClick(this._cancel, this);
        
        help.setText('?');
        close.setText('×');
        
        topBar.appendChild([help, title, close]);
        
        var opBar  = this._createElm('tr');
        var pYear  = this._createElm('td');
        var pMonth = this._createElm('td');
        var today  = this._createElm('td');
        var nMonth = this._createElm('td');
        var nYear  = this._createElm('td');
        
        opBar.addClass(this.constructor.CLASS.DATE_OPERATOR);
        pYear.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_PREV])
              .addClick(this.changePrevYear, this);
        
        pMonth.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_PREV])
             .addClick(this.changePrevMonth, this);
        
        nYear.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_NEXT])
              .addClick(this.changeNextYear, this);
        
        nMonth.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_NEXT])
             .addClick(this.changeNextMonth, this);
        
        today.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_TODAY])
             .addClick(this.changeToday, this)
             .setProp('colSpan', 4);
        
        pYear.setText('<<');
        pMonth.setText('<');
        today.setText('今日');
        nMonth.setText('>');
        nYear.setText('>>');
        
        opBar.appendChild([pYear, pMonth, today, nMonth, nYear]);
        
        var tr, th, td, w, l = Jeeel.Object.Date.DAYS.length;
        var dayClasses = this.constructor.CLASS.DAYS;
        var weekTitle = this._createElm('tr')
                            .addClass(this.constructor.CLASS.TABLE_HEADER);
        
        th = this._createElm('th');
        th.addClass([this.constructor.CLASS.TABLE_HEADER_TITLE, this.constructor.CLASS.TABLE_HEADER_WEEK])
          .setText('週');
        
        weekTitle.appendChild(th);
        
        for (w = 0; w < l; w++) {
            th = this._createElm('th');
            th.addClass([this.constructor.CLASS.TABLE_HEADER_TITLE, dayClasses[w]])
              .setText(Jeeel.Object.Date.DAYS[w]);
            
            weekTitle.appendChild(th);
        }
        
        header.appendChild([topBar, opBar, weekTitle]);
        
        body.addClass(this.constructor.CLASS.DATE_TABLE)
            .addClick(this._selectDate, this);

        var date = Jeeel.Object.Date.create();
        today = date;
        
        this._date = date;
        
        title.setText(date.toString('Y年m月'));
        date = Jeeel.Object.Date.create(date.toString('Y-m-1'));
        
        var dates = date.getDatesOfMonth();
        var mi = - date.getDay();
        
        for (var i = 0; i < 6; i++) {
            tr = this._createElm('tr').addClass(this.constructor.CLASS.WEEK);
            td = this._createElm('td');
            td.addClass([this.constructor.CLASS.TABLE_DATA, this.constructor.CLASS.TABLE_HEADER_WEEK])
              .setText(i + 1);
                  
            tr.appendChild(td);
            
            var hide = true;
            
            for (w = 0; w < l; w++) {
                var txt = dates[mi] || '';
                
                td = this._createElm('td');
                td.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.TABLE_DATA, this.constructor.CLASS.DATE, dayClasses[w]])
                  .setText(txt);
                  
                if (today.date == txt) {
                    td.addClass(this.constructor.CLASS.TODAY);
                }
                
                if (txt) {
                    hide = false;
                    td.addClass(this.constructor.CLASS.ACTIVE);
                } else {
                    td.removeClass(this.constructor.CLASS.ACTIVE);
                }

                tr.appendChild(td);
                
                mi++;
            }
            
            if (hide) {
                tr.hide();
            }
            
            body.appendChild(tr);
        }
        
        tr = this._createElm('tr');
        td = this._createElm('td');
        
        td.setProp('colSpan', 8)
          .addClass([this.constructor.CLASS.DRAG, this.constructor.CLASS.MESSAGE])
          .setText('日付を選択して下さい');
          
        tr.appendChild(td);
        
        footer.appendChild(tr);
        
        tr = this._createElm('tr');
        td = this._createElm('td');

        td.setProp('colSpan', 8)
          .addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DECISION])
          .addClick(this._ok, this)
          .setText('決定');
          
        tr.appendChild(td);
        
        if ( ! this._multiSelect) {
            tr.hide();
        }
        
        footer.appendChild(tr);
        
        var parent = this._createElm('div');
        
        this._calendar = parent.addMouseMove(this._changeState, this)
                               .addOut(this._resetState, this)
                               .addClass(this.constructor.CLASS.CALENDAR)
                               .appendChild(calendar);
                               
        this._calendar.$CLASS(this.constructor.CLASS.DRAG)
                      .addMouseDown(this._dragOn, this);
        
        this.enablePopup(false);
        Jeeel.Document.appendToBody(this._calendar.get(0));
                      
        this.constructor._initStyle();
        
        this._defaultStyle = this.constructor._defaultStyle;
        this._styleTag = this.constructor._styleTag;
    }
};

Jeeel.Class.extend(Jeeel.Gui.Calendar, Jeeel.Gui.Abstract);
Jeeel.directory.Jeeel.Gui.Mouse = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Gui + 'Mouse/';
    }
};

/**
 * マウス関連のGUIネームスペース
 */
Jeeel.Gui.Mouse = {

    /**
     * リスナ対象となるオブジェクト
     *
     * @type Element|Document|Window
     * @private
     */
    _currentTarget: Jeeel._doc,

    /**
     * 初期化を終えたかどうか
     *
     * @type Boolean
     * @private
     */
    _inited: false,

    /**
     * マウスの現在位置
     *
     * @type Jeeel.Object.Point
     * @private
     */
    _point: new Jeeel.Object.Point(0, 0),

    /**
     * マウスボタンの押されている判別子
     *
     * @type Object
     * @private
     */
    _button: {
        left: false,
        right: false,
        middle: false
    },

    /**
     * マウス情報の取得のためのリスナー
     * 
     * @private
     */
    _listener: function () {
        var ev = Jeeel.Dom.Event.getEventObject();
        Jeeel.Gui.Mouse._point = ev.mousePoint.clone();

        this._button.left   = ev.isLeftDown;
        this._button.right  = ev.isRightDown;
        this._button.middle = ev.isMiddleDown;
    },

    /**
     * マウス情報を取得するための初期化を行う<br />
     * 常にマウスを追いかけるためやや重い<br />
     * このメソッドを呼んでいないと、他のメソッドが意味をなさない
     */
    init: function () {
        if (this._inited) {
            return;
        }

        Jeeel.Dom.Event.addEventListener(this._currentTarget, Jeeel.Dom.Event.Type.MOUSE_MOVE, this._listener);
        this._inited = true;
    },

    /**
     * マウス情報を取得するための初期化処理を無効化する
     */
    clear: function () {
        if ( ! this._inited) {
            return;
        }

        Jeeel.Dom.Event.removeEventListener(this._currentTarget, Jeeel.Dom.Event.Type.MOUSE_MOVE, this._listener);
        this._inited = false;
    },

    /**
     * マウスの左ボタンが押されているかどうか
     *
     * @return {Boolean}
     */
    isLeftDown: function () {
        return this._button.left;
    },

    /**
     * マウスの右ボタンが押されているかどうか
     *
     * @return {Boolean}
     */
    isRightDown: function () {
        return this._button.right;
    },

    /**
     * マウスの中央ボタンが押されているかどうか
     * 
     * @return {Boolean}
     */
    isMiddleDown: function () {
        return this._button.middle;
    },

    /**
     * マウスの現在位置を取得する
     * 
     * @return {Jeeel.Object.Point} マウス位置
     */
    getPoint: function () {
        return Jeeel.Gui.Mouse.point;
    },

    /**
     * マウスの現在位置のX座標を取得する
     *
     * @return {Integer}
     */
    getX: function () {
        return Jeeel.Gui.Mouse.point.x;
    },

    /**
     * マウスの現在位置のY座標を取得する
     *
     * @return {Integer}
     */
    getY: function () {
        return Jeeel.Gui.Mouse.point.y;
    }
};

Jeeel.file.Jeeel.Gui.Mouse = ['Gesture'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Gui.Mouse, Jeeel.file.Jeeel.Gui.Mouse);

/**
 * コンストラクタ
 *
 * @class マウスジェスチャーを管理するクラス
 * @param {Element|Document|Window} [target] ジェスチャーの対象になるオブジェクト
 * @param {Integer} [sensitivityPlay] マウスの感度の遊び
 */
Jeeel.Gui.Mouse.Gesture = function (target, sensitivityPlay) {
    if ( ! target) {
        target = Jeeel.Gui.Mouse._currentTarget;
    }

    if (Jeeel.Type.isInteger(sensitivityPlay)) {
        this._sensitivityPlay = sensitivityPlay;
    }

    this._target = target;
    this._onMouseDown.bind(this);
    this._onMouseUp.bind(this);
    this._onMouseMove.bind(this);
};

/**
 * インスタンスの作成を行う
 *
 * @param {Element|Document|Window} [target] ジェスチャーの対象になるオブジェクト
 * @param {Integer} [sensitivityPlay] マウスの感度の遊び
 * @return {Jeeel.Gui.Mouse.Gesture} 作成したインスタンス
 */
Jeeel.Gui.Mouse.Gesture.create = function (target, sensitivityPlay) {
    return new this(target, sensitivityPlay);
};

Jeeel.Gui.Mouse.Gesture.prototype = {

    /**
     * マウス感度の遊び
     *
     * @type Integer
     * @protected
     */
    _sensitivityPlay: 10,

    /**
     * ジェスチャー対象となるオブジェクト
     *
     * @type Element|Document|Window
     * @protected
     */
    _target: null,

    /**
     * マウスジェスチャーが始動しているかどうか
     *
     * @type Boolean
     * @protected
     */
    _started: false,

    /**
     * 現在実行されているかどうか
     *
     * @type Boolean
     * @protected
     */
    _active: false,

    /**
     * アクティブになった時のコールバック
     *
     * @type Function
     * @protected
     */
    _activeCallback: null,

    /**
     * アクティブが解除された時のコールバック
     * 
     * @type Function
     * @protected
     */
    _inactiveCallback: null,

    /**
     * ジェスチャーした地点のリスト
     *
     * @type Jeeel.Object.Point[]
     * @protected
     */
    _pointList: [],

    /**
     * ジェスチャーした方向のリスト
     *
     * @type Integer[]
     * @protected
     */
    _gestureList: [],

    /**
     * ジェスチャーのマウスボタンを右クリックで行うかどうか(通常はfalse)
     *
     * @type Boolean
     * @protected
     */
    _isRight: false,

    /**
     * マウスが押し込まれた時の動作
     *
     * @type Jeeel.Function
     * @protected
     */
    _onMouseDown: Jeeel.Function.create(function () {

        if (this._active) {
            return;
        }

        var ev = Jeeel.Dom.Event.getEventObject();

        if ((this._isRight && ! ev.isRightDown) ||
            ( ! this._isRight && ! ev.isLeftDown))
        {
            return;
        }

        this._gestureList = [];
        this._pointList   = [];
        
        this._active = true;
        this._pointList.push(ev.mousePoint.clone());

        if (this._activeCallback) {
            this._activeCallback.call(this);
        }

    }),

    /**
     * マウスのボタンを上げた時の動作
     *
     * @type Jeeel.Function
     * @protected
     */
    _onMouseUp: Jeeel.Function.create(function () {

        if ( ! this._active) {
            return;
        }

        var ev = Jeeel.Dom.Event.getEventObject();

        if ((this._isRight && ev.isRightDown) ||
            ( ! this._isRight && ! ev.isLeftDown))
        {
            return;
        }
        
        this._active = false;

        if (this._inactiveCallback) {
            this._inactiveCallback.call(this, this.getGestureList());
        }

    }),

    /**
     * マウスが移動したときのイベント
     *
     * @type Jeeel.Function
     * @protected
     */
    _onMouseMove: Jeeel.Function.create(function () {

        if ( ! this._active) {
            return;
        }
        
        var ev = Jeeel.Dom.Event.getEventObject();

        if ((this._isRight && ! ev.isRightDown) ||
            ( ! this._isRight && ! ev.isLeftDown)){
            this._active = false;

            if (this._inactiveCallback) {
                this._inactiveCallback.call(this, this.getGestureList());
            }
            
            return;
        }

        var oldGesture = this._gestureList[this._pointList.length - 2];
        var newGesture;

        var oldPoint = this._pointList[this._pointList.length - 1];
        var newPoint = ev.mousePoint;
        var hLength  = newPoint.x - oldPoint.x;
        var vLength  = newPoint.y - oldPoint.y;

        if (Math.abs(hLength) > Math.abs(vLength) + this._sensitivityPlay) {
            newGesture = (hLength < 0 ? Jeeel.Code.KeyCode.Left : Jeeel.Code.KeyCode.Right);
        } else if (this._sensitivityPlay + Math.abs(hLength) < Math.abs(vLength)) {
            newGesture = (vLength < 0 ? Jeeel.Code.KeyCode.Up : Jeeel.Code.KeyCode.Down);
        } else {
            return;
        }

        if (oldGesture && oldGesture === newGesture) {
            this._pointList[this._pointList.length - 1] = newPoint.clone();
            return;
        }

        this._gestureList.push(newGesture);
        this._pointList.push(newPoint.clone());
        
    }),

    /**
     * マウスジェスチャーを開始する
     *
     * @return {Jeeel.Gui.Mouse.Gesture} 自インスタンス
     */
    start: function () {

        if (this._started) {
            return this;
        }

        Jeeel.Dom.Event.addEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_DOWN, this._onMouseDown);
        Jeeel.Dom.Event.addEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_UP,   this._onMouseUp);
        Jeeel.Dom.Event.addEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_MOVE, this._onMouseMove);
        this._started = true;

        return this;
    },

    /**
     * マウスジェスチャーを終了する
     *
     * @return {Jeeel.Gui.Mouse.Gesture} 自インスタンス
     */
    end: function () {

        if ( ! this._started) {
            return this;
        }

        Jeeel.Dom.Event.removeEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_DOWN, this._onMouseDown);
        Jeeel.Dom.Event.removeEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_UP,   this._onMouseUp);
        Jeeel.Dom.Event.removeEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_MOVE, this._onMouseMove);
        this._started = false;
        this._active  = false;

        return this;
    },

    /**
     * 使用するマウスのボタンを右ボタンにするかどうかを設定する<br />
     * なおこの設定を呼ぶと強制的にマウスジェスチャーが終了させられる
     *
     * @param {Boolean} isRight 右かどうか
     */
    setMouseButtonRight: function (isRight) {
        this.end();
        this._isRight = isRight;

        return this;
    },

    /**
     * ジェスチャーがアクティブになった時のコールバックを設定する
     *
     * @param {Function} callback 設定コールバック(引数はなしで、thisはこのインスタンスになる)
     * @return {Jeeel.Gui.Mouse.Gesture} 自インスタンス
     */
    setActiveCallback: function (callback) {
        this._activeCallback = callback;

        return this;
    },

    /**
     * ジェスチャーがアクティブになった時のコールバックを設定する
     *
     * @param {Function} callback 設定コールバック(引数はこのジェスチャーのリストで、thisはこのインスタンスになる)
     * @return {Jeeel.Gui.Mouse.Gesture} 自インスタンス
     */
    setInactiveCallback: function (callback) {
        this._inactiveCallback = callback;

        return this;
    },

    /**
     * 現在までのジェスチャーを取得する<br />
     * なおリスト内に入っている数値は、<br />
     * Jeeel.Code.KeyCode内のLeft, Right, Up, Downのいずれかである
     *
     * @return {Integer[]} 取得したジェスチャーのリスト
     */
    getGestureList: function () {
        return this._gestureList;
    },

    /**
     * 現在までのジェスチャーを文字列として取得する
     *
     * @return {String}
     */
    getGestureListToString: function () {
        var res = '';

        for (var i = 0; i < this._gestureList.length; i++) {

            if (i > 0) {
                res += ' ';
            }

            switch (this._gestureList[i]) {
                case Jeeel.Code.KeyCode.Left:
                    res += '←';
                    break;

                case Jeeel.Code.KeyCode.Right:
                    res += '→';
                    break;

                case Jeeel.Code.KeyCode.Up:
                    res += '↑';
                    break;

                case Jeeel.Code.KeyCode.Down:
                    res += '↓';
                    break;

                default:
                    res += '？';
                    break;
            }
        }

        return res;
    },

    /**
     * 指定したジェスチャーと現在の結果が一致するかどうかを返す
     * 
     * @param {Integer[]} gesture 比較対象のジェスチャーのリスト
     * @return {Boolean} ジェスチャーが一致するかどうか
     */
    matchGesture:function (gesture) {
        if (gesture.length !== this._gestureList.length) {
            return false;
        }

        for (var i = 0; i < gesture.length; i++) {
            if (gesture[i] !== this._gestureList[i]) {
                return false;
            }
        }

        return true;
    },

    /**
     * 現在までのマウス座標を取得する
     *
     * @type Jeeel.Object.Point[]
     */
    getPointList: function () {
        return this._pointList;
    }
};
Jeeel.directory.Jeeel.Worker = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Worker/';
    }
};

/**
 * コンストラクタ
 * 
 * @class マルチスレッドを提供するクラス(1インスタンスにつき1スレッド)
 */
Jeeel.Worker = function () {
    var script = Jeeel.directory.Jeeel.Worker + 'Thread.js';
    
    this._worker = new Worker(script);
    this._errors = [];
    this._messages = {};
    
    this._init();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Worker} 作成したインスタンス
 */
Jeeel.Worker.create = function () {
    return new this();
};

Jeeel.Worker.prototype = {
  
    /**
     * 内部スレッドWorker
     * 
     * @type Worker
     * @private
     */
    _worker: null,
    
    /**
     * 内部スレッドの動作数(待ちキュー)
     * 
     * @type Integer
     * @private
     */
    _workCount: 0,
    
    /**
     * メッセージイベントリスト
     * 
     * @type Hash
     * @private
     */
    _messages: {},
    
    /**
     * エラーイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _errors: [],
    
    /**
     * メッセージイベント
     * 
     * @private
     */
    _messageEvent: function () {
        var event = Jeeel.Dom.Event.getEventObject();
        var data = event.data;
        
        if (Jeeel.Type.inArray(data.type, [Jeeel.Worker.Type.EXECUTE_SCRIPT])) {
            return;
        }
        
        var actionEvents = this._messages[data.type];
        
        if ( ! actionEvents) {
            this._workCount--;
            return;
        }
        
        for (var i = 0, l = actionEvents.length; i < l; i++) {
            actionEvents[i](data.msg, data.type);
        }
        
        this._workCount--;
    },
    
    /**
     * エラーイベント
     * 
     * @private
     */
    _errorEvent: function () {
        var event = Jeeel.Dom.Event.getEventObject().getEvent();

        for (var i = 0, l = this._errors.length; i < l; i++) {
            this._errors[i](event);
        }
        
        if (l === 0) {
            var error = event.message + '\n'
                      + event.filename + '('
                      + event.lineno + ')';

            Jeeel.errorDump(error);
        }
        
        this._workCount--;
    },
    
    /**
     * タスク内でJeeel.jsを使用できるようにする
     * 
     * @private
     */
    _init: function () {
      
        this._messageEvent = Jeeel.Function.simpleBind(this._messageEvent, this);
        this._errorEvent = Jeeel.Function.simpleBind(this._errorEvent, this);
        
        this._worker.onmessage = this._messageEvent;
        this._worker.onerror = this._errorEvent;
        
        var i, l, script = [];
        var globalValues = [
            '_JEEEL_CLEAN_MODE_',
            '_JEEEL_DEBUG_MODE_',
            '_JEEEL_EXTEND_MODE_',
            '_JEEEL_FULL_MODE_'
        ];

        for (i = 0, l = globalValues.length; i < l; i++) {
            script[i] = globalValues[i] + '=' + Jeeel.Json.encode(Jeeel._global[globalValues[i]]) + ';';
        }
        
        var scriptData = {
            type: Jeeel.Worker.Type.EXECUTE_SCRIPT,
            data: '_JEEEL_MANUAL_LOAD_ = true;\n' + script.join('\n')
        };
        
        this._worker.postMessage(Jeeel.Json.encode(scriptData));
        
        if (Jeeel._auto) {
            var urls = Jeeel.getFilePath().replace(/\n$/g, '').split('\n');

            for (i = 0, l = urls.length; i < l; i++) {
                this.importScript(urls[i]);
            }
        } else {
            this.importScript(Jeeel.directory.Jeeel + 'Jeeel-Set.js');
        }
    },
    
    /**
     * タスク内で使用するスクリプトを読み込ませる(windowやDomを使用しているスクリプトは動作しない: windowの代わりにglobal変数が存在する)
     * 
     * @param {String} url スクリプトのURL
     * @return {Jeeel.Worker} 自インスタンス
     */
    importScript: function (url) {
        var importData = {
            type: Jeeel.Worker.Type.IMPORT_SCRIPT,
            data: url
        };
        
        this._post(Jeeel.Json.encode(importData));
        
        return this;
    },
    
    /**
     * このスレッドで実行を行うタスクの追加を行う(タスク内では外部変数にアクセスしてはならず、window・Domに対してのアクセスは出来ない: JeeelやImportしたライブラリのみ可能, windowの代わりにglobal変数が存在する)
     * 
     * @param {Function} task 実行タスク Mixied task(Mixied data)
     * @return {Jeeel.Worker} 自インスタンス
     */
    addTask: function (task) {
        var taskData = {
            type: Jeeel.Worker.Type.ADD_TASK,
            data: task
        };
        
        this._post(Jeeel.Json.encode(taskData));
        
        return this;
    },
    
    /**
     * 様々なアクションを起こした際に呼ばれるイベントの追加を行う
     * 
     * @param {String} actionType アクションタイプ
     * @param {Function} listener イベント
     * @return {Jeeel.Worker} 自インスタンス
     * @see Jeeel.Worker.Type
     */
    addActionEvent: function (actionType, listener) {
        if ( ! this._messages[actionType]) {
            this._messages[actionType] = [];
        }
        
        var actionEvents = this._messages[actionType];
        
        actionEvents[actionEvents.length] = listener;

        return this;
    },
    
    /**
     * タスク内でエラーが発生した場合に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Worker} 自インスタンス
     */
    addErrorEvent: function (listener) {
        this._errors.push(listener);

        return this;
    },
    
    /**
     * タスクをバックグラウンドで順に実行する
     * 
     * @param {Mixied} [data] タスクに渡すデータ
     * @return {Jeeel.Worker} 自インスタンス
     */
    execute: function (data) {
        var messageData = {
            type: Jeeel.Worker.Type.EXECUTE_TASK,
            data: (Jeeel.Type.isSet(data) ? data : null)
        };
        
        this._post(Jeeel.Json.encode(messageData, true));
        
        return this;
    },
    
    /**
     * 現在バックグラウンドで実行・待機中のアクション数を取得する<br />
     * タスクが複数あってもexecuteして増えるアクション数は1である
     * 
     * @return {Integer} アクション数
     */
    getActioningCount: function () {
        return this._workCount;
    },
    
    /**
     * スレッドの実行を停止する
     * 
     * @return {Jeeel.Worker} 自インスタンス
     */
    terminate: function () {
        this._workCount = 0;
        this._worker.terminate();
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Worker,
    
    _post: function (msg) {
        this._workCount++;
        this._worker.postMessage(msg);
    }
};

Jeeel.file.Jeeel.Worker = ['Type'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Worker, Jeeel.file.Jeeel.Worker);
/**
 * Worker内で使用されるイベントタイプを示す列挙体
 */
Jeeel.Worker.Type = {
    
    /**
     * Scriptのインポートイベント
     * 
     * @type String
     * @constant
     */
    IMPORT_SCRIPT: 'import',
    
    /**
     * Scriptの実行イベント
     * 
     * @type String
     * @constant
     */
    EXECUTE_SCRIPT: 'script',
    
    /**
     * タスク追加イベント
     * 
     * @type String
     * @constant
     */
    ADD_TASK: 'add-task',
    
    /**
     * タスク実行イベント
     * 
     * @type String
     * @constant
     */
    EXECUTE_TASK: 'execute'
};

Jeeel.directory.Jeeel.Database = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Database/';
    }
};

/**
 * DBMSに相当するStaticクラス
 *
 * @ignore 未完
 */
Jeeel.Database = {

    /**
     * デフォルトで使用するDBのVersion
     *
     * @type String
     * @private
     */
    _defaultDbVersion: '',

    /**
     * デフォルトで使用するDBの最大サイズ<br />
     * デフォルト
     *
     * @type Integer
     * @private
     */
    _defaultEstimatedSize: 1024 * 1024 * 512,
    
    /**
     * @type Hash
     * @private
     */
    _dbList: {},

    /**
     * データベースへの接続を行う
     * 
     * @param {String} dbName 対象データベース名
     * @param {String} [displayName] 表示データベース名
     * @return {Jeeel.Database.Connection} データベースとの接続インスタンス
     */
    connectDatabase: function (dbName, displayName) {

        if ( ! Jeeel.Type.isString(dbName) || dbName.length <= 0) {
            throw new Error('データベース名が不正です。');
        }

        if ( ! Jeeel.Type.isString(displayName) || displayName.length <= 0) {
            displayName = dbName;
        }

        if ( ! (dbName in this._dbList)) {
            this._dbList[dbName] = new this.Connection(
                                       dbName,
                                       this._defaultDbVersion,
                                       displayName,
                                       this._defaultEstimatedSize
                                   );
        }

        return this._dbList[dbName];
    },

    /**
     * SQLインジェクションを防ぐためのクォートを行う
     *
     * @param {Mixied} value クォートする値
     * @return {Mixied} クォート後の値
     */
    quote: function (value) {
        if (Jeeel.Type.isHash(value)) {
            var res = {};
            
            Jeeel.Hash.forEach(value,
                function (val, key) {
                    res[key] = this.quote(val);
                }, this
            );
              
            return res;
        }
        else if ( ! Jeeel.Type.isPrimitive(value)) {
            throw new Error('対応していない型');
        }

        if (Jeeel.Type.isEmpty(value)) {
            return 'NULL';
        }
        else if (Jeeel.Type.isNumber(value)) {
            return value;
        }
        else if (Jeeel.Type.isBoolean(value)) {
            return value.toString();
        }

        value = '' + value;

        return "'"
             + value.replace(/(\\|'|")/, "\\$1")
                    .replace(/\000/, "\\000")
                    .replace(/\n/, "\\n")
                    .replace(/\r/, "\\r")
                    .replace(/\032/, "\\032")
             + "'";
    }
};

Jeeel.file.Jeeel.Database = ['Connection', 'Transaction', 'Result', 'Table'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Database, Jeeel.file.Jeeel.Database);

/**
 * コンストラクタ
 * 
 * @class 1つのデータベースとの接続を管理するクラス
 */
Jeeel.Database.Connection = function (dbName, dbVersion, displayName, estimatedSize) {
    this._db = openDatabase(dbName, dbVersion, displayName, estimatedSize);
};

Jeeel.Database.Connection.prototype = {
    /**
     * 基となるデータベース
     * 
     * @type Database
     */
    _db: null,

    /**
     * 成功時のメソッド
     *
     * @type Function
     * @private
     */
    _successMethod: null,

    /**
     * エラー時のメソッド
     *
     * @type Function
     * @private
     */
    _errorMethod: null,

    /**
     * 成功時のメソッドの登録を行う
     *
     * @param {Function} callback 登録メソッド
     * @return {Jeeel.Database.Connection} 自インスタンス
     */
    setSuccessMethod: function (callback) {
        this._successMethod = callback;

        return this;
    },

    /**
     * 失敗時のメソッドの登録を行う
     *
     * @param {Function} callback 登録メソッド
     * @return {Jeeel.Database.Connection} 自インスタンス
     */
    setErrorMethod: function (callback) {
        this._errorMethod = callback;

        return this;
    },

    /**
     * トランザクション処理を行う
     *
     * @param {Function} execute 実行トランザクション
     * @return {Jeeel.Database.Connection} 自インスタンス
     */
    transaction: function (execute) {
        var self = this;

        this._db.transaction(
            function (tx) {
                execute.call(this, new Jeeel.Database.Transaction(tx));
            },

            function (error) {
                if (self._errorMethod) {
                    self._errorMethod.apply(this, arguments);
                } else {
                    Jeeel.errorDump('TransactionError ', error.message + '(' + error.code + ')');
                }
            },
            
            function () {
                if (self._successMethod) {
                    self._successMethod.apply(this, arguments);
                }
            }
        );

        return this;
    },
    
    /**
     * トランザクション処理を行う<br />
     * 但しこのトランザクション内部では参照しかできない
     *
     * @param {Function} execute 実行トランザクション
     * @return {Jeeel.Database.Connection} 自インスタンス
     */
    readTransaction: function (execute) {
        var self = this;

        this._db.readTransaction(
            function (tx) {
                execute.call(this, new Jeeel.Database.Transaction(tx));
            },

            function (error) {
                if (self._errorMethod) {
                    self._errorMethod.apply(this, arguments);
                } else {
                    Jeeel.errorDump('TransactionError ', error.message + '(' + error.code + ')');
                }
            },
            
            function () {
                if (self._successMethod) {
                    self._successMethod.apply(this, arguments);
                }
            }
        );

        return this;
    },

    /**
     * テーブルの作成を行う
     * 
     * @param {Jeeel.Database.Table} table 作成するテーブル情報をもったオブジェクト
     * @param {Boolean} [ignore] テーブルが存在した場合無視するかどうか
     * @return {Jeeel.Database.Connection} 自インスタンス
     */
    createTable: function (table, ignore) {
      
        return this.transaction(
            function (tx) {
                tx.query(table.toSql(ignore));
            }
        );
    },

    /**
     * テーブルの削除を行う
     * 
     * @param {String} table テーブル名
     * @param {Boolean} [ignore] テーブルが存在しなかった場合無視するかどうか
     * @return {Jeeel.Database.Connection} 自インスタンス
     */
    dropTable: function (table, ignore) {
        var sql = 'DROP TABLE ' + (ignore ? 'IF EXISTS ' : '') + '`' + table + '`;';

        return this.transaction(
            function (tx) {
                tx.query(sql);
            }
        );
    }
};
Jeeel.Database.Transaction = function (transaction) {
    this._transaction = transaction;
};

Jeeel.Database.Transaction.prototype = {
    /**
     * トランザクション
     * 
     * @type SQLTransaction
     * @private
     */
    _transaction: null,

    /**
     * 成功時のメソッド
     * 
     * @type Function
     * @private
     */
    _successMethod: null,

    /**
     * エラー時のメソッド
     *
     * @type Function
     * @private
     */
    _errorMethod: null,
    
    _errorInfo: null,

    setSuccessMethod: function (callback) {
        this._successMethod = callback;

        return this;
    },

    setErrorMethod: function (callback) {
        this._errorMethod = callback;

        return this;
    },

    query: function (sql, bind) {
      
        var trace = (Jeeel._debugMode ? Jeeel.Debug.Debugger.getTrace() : null);
      
        var self = this;

        this._transaction.executeSql(
            sql,
            bind || [],
            function (transaction, result) {
                if (self._successMethod) {
                    self._successMethod.call(this, self, new Jeeel.Database.Result(result));
                }
            },
            function (transaction, error) {
                if (trace) {
                    var message = 'Caller:\n' + trace[0].name + '\n\n'
                                + 'Sql:\n' + sql + '\n\n'
                                + 'Bind:\n[' + (bind || []).join(', ') + ']\n\n'
                                + 'BaseError:\n' + error.message;
                    
                    self._errorInfo = {
                        message: message,
                        caller: trace[0].func
                    };
                }
                
                if (self._errorMethod) {
                    self._errorMethod.call(this, self, error);
                } else {
                    throw error;
                }
            }
        );

        return this;
    },

    /**
     * レコードの挿入を行う
     * 
     * @param {String} table テーブル名
     * @param {Hash} bind 挿入するレコード内容のキーと値のペアリスト
     * @return {Jeeel.Database.Transaction} 自インスタンス
     */
    insertRecord: function (table, bind) {
        var sql = 'INSERT INTO `' + table + '` ';
        var cols = [];
        var vals = [];
        var len = 0;
        
        for (var key in bind) {
            cols[len] = key;
            vals[len] = bind[key];
            len++;
        }
        
        vals = this.quote(vals);
        
        sql += '(`' + cols.join('`, `') + '`)'
             + 'VALUES(' + vals.join(', ') + ');';
           
        return this.query(sql);
    },

    updateRecord: function (table, bind, where) {

    },

    deleteRecord: function (table, bind, where) {
        
    },

    /**
     * SQLインジェクションを防ぐためのクォートを行う
     *
     * @param {Mixied} value クォートする値
     * @return {Mixied} クォート後の値
     */
    quote: function (value) {
        return Jeeel.Database.quote(value);
    }
};

Jeeel.Database.Result = function (result) {
    this._result = result;
};

Jeeel.Database.Result.prototype = {

    /**
     * @type SQLResultSet
     */
    _result: null,

    getInsertId: function () {
        return this._result.insertId;
    },

    getLength: function () {
        return this._result.rows.length;
    },

    get: function (index) {
        return this._result.rows.item(index);
    },

    getAll: function () {
        var res = [];
        var len = this.getLength();

        for (var i = 0; i < len; i++) {
            res[i] = this.get(i);
        }

        return res;
    }
};
Jeeel.directory.Jeeel.Database.Table = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Database + 'Table/';
    }
};

/**
 * コンストラクタ
 *
 * @class テーブルを管理するクラス
 * @param {String} name テーブル名
 */
Jeeel.Database.Table = function (name) {
    this._name = name;
    this._columns = {};
    this._keys = [];
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name テーブル名
 * @return {Jeeel.Database.Table} 作成したインスタンス
 */
Jeeel.Database.Table.create = function (name) {
    return new this(name);
};

Jeeel.Database.Table.prototype = {

    /**
     * テーブル名
     *
     * @type String
     * @private
     */
    _name: '',

    /**
     * テーブルに定義されているカラムのHash
     *
     * @type Hash
     * @private
     */
    _columns: {},

    /**
     * 主キー
     *
     * @type Jeeel.Database.Table.Key
     * @private
     */
    _primary: null,

    /**
     * ユニークキー・インデックスキー
     *
     * @type Jeeel.Database.Table.Key[]
     * @private
     */
    _keys: [],

    /**
     * カラムを新規で作成する
     *
     * @param {String} name カラム名
     * @param {String} type カラムの型
     * @param {Boolean} [allowNull] NULL値を許可するかどうか
     * @param {String} [defaultValue] 初期値
     * @param {String} [extra] 追加情報(AUTO_INCREMENT等)
     * @param {String} [comment] カラムの説明
     * @return {Jeeel.Database.Table.Column} 追加したカラムインスタンス
     */
    createColumn: function (name, type, allowNull, defaultValue, extra, comment) {
        var column = new Jeeel.Database.Table.Column(name, type);

        if (Jeeel.Type.isBoolean(allowNull)) {
            column.setNull(allowNull);
        }

        if (defaultValue) {
            column.setDefault(defaultValue);
        }

        if (extra) {
            column.setExtra(extra);
        }

        if (comment) {
            column.setComment(comment);
        }

        this.addColumn(column);

        return column;
    },

    /**
     * カラムの追加を行う
     *
     * @param {Jeeel.Database.Table.Column} column カラムインスタンス
     * @return {Jeeel.Database.Table} 自インスタンス
     */
    addColumn: function (column) {
        this._columns[column.getName()] = column;

        return this;
    },

    /**
     * 主キーの設定を行う
     *
     * @param {String} var_args 主キーに使用するカラム名を複数引き渡す
     * @return {Jeeel.Database.Table} 自インスタンス
     */
    setPrimaryKey: function (var_args) {

        if (arguments.length == 0) {
            throw new Error('キーは少なくとも1つは指定してください。');
        }

        var primary = new Jeeel.Database.Table.Key(Jeeel.Database.Table.Key.Type.PRIMARY);

        primary.setName('primary_' + arguments[0]);

        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] in this._columns) {
                primary.addKey(arguments[i]);
            }
            else {
                throw new Error('存在しないカラムを指定しています。');
            }
        }

        this._primary = primary;

        return this;
    },

    /**
     * ユニークキーを追加する
     *
     * @param {String} var_args ユニークキーに使用するカラム名を複数引き渡す
     * @return {Jeeel.Database.Table} 自インスタンス
     */
    addUniqueKey: function (var_args) {
      
        if (arguments.length == 0) {
            throw new Error('キーは少なくとも1つは指定してください。');
        }
        
        var uniqueKey = new Jeeel.Database.Table.Key(Jeeel.Database.Table.Key.Type.UNIQUE);

        uniqueKey.setName('unique_' + arguments[0] + '_' + this._keys.length);

        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] in this._columns) {
                uniqueKey.addKey(arguments[i]);
            }
            else {
                throw new Error('存在しないカラムを指定しています。');
            }
        }

        this._keys[this._keys.length] = uniqueKey;

        return this;
    },

    /**
     * インデックスキーを追加する
     *
     * @param {String} var_args インデックスキーに使用するカラム名を複数引き渡す
     * @return {Jeeel.Database.Table} 自インスタンス
     */
    addIndexKey: function (var_args) {
        if (arguments.length == 0) {
            throw new Error('キーは少なくとも1つは指定してください。');
        }

        var indexKey = new Jeeel.Database.Table.Key(Jeeel.Database.Table.Key.Type.INDEX);

        indexKey.setName('index_' + arguments[0] + '_' + this._keys.length);

        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] in this._columns) {
                indexKey.addKey(arguments[i]);
            }
            else {
                throw new Error('存在しないカラムを指定しています。');
            }
        }

        this._keys[this._keys.length] = indexKey;

        return this;
    },

    /**
     * テーブルを作成する際のSQLに変換する
     * 
     * @param {Boolean} [ignore] テーブルが存在する際にSQL文を無視するかどうか
     * @return {String} SQL文字列
     */
    toSql: function (ignore) {
        return this.toString(ignore);
    },

    /**
     * このインスタンスを示すSQLを返す
     * 
     * @param {Boolean} [ignore] テーブルが存在する際にSQL文を無視するかどうか
     * @return {String} SQL文字列
     */
    toString: function (ignore) {
        var sql = 'CREATE TABLE ' + (ignore ? 'IF NOT EXISTS ' : '') + '`' + this._name + '` (';

        for (var columnName in this._columns) {
            sql += ',\n  ' + this._columns[columnName].toSql();
        }

        var keys = Jeeel.Method.clone(this._keys);

        if (this._primary) {
            keys.unshift(this._primary);
        }

        for (var j = 0; j < keys.length; j++) {
            sql += ',\n  ' + keys[j].toSql();
        }

        return sql + '\n);';
    }
};

Jeeel.file.Jeeel.Database.Table = ['Column', 'Key'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Database.Table, Jeeel.file.Jeeel.Database.Table);

/**
 * コンストラクタ
 * 
 * @class カラムを扱うクラス
 * @param {String} name カラム名
 * @param {String} type カラムの型
 */
Jeeel.Database.Table.Column = function (name, type) {
    this._name = name;
    this._type = type;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name カラム名
 * @param {String} type カラムの型
 * @return {Jeeel.Database.Table.Column} 作成したインスタンス
 */
Jeeel.Database.Table.Column.create = function (name, type) {
    return new this(name, type);
};

Jeeel.Database.Table.Column.prototype = {
    _name: '',
    _type: '',
    _null: true,
    _default: 'NULL',
    _extra: '',
    _comment: '',

    getName: function () {
        return this._name;
    },

    getType: function () {
        return this._type;
    },

    getNull: function () {
        return this._null;
    },

    setNull: function (allowNull) {
        this._null = !!allowNull;

        return this;
    },

    getDefault: function () {
        return this._default;
    },

    setDefault: function (defaultValue) {
        this._default = '' + defaultValue;

        return this;
    },

    getExtra: function () {
        return this._extra;
    },

    setExtra: function (extra) {
        this._extra = '' + extra;

        return this;
    },

    getComment: function () {
        return this._comment;
    },

    setComment: function (comment) {
        this._comment = '' + comment;

        return this;
    },

    /**
     * このカラムを示すSQL文字列に変換する
     *
     * @return {String} SQL文字列
     */
    toSql: function () {
        return this.toString();
    },

    /**
     * このカラムを示すSQL文字列に変換する
     *
     * @return {String} SQL文字列
     */
    toString: function () {
        var sql = '`' + this._name + '` ' + this._type
                + (this._null ? '' : ' NOT NULL')
                + (this._default == 'NULL' ? '' : ' DEFAULT ' + this._default)
                + (this._extra ? ' ' + this._extra : '')
                + (this._comment ? ' COMMENT ' + this._comment : '');

        return sql;
    }
};
Jeeel.directory.Jeeel.Database.Table.Key = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Database.Table + 'Key/';
    }
};

/**
 * コンストラクタ
 * 
 * @class キーを管理するクラス
 * @param {String} type キーの種類を示す文字列
 * @see Jeeel.Database.Table.Key.Type
 */
Jeeel.Database.Table.Key = function (type) {
    if ( ! Jeeel.Type.inArray(type, Jeeel.Database.Table.Key.Type, true)) {
        throw new Error('キーの種類が間違っています。');
    }

    this._type = type;
    this._keys = [];
};

Jeeel.Database.Table.Key.prototype = {

    /**
     * キーの名前
     *
     * @type String
     * @private
     */
    _name: '',

    /**
     * キーの種類
     *
     * @type String
     * @private
     */
    _type: '',

    /**
     * キーの対象のカラムリスト
     *
     * @type String[]
     * @private
     */
    _keys: [],

    /**
     * 名前を取得する
     *
     * @return {String} 名前
     */
    getName: function () {
        return this._name;
    },

    /**
     * 名前を設定する
     *
     * @param {String} name 名前
     * @return {Jeeel.Database.Table.Key} 自インスタンス
     */
    setName: function (name) {
        this._name = name;

        return this;
    },

    /**
     * キーの種類を取得する
     *
     * @return {String} キーの種類
     */
    getType: function () {
        return this._type;
    },

    /**
     * キーの種類を設定する
     *
     * @param {String} type キーの種類
     * @return {Jeeel.Database.Table.Key} 自インスタンス
     */
    setType: function (type) {
        if ( ! Jeeel.Type.inArray(type, Jeeel.Database.Table.Key.Type, true)) {
            throw new Error('キーの種類が間違っています。');
        }

        this._type = type;

        return this;
    },

    /**
     * 対象のカラムリストを取得する
     * 
     * @return {String[]} 対象のカラムリスト
     */
    getKeys: function () {
        return this._keys;
    },

    /**
     * 対象のカラムを追加する
     *
     * @param {String} key カラム名
     * @return {Jeeel.Database.Table.Key} 自インスタンス
     */
    addKey: function (key) {
        this._keys.push(key);

        return this;
    },

    /**
     * カラム名のリストを空にする
     * 
     * @return {Jeeel.Database.Table.Key} 自インスタンス
     */
    clearKeys: function () {
        this._keys = [];

        return this;
    },

    /**
     * このキーを示すSQL文字列に変換する
     *
     * @return {String} SQL文字列
     */
    toSql: function () {
        return this.toString();
    },

    /**
     * このキーを示すSQL文字列に変換する
     *
     * @return {String} SQL文字列
     */
    toString: function () {
      
        var sql = this._type
                + (this._type != Jeeel.Database.Table.Key.Type.PRIMARY && this._name ? ' `' + this._name + '`' : '') + ' (';

        for (var i = 0; i < this._keys.length; i++) {
            if (i > 0) {
                sql += ', ';
            }

            sql += '`' + this._keys[i] + '`';
        }

        sql += ')';

        return sql;
    }
};

Jeeel.file.Jeeel.Database.Table.Key = ['Type'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Database.Table.Key, Jeeel.file.Jeeel.Database.Table.Key);

/**
 * キーの種類についての列挙対
 */
Jeeel.Database.Table.Key.Type = {

    /**
     * 主キー
     *
     * @type String
     * @constant
     */
    PRIMARY: 'PRIMARY KEY',

    /**
     * ユニークキー
     *
     * @type String
     * @constant
     */
    UNIQUE: 'UNIQUE KEY',

    /**
     * インデックス
     *
     * @type String
     * @constant
     */
    INDEX: 'KEY'
};
Jeeel.directory.Jeeel.File = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'File/';
    }
};

/**
 * ファイルに関するネームスペース
 */
Jeeel.File = {
  
    /**
     * 取得したファイルの数だけデータの作成を行う
     * 
     * @param {Element|FormData} fileOwner ファイル選択をしたfileタイプのinputタグかファイルドロップをしたFormData
     * @return {Jeeel.File.Data[]} 取得したファイルの数だけのデータリスト
     */
    createData: function (fileOwner) {
        if ( ! fileOwner.files) {
            throw new Error('fileOwnerがファイルを保持していません。');
        }
        
        var files = fileOwner.files;
        var res = [];
        
        for (var i = 0, l = files.length; i < l; i++) {
            res[i] = new this.Data(files[i]);
        }
        
        return res;
    }
};

Jeeel.file.Jeeel.File = ['Reader', 'Data'];

Jeeel._autoImports(Jeeel.directory.Jeeel.File, Jeeel.file.Jeeel.File);
/**
 * コンストラクタ
 * 
 * @class ファイルデータの読み込み操作を提供するクラス
 * @param {Jeeel.File.Data} file ファイルデータ
 */
Jeeel.File.Reader = function (file) {
    this._file = file;
    this._reader = new FileReader();
    this._setEvents();
};

Jeeel.File.Reader.prototype = {
  
    /**
     * 読み込み元
     * 
     * @type Jeeel.File.Data
     * @private
     */
    _file: null,
    
    /**
     * 読み込みインスタンス
     * 
     * @type FileReader
     * @private
     */
    _reader: null,
    
    /**
     * 読み込み開始コールバック
     * 
     * @type Hash
     * @private
     */
    _loadStartMethod: null,
    
    /**
     * 読み込み処理完了コールバック
     * 
     * @type Hash
     * @private
     */
    _loadEndMethod: null,
    
    /**
     * 正常読み込み完了コールバック
     * 
     * @type Hash
     * @private
     */
    _loadMethod: null,

    /**
     * 読み込み作業中コールバック
     * 
     * @type Hash
     * @private
     */
    _progressMethod: null,
    
    /**
     * 読み込み中断コールバック
     * 
     * @type Hash
     * @private
     */
    _abortMethod: null,
    
    /**
     * エラーコールバック
     * 
     * @type Hash
     * @private
     */
    _errorMethod: null,
    
    /**
     * 読み込み開始メソッドの登録
     *
     * @param {Function} callBack 読み込み開始メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setLoadStartMethod: function (callBack, thisArg) {
        this._loadStartMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 読み込み処理完了メソッドの登録
     *
     * @param {Function} callBack 読み込み処理完了メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setLoadEndMethod: function (callBack, thisArg) {
        this._loadEndMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 正常読み込み完了メソッドの登録
     *
     * @param {Function} callBack 正常読み込み完了メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setLoadMethod: function (callBack, thisArg) {
        this._loadMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 読み込み作業中メソッドの登録
     *
     * @param {Function} callBack 読み込み作業中メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setProgressMethod: function (callBack, thisArg) {
        this._progressMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 読み込み中断メソッドの登録
     *
     * @param {Function} callBack 読み込み中断メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setAbortMethod: function (callBack, thisArg) {
        this._abortMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * エラーメソッドの登録
     *
     * @param {Function} callBack エラーメソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setErrorMethod: function (callBack, thisArg) {
        this._errorMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 読み込み結果を取得する
     * 
     * @return {ArrayBuffer|String} 読み込み結果
     */
    getResult: function () {
        return this._reader.result;
    },
    
    /**
     * 読み込みが完了しているかどうかを取得する
     * 
     * @return {Boolean} 読み込みが完了しているかどうか
     */
    isLoaded: function () {
        return this._reader.readyState === FileReader.DONE;
    },
    
    /**
     * 読み込中かどうかを取得する
     * 
     * @return {Boolean} 読み込中かどうか
     */
    isLoading: function () {
        return this._reader.readyState === FileReader.LOADING;
    },
    
    /**
     * ArrayBufferとして読み込みを行う
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    readArrayBuffer: function () {
        this._errorConfirm();
        
        this._reader.readAsArrayBuffer(this._file.getFileData());
        
        return this;
    },
    
    /**
     * バイナリ文字列として読み込みを行う
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    readBinaryString: function () {
        this._errorConfirm();
        
        this._reader.readAsBinaryString(this._file.getFileData());
        
        return this;
    },
    
    /**
     * テキストとして読み込みを行う
     * 
     * @param {String} [charCode] 明示的にキャラクターコードを設定する場合に指定(Jeeel.Code.CharEncoding参照)
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    readText: function (charCode) {
        this._errorConfirm();
        
        this._reader.readAsText(this._file.getFileData(), charCode);
        
        return this;
    },
    
    /**
     * データのURLの読み込みを行う
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    readDataUrl: function () {
        this._errorConfirm();
      
        this._reader.readAsDataURL(this._file.getFileData());
        
        return this;
    },
    
    /**
     * 読み込みを途中で中断する
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     */
    abort: function () {
        this._reader.abort();
      
        return this;
    },
    
    /**
     * 読み込み込んだ結果を全て破棄する
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中の場合に発生
     */
    reset: function () {
        if (this.isLoading()) {
            throw new Error('読み込み中にこのメソッドは呼び出せません。');
        }
        
        this._reader = new FileReader();
        this._setEvents();
        
        return this;
    },

    /**
     * 読み込みを始める前に呼び出しエラーを確認する
     * 
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    _errorConfirm: function () {
        if (this._reader.readyState !== FileReader.EMPTY) {
            throw new Error('読み込み中もしくは読み込み完了後にこのメソッドは呼び出せません。');
        }
    },
    
    /**
     * 初期イベントの設定を行う
     * 
     * @private
     */
    _setEvents: function () {
        var self = this;
        
        this._reader.onloadstart = function () {
            if (self._loadStartMethod) {
                self._loadStartMethod.func.apply(self._loadStartMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onloadend = function () {
            if (self._loadEndMethod) {
                self._loadEndMethod.func.apply(self._loadEndMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onload = function () {
            if (self._loadMethod) {
                self._loadMethod.func.apply(self._loadMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onprogress = function () {
            if (self._progressMethod) {
                self._progressMethod.func.apply(self._progressMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onabort = function () {
            if (self._abortMethod) {
                self._abortMethod.func.apply(self._abortMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onerror = function () {
            if (self._errorMethod) {
                self._errorMethod.func.apply(self._errorMethod.thisArg || self, arguments);
            }
        };
    }
};

/**
 * コンストラクタ
 * 
 * @class ファイルデータを管理するクラス
 * @param {File} fileData 読み込み元のファイルデータ
 */
Jeeel.File.Data = function (fileData) {
    this._file = fileData;
};

Jeeel.File.Data.prototype = {
  
    /**
     * 読み込み元のファイルデータ
     * 
     * @type File
     * @private
     */
    _file: null,
    
    /**
     * 読み込み元のファイルデータを取得する
     * 
     * @return {File} 読み込み元のファイルデータ
     */
    getFileData: function () {
        return this._file;
    },

    /**
     * ファイルの名前を取得する
     * 
     * @return {String} ファイル名
     */
    getFileName: function () {
        return this._file.fileName;
    },
    
    /**
     * ファイルのサイズを取得する
     * 
     * @return {Integer} ファイルサイズ
     */
    getFileSize: function () {
        return this._file.fileSize;
    },
    
    /**
     * ファイルの種類を取得する
     * 
     * @return {String} ファイル種類
     */
    getFileType: function () {
        return this._file.type;
    },
    
    /**
     * ファイルの最終更新時間を取得する
     * 
     * @return {Jeeel.Object.Date} 最終更新時間
     */
    getLastModifiedDate: function () {
        return Jeeel.Object.Date.create(this._file.lastModifiedDate);
    },
    
    /**
     * 現在のインスタンスを読み込むためのインスタンスを取得する
     * 
     * @return {Jeeel.File.Reader} 読み込みインスタンス
     */
    getReader: function () {
        return new Jeeel.File.Reader(this);
    }
};

Jeeel.directory.Jeeel.Media = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Media/';
    }
};

/**
 * メディア関連のネームスペース
 */
Jeeel.Media = {

};

Jeeel.file.Jeeel.Media = ['Abstract', 'Audio', 'Video'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Media, Jeeel.file.Jeeel.Media);

/**
 * コンストラクタ
 * 
 * @abstractClass メディア系の抽象クラス
 * @param {HTMLMediaElement} media 基となるメディア要素
 */
Jeeel.Media.Abstract = function (media) {
    if (media) {
        this._media = media;
    }
};

Jeeel.Media.Abstract.prototype = {
  
    /**
     * 基となるメディア要素
     * 
     * @type HTMLMediaElement
     * @private
     */
    _media: null,
    
    /**
     * 内部メディアを取得する
     * 
     * @return {HTMLMediaElement} メディア
     */
    getMedia: function () {
        return this._media;
    },
    
    /**
     * メディアを再生する
     * 
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    play: function () {
        this._media.play();
        
        return this;
    },
    
    /**
     * メディアを停止する
     * 
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    pause: function () {
        this._media.pause();
        
        return this;
    },
    
    /**
     * メディアの再生位置を変更する
     * 
     * @param {Number} time 再生位置(秒)
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    seek: function (time) {
        if (isNaN(this._media.duration)) {
            throw new Error('メディアが読み込まれていません。');
        }
        
        time = +time;
        
        if (time > this._media.duration) {
            time = this._media.duration;
        }
        
        this._media.currentTime = time;
        
        return this;
    },
    
    /**
     * 連続再生の設定を行う
     * 
     * @param {Boolean} enable 連続再生を有効にするかどうか
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    enableLoop: function (enable) {
        this._media.loop = !!enable;
        
        return this;
    },
    
    /**
     * シークの設定を行う
     * 
     * @param {Boolean} enable ユーザーがシークを行えるかどうか
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    enableSeek: function (enable) {
        this._media.seekable = !!enable;
        
        return this;
    },
    
    /**
     * メディアコントロールのUIの設定を行う
     * 
     * @param {Boolean} enable UIを表示するかどうか
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    enableControl: function (enable) {
        this._media.controls = !!enable;
        
        return this;
    },
    
    /**
     * ミュートの設定を行う
     * 
     * @param {Boolean} enable ミュートにするかどうか
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    enableMute: function (enable) {
        this._media.muted = !!enable;
        
        return this;
    },
    
    /**
     * ボリュームを取得する
     * 
     * @return {Number} ボリューム(0.0～1.0)
     */
    getVolume: function () {
        return this._media.volume;
    },
    
    /**
     * ボリュームを設定する
     * 
     * @param {Number} volume ボリューム(0.0～1.0)
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    setVolume: function (volume) {
        this._media.volume = volume;
        
        return this;
    },
    
    /**
     * 現在ユーザーがシーク動作を行っているかどうかを返す
     * 
     * @return {Boolean} シークを行っているかどうか
     */
    seeking: function () {
        return this._media.seeking;
    },
    
    /**
     * 指定したメディアソースのタイプが再生可能かどうかを返す
     * 
     * @param {String} type メディアソースタイプ
     * @return {Boolean} 再生可能かどうか
     */
    canPlayType: function (type) {
        return "" != this._media.canPlayType(type);
    },
    
    /**
     * メディアの読み込みを行う
     * 
     * @param {String} mediaUrl メディアのURL
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    load: function (mediaUrl) {
        this._media.load(mediaUrl);
        
        return this;
    },
    
    /**
     * メディアの再読み込みを行う<br />
     * 読み込みを行うのは元々のメディアである
     * 
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    reload: function () {
        return this.load(this._media.src);
    }
};

/**
 * コンストラクタ
 * 
 * @class オーディオを扱うクラス
 * @augments Jeeel.Media.Abstract
 * @param {Audio} audio 基となるオーディオ要素
 */
Jeeel.Media.Audio = function (audio) {
    Jeeel.Media.Abstract.call(this, audio);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Audio} audio 基となるオーディオ要素
 * @return {Jeeel.Media.Audio} 作成したインスタンス
 */
Jeeel.Media.Audio.create = function (audio) {
    return new this(audio);
};

Jeeel.Media.Audio.prototype = new Jeeel.Media.Abstract();

/**
 * コンストラクタ
 * 
 * @class ビデオを扱うクラス
 * @augments Jeeel.Media.Abstract
 * @param {Video} video 基となるビデオ要素
 */
Jeeel.Media.Video = function (video) {
    Jeeel.Media.Abstract.call(this, video);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Video} video 基となるビデオ要素
 * @return {Jeeel.Media.Video} 作成したインスタンス
 */
Jeeel.Media.Video.create = function (video) {
    return new this(video);
};

Jeeel.Media.Video.prototype = {
  
    /**
     * 動画の幅を取得する
     * 
     * @return {Number} 幅(初期値は0)
     */
    getWidth: function () {
        return this._media.width;
    },
    
    /**
     * 動画の幅を設定する
     * 
     * @param {Number} width 幅
     * @return {Jeeel.Media.Video} 自インスタンス
     */
    setWidth: function (width) {
        this._media.width = width;
        
        return this;
    },
    
    /**
     * 動画の高さを取得する
     * 
     * @return {Number} 高さ(初期値は0)
     */
    getHeight: function () {
        return this._media.height;
    },
    
    /**
     * 動画の高さを設定する
     * 
     * @param {Number} height 高さ
     * @return {Jeeel.Media.Video} 自インスタンス
     */
    setHeight: function (height) {
        this._media.height = height;
        
        return this;
    },
    
    /**
     * 動画のサイズを取得する
     * 
     * @return {Jeeel.Object.Size} サイズ
     */
    getSize: function () {
        return new Jeeel.Object.Size(this._media.width, this._media.height);
    },
    
    /**
     * 動画の元の幅を取得する
     * 
     * @return {Number} 幅
     */
    getVideoWidth: function () {
        return this._media.videoWidth;
    },
    
    /**
     * 動画の元の高さを取得する
     * 
     * @return {Number} 高さ
     */
    getVideoHeight: function () {
        return this._media.videoHeight;
    },
    
    /**
     * 動画の元のサイズを取得する
     * 
     * @return {Jeeel.Object.Size} サイズ
     */
    getVideoSize: function () {
        return new Jeeel.Object.Size(this._media.videoWidth, this._media.videoHeight);
    },
    
    /**
     * 再生可能な動画がなかった場合の静止画のURLを取得する
     * 
     * @return {String} 静止画URL
     */
    getPoster: function () {
        return this._media.poster;
    },
    
    /**
     * 再生可能な動画がなかった場合の静止画のURLを設定する
     * 
     * @param {String} url 静止画URL
     * @return {Jeeel.Media.Video} 自インスタンス
     */
    setPoster: function (url) {
        this._media.poster = url;
        
        return this;
    }
};

Jeeel.Class.extend(Jeeel.Media.Video, Jeeel.Media.Abstract);

Jeeel.directory.Jeeel.Graphics = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Graphics/';
    }
};

/**
 * グラフィックス関連のネームスペース
 */
Jeeel.Graphics = {

};

Jeeel.file.Jeeel.Graphics = ['Abstract', 'Pen', 'Brush', 'Raster', 'Vector'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics, Jeeel.file.Jeeel.Graphics);

/**
 * コンストラクタ
 * 
 * @abstractClass グラフィックス関連に抽象クラス
 */
Jeeel.Graphics.Abstract = function () {
    
};

Jeeel.Graphics.Abstract.prototype = {
  
    /**
     * 実際の操作を保持するインスタンス
     * 
     * @type Object
     * @private
     */
    _adapter: null,
    
    /**
     * 線を描画する際のペンを取得する
     * 
     * @return {Jeeel.Graphics.Pen} Penオブジェクト
     */
    getPen: function () {
        return this._adapter.getPen();
    },
    
    /**
     * 線を描画する際のペンを設定する<br />
     * getで取得したPenを変更した時はsetしないと反映されない
     * 
     * @param {Jeeel.Graphics.Pen} pen Penオブジェクト
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    setPen: function (pen) {
        this._adapter.setPen(pen);
        
        return this;
    },
    
    /**
     * 面を塗りつぶすためのブラシを取得する<br />
     * getで取得したBrushを変更した時はsetしないと反映されない
     * 
     * @return {Jeeel.Graphics.Brush} Brushオブジェクト
     */
    getBrush: function () {
        return this._adapter.getBrush();
    },
    
    /**
     * 面を塗りつぶすためのブラシを設定する
     * 
     * @param {Jeeel.Graphics.Brush} brush Brushオブジェクト
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    setBrush: function (brush) {
        this._adapter.setBrush(brush);
        
        return this;
    },
    
    /**
     * 文字を描くためのフォントを取得する
     * 
     * @return {Jeeel.Object.Font} フォント
     */
    getFont: function () {
        return this._adapter.getFont();
    },
    
    /**
     * 文字を描くためのフォントを設定する
     * 
     * @param {Jeeel.Object.Font} font フォント
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    setFont: function (font) {
        this._adapter.setFont(font);
        
        return this;
    },
    
    /**
     * 線を描画する
     * 
     * @param {Number} x1 一つ目の座標X
     * @param {Number} y1 一つ目の座標Y
     * @param {Number} x2 二つ目の座標X
     * @param {Number} y2 二つ目の座標Y
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    drawLine: function (x1, y1, x2, y2) {
        this._adapter.drawLine(x1, y1, x2, y2);
        
        return this;
    },
    
    /**
     * 長方形を描画する
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokeRect: function (x, y, width, height) {
        this._adapter.strokeRect(x, y, width, height);
        
        return this;
    },
    
    /**
     * 長方形を描画し塗りつぶす
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillRect: function (x, y, width, height) {
        this._adapter.fillRect(x, y, width, height);
        
        return this;
    },
    
    /**
     * 長方形のパス内をクリッピング対象にする
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipRect: function (x, y, width, height) {
        this._adapter.clipRect(x, y, width, height);
        
        return this;
    },
    
    /**
     * 指定した頂点リストから多角形を描画する
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokePolygon: function (vertexes) {
        if ( ! Jeeel.Type.isArray(vertexes)) {
            throw new Error('vertexesが配列ではありません。');
        } else if (vertexes.length < 3) {
            throw new Error('vertexesが必要数に達していません。');
        }
        
        this._adapter.strokePolygon(vertexes);
        
        return this;
    },
    
    /**
     * 指定した頂点リストから多角形を描画し塗りつぶす
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillPolygon: function (vertexes) {
        if ( ! Jeeel.Type.isArray(vertexes)) {
            throw new Error('vertexesが配列ではありません。');
        } else if (vertexes.length < 3) {
            throw new Error('vertexesが必要数に達していません。');
        }
        
        this._adapter.fillPolygon(vertexes);
        
        return this;
    },
    
    /**
     * 指定した頂点リストから多角形のパスを作り、その範囲をクリッピング対象にする
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipPolygon: function (vertexes) {
        if ( ! Jeeel.Type.isArray(vertexes)) {
            throw new Error('vertexesが配列ではありません。');
        } else if (vertexes.length < 3) {
            throw new Error('vertexesが必要数に達していません。');
        }
        
        this._adapter.clipPolygon(vertexes);
        
        return this;
    },
    
    /**
     * 楕円を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokeEllipse: function (x, y, radiusX, radiusY) {
        this._adapter.strokeEllipse(x, y, radiusX, radiusY);
        
        return this;
    },
    
    /**
     * 楕円を描画し塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillEllipse: function (x, y, radiusX, radiusY) {
        this._adapter.fillEllipse(x, y, radiusX, radiusY);
        
        return this;
    },
    
    /**
     * 楕円のパスを作り、その内部をクリッピング対象にする
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipEllipse: function (x, y, radiusX, radiusY) {
        this._adapter.clipEllipse(x, y, radiusX, radiusY);
        
        return this;
    },
    
    /**
     * 文字列を描画する
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokeText: function (text, x, y) {
        this._adapter.strokeText(text, x, y);
        
        return this;
    },
    
    /**
     * 文字列を描画して塗りつぶす
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillText: function (text, x, y) {
        this._adapter.fillText(text, x, y);
        
        return this;
    },
    
    /**
     * 扇形を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokePie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._adapter.strokePie(x, y, radiusX, radiusY, startAngle, endAngle);
        
        return this;
    },
    
    /**
     * 扇形を描画して塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillPie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._adapter.fillPie(x, y, radiusX, radiusY, startAngle, endAngle);
        
        return this;
    },
    
    /**
     * 楕円弧を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    drawArc: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._adapter.drawArc(x, y, radiusX, radiusY, startAngle, endAngle);
        
        return this;
    },
    
    /**
     * イメージを描画する
     * 
     * @param {Image} image 描画イメージ
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    drawImage: function (image, x, y) {},
    
    /**
     * 描画されている全ての図形を消去する
     * 
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clear: function () {
        this._adapter.clear();
        
        return this;
    }
};

/**
 * イメージを描画する
 * 
 * @param {Image} image 描画イメージ
 * @param {Jeeel.Object.Point} point 描画先座標
 * @return {Jeeel.Graphics.Abstract} 自インスタンス
 */
Jeeel.Graphics.Abstract.prototype.drawImage = function (image, point) {};

/**
 * イメージを描画する
 * 
 * @param {Image} image 描画イメージ
 * @param {Jeeel.Object.Rect} rect 描画先矩形
 * @return {Jeeel.Graphics.Abstract} 自インスタンス
 */
Jeeel.Graphics.Abstract.prototype.drawImage = function (image, rect) {};

/**
 * イメージを描画する
 * 
 * @param {Image} image 描画イメージ
 * @param {Number} x 描画座標X
 * @param {Number} y 描画座標Y
 * @param {Number} width 描画する幅
 * @param {Number} height 描画する高さ
 * @return {Jeeel.Graphics.Abstract} 自インスタンス
 */
Jeeel.Graphics.Abstract.prototype.drawImage = function (image, x, y, width, height) {
    
    switch (arguments.length) {
        case 2:
            if (x instanceof Jeeel.Object.Point) {
                this._adapter.drawImage(image, x.x, x.y);
            } else {
                this._adapter.drawImage(image, x.x, x.y, x.width, x.height);
            }
            break;
            
        case 3:
            this._adapter.drawImage(image, x, y);
            break;
            
        case 5:
            this._adapter.drawImage(image, x, y, width, height);
            break;
    }
    
    return this;
};

/**
 * コンストラクタ
 * 
 * @class 線を描画する際の情報を管理するクラス
 */
Jeeel.Graphics.Pen = function () {
    this._color = Jeeel.Object.Color.createRgb(0, 0, 0);
};

Jeeel.Graphics.Pen.prototype = {
    
    /**
     * 線の幅
     * 
     * @type Number
     * @private
     */
    _width: 1,
    
    /**
     * 線の色
     * 
     * @type Jeeel.Object.Color
     * @private
     */
    _color: null,
    
    /**
     * キャップのスタイル
     * 
     * @type String
     * @private
     */
    _cap: 'butt',
    
    /**
     * 接続スタイル
     * 
     * @type String
     * @private
     */
    _join: 'miter',
    
    /**
     * マイター限界比率
     * 
     * @type Number
     * @private
     */
    _miterLimit: 10,
    
    /**
     * 更新時自動コールバック
     * 
     * @type Function
     * @private
     */
    _callback: null,
    
    /**
     * ペン幅を取得する
     * 
     * @return {Number} ペン幅
     */
    getWidth: function () {
        return this._width;
    },
    
    /**
     * ペン幅を設定する
     * 
     * @param {Number} width ペン幅
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setWidth: function (width) {
        this._width = +width;
        
        return this.refresh(1);
    },
    
    /**
     * ペンの色を取得する
     * 
     * @return {Jeeel.Object.Color} ペンの色
     */
    getColor: function () {
        return this._color;
    },
    
    /**
     * ペンの色を設定する
     * 
     * @param {Jeeel.Object.Color} color ペンの色
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setColor: function (color) {
        this._color = color;
        
        return this.refresh(2);
    },
    
    /**
     * ペンのキャップスタイルを取得する
     * 
     * @return {String} キャップスタイル
     */
    getCapStyle: function () {
        return this._cap;
    },
    
    /**
     * ペンのキャップスタイルを設定する
     * 
     * @param {String} capStyle キャップスタイル
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setCapStyle: function (capStyle) {
        this._cap = capStyle;
        
        return this.refresh(3);
    },
    
    /**
     * ペンの線接続スタイルを取得する
     * 
     * @return {String} 接続スタイル
     */
    getJoinStyle: function () {
        return this._join;
    },
    
    /**
     * ペンの線接続スタイルを設定する
     * 
     * @param {String} join 接続スタイル
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setJoinStyle: function (join) {
        this._join = join;
        
        return this.refresh(4);
    },
    
    /**
     * ペンのマイター限界比率を取得する
     * 
     * @return {Number} マイター限界比率
     */
    getMiterLimit: function () {
        return this._miterLimit;
    },
    
    /**
     * ペンのマイター限界比率を設定する
     * 
     * @param {Number} miterLimit マイター限界比率
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setMiterLimit: function (miterLimit) {
        this._miterLimit = +miterLimit;
        
        return this.refresh(5);
    },
    
    /**
     * 更新を行った際に呼び出すコールバックを設定する
     * 
     * @param {Function} callback コールバック
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setRefreshCallback: function (callback) {
        this._callback = callback;
        
        return this;
    },
    
    /**
     * 更新を行いコールバックを呼び出す
     * 
     * @param {Integer} [type] 更新タイプ
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    refresh: function (type) {
        if (this._callback) {
            this._callback(this, type || 0);
        }
        
        return this;
    }
};
/**
 * コンストラクタ
 * 
 * @class 面を塗りつぶす際の情報を管理するクラス
 */
Jeeel.Graphics.Brush = function () {
    this._color = Jeeel.Object.Color.createRgb(0, 0, 0);
};

Jeeel.Graphics.Brush.prototype = {
    
    /**
     * 塗りつぶしの色
     * 
     * @type Jeeel.Object.Color
     * @private
     */
    _color: null,
    
    /**
     * 更新時自動コールバック
     * 
     * @type Function
     * @private
     */
    _callback: null,
    
    /**
     * ブラシの色を取得する
     * 
     * @return {Jeeel.Object.Color} ブラシの色
     */
    getColor: function () {
        return this._color;
    },
    
    /**
     * ブラシの色を設定する
     * 
     * @param {Jeeel.Object.Color} color ブラシの色
     * @return {Jeeel.Graphics.Brush} 自インスタンス
     */
    setColor: function (color) {
        this._color = color;
        
        return this.refresh(1);
    },
    
    /**
     * 更新を行った際に呼び出すコールバックを設定する
     * 
     * @param {Function} callback コールバック
     * @return {Jeeel.Graphics.Brush} 自インスタンス
     */
    setRefreshCallback: function (callback) {
        this._callback = callback;
        
        return this;
    },
    
    /**
     * 更新を行いコールバックを呼び出す
     * 
     * @param {Integer} [type] 更新タイプ
     * @return {Jeeel.Graphics.Brush} 自インスタンス
     */
    refresh: function (type) {
        if (this._callback) {
            this._callback(this, type || 0);
        }
        
        return this;
    }
};Jeeel.directory.Jeeel.Graphics.Raster = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Graphics + 'Raster/';
    }
};

/**
 * コンストラクタ
 * 
 * @class ラスター系のグラフィックス処理機能を提供するクラス
 * @augments Jeeel.Graphics.Abstract
 * @param {Jeeel.Graphics.Raster.*} adapter 内部アダプター
 * @ignore 未完
 */
Jeeel.Graphics.Raster = function (adapter) {
    Jeeel.Graphics.Abstract.call(this);
    
    this._adapter = adapter;
};

/**
 * Canvasタイプのインスタンスを作成する
 * 
 * @param {Canvas} canvas キャンバスElement
 * @param {String} [contextId] コンテキストID
 * @return {Jeeel.Graphics.Raster} 作成したインスタンス
 */
Jeeel.Graphics.Raster.factoryCanvas = function (canvas, contextId) {
    return new this(this.Canvas.factory(canvas, contextId));
};

Jeeel.Graphics.Raster.prototype = {
  
    /**
     * 未実装
     */
    strokePie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        throw new Error('未実装');
    },
    
    /**
     * 未実装
     */
    fillPie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        throw new Error('未実装');
    },
    
    /**
     * 未実装
     */
    drawArc: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        throw new Error('未実装');
    }
};

Jeeel.Class.extend(Jeeel.Graphics.Raster, Jeeel.Graphics.Abstract);

Jeeel.file.Jeeel.Graphics.Raster = ['Canvas'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics.Raster, Jeeel.file.Jeeel.Graphics.Raster);Jeeel.directory.Jeeel.Graphics.Raster.Canvas = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Graphics.Raster + 'Canvas/';
    }
};

/**
 * Canvasに関してのネームスペース
 */
Jeeel.Graphics.Raster.Canvas = {
  
    /**
     * キャンバスの操作インスタンスの作成を行う
     * 
     * @param {Canvas} canvas キャンバス
     * @param {String} [contextId] コンテキストID
     * @return {Jeeel.Graphics.Raster.Canvas.Context.*} 作成したインスタンス
     */
    factory: function (canvas, contextId) {
        return this.Context.getContext(canvas, contextId || this.Context.Type.TWO_DIMENSION);
    }
};

Jeeel.file.Jeeel.Graphics.Raster.Canvas = ['Context'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics.Raster.Canvas, Jeeel.file.Jeeel.Graphics.Raster.Canvas);Jeeel.directory.Jeeel.Graphics.Raster.Canvas.Context = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Graphics.Raster.Canvas + 'Context/';
    }
};

/**
 * Canvasのコンテキストに関するネームスペース
 */
Jeeel.Graphics.Raster.Canvas.Context = {
    
    /**
     * canvasのコンテキストを取得する
     * 
     * @param {Canvas} canvas キャンバスElement
     * @param {String} contextId コンテキストの種類を示す定数文字列
     * @return {Jeeel.Graphics.Raster.Canvas.Context.2d} コンテキスト
     */
    getContext: function (canvas, contextId) {
        return new this[contextId](canvas);
    },
    
    /**
     * コンストラクタ
     * 
     * @class 2次元のグラフィックスを扱うクラス
     * @param {Canvas} canvas キャンバスElement
     * @constructor
     */
    '2d': function (canvas) {
        this._canvas = canvas;
        this._context = canvas.getContext('2d');
        this._pen = new Jeeel.Graphics.Pen();
        this._brush = new Jeeel.Graphics.Brush();
        this._font = new Jeeel.Object.Font('sans-serif', '10px');
        
        var self = this, rp = this._refreshPen, rb = this._refreshBrush;
        
        this._refreshPen = function () {
            rp.apply(self, arguments);
        };
        
        this._refreshBrush = function () {
            rb.apply(self, arguments);
        };
        
        this._pen.setRefreshCallback(this._refreshPen);
        this._brush.setRefreshCallback(this._refreshBrush);
        
        this._context.textAlign = 'left';
        this._context.textBaseline = 'top';
    }
};

Jeeel.Graphics.Raster.Canvas.Context['2d'].prototype = {
  
    /**
     * キャンバス
     * 
     * @type Canvas
     * @private
     */
    _canvas: null,
  
    /**
     * キャンバスコンテキスト
     * 
     * @type CanvasRenderingContext2D
     * @private
     */
    _context: null,
    
    /**
     * Penオブジェクト
     * 
     * @type Jeeel.Graphics.Pen
     * @private
     */
    _pen: null,
    
    /**
     * Brushオブジェクト
     * 
     * @type Jeeel.Graphics.Brush
     * @private
     */
    _brush: null,
    
    /**
     * Fontオブジェクト
     * 
     * @type Jeeel.Object.Font
     * @private
     */
    _font: null,
    
    /**
     * 線を描画する際のペンを取得する
     * 
     * @return {Jeeel.Graphics.Pen} Penオブジェクト
     */
    getPen: function () {
        return this._pen;
    },
    
    /**
     * 線を描画する際のペンを設定する
     * 
     * @param {Jeeel.Graphics.Pen} pen Penオブジェクト
     */
    setPen: function (pen) {
        this._pen.setRefreshCallback(null);
        this._pen = pen.setRefreshCallback(this._refreshPen).refresh();
    },
    
    /**
     * 面を塗りつぶすためのブラシを取得する
     * 
     * @return {Jeeel.Graphics.Brush} Brushオブジェクト
     */
    getBrush: function () {
        return this._brush;
    },
    
    /**
     * 面を塗りつぶすためのブラシを設定する
     * 
     * @param {Jeeel.Graphics.Brush} brush Brushオブジェクト
     */
    setBrush: function (brush) {
        this._brush.setRefreshCallback(null);
        this._brush = brush.setRefreshCallback(this._refreshPen).refresh();
    },
    
    /**
     * 文字を描くためのフォントを取得する
     * 
     * @return {Jeeel.Object.Font} フォント
     */
    getFont: function () {
        return this._font;
    },
    
    /**
     * 文字を描くためのフォントを設定する
     * 
     * @param {Jeeel.Object.Font} font フォント
     */
    setFont: function (font) {
        this._font = font;
    },
    
    /**
     * 線を描画する
     * 
     * @param {Number} x1 一つ目の座標X
     * @param {Number} y1 一つ目の座標Y
     * @param {Number} x2 二つ目の座標X
     * @param {Number} y2 二つ目の座標Y
     */
    drawLine: function (x1, y1, x2, y2) {
        this._context.beginPath();
        this._context.moveTo(x1, y1);
        this._context.lineTo(x2, y2);
        this._context.stroke();
    },
    
    /**
     * 長方形を描画する
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     */
    strokeRect: function (x, y, width, height) {
        this._context.strokeRect(x, y, width, height);
    },
    
    /**
     * 長方形を描画し塗りつぶす
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     */
    fillRect: function (x, y, width, height) {
        this._context.fillRect(x, y, width, height);
    },
    
    /**
     * 長方形のパス内をクリッピング対象にする
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipRect: function (x, y, width, height) {
        this._context.beginPath();
        this._context.rect(x, y, width, height);
        this._context.clip();
    },
    
    /**
     * 指定した頂点リストから多角形を描画する
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     */
    strokePolygon: function (vertexes) {
        this._drawPolygonPath(vertexes);
        this._context.stroke();
    },
    
    /**
     * 指定した頂点リストから多角形を描画し塗りつぶす
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     */
    fillPolygon: function (vertexes) {
        this._drawPolygonPath(vertexes);
        this._context.fill();
    },
    
    /**
     * 指定した頂点リストから多角形のパスを作り、その範囲をクリッピング対象にする
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipPolygon: function (vertexes) {
        this._drawPolygonPath(vertexes);
        this._context.clip();
    },
    
    /**
     * 楕円を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    strokeEllipse: function (x, y, radiusX, radiusY) {
        this._drawEllipsePath(x, y, radiusX, radiusY);
        this._context.stroke();
    },
    
    /**
     * 楕円を描画し塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    fillEllipse: function (x, y, radiusX, radiusY) {
        this._drawEllipsePath(x, y, radiusX, radiusY);
        this._context.fill();
    },
    
    /**
     * 楕円のパスを作り、その内部をクリッピング対象にする
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipEllipse: function (x, y, radiusX, radiusY) {
        this._drawEllipsePath(x, y, radiusX, radiusY);
        this._context.clip();
    },
    
    /**
     * 文字列を描画する
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     */
    strokeText: function (text, x, y) {
        this._context.font = this._font.toString();
        this._context.strokeText(text, x, y);
    },
    
    /**
     * 文字列を描画して塗りつぶす
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     */
    fillText: function (text, x, y) {
        this._context.font = this._font.toString();
        this._context.fillText(text, x, y);
    },
    
    /**
     * 扇形を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    strokePie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._drawArcPath(x, y, radiusX, radiusY, startAngle, endAngle, true);
        this._context.stroke();
    },
    
    /**
     * 扇形を描画して塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    fillPie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._drawArcPath(x, y, radiusX, radiusY, startAngle, endAngle, true);
        this._context.fill();
    },
    
    /**
     * 楕円弧を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    drawArc: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._drawArcPath(x, y, radiusX, radiusY, startAngle, endAngle);
        this._context.stroke();
    },
    
    /**
     * イメージを描画する
     * 
     * @param {Image} image 描画イメージ
     * @param {Number} imageX イメージ座標X
     * @param {Number} imageY イメージ座標Y
     * @param {Number} imageWidth 切り抜くイメージ幅
     * @param {Number} imageHeight 切り抜くイメージ高さ
     * @param {Number} drawX 描画座標X
     * @param {Number} drawY 描画座標Y
     * @param {Number} drawWidth 描画する幅
     * @param {Number} drawHeight 描画する高さ
     */
    drawImage: function (image, imageX, imageY, imageWidth, imageHeight, drawX, drawY, drawWidth, drawHeight) {
        switch (arguments.length) {
            case 3:
                this._context.drawImage(image, imageX, imageY);
                break;
                
            case 5:
                this._context.drawImage(image, imageX, imageY, imageWidth, imageHeight);
                break;
                
            case 9:
                this._context.drawImage(image, imageX, imageY, imageWidth, imageHeight, drawX, drawY, drawWidth, drawHeight);
                break;
                
            default:
                this._context.drawImage.apply(this._context, arguments);
                break;
        }
    },
    
    /**
     * 描画されている全ての図形を消去する
     */
    clear: function () {
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
    },
    
    /**
     * Penの更新時に呼ばれるコールバック
     * 
     * @param {Jeeel.Graphics.Pen} pen ペン
     * @param {Integer} type 更新タイプ
     */
    _refreshPen: function (pen, type) {
        switch (type) {
            case 0:
                this._context.lineWidth = pen.getWidth();
                this._context.strokeStyle = pen.getColor().toRgb().toRgbaString();
                this._context.lineCap = pen.getCapStyle();
                this._context.lineJoin = pen.getJoinStyle();
                this._context.miterLimit = pen.getMiterLimit();
                break;
                
            case 1:
                this._context.lineWidth = pen.getWidth();
                break;
                
            case 2:
                this._context.strokeStyle = pen.getColor().toRgb().toRgbaString();
                break;
                
            case 3:
                this._context.lineCap = pen.getCapStyle();
                break;
                
            case 4:
                this._context.lineJoin = pen.getJoinStyle();
                break;
                
            case 5:
                this._context.miterLimit = pen.getMiterLimit();
                break;
                
            default:
                break;
        }
    },
    
    /**
     * Brushの更新時に呼ばれるコールバック
     * 
     * @param {Jeeel.Graphics.Brush} brush ブラシ
     * @param {Integer} type 更新タイプ
     */
    _refreshBrush: function (brush, type) {
        switch (type) {
            case 0:
                this._context.fillStyle = brush.getColor().toRgb().toRgbaString();
                break;
                
            case 1:
                this._context.fillStyle = brush.getColor().toRgb().toRgbaString();
                break;
                
            default:
                break;
        }
    },
    
    /**
     * 多角形を描画する際のパスを設定する
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト
     */
    _drawPolygonPath: function (vertexes) {
        var v = vertexes[0];
        
        this._context.beginPath();
        this._context.moveTo(v.x, v.y);
        
        for (var i = vertexes.length; i--;) {
            v = vertexes[i];
            
            this._context.lineTo(v.x, v.y);
        }

        this._context.closePath();
    },
    
    /**
     * 楕円のパスを描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    _drawEllipsePath: function (x, y, radiusX, radiusY) {
        var top = y - radiusY;
        var left = x - radiusX;
        var bottom = y + radiusY;
        var right = x + radiusX;
        
        var cw = 4.0 * (Math.SQRT2 - 1.0) * radiusX / 3.0;
        var ch = 4.0 * (Math.SQRT2 - 1.0) * radiusY / 3.0;
        
        this._context.beginPath();

        this._context.moveTo(x, top);
        this._context.bezierCurveTo(x + cw, top, right, y - ch, right, y);
        this._context.bezierCurveTo(right, y + ch, x + cw, bottom, x, bottom);
        this._context.bezierCurveTo(x - cw, bottom, left, y + ch, left, y);
        this._context.bezierCurveTo(left, y - ch, x - cw, top, x, top);
        this._context.closePath();
    },
    
    /**
     * 楕円弧のパスを描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @param {Boolean} [isPie] 扇形かどうか
     */
    _drawArcPath: function (x, y, radiusX, radiusY, startAngle, endAngle, isPie) {
        var largeFlag = true, 
            sweepFlag = true, 
            PI2 = Math.PI * 2;
        
        if (startAngle > endAngle) {
            sweepFlag = false;
        }
        
        if (Math.abs(endAngle - startAngle) < Math.PI) {
            largeFlag = false;
        }
        
        while (startAngle < 0) {
            startAngle += PI2;
        }

        while (startAngle > PI2) {
            startAngle -= PI2;
        }

        while (endAngle < 0) {
            endAngle += PI2;
        }
        
        while (endAngle > PI2) {
            endAngle -= PI2;
        }
        
        if (Math.abs(endAngle - startAngle) >= PI2) {
            this._drawEllipsePath(x, y, radiusX, radiusY);
            return;
        }
        
        startAngle = PI2 - startAngle;
        endAngle = PI2 - endAngle;
        
        var sx = radiusX * Math.cos(startAngle);
        var sy = radiusY * Math.sin(startAngle);
        var ex = radiusX * Math.cos(endAngle);
        var ey = radiusY * Math.sin(endAngle);
        
        var cw = (radiusX * Math.cos(endAngle / 2 + startAngle) - sx / 2 - ex / 8) * 8 / 3;
        var ch = (radiusY * Math.sin(endAngle / 2 + startAngle) - ey / 2 - sy / 8) * 8 / 3;
        
        this._context.beginPath();
        this._context.moveTo(x + sx, y - sy);
        this._context.bezierCurveTo(x + sx, y - ch, x + cw, y - ey, x + ex, y - ey);
        this._context.stroke();
        
        console.log([sx + x, y - sy], [sx + x, y - ch], [x - cw, y - ey], [ex + x, y - ey], cw, ch);
    }
};

Jeeel.file.Jeeel.Graphics.Raster.Canvas.Context = ['Type'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics.Raster.Canvas.Context, Jeeel.file.Jeeel.Graphics.Raster.Canvas.Context);
/**
 * canvasのcontextに使用できるcontextIdの列挙体
 */
Jeeel.Graphics.Raster.Canvas.Context.Type = {
  
    /**
     * 2Dグラフィックスを扱うコンテキスト
     *
     * @type String
     * @constant
     */
    TWO_DIMENSION: '2d'
};Jeeel.directory.Jeeel.Graphics.Vector = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Graphics + 'Vector/';
    }
};

/**
 * コンストラクタ
 * 
 * @class ベクター系のグラフィックス処理機能を提供するクラス
 * @augments Jeeel.Graphics.Abstract
 * @param {Jeeel.Graphics.Vector.*} adapter 内部アダプター
 * @ignore 未完
 */
Jeeel.Graphics.Vector = function (adapter) {
    Jeeel.Graphics.Abstract.call(this);
    
    this._adapter = adapter;
};

/**
 * SVGタイプのインスタンスを作成する
 * 
 * @param {SVG} svg SVGElement
 * @return {Jeeel.Graphics.Vector} 作成したインスタンス
 */
Jeeel.Graphics.Vector.factorySvg = function (svg) {
    return new this(new this.Svg(svg));
};

Jeeel.Graphics.Vector.prototype = {

};

Jeeel.Class.extend(Jeeel.Graphics.Vector, Jeeel.Graphics.Abstract);

Jeeel.file.Jeeel.Graphics.Vector = ['Svg'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics.Vector, Jeeel.file.Jeeel.Graphics.Vector);
Jeeel.Graphics.Vector.Svg = function (svg) {
    this._svg = svg;
    this._doc = Jeeel.Dom.Document.create(svg.ownerDocument);
    this._pen = new Jeeel.Graphics.Pen();
    this._brush = new Jeeel.Graphics.Brush();
    this._font = new Jeeel.Object.Font('sans-serif');
};

Jeeel.Graphics.Vector.Svg.prototype = {
    /**
     * ドキュメント
     * 
     * @type Jeeel.Dom.Document
     * @private
     */
    _doc: null,
    
    /**
     * SVGElement
     * 
     * @type SVGElement
     */
    _svg: null,
    
    /**
     * Penオブジェクト
     * 
     * @type Jeeel.Graphics.Pen
     * @private
     */
    _pen: null,
    
    /**
     * Brushオブジェクト
     * 
     * @type Jeeel.Graphics.Brush
     * @private
     */
    _brush: null,
    
    /**
     * Fontオブジェクト
     * 
     * @type Jeeel.Object.Font
     * @private
     */
    _font: null,
    
    /**
     * 線を描画する際のペンを取得する
     * 
     * @return {Jeeel.Graphics.Pen} Penオブジェクト
     */
    getPen: function () {
        return this._pen;
    },
    
    /**
     * 線を描画する際のペンを設定する
     * 
     * @param {Jeeel.Graphics.Pen} pen Penオブジェクト
     */
    setPen: function (pen) {
        this._pen.setRefreshCallback(null);
        this._pen = pen.setRefreshCallback(this._refreshPen).refresh();
    },
    
    /**
     * 面を塗りつぶすためのブラシを取得する
     * 
     * @return {Jeeel.Graphics.Brush} Brushオブジェクト
     */
    getBrush: function () {
        return this._brush;
    },
    
    /**
     * 面を塗りつぶすためのブラシを設定する
     * 
     * @param {Jeeel.Graphics.Brush} brush Brushオブジェクト
     */
    setBrush: function (brush) {
        this._brush.setRefreshCallback(null);
        this._brush = brush.setRefreshCallback(this._refreshPen).refresh();
    },
    
    /**
     * 文字を描くためのフォントを取得する
     * 
     * @return {Jeeel.Object.Font} フォント
     */
    getFont: function () {
        return this._font;
    },
    
    /**
     * 文字を描くためのフォントを設定する
     * 
     * @param {Jeeel.Object.Font} font フォント
     */
    setFont: function (font) {
        this._font = font;
    },
    
    /**
     * 線を描画する
     * 
     * @param {Number} x1 一つ目の座標X
     * @param {Number} y1 一つ目の座標Y
     * @param {Number} x2 二つ目の座標X
     * @param {Number} y2 二つ目の座標Y
     */
    drawLine: function (x1, y1, x2, y2) {
        var line = this._createSvgElement('line');
        
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        
        this._setStroke(line);
    },
    
    /**
     * 長方形を描画する
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     */
    strokeRect: function (x, y, width, height) {
        var rect = this._createSvgElement('rect');
        
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', width);
        rect.setAttribute('height', height);
        
        this._setStroke(rect);
    },
    
    /**
     * 長方形を描画し塗りつぶす
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     */
    fillRect: function (x, y, width, height) {
        var rect = this._createSvgElement('rect');
        
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', width);
        rect.setAttribute('height', height);
        
        this._setFill(rect);
    },
    
    /**
     * 指定した頂点リストから多角形を描画する
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     */
    strokePolygon: function (vertexes) {
        var polygon = this._createSvgElement('polygon');
        
        polygon.setAttribute('points', this._getPolygonPoints(vertexes));
        
        this._setStroke(polygon);
    },
    
    /**
     * 指定した頂点リストから多角形を描画し塗りつぶす
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     */
    fillPolygon: function (vertexes) {
        var polygon = this._createSvgElement('polygon');
        
        polygon.setAttribute('points', this._getPolygonPoints(vertexes));
        
        this._setFill(polygon);
    },
    
    /**
     * 楕円を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    strokeEllipse: function (x, y, radiusX, radiusY) {
        var ellipse = this._createSvgElement('ellipse');
        
        ellipse.setAttribute('cx', x);
        ellipse.setAttribute('cy', y);
        ellipse.setAttribute('rx', radiusX);
        ellipse.setAttribute('ry', radiusY);
        
        this._setStroke(ellipse);
    },
    
    /**
     * 楕円を描画し塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    fillEllipse: function (x, y, radiusX, radiusY) {
        var ellipse = this._createSvgElement('ellipse');
        
        ellipse.setAttribute('cx', x);
        ellipse.setAttribute('cy', y);
        ellipse.setAttribute('rx', radiusX);
        ellipse.setAttribute('ry', radiusY);
        
        this._setFill(ellipse);
    },
    
    /**
     * 文字列を描画する
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     */
    strokeText: function (text, x, y) {
        var svgText = this._createSvgElement('text');
        
        svgText.setAttribute('x', x);
        svgText.setAttribute('font-size', this._font.size);
        svgText.setAttribute('font-family', this._font.family.join(','));
        svgText.setAttribute('font-style', this._font.style);
        svgText.setAttribute('font-weight', this._font.weight);
        
        svgText.appendChild(this._doc.createTextNode(text));
        
        this._setStroke(svgText);
        
        svgText.setAttribute('y', y + Jeeel.Dom.Element.prototype.getSize.call({_element: svgText}).height);
    },
    
    /**
     * 文字列を描画して塗りつぶす
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     */
    fillText: function (text, x, y) {
        var svgText = this._createSvgElement('text');
        
        svgText.setAttribute('x', x);
        svgText.setAttribute('font-size', this._font.size);
        svgText.setAttribute('font-family', this._font.family.join(','));
        svgText.setAttribute('font-style', this._font.style);
        svgText.setAttribute('font-weight', this._font.weight);
        
        svgText.appendChild(this._doc.createTextNode(text));
        
        this._setFill(svgText);
        
        svgText.setAttribute('y', y + Jeeel.Dom.Element.prototype.getSize.call({_element: svgText}).height);
    },
    
    /**
     * 扇形を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    strokePie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        var directions = this._getArcDirections(x, y, radiusX, radiusY, startAngle, endAngle, true);
        
        if (directions === false) {
            this.strokeEllipse(x, y, radiusX, radiusY);
            return;
        }
        
        var arc = this._createSvgElement('path');
        
        arc.setAttribute('d', directions);
        
        this._setStroke(arc);
    },
    
    /**
     * 扇形を描画して塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    fillPie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        var directions = this._getArcDirections(x, y, radiusX, radiusY, startAngle, endAngle, true);
        
        if (directions === false) {
            this.strokeEllipse(x, y, radiusX, radiusY);
            return;
        }
        
        var arc = this._createSvgElement('path');
        
        arc.setAttribute('d', directions);
        
        this._setFill(arc);
    },
    
    /**
     * 楕円弧を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    drawArc: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        var directions = this._getArcDirections(x, y, radiusX, radiusY, startAngle, endAngle);
        
        if (directions === false) {
            this.strokeEllipse(x, y, radiusX, radiusY);
            return;
        }
        
        var arc = this._createSvgElement('path');
        
        arc.setAttribute('d', directions);
        
        this._setStroke(arc);
    },

    /**
     * イメージを描画する
     * 
     * @param {Image} image 描画イメージ
     * @param {Number} x 描画座標X
     * @param {Number} y 描画座標Y
     * @param {Number} [width] 描画する幅
     * @param {Number} [height] 描画する高さ
     */
    drawImage: function (image, x, y, width, height) {
        var svgImage = this._createSvgElement('image');
        
        svgImage.setAttribute('x', x);
        svgImage.setAttribute('y', y);
        
        if (width && height) {
            svgImage.setAttribute('width', width);
            svgImage.setAttribute('height', height);
        } else {
            svgImage.setAttribute('width', image.width);
            svgImage.setAttribute('height', image.height);
        }
        
        svgImage.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', image.src);
        
        this._svg.appendChild(svgImage);
    },
    
    /**
     * 描画されている全ての図形を消去する
     */
    clear: function () {
        var f, elm = this._svg;

        while (f = elm.firstChild) {
            elm.removeChild(f);
        }
    },
    
    /**
     * SVGエレメントを作成する
     * 
     * @param {String} tagName 作成するSVGエレメントのタグ名
     * @return {SVGElement} 作成したSVGエレメント
     */
    _createSvgElement: function (tagName) {
        return this._doc.createElementNS(this._svg.namespaceURI, tagName);
    },
    
    /**
     * 枠塗り図形としてSVGに追加する
     * 
     * @param {SVGElement} element 対象のSVGエレメント
     */
    _setStroke: function (element) {
        element.setAttribute('fill', 'none');
        element.setAttribute('stroke', this._pen.getColor().toRgb().toRgbaString());
        element.setAttribute('stroke-width', this._pen.getWidth());
        element.setAttribute('stroke-linecap', this._pen.getCapStyle());
        element.setAttribute('stroke-linejoin', this._pen.getJoinStyle());
        element.setAttribute('stroke-miterlimit', this._pen.getMiterLimit());
        
        this._svg.appendChild(element);
    },
    
    /**
     * 塗りつぶし図形としてSVGに追加する
     * 
     * @param {SVGElement} element 対象のSVGエレメント
     */
    _setFill: function (element) {
        element.setAttribute('stroke', 'none');
        element.setAttribute('fill', this._brush.getColor().toRgb().toRgbaString());
        
        this._svg.appendChild(element);
    },
    
    /**
     * 指定した頂点リストから文字列化を行う
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト
     * @return {String} 頂点表記文字列
     */
    _getPolygonPoints: function (vertexes) {
        var v,
            p = [];
        
        for (var i = vertexes.length; i--;) {
            v = vertexes[i];
            
            p[p.length] = v.x;
            p[p.length] = v.y;
        }

        return p.join(' ');
    },
    
    /**
     * 楕円弧を作成するための命令文を取得する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @param {Boolean} [isPie] 扇形かどうか
     * @return {String} 命令文
     */
    _getArcDirections: function (x, y, radiusX, radiusY, startAngle, endAngle, isPie) {
        var largeFlag = true, 
            sweepFlag = true, 
            PI2 = Math.PI * 2;
        
        if (startAngle > endAngle) {
            sweepFlag = false;
        }
        
        if (Math.abs(endAngle - startAngle) < Math.PI) {
            largeFlag = false;
        }
        
        while (startAngle < 0) {
            startAngle += PI2;
        }

        while (startAngle > PI2) {
            startAngle -= PI2;
        }

        while (endAngle < 0) {
            endAngle += PI2;
        }
        
        while (endAngle > PI2) {
            endAngle -= PI2;
        }
        
        if (Math.abs(endAngle - startAngle) >= PI2) {
            return false;
        }
        
        startAngle = PI2 - startAngle;
        endAngle = PI2 - endAngle;
        
        var sx = x + radiusX * Math.cos(startAngle);
        var sy = y - radiusY * Math.sin(startAngle);
        var ex = x + radiusX * Math.cos(endAngle);
        var ey = y - radiusY * Math.sin(endAngle);
        
        var d = [
            'M' + sx, 
            sy, 
            'A' + radiusX, 
            radiusY, 
            0, 
            +largeFlag, 
            +sweepFlag,
            ex, 
            ey
        ];
        
        if (isPie) {
            d[d.length] = 'L' + x;
            d[d.length] = y;
            d[d.length] = 'Z';
        }
        
        return d.join(' ');
    }
};Jeeel.directory.Jeeel.Debug = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Debug/';
    }
};

/**
 * デバッグ関連の機能を保持するネームスペース
 */
Jeeel.Debug = {

};

Jeeel.file.Jeeel.Debug = ['ObjectExport', 'ObjectExpander', 'ErrorMessage', 'Timer', 'Console', 'Profiler', 'UnitTest', 'Debugger', 'Compressor'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Debug, Jeeel.file.Jeeel.Debug);
/**
 * 指定したオブジェクトを展開する
 *
 * @param {Mixied} obj 展開するオブジェクト
 * @return {String} 展開したオブジェクト
 */
Jeeel.Debug.ObjectExport = function (obj) {
    var res = typeof obj;
    var cnt = (arguments[1] ? arguments[1] : 0);
    var i, l;
    var sp = '';

    for (i = 0; i < cnt; i++) {
        sp += '    ';
    }

    if (Jeeel.Type.isPrimitive(obj)) {
        if (Jeeel.Type.isString(obj)) {
            return '"' + obj + '"';
        }
        
        return obj;
    }

    if (Jeeel.Type.isFunction(obj)) {
        var str = obj.toString();
        var remove = str.match(/ +}$/gi);
        if (remove) {
            remove = remove[0].substring(0, remove[0].length-1);
            var regExp = new RegExp('(\\n|\\r\\n)'+remove, 'ig');
            str = str.replace(regExp, '\n');
        }

        return str.replace(/(\n|\r\n)/ig, '$1'+sp);
    }

    cnt++;

    if (Jeeel.Type.isArray(obj)) {
        res = [];

        for (i = 0, l = obj.length; i < l; i++) {
            res[i] = sp + '    ' + i + ': ' + arguments.callee(obj[i], cnt);
        }

        return 'array {\n' + res.join(',\n') + '\n' + sp + '}';
    } else {
        var className = res;
        
        res = [];

        for (var key in obj) {
            if (key === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }
            
            res[res.length] = sp + '    ' + key + ': ' + arguments.callee(obj[key], cnt);
        }

        return className + ' {\n' + res.join(',\n') + '\n' + sp + '}';
    }
};

/**
 * コンストラクタ
 *
 * @class オブジェクトの展開を動的に行うクラス
 * @param {Boolean} [useHtmlExplorer=false] Html展開及び操作を行う機能を使用するかどうか
 */
Jeeel.Debug.ObjectExpander = function (useHtmlExplorer) {
    Jeeel.Debug.ObjectExpander._createCss();
    
    this._useHtmlExplorer = !!useHtmlExplorer;
    this._mouseGesture = Jeeel.Gui.Mouse.Gesture.create();
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [useHtmlExplorer=false] Html展開及び操作を行う機能を使用するかどうか
 * @return {Jeeel.Debug.ObjectExpander} 作成したインスタンス
 */
Jeeel.Debug.ObjectExpander.create = function (useHtmlExplorer) {
    return new this(useHtmlExplorer);
};

/**
 * 指定したオブジェクトを展開する
 *
 * @param {Mixied} obj 展開するオブジェクト
 * @param {Boolean} [useHtmlExplorer=false] Html展開及び操作を行う機能を使用するかどうか
 * @return {Element} 展開したオブジェクト
 */
Jeeel.Debug.ObjectExpander.expand = function (obj, useHtmlExplorer) {
    return this.create(useHtmlExplorer).expand(obj);
};

/**
 * 展開HTML要素のClass名
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.EXPAND_OBJECT_ROOT_CLASS = 'jeeel-expand-object-root';

/**
 * 展開HTML要素のtableタグにあたる子要素のClass名
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.EXPAND_TABLE_CLASS = 'jeeel-expand-object-table';

/**
 * 展開HTML要素のtrタグにあたる子要素のClass名
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.EXPAND_CHILD_CLASS = 'jeeel-expand-object-child';

/**
 * HtmlExplorerを有効にした時の前景レイヤーのClass名
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.HTML_LAYER_CLASS = 'jeeel-expand-element-layer';

/**
 * 開いている時の矢印のHTML文字列
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.EXPAND_ARROW = '<font color="#515151">&#9660;</font>';

/**
 * 閉じている時の矢印のHTML文字列
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.COLLAPSE_ARROW = '<font color="#515151">&#9654;</font>';

/**
 * メインに使用するフォントサイズ
 *
 * @type Integer
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.MAIN_FONT_SIZE = 16;

/**
 * 展開する矢印のフォントサイズ
 *
 * @type Integer
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.ARROW_FONT_SIZE = 15;

/**
 * この機能内で使用するCSSを定義する
 *
 * @private
 */
Jeeel.Debug.ObjectExpander._createCss = function () {
    if (arguments.callee.ignore) {
        return;
    }

    arguments.callee.ignore = true;

    var css = 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' {\n'
            + '    position: relative;\n'
            + '    z-index: 100;\n'
            + '    border-spacing: 0px;\n'
            + '    white-space: nowrap;\n'
            + '    color: black;\n'
            + '    background-color: white;\n'
            + '    text-align: left;\n'
            + '    vertical-align: middle;\n'
            + '    font-family: "Arial", "Times New Roman", "Courier New", "Courier", cursive;\n'
            + '    width: auto;\n'
            + '}\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' th,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' td {\n'
            + '    display: table-cell;\n'
            + '}\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' table {\n'
            + '    width: auto;\n'
            + '    border-spacing: 0px;\n'
            + '}\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' table,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' tbody,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' tr,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' th,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' td {\n'
            + '    font-size: ' + this.MAIN_FONT_SIZE + 'px;\n'
            + '    font-weight: normal;\n'
            + '    font-style: normal;\n'
            + '    margin: 0px;\n'
            + '    padding: 0px;\n'
            + '}\n'
            + 'tr.' + this.EXPAND_CHILD_CLASS + ' th,\n'
            + 'tr.' + this.EXPAND_CHILD_CLASS + ' td {\n'
            + '    padding: 0 0 2px 0;\n'
            + '}';

    Jeeel.Loader.addStyle(css);
};

Jeeel.Debug.ObjectExpander.prototype = {

    /**
     * Html要素の展開及び操作を行うモードかどうかを示す
     *
     * @type Boolean
     * @private
     */
    _useHtmlExplorer: false,
    
    /**
     * 展開を行った情報を保持するHtml要素
     * 
     * @type Element
     * @private
     */
    _rootElement: null,

    /**
     * 現在選択中のHTML要素
     *
     * @type Element
     * @private
     */
    _selectedElement: null,

    /**
     * 現在選択中のexpand要素
     *
     * @type Element
     * @private
     */
    _selectedTarget: null,

    /**
     * 現在選択中の削除expand要素
     *
     * @type Element
     * @private
     */
    _selectedRemoveTarget: null,

    /**
     * マウスジェスチャインスタンス
     *
     * @type Jeeel.Gui.Mouse.Gesture
     * @private
     */
    _mouseGesture: null,

    /**
     * Html要素の削除を行うジェスチャー<br />
     * ↓→
     *
     * @type Integer[]
     * @private
     * @constant
     */
    _removeGesture: [Jeeel.Code.KeyCode.Down, Jeeel.Code.KeyCode.Right],
    
    /**
     * コンストラクタ
     * 
     * @param {Boolean} [useHtmlExplorer=false] Html展開及び操作を行う機能を使用するかどうか
     * @constructor
     */
    constructor: Jeeel.Debug.ObjectExpander,

    /**
     * 指定したオブジェクトを展開する
     *
     * @param {Mixied} obj 展開するオブジェクト
     * @return {Element} 展開したオブジェクト
     */
    expand: function (obj) {
        this._rootElement = this._createExpander.call(this, obj, null, false, true);
        this._rootElement.className = this.constructor.EXPAND_OBJECT_ROOT_CLASS;
        
        return this._rootElement;
    },
    
    /**
     * オブジェクトを展開できるHTML要素を作成する
     *
     * @param {Mixied} obj 展開対象のオブジェクト
     * @param {String} [key] オブジェクトに対応するキー
     * @param {Boolean} [isSimple=false] シンプルな形で取得するかどうか
     * @param {Boolean} [isFirst=false] 最初の呼び出しかどうか
     * @return {Element} テーブルタグのHTML要素
     * @private
     */
    _createExpander: function (obj, key, isSimple, isFirst) {

        var elm = this._expandObject.call(this, obj, key, isFirst);

        if (isSimple && ! elm.canExpand && ! elm.isError) {
            return elm;
        }

        var table = Jeeel.Document.createElement('table');
        var tbody = Jeeel.Document.createElement('tbody');
        var tr    = Jeeel.Document.createElement('tr');
        var th    = Jeeel.Document.createElement('th');
        var td    = Jeeel.Document.createElement('td');

        var thStyle = th.style;
        var arrowSize = this.constructor.ARROW_FONT_SIZE + 'px';
        
        thStyle.fontSize  = arrowSize;
        thStyle.width     = arrowSize;
        thStyle.height    = arrowSize;
        thStyle.textAlign = 'center';

        table.className = this.constructor.EXPAND_TABLE_CLASS;

        var self = this;

        if (elm.canExpand) {
            th.innerHTML = this.constructor.COLLAPSE_ARROW;
            thStyle.cursor = 'pointer';

            var func = function () {
                var data  = arguments.callee.data;
                var tbody = arguments.callee.tbody;

                if (arguments.callee.isExpand) {
                    self._collapseTable.call(self, data, tbody);
                } else {
                    self._expandTable.call(self, data, tbody, arguments.callee.first);
                }

                arguments.callee.first = false;
                arguments.callee.isExpand = ! arguments.callee.isExpand;
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            func.first = true;
            func.isExpand = false;
            func.data = obj;
            func.tbody = tbody;

            th.onclick = func;
        } else if (elm.isError) {
            th.innerHTML = '<font color="red">&#8855;</font>';
        } else {
            thStyle.width = arrowSize;
            th.innerHTML = '<div style="width: ' + arrowSize + '; height: ' + arrowSize + ';">&nbsp;</div>';
        }

        if (elm.isElement) {

            var mouseDown = function () {
                var data   = arguments.callee.data;
                var target = arguments.callee.targetTr;

                self._selectElement(data, target);
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            mouseDown.data = obj;
            mouseDown.targetTr = tr;

            var mouseUp = function () {
                var event  = Jeeel.Dom.Event.getEventObject();

                if (event.ctrlKey && event.isLeftDown) {
                    self._removeElement();
                }
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            var over = function () {
                var data   = arguments.callee.data;
                var target = arguments.callee.targetTr;

                if (target.enableMouse) {
                    self._markupElement(data, target);
                }
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            over.data = obj;
            over.targetTr = tr;

            var out = function () {
                var data   = arguments.callee.data;
                var target = arguments.callee.targetTr;

                if (target.enableMouse) {
                    self._cleanupElement(data, target);
                }
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            out.data = obj;
            out.targetTr = tr;

            elm.onmousedown = mouseDown;
            elm.onmouseup   = mouseUp;
//            tr.onmouseover = over;
//            tr.onmouseout  = out;
            tr.enableMouse = true;
        }
        
        td.appendChild(elm);
        tr.appendChild(th);
        tr.appendChild(td);
        tbody.appendChild(tr);
        table.appendChild(tbody);

        return table;
    },
    
    /**
     * 不特定なオブジェクトの名前を取得する
     *
     * @param {Mixied} obj 展開対象のオブジェクト
     * @return {String} 名前
     * @private
     */
    _getUnknownObjectName: function (obj) {
        var objType;

        if (obj.__proto__ && obj.__proto__.constructor && obj.__proto__.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME]) {
            objType = obj.__proto__.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME].name;
        }
        else if ( ! obj.__proto__ && obj.constructor && obj.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME]) {
            objType = obj.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME].name;
        }
        else if(obj.constructor && obj.constructor.name) {
            objType = obj.constructor.name;
        }
        else {
            objType = Object.prototype.toString.call(obj);
            objType = objType.substring(8, objType.length - 1);
        }

        return objType;
    },

    /**
     * 不特定なオブジェクトの展開を定義づける
     *
     * @param {Element} elm 定義づけ対象のElement
     * @param {Mixied} obj 展開対象のオブジェクト
     * @private
     */
    _expandForUnknownObject: function (elm, obj) {
        elm.color = 'black';
        elm.innerHTML = this._getUnknownObjectName(obj);
    },

    /**
     * オブジェクトを展開し、それを示す文字列等に変換して返す
     *
     * @param {Mixied} obj 展開対象のオブジェクト
     * @param {String} [key] オブジェクトに対応するキー
     * @param {Boolean} [isFirst=false] 最初の呼び出しかどうか
     * @return {Element} 要素を示す文字列等を含むHTML要素
     * @private
     */
    _expandObject: function (obj, key, isFirst) {

        var elm = Jeeel.Document.createElement('font');
        var type;
        var canExpand = true;
        var isError   = false;
        var isElement = false;

        try {
            type = Jeeel.Type.getType(obj);
        } catch (e) {
            obj = e;
            type = Jeeel.Type.getType(obj);
        }

        switch (type) {
            case Jeeel.Type.ObjectType.STRING:
                elm.color = 'red';
                elm.innerHTML = '&quot;' + Jeeel.Filter.Html.Escape.create(true).filter(obj) + '&quot;';

                if (obj.match(/^(https?|ttp):\/\/.+/)) {
                    var url = (obj.match(/^ttp:\/\/.+/) ? 'h' + obj : obj);

                    elm.innerHTML = '<a href="' + url + '" target="_blank">' + elm.innerHTML + '</a>';
                }

                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.REGULAR_EXPRESSION:
                elm.color = 'violet';
                elm.innerHTML = Jeeel.Filter.Html.Escape.create(true).filter('' + obj);
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.DATE:
                elm.color = 'black';
                elm.innerHTML = Jeeel.Filter.Html.Escape.create(true).filter(obj.toString());
                break;

            case Jeeel.Type.ObjectType.BOOLEAN:
            case Jeeel.Type.ObjectType.NUMBER:
                elm.color = 'blue';
                elm.innerHTML = '' + obj;
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.UNDEFINED:
            case Jeeel.Type.ObjectType.NULL:
                elm.color = 'gray';
                elm.innerHTML = '' + obj;
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.ARGUMENTS:
            case Jeeel.Type.ObjectType.ARRAY:
                if ( ! isFirst) {
                    elm.innerHTML = type + '[' + obj.length + ']';
                    break;
                }
                
                elm = Jeeel.Document.createElement('table');
                var tbody = Jeeel.Document.createElement('tbody');
                var tr = Jeeel.Document.createElement('tr');
                var th, td;

                tr.style.verticalAlign = 'top';
                
                var tmp;
                var txt = Jeeel.Document.createTextNode('[');
                th = Jeeel.Document.createElement('th');
                th.style.verticalAlign = 'top';
                th.appendChild(txt);
                tr.appendChild(th);

                for (var i = 0; i < obj.length; i++) {
                    if (i > 0) {
                        txt = Jeeel.Document.createTextNode(',　');
                        th = Jeeel.Document.createElement('th');
                        th.appendChild(txt);
                        tr.appendChild(th);
                    }

                    tmp = this._createExpander.call(this, obj[i], null, true);
                    td = Jeeel.Document.createElement('td');
                    td.appendChild(tmp);
                    td.style.verticalAlign = 'top';
                    tr.appendChild(td);
                }

                txt = Jeeel._doc.createTextNode(']');
                th = Jeeel.Document.createElement('th');
                th.appendChild(txt);
                th.style.verticalAlign = 'top';
                tr.appendChild(th);
                
                tbody.appendChild(tr);
                elm.appendChild(tbody);
                
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.FUNCTION:
                var func = Jeeel.Filter.Html.Escape.create(false).filter('' + obj).toString().replace(/(\r\n|\n)/g, '&crarr;');
                elm.color = 'black';
                elm.innerHTML = (func.length > 100 ? func.substr(0, 100) + ' ...' : func);
                break;

            case Jeeel.Type.ObjectType.WINDOW:
                elm.color = 'green';
                elm.innerHTML = 'Window';
                break;

            case Jeeel.Type.ObjectType.DOCUMENT_FRAGMENT:
                elm.color = 'black';
                elm.innerHTML = 'Document Fragment';
                break;

            case Jeeel.Type.ObjectType.DOCUMENT:
                elm.color = 'green';
                elm.innerHTML = 'Document';
                break;

            case Jeeel.Type.ObjectType.OBJECT:
                this._expandForUnknownObject(elm, obj);
                break;

            case Jeeel.Type.ObjectType.PROTOTYPE:
                elm.color = 'black';
                elm.innerHTML = 'Object(__proto__)';
                break;

            case Jeeel.Type.ObjectType.ELEMENT:

                if ( ! this._useHtmlExplorer) {
                    this._expandForUnknownObject(elm, obj);
                    break;
                }

                elm.color = '#881391';
                elm.innerHTML = this._createInfoElement(obj);
                isElement = true;

                if ( ! obj.contentWindow && ( ! obj.childNodes[0] || this._isAlwaysOpenedElement(obj))) {
                    canExpand = false;
                }
                break;
                
            case Jeeel.Type.ObjectType.ATTRIBUTE:

                if ( ! this._useHtmlExplorer) {
                    elm.color = 'black';
                    elm.innerHTML = type;
                    break;
                }
                
                var div = Jeeel.Document.createElement('div');
                var name = Jeeel.Document.createElement('font');
                
                name.color = '#994500';
                name.innerHTML = obj.name;
                
                elm.color = '#1A1AA6';
                elm.innerHTML = Jeeel.Filter.Html.Escape.create(true).filter('"' + obj.value + '"');
                
                div.appendChild(name);
                div.appendChild(elm);
                
                elm = div;

                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.TEXT:

                if ( ! this._useHtmlExplorer) {
                    elm.color = 'black';
                    elm.innerHTML = type;
                    break;
                }

                var replaceCR = !(obj.data.match(/^(\r|\n|\t| )*$/) && true);
                elm.color = 'black';
                elm.innerHTML = Jeeel.Filter.Html.Escape.create(replaceCR).filter('"' + obj.data + '"');

                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.COMMENT:

                if ( ! this._useHtmlExplorer) {
                    elm.color = 'black';
                    elm.innerHTML = type;
                    break;
                }
                
                elm.color = '#236E25';
                elm.innerHTML = Jeeel.Filter.Html.Escape.create(true).filter('<!--' + obj.data + '-->');
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.EVENT:
                var eventType = this._getUnknownObjectName(obj);
                
                elm.color = '#0080FF';
                elm.innerHTML = (eventType == 'Object' ? 'Event' : eventType);
                break;

            case Jeeel.Type.ObjectType.ERROR:
                elm.color = 'red';
                elm.innerHTML = Jeeel.Filter.Html.Escape.create(true).filter(obj.name + ': ' + obj.message);
                canExpand = false;
                isError = true;
                break;
                
            case Jeeel.Type.ObjectType.MATH:
                elm.color = '#006699';
                elm.innerHTML = 'Math';
                break;
                
            case Jeeel.Type.ObjectType.JSON:
                elm.color = '#61A458';
                elm.innerHTML = 'JSON';
                break;  

            case Jeeel.Type.ObjectType.STORAGE:
                elm.color = 'black';
                elm.innerHTML = 'Storage';
                break;

            default:
                elm.innerHTML = type;
                break;
        }

        if (Jeeel.Type.isString(key)) {
            var tab = Jeeel.Document.createElement('table');
            var tby = Jeeel.Document.createElement('tbody');
            var tre = Jeeel.Document.createElement('tr');
            var the = Jeeel.Document.createElement('th');
            var tde = Jeeel.Document.createElement('td');

            the.innerHTML = '<font color="#881391">' + key + '</font>:&nbsp;&nbsp;';

            the.style.verticalAlign = 'top';
            tde.appendChild(elm);
            
            tre.appendChild(the);
            tre.appendChild(tde);
            tby.appendChild(tre);
            tab.appendChild(tby);
            
            elm = tab;
        }

        elm.canExpand = canExpand;
        elm.isError   = isError;
        elm.isElement = isElement;
        
        return elm;
    },

    /**
     * Tableを展開する
     *
     * @param {Mixied} obj Tableに定義づけられているオブジェクト
     * @param {Element} tbody 閉じる対象のtbody
     * @param {Boolean} [isFirst=false] 最初の展開かどうか
     * @private
     */
    _expandTable: function (obj, tbody, isFirst) {

        if (this._useHtmlExplorer && Jeeel.Type.isDocumentFragment(obj)) {
            this._expandTableForDocumentFragment.call(this, obj, tbody, isFirst);
            return;
        } else if (this._useHtmlExplorer && Jeeel.Type.isElement(obj)) {
            this._expandTableForElement.call(this, obj, tbody, isFirst);
            return;
        }

        var i, l, th;

        th = tbody.firstChild.firstChild;
        th.innerHTML = Jeeel.Debug.ObjectExpander.EXPAND_ARROW;

        if (isFirst) {
            var tr, td;
            var list = Jeeel.Hash.getPairs(obj);
            var flag = Jeeel._doc.createDocumentFragment();
            
            for (i = 0, l = list.length; i < l; i++) {
                var key = list[i].key;
                var val = list[i].value;
                
                tr = Jeeel.Document.createElement('tr');
                th = Jeeel.Document.createElement('th');
                td = Jeeel.Document.createElement('td');

                var elm = this._createExpander.call(this, val, key);

                td.appendChild(elm);
                
                tr.appendChild(th);
                tr.appendChild(td);
                tr.className = this.constructor.EXPAND_CHILD_CLASS;
                
                flag.appendChild(tr);
            }
            
            tbody.appendChild(flag);
        } else {
            var children = tbody.childNodes;

            for (i = 0, l = children.length; i < l; i++) {
                if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                    children[i].style.display = '';
                }
            }
        }
    },

    /**
     * Tableを閉じる
     *
     * @param {Mixied} obj Tableに定義づけられているオブジェクト
     * @param {Element} tbody 閉じる対象のtbody
     * @private
     */
    _collapseTable: function (obj, tbody) {

        if (this._useHtmlExplorer && Jeeel.Type.isElement(obj)) {
            this._collapseTableForElement.call(this, obj, tbody);
            return;
        }

        var th;

        th = tbody.firstChild.firstChild;
        th.innerHTML = this.constructor.COLLAPSE_ARROW;

        var children = tbody.childNodes;

        for (var i = 0, l = children.length; i < l; i++) {
            if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                children[i].style.display = 'none';
            }
        }
    },

    /**
     * Html要素のための展開メソッド
     *
     * @param {Element} element 展開するElement
     * @param {Element} tbody 閉じる対象のtbody
     * @param {Boolean} [isFirst=false] 最初の展開かどうか
     * @private
     */
    _expandTableForElement: function (element, tbody, isFirst) {

        var i, l, th, td, children;
        var nodeName = element.nodeName.toLowerCase();

        th = tbody.firstChild.firstChild;
        td = tbody.firstChild.children[1];
        th.innerHTML = this.constructor.EXPAND_ARROW;

        if (td.firstChild.nodeName.toLowerCase() !== 'font') {
            td = td.firstChild.firstChild.firstChild.children[1];
        }

        td.firstChild.innerHTML = this._createInfoElement(element, true);
        tbody.firstChild.enableMouse = false;
        this._cleanupElement(element);

        if (isFirst) {
            var tr;
            var flag = Jeeel.Document.createDocumentFragment();
            children = (element.contentWindow ? [element.contentWindow.document.documentElement] : element.childNodes);

            for (i = 0, l = children.length; i < l; i++) {

                if (Jeeel.Type.isText(children[i]) && children[i].data.match(/^(\r|\n|\t| )*$/)) {
                    continue;
                }

                tr = Jeeel.Document.createElement('tr');
                th = Jeeel.Document.createElement('th');
                td = Jeeel.Document.createElement('td');

                var elm = this._createExpander.call(this, children[i]);

                td.appendChild(elm);
                
                tr.appendChild(th);
                tr.appendChild(td);
                tr.className = this.constructor.EXPAND_CHILD_CLASS;

                flag.appendChild(tr);
            }

            tr = Jeeel.Document.createElement('tr');
            th = Jeeel.Document.createElement('th');
            td = Jeeel.Document.createElement('td');
            
            td.innerHTML = '<font color="#881391">&lt;/' + nodeName + '&gt;</font>';

            var self = this;
            var mouseDown = function () {
                var data   = arguments.callee.data;
                var target = arguments.callee.targetTr;

                self._selectElement(data, target);
            };

            mouseDown.data = element;
            mouseDown.targetTr = tr;

            var mouseUp = function () {
                var event  = Jeeel.Dom.Event.getEventObject();

                if (event.ctrlKey && event.isLeftDown) {
                    self._removeElement();
                }
            };

            td.firstChild.onmousedown = mouseDown;
            td.firstChild.onmouseup   = mouseUp;
            
            tr.appendChild(th);
            tr.appendChild(td);
            
            flag.appendChild(tr);

            tbody.appendChild(flag);

        } else {
            children = tbody.childNodes;

            for (i = 0, l = children.length; i < l; i++) {
                if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                    children[i].style.display = '';
                }
            }

            tbody.lastChild.style.display = '';
        }
    },

    /**
     * Html要素のための閉じるメソッド
     *
     * @param {Element} element 閉じるElement
     * @param {Element} tbody 閉じる対象のtbody
     * @private
     */
    _collapseTableForElement: function (element, tbody) {
        var th, td;

        th = tbody.firstChild.firstChild;
        td = tbody.firstChild.children[1];
        th.innerHTML = this.constructor.COLLAPSE_ARROW;

        if (td.firstChild.nodeName.toLowerCase() !== 'font') {
            td = td.firstChild.firstChild.firstChild.children[1];
        }
        
        td.firstChild.innerHTML = this._createInfoElement(element);
        tbody.firstChild.enableMouse = true;

        var children = tbody.childNodes;

        for (var i = 0, l = children.length; i < l; i++) {
            if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                children[i].style.display = 'none';
            }
        }

        tbody.lastChild.style.display = 'none';
    },

    /**
     * DocumentFragmentを展開する
     *
     * @param {Mixied} obj Tableに定義づけられているオブジェクト
     * @param {Element} tbody 閉じる対象のtbody
     * @param {Boolean} [isFirst=false] 最初の展開かどうか
     * @private
     */
    _expandTableForDocumentFragment: function (obj, tbody, isFirst) {

        var i, l, th;

        th = tbody.firstChild.firstChild;
        th.innerHTML = this.constructor.EXPAND_ARROW;

        if (isFirst) {
            var tr, td;
            var flag = Jeeel.Document.createDocumentFragment();
            var length = obj.childNodes.length;

            for (i = 0; i < length; i++) {
                var val = obj.childNodes[i];

                tr = Jeeel.Document.createElement('tr');
                th = Jeeel.Document.createElement('th');
                td = Jeeel.Document.createElement('td');
                
                var elm = this._createExpander.call(this, val);

                td.appendChild(elm);

                tr.appendChild(th);
                tr.appendChild(td);
                tr.className = this.constructor.EXPAND_CHILD_CLASS;
                
                flag.appendChild(tr);
            }
            
            tbody.appendChild(flag);
        } else {
            var children = tbody.childNodes;

            for (i = 0, l = children.length; i < l; i++) {
                if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                    children[i].style.display = '';
                }
            }
        }
    },

    /**
     * ジェスチャーの判定を行う
     * 
     * @param {Integer[]} judge 判定対象のジェスチャー
     * @type Jeeel.Function.create
     * @function
     */
    _mouseGestureJudge: Jeeel.Function.create(function (judge) {

        if (this._mouseGesture.matchGesture(judge)) {
            this._removeElement();
            this._mouseGesture.end();
        }
    }),

    /**
     * @ignore
     */
    _markupElement: function (element, target) {
        var foreground = Jeeel.Document.createElement('div');
        var foregroundStyle = Jeeel.Dom.Style.create(foreground);
        var elementStyle = element.style;
        
        Jeeel.Dom.Event.disableMouseEvent(foreground);
        
        foreground.className = this.constructor.HTML_LAYER_CLASS;
        
        foregroundStyle.setStyleList({
            backgroundColor: '#3879D9',
            width: '100%',
            height: '100%',
            zIndex: '50',
            top: '0px',
            left: '0px',
            position: 'absolute'
        });

        foregroundStyle.setOpacity(0.3);

//        target._position = elementStyle.position;
//        target._zIndex   = elementStyle.zIndex;
//
//        elementStyle.position = 'relative';
//
//        if ( ! elementStyle.zIndex) {
//            elementStyle.zIndex   = '1';
//        }
        
        element.appendChild(foreground);
    },

    /**
     * @ignore
     */
    _cleanupElement: function (element, target) {
        var elm = Jeeel.Dom.Element.create(element);
        var elementStyle = element.style;
        var foreground = elm.getElementsByClassName(this.constructor.HTML_LAYER_CLASS)[0];

        if ( ! foreground) {
            return;
        }

        Jeeel.Dom.Element.create(foreground).remove();

//        if (Jeeel.Type.isString(target._position)) {
//            elementStyle.position = target._position;
//        }
//
//        if (Jeeel.Type.isString(target._zIndex)) {
//            elementStyle.zIndex = target._zIndex;
//        }
    },

    /**
     * 指定したHTML要素を選択し、それに対応するexpand要素をセレクト状態にする
     *
     * @param {Element} element 対象HTML要素
     * @param {Element} target 対象expand要素
     */
    _selectElement: function (element, target) {
        if (this._selectedTarget) {
            this._mouseGesture.end();
            this._selectedTarget.style.backgroundColor = '';
        }

        target.style.backgroundColor = '#C8D8FB';

        this._selectedElement = element;
        this._selectedTarget  = target;
        this._selectedRemoveTarget = target.parentNode.parentNode.parentNode.parentNode;
        this._mouseGestureJudge.reset();
        this._mouseGestureJudge.curry(this._removeGesture).bind(this);
        this._mouseGesture.setInactiveCallback(this._mouseGestureJudge)
                          .start();
    },

    /**
     * 現在選択中のHTML要素を取り除く
     */
    _removeElement: function () {
        if ( ! this._selectedTarget) {
            return;
        }

        Jeeel.Dom.Element.create(this._selectedElement).remove();
        Jeeel.Dom.Element.create(this._selectedRemoveTarget).remove();

        this._selectedElement = null;
        this._selectedTarget  = null;
        this._selectedRemoveTarget = null;
    },

    /**
     * Html要素を表すHTML文字列を作成する
     *
     * @param {Element} element 対象のElement
     * @param {Boolean} [isExpanded] 開いた状態のHTML文字列かどうか
     * @private
     */
    _createInfoElement: function (element, isExpanded) {
        var nodeName = (element.scopeName && element.scopeName !== 'HTML' ? element.scopeName + ':' : '')
                     + element.nodeName.toLowerCase();
        var html = ['&lt;' + nodeName];
        var attr = element.attributes;
        var isIE = Jeeel.UserAgent.isInternetExplorer();

        for (var i = 0, l = attr.length; i < l; i++) {

            if ( ! attr[i].value || (isIE && attr[i].value == 'null')) {
                continue;
            }

            html[html.length] = ' <font color="#994500">' + attr[i].name + '=&quot;<font color="#1A1AA6">' + attr[i].value + '</font>&quot;</font>';
        }

        html[html.length] = '&gt;';

        if ( ! isExpanded) {

            if (element.firstChild || element.tagName.toUpperCase() == 'STYLE') {
              
                var isOpendElm = this._isAlwaysOpenedElement(element);
                var multiLine = false;
                var innerText;
                
                if (isOpendElm) {
                    innerText = (element.styleSheet && element.styleSheet.cssText || element.innerHTML).replace(/(^(\r\n|\n))|((\r\n|\n)$)/, '');
                }
                
                if (innerText && innerText.indexOf('\n') + 1) {
                    multiLine = true;
                }
                
                var txt = (isOpendElm ? Jeeel.Filter.Html.Escape.create(true).filter(innerText) : '_');
                
                if (isOpendElm && multiLine) {
                    txt = '<br />' + txt + '<br />';
                }
                
                html[html.length] = '<font color="black">' + txt + '</font>';
            }

            html[html.length] = '&lt;/' + nodeName + '&gt;';
        }

        return html.join('');
    },

    /**
     *
     */
    _isAlwaysOpenedElement: function (element) {
        var closeElm = ['SCRIPT', 'STYLE'];

//        if (Jeeel.Type.inArray(element.tagName.toUpperCase(), closeElm)) {
//            return true;
//        }

        return (element.childNodes.length == 1 && Jeeel.Type.isText(element.childNodes[0]));
    }
};

/**
 * メッセージをHTML上に表示するためのモジュール
 */
Jeeel.Debug.ErrorMessage = {
    
    _timer: 0,
    
    _setLf: false,
    
    /**
     * エラーメッセージの出力するためのdivタグを作る
     *
     * @return {Element} 取得したdiv要素
     * @private
     */
    _create: function () {
        var errorDiv = 'jeeel-debug-error-message-div';

        var div = Jeeel._doc.getElementById(errorDiv);

        if ( ! div) {
            div = Jeeel.Document.createElement('div');
            div.id = errorDiv;
            
            var style = div.style;
            
            style.backgroundColor = 'white';
            style.color = 'black';
            style.textAlign = 'left';
            style.fontSize = '15px';
            style.fontWeight = 'normal';
            
            Jeeel.Debug.Debugger.elementInsertTop(div);
        }

        return div;
    },

    /**
     * エラーをダンプする<br />
     * errorDiv変数のIDからdivを取得<br />
     * なければ作成する
     *
     * @param {Mixied} var_args 可変引数、ダンプするエラーを羅列する
     */
    dump: function (var_args) {},

    /**
     * タグを全て取り除いたエラーダンプする<br />
     * errorDiv変数のIDからdivを取得<br />
     * なければ作成する
     *
     * @param {Mixied} var_args 可変引数、ダンプするエラーを羅列する
     */
    dumpStripTags: function (var_args) {

        for (var i = 0, l = arguments.length; i < l; i++) {
            arguments[i] = Jeeel.String.stripTags(''+arguments[i]);
        }

        Jeeel.Debug.ErrorMessage.dump.apply(this, arguments);
    },

    /**
     * タグをエスケープしないで直接ダンプを行う<br />
     * errorDiv変数のIDからdivを取得<br />
     * なければ作成する
     *
     * @param {Mixied} var_args 可変引数、ダンプするエラーを羅列する
     */
    dumpHtml: function (var_args) {
        var div = Jeeel.Debug.ErrorMessage._create();

        var error = [];

        for (var i = 0, l = arguments.length; i < l; i++) {
            error[i] = arguments[i];
        }
        
        Jeeel.Debug.ErrorMessage._setLinefeed();
        
        div.innerHTML += error.join(' ');
        
        Jeeel.Debug.ErrorMessage._setLinefeedTimer();
    },

    /**
     * エラーを消去する<br />
     * errorDiv変数のIDからdivを取得<br />
     * なければ作成する
     */
    clear: function () {

        var div = Jeeel.Debug.ErrorMessage._create();

        div.innerHTML = '';
    },

    /**
     * エラーメッセージを出力するためのdiv要素を得る
     *
     * @return {Element} 取得したdiv要素
     */
    get: function () {
        return Jeeel.Debug.ErrorMessage._create();
    },

    /**
     * 出力されたエラーメッセージを文字列として得る
     *
     * @return {String} 取得したエラーメッセージ
     */
    getText: function () {},
    
    _setLinefeed: function () {
        if (this._setLf) {
            this._create().innerHTML += '<br />';
            this._setLf = false;
        }
    },
    
    _setLinefeedTimer: function () {
        if (this._timer) {
            return;
        }
        
        this._timer = Jeeel.Timer.setTimeout(function () {
            Jeeel.Debug.ErrorMessage._setLf = true;
            Jeeel.Debug.ErrorMessage._timer = 0;
        }, 0);
    },
    
    _init: function () {
        var ef = new Jeeel.Filter.Html.Escape(true);
        var uf = new Jeeel.Filter.Html.Unescape(true);
        
        this.dump = function (var_args) {
            var div = Jeeel.Debug.ErrorMessage._create();

            var error = [];

            for (var i = 0, l = arguments.length; i < l; i++) {
                error[i] = ef.filter(arguments[i]);
            }
            
            Jeeel.Debug.ErrorMessage._setLinefeed();

            div.innerHTML += error.join(' ');
            
            Jeeel.Debug.ErrorMessage._setLinefeedTimer();
        };
        
        this.getText = function () {
            return uf.filter(Jeeel.Debug.ErrorMessage._create().innerHTML);
        };
        
        delete this._init;
    }
};

Jeeel.Debug.ErrorMessage._init();
/**
 * コンストラクタ
 * 
 * @class デバッグ用のタイマー(ストップウォッチ)を管理するクラス
 */
Jeeel.Debug.Timer = function () {
    this.reset();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Debug.Timer} 作成したインスタンス
 */
Jeeel.Debug.Timer.create = function () {
    return new this();
};

Jeeel.Debug.Timer.prototype = {
    
    /**
     * Timerを作る際のベースにする現時刻
     * 
     * @type Jeeel.Object.Date
     * @private
     */
    _date: null,
    
    /**
     * ラップタイムの記録
     * 
     * @type Hash
     * @private
     */
    _laps: {},
    
    /**
     * インターバルの記録
     * 
     * @type Hash
     * @private
     */
    _interval: {},
    
    /**
     * インターバルを最後に記録した際のタイム
     * 
     * @type Integer
     * @private
     */
    _lastTime: 0,
    
    /**
     * 現在動いているかどうか
     * 
     * @type Boolean
     */
    _active: true,
    
    /**
     * stopメソッドを呼び出した際の時間
     * 
     * @type Integer
     */
    _stopTime: 0,
    
    /**
     * タイマーをスタートする<br />
     * 作成時は既にスタート済み
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    start: function () {
        if ( ! this._active) {
            this._date.setElapsedTime(this._stopTime);
            this._active = true;
        }

        return this;
    },
    
    /**
     * タイマーを一時停止する<br />
     * もう一度使いたい場合はstartメソッドを呼び出す
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    stop: function () {
        this._active   = false;
        this._stopTime = this._date.getElapsedTime();
        
        return this;
    },
    
    /**
     * インスタンスを作成時の状態にリセットする
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    reset: function () {

        this._laps = {};
        this._interval = {};
        this._lastTime = 0;
        this._stopTime = 0;
        this._date = Jeeel.Object.Date.create();
        this._active = true;
        
        return this;
    },
    
    /**
     * ラップタイムを記録する
     * 
     * @param {String} [key] 任意の記録キーを指定したい場合に引き渡す(デフォルトは現在の記録数)
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    lap: function (key) {
        if ( ! this._active) {
            return this;
        }
        
        if ( ! key) {
            key = Jeeel.Hash.getCount(this._laps);
        }
        
        this._laps[key] = this._date.getElapsedTime();
        
        return this;
    },
    
    /**
     * ラップタイムの記録を返す
     * 
     * @param {String} key 読み込みたいラップのキー
     * @return {Integer} ラップタイム
     */
    loadLap: function (key) {
        return this._laps[key];
    },
    
    /**
     * ラップタイムの記録を全て返す
     * 
     * @return {Hash} ラップタイムとそのキーのペアリスト
     */
    loadAllLap: function () {
        return this._laps;
    },
    
    /**
     * ラップタイムの記録を全て破棄する
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    clearLap: function () {
        this._laps = {};
        
        return this;
    },
    
    /**
     * インターバルを記録する
     * 
     * @param {String} [key] 任意の記録キーを指定したい場合に引き渡す(デフォルトは現在の記録数)
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    interval: function (key) {
        if ( ! this._active) {
            return this;
        }
        
        if ( ! key) {
            key = Jeeel.Hash.getCount(this._interval);
        }
        
        var t = this._date.getElapsedTime();
        
        this._interval[key] = (this._interval[key] || 0) + t - this._lastTime;
        
        this._lastTime = t;
        
        return this;
    },
    
    /**
     * インターバルの記録を取得する
     * 
     * @param {String} key 読み込みたいインターバルのキー
     * @return {Integer} インターバル
     */
    loadInterval: function (key) {
        return this._interval[key];
    },
    
    /**
     * インターバルの記録を全て取得する
     * 
     * @return {Hash} インターバルとそのキーのペアリスト
     */
    loadAllInterval: function () {
        return this._interval;
    },
    
    /**
     * インターバルの記録を全破棄する
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    clearInterval: function () {
        this._interval = {};
        this._lastTime = 0;
        
        return this;
    }
};

/**
 * コンソールを管理するスタティッククラス
 */
Jeeel.Debug.Console = {

    /**
     * コンソールの識別子
     *
     * @type String
     * @constant
     */
    CONSOLE_ID: 'jeeel-debug-console',

    /**
     * コンソールログの識別子
     *
     * @type String
     * @constant
     */
    CONSOLE_LOG_ID: 'jeeel-debug-console-log',
    
    /**
     * コンソールキーボードの識別子
     * 
     * @type String
     * @constant
     */
    CONSOLE_KEYBOARD_ID: 'jeeel-debug-console-keyboard',

    /**
     * コンソール実行結果の識別子
     *
     * @type String
     * @constant
     */
    CONSOLE_RESULT_ID: 'jeeel-debug-console-res',

    /**
     * コンソールの関数補完識別子
     *
     * @type String
     * @constant
     */
    CONSOLE_CODE_ASSIST_ID: 'jeeel-debug-console-code-assist',

    /**
     * コンソール
     *
     * @type Element
     * @private
     */
    _console: null,

    /**
     * コンソール入力部
     *
     * @type Jeeel.Dom.Element.Textarea
     * @private
     */
    _consoleIn: null,
    
    /**
     * コンソールキーボード
     * 
     * @type Element
     * @private
     */
    _consoleKeyboard: null,

    /**
     * コンソール出力部
     *
     * @type Element
     * @private
     */
    _consoleOut: null,

    /**
     * コンソール関数補完ウィンドウ
     *
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _consoleCodeAssistWindow: null,

    /**
     * コンソールログの現在のポジション
     *
     * @type Integer
     * @private
     */
    _consolePosition: 0,

    /**
     * コンソールのログ
     *
     * @type String[]
     * @private
     */
    _consoleLog: [],

    /**
     * コンソールの実行結果
     *
     * @type Element[]
     * @private
     */
    _consoleResult: [],
    
    /**
     * コンソールの保存媒体
     * 
     * @type Jeeel.Session.Name
     */
    _consoleSession: null,
    
    _isSingleLineMode: true,

    /**
     * Html要素の展開及び操作を行うモードかどうかを示す
     *
     * @type Boolean
     * @private
     */
    _useHtmlExplorer: true,

    /**
     * 関数補完に使用するデータ
     *
     * @type Hash
     * @private
     */
    _codeAssistData: {
        use: true,
        
        /**
         * 補完Windowの子リストを収めたElementラッパー
         * 
         * @type Jeeel.Dom.ElementOperator
         */
        winChild: null,
        
        /**
         * 使用中かどうか
         * 
         * @type Boolean
         */
        enable: false,
        
        /**
         * ウィンドウが表示中かどうか
         * 
         * @type Boolean
         */
        show: false,
        
        /**
         * 次のデータ更新をキャンセルするかどうか
         * 
         * @type Boolean
         */
        cancel: false,
        
        /**
         * 親要素
         * 
         * @type String
         */
        parent: '',
        
        /**
         * 子要素
         * 
         * @type String
         */
        child: '',
        
        /**
         * 補完した際に書き換えを行うインデックス
         * 
         * @type Interger
         */
        index: 0,
        
        /**
         * 補完した際の選択中のデータのインデックス
         * 
         * @type Interger
         */
        selectIndex: -1,
        
        /**
         * 現在補完している要素のキーと値のペアリストを保持する配列
         * 
         * @type Jeeel.Object.Item[]
         */
        pairs: [],
        
        /**
         * 現在補完している要素のキーを保持する配列
         * 
         * @type String[]
         */
        keys: [],
        
        /**
         * 検索が完了したキャッシュ
         * 
         * @type Hash
         */
        cache: {}
    },

    /**
     * 簡易コンソールを生成する<br />
     * 以下操作方法<br />
     * 単数行モード<br />
     * <ul>
     *   <li>Enterで実行</li>
     *   <li>上下で履歴</li>
     *   <li>Ctrl+Mで複数行モードに切り替え</li>
     *   <li>結果がオブジェクトの場合は矢印をクリックで展開</li>
     * </ul><br />
     * 複数行モード<br />
     * <ul>
     *   <li>Ctrl+Enterで実行</li>
     *   <li>Ctrl+上下で履歴</li>
     *   <li>Ctrl+Mで複数行モードに切り替え</li>
     *   <li>結果がオブジェクトの場合は矢印をクリックで展開</li>
     * </ul>
     */
    create: function () {

        if (arguments.callee.ignore) {
            return;
        }
        
        // thisをbind
        for (var property in this) {
            if (Jeeel.Type.isFunction(this[property])) {
                this[property] = Jeeel.Function.simpleBind(this[property], this);
            }
        }

        arguments.callee.ignore = true;

        this._setStyle();

        var div = Jeeel.Document.createElement('div');
        div.innerHTML = '<textarea style="height: 25px;" id="' + this.CONSOLE_LOG_ID + '"></textarea>\n'
                      + '<div id="' + this.CONSOLE_KEYBOARD_ID + '"></div>\n'
                      + '<div id="' + this.CONSOLE_RESULT_ID + '"></div>\n'
                      + '<div style="display: none;" id="' + this.CONSOLE_CODE_ASSIST_ID + '"></div>';

        div.id = this.CONSOLE_ID;
        this._console = Jeeel.Debug.Debugger.elementInsertTop(div);

        var self = this;
        var session = Jeeel.Session.Name.create();

        this._consoleSession = session.setExpires(-1);
        
        this._consoleIn  = Jeeel.Dom.Element.Textarea.create(Jeeel.Document.getElementById(this.CONSOLE_LOG_ID));
        this._consoleOut = Jeeel.Document.getElementById(this.CONSOLE_RESULT_ID);
        this._consoleKeyboard = Jeeel.Document.getElementById(this.CONSOLE_KEYBOARD_ID);
        this._consoleCodeAssistWindow = Jeeel.Dom.ElementOperator.create(Jeeel.Dom.Element.create(Jeeel.Document.getElementById(this.CONSOLE_CODE_ASSIST_ID)).setBackgroundIframe());

        this._consoleLog    = session.get(this.CONSOLE_LOG_ID, []);
        this._consoleResult = Jeeel.Filter.Array.Fill.create(0, this._consoleLog.length, null).filter([]);
        this._initKeyboard();

        this._consolePosition = this._consoleLog.length;
        
        var singleLine, multiLine;

        var setEvent = function (listener) {
            if (Jeeel.UserAgent.isOpera()) {
                self._consoleIn.getElement()['on' + Jeeel.Dom.Event.Type.KEY_PRESS] =listener;
            } else {
                self._consoleIn.getElement()['on' + Jeeel.Dom.Event.Type.KEY_DOWN] = listener;
            }
            
            self._isSingleLineMode = listener === singleLine;
        };

        singleLine = function () {
            var e = Jeeel.Dom.Event.getEventObject();
            var keyCode = e.getKeyCode();
            var timeoutId;

            if (self._codeAssistData.use) {
                if (Jeeel.Type.inArray(keyCode, [Jeeel.Code.KeyCode.Space, Jeeel.Code.KeyCode.LeftBracket, Jeeel.Code.KeyCode.RightBracket])) {
                    self._codeAssistDataClose();
                } else if (self._codeAssistData.enable || Jeeel.Type.inArray(keyCode, [Jeeel.Code.KeyCode.Period, Jeeel.Code.KeyCode.BackSpace]) || ! self._consoleIn.getText()) {
                    timeoutId = Jeeel.Timer.setTimeout(self._setCodeAssistData, 1);
                }
            }

            if (keyCode === Jeeel.Code.KeyCode.Enter) {

                e.stop();

                self._evalConsoleText();
                
                return false;
                
            } else if (Jeeel.Type.inArray(keyCode, [Jeeel.Code.KeyCode.Up, Jeeel.Code.KeyCode.PageUp])) {

                e.stop();

                self._consoleUp();
                
                Jeeel.Timer.clearTimeout(timeoutId);

                return false;
                
            } else if (Jeeel.Type.inArray(keyCode, [Jeeel.Code.KeyCode.Down, Jeeel.Code.KeyCode.PageDown])) {
                
                e.stop();

                self._consoleDown();
                
                Jeeel.Timer.clearTimeout(timeoutId);

                return false;
                
            } else if (self._codeAssistData.enable && keyCode === Jeeel.Code.KeyCode.Tab) {
                e.stop();

                if (e.shiftKey) {
                    self._consoleUp();
                } else {
                    self._consoleDown();
                }
                
                Jeeel.Timer.clearTimeout(timeoutId);

                return false;
                
            } else if (keyCode === Jeeel.Code.KeyCode.M && e.ctrlKey) {

                e.stop();

                self._consoleIn.getStyle().height = '75px';
                setEvent(multiLine);
                
                self._codeAssistDataClose(true);
                
                Jeeel.Dom.Element.create(self._consoleOut).hide().show();

                return false;
            } else if (keyCode === Jeeel.Code.KeyCode.Shift) {
                e.stop();
                
                Jeeel.Timer.clearTimeout(timeoutId);

                return false;
            }

            return true;
        };

        multiLine = function () {
            var e = Jeeel.Dom.Event.getEventObject();
            var keyCode = e.getKeyCode();
            
            if (e.ctrlKey) {
                if (keyCode === Jeeel.Code.KeyCode.Enter) {

                    e.stop();

                    self._evalConsoleText();

                    return false;

                } else if (Jeeel.Type.inArray(keyCode, [Jeeel.Code.KeyCode.Up, Jeeel.Code.KeyCode.PageUp])) {

                    e.stop();

                    self._consoleUp();

                    return false;

                } else if (Jeeel.Type.inArray(keyCode, [Jeeel.Code.KeyCode.Down, Jeeel.Code.KeyCode.PageDown])) {

                    e.stop();

                    self._consoleDown();

                    return false;

                } else if (keyCode === Jeeel.Code.KeyCode.M) {

                    e.stop();

                    self._consoleIn.getStyle().height = '25px';
                    setEvent(singleLine);
                    self._setConsoleText(self._consoleIn.replace(/\r\n|\n/g, ' '));
                    
                    Jeeel.Dom.Element.create(self._consoleOut).hide().show();

                    return false;
                }
            }

            return true;
        };

        setEvent(singleLine);
    },

    /**
     * コンソール出力に値を表示する<br />
     * 履歴には残らない
     *
     * @param {Mixied} var_args 表示する値の可変引数
     * @return {Array} 表示する値をそのまま返す
     */
    log: function (var_args) {
        Jeeel.Debug.Console.create();

        var logs = Array.prototype.slice.call(arguments, 0, arguments.length);

        Jeeel.Debug.Console._addResult(logs);

        return logs;
    },

    /**
     * コンソールの履歴等を全て破棄する
     */
    clear: function () {
        this._consoleLog = this._consoleResult = [];
        this._consolePosition = 0;
        this._setConsoleText('');
        
        Jeeel.Dom.ElementOperator.create(this._consoleOut.childNodes).remove();

        this._consoleSession.set(this.CONSOLE_LOG_ID, [])
                            .save();
    },

    /**
     * コンソールの履歴を返す
     *
     * @param {Integer} index 履歴番号
     * @return {String} 結果値
     */
    getLog: function (index) {
        if (0 <= index && index < this._consoleLog.length) {
            return this._consoleLog[index];
        }

        return null;
    },

    /**
     * コンソールの結果履歴を全て返す
     *
     * @return {String[]} 結果値のリスト
     */
    getLogAll: function () {
        return this._consoleLog;
    },

    /**
     * HTML操作、閲覧機能の有効にするかどうかを設定する
     *
     * @param {Boolean} enable 有効にするかどうか
     */
    enableHtmlExplorer: function (enable) {
        this._useHtmlExplorer = !!enable;
    },
    
    /**
     * コード補完を有効にするかどうかを設定する
     * 
     * @param {Boolean} enable 有効にするかどうか
     */
    enableCodeAssist: function (enable) {
        this._codeAssistData.use = !!enable;
        
        if ( ! enable) {
            this._codeAssistDataClose(true);
        }
    },

    /**
     * コンソールを上部に移動する(デフォルト)
     */
    moveTop: function () {
        Jeeel.Debug.Debugger.elementInsertTop(this._console);
    },

    /**
     * コンソールを下部に移動する
     */
    moveBottom: function () {
        Jeeel._doc.body.appendChild(this._console);
    },

    /**
     * コンソールに対するスタイルの設定を行う
     */
    _setStyle: function () {
        if (arguments.callee.ignore) {
            return;
        }

        arguments.callee.ignore = true;

        var css = 'div#' + this.CONSOLE_ID + ' {\n'
                + '    background-color: white;\n'
                + '    text-align: left;\n'
                + '    font-family: "Arial", "Times New Roman", "Courier New", "Courier", cursive;\n'
                + '}\n'
                + 'textarea#' + this.CONSOLE_LOG_ID + ' {\n'
                + '    width: 99.3%;\n'
                + '    font-size: 20px;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_RESULT_ID + ' {\n'
                + '    background-color: white;\n'
                + '    text-align: left;\n'
                + '    width: 100%;\n'
                + '    height: auto;\n'
                + '    font-size:15px;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_KEYBOARD_ID + ' {\n'
                + '    background-color: white;\n'
                + '    width: 100%;\n'
                + '    height: 25px;\n'
                + '    display: none;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_KEYBOARD_ID + ' .button {\n'
                + '    cursor: pointer;\n'
                + '    text-align: center;\n'
                + '    float: left;'
                + '    width: 25px;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_CODE_ASSIST_ID + ' {\n'
                + '    font-size: 15px;\n'
                + '    text-align: left;\n'
                + '    overflow: auto;\n'
                + '    border: solid 1px gray;\n'
                + '    z-index: 200;\n'
                + '    position: absolute;\n'
                + '    left: 200px;\n'
                + '    top: 40px;\n'
                + '    overflow-x: hidden;\n'
                + '    overflow-y: auto;\n'
                + '    background-color: white;\n'
                + '    max-height: 210px;\n'
                + '    _height: 210px;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_CODE_ASSIST_ID + ' div {\n'
                + '    padding: 2px;\n'
                + '    cursor: pointer;\n'
                + '}';

        Jeeel.Loader.addStyle(css);
    },

    /**
     * コンソール入力部にテキストをセットする
     *
     * @param {String} text 設定値
     * @private
     */
    _setConsoleText: function (text) {

        this._codeAssistDataClose();
        this._consoleIn.setText(text);
    },
    
    /**
     * thisをbindして実行を行う
     * 
     * @param {String} _$txt$_ 実行文字列
     * @return {Mixied} 実行結果
     */
    _eval: function (_$txt$_) {
        // eval中に使える関数の定義
        var clear = this.clear;
        var enableCodeAssist = this.enableCodeAssist;
        var enableHtmlExplorer = this.enableHtmlExplorer;
        
        // 先頭のvar宣言は自動的にグローバル宣言に切り替える
        _$txt$_ = _$txt$_.replace(/^ *var +([a-zA-Z$_][a-zA-Z0-9$_]*) *= */g, "this['$1'] = ");
        
        return (function (){
            return eval(_$txt$_);
        }).call(Jeeel._global);
    },
    
    /**
     * コンソールの文字列をスクリプトとして実行し結果を保持する
     */
    _evalConsoleText: function () {
        if (this._codeAssistData.show) {
            this._selectCodeAssistDataExecute();
            return;
        }
        
        if ( ! this._consoleIn.getText()) {
            return;
        }
        
        var tmp;

        try {
            tmp = this._eval(this._consoleIn.getText());
        } catch (e) {
            tmp = e;
        }

        this._addResult(tmp);

        this._consolePosition = this._consoleLog.length;

        this._consoleResult[this._consolePosition] = tmp;
        this._consoleLog[this._consolePosition] = this._consoleIn.getText();

        this._consoleSession.set(this.CONSOLE_LOG_ID, this._consoleLog).save();

        this._consolePosition++;

        this._setConsoleText('');
    },
    
    /**
     * コンソールの履歴ポジションを上に一つ上げる
     */
    _consoleUp: function () {
        if (this._codeAssistData.show) {
            this._selectCodeAssistData(1);
            return;
        }
        
        if (this._consoleLog.length == 0) {
            return;
        }

        this._consolePosition--;

        if (this._consolePosition < 0) {
            this._consolePosition = 0;
        }
        
        var txt = this._consoleLog[this._consolePosition];
        
        this._setConsoleText(this._isSingleLineMode ? txt.replace(/\r\n|\n/g, ' ') : txt);
    },
    
    /**
     * コンソールの履歴ポジションを下に一つ下げる
     */
    _consoleDown: function () {
        if (this._codeAssistData.show) {
            this._selectCodeAssistData(-1);
            return;
        }
      
        if (this._consoleLog.length == 0) {
            return;
        }

        this._consolePosition++;

        if (this._consolePosition > this._consoleLog.length) {
            this._consolePosition = this._consoleLog.length;
        }

        if (this._consolePosition < this._consoleLog.length) {
            var txt = this._consoleLog[this._consolePosition];

            this._setConsoleText(this._isSingleLineMode ? txt.replace(/\r\n|\n/g, ' ') : txt);
        } else {
            this._setConsoleText('');
        }
    },

    /**
     * 結果を展開できる状態にする
     *
     * @param {Mixied} obj 展開する結果値
     * @private
     */
    _addResult: function (obj) {
        var res = Jeeel.Debug.ObjectExpander.expand(obj, this._useHtmlExplorer);

        if (this._consoleOut.firstChild) {
            var hr = Jeeel.Document.createElement('hr');
            this._consoleOut.appendChild(hr);
        }
        
        this._consoleOut.appendChild(res);
    },

    /**
     * コード補完のデータを初期化して終了させる
     * 
     * @param {Boolean} [cancel] この後の動作キャンセルを行うかどうか
     */
    _codeAssistDataClose: function (cancel) {
        var caData = this._codeAssistData;
        
        caData.selectIndex = -1;
        caData.enable = false;
        caData.cancel = !!cancel;
        
        this._codeAssistWindowHide();
    },
    
    /**
     * コード補完ウィンドウを表示させる
     */
    _codeAssistWindowShow: function () {
        var left = this._codeAssistData.index * 10 + 20;
        
        this._consoleCodeAssistWindow.shiftTo(left, 40);
        
        this._consoleCodeAssistWindow.show();
        this._codeAssistData.show = true;
    },
    
    /**
     * コード補完ウィンドウを非表示にする
     */
    _codeAssistWindowHide: function () {
        this._consoleCodeAssistWindow.hide();
        this._codeAssistData.show = false;
    },
    
    /**
     * コード補完に必要なデータを更新する
     */
    _setCodeAssistData: (function () {
        var txtReg = /(^|[;:{}(\[\] ])([a-zA-Z$_][a-zA-Z0-9$_.]*)\.(|[a-zA-Z$_][a-zA-Z0-9$_]*)$/;
        var idxReg = /\.(|[a-zA-Z$_][a-zA-Z0-9$_]*)$/;
        var rf = new Jeeel.Filter.RegularExpressionEscape();
        var appendKeys = [
            'var',
            'function',
            'return',
            'delete',
            'in',
            'typeof',
            'instanceof',
            'for',
            'do',
            'while',
            'switch',
            'case',
            'break',
            'continue',
            'if',
            'else',
            'else if',
            'with'
        ];
        
        return function () {
            var caData = this._codeAssistData;

            if (caData.cancel) {
                caData.cancel = false;
                return;
            }

            var txt = this._consoleIn.getText();
            var appendThis = false;
            
            if ( ! txt) {
                this._codeAssistDataClose();
                return;
            }
            
            if (txt.indexOf('.') < 0) {
                appendThis = true;
                txt = 'this.' + txt;
            }

            var tmp = txt.match(txtReg);
            var index = txt.search(idxReg) + 1 - (appendThis ? 5 : 0);

            if ( ! tmp) {
                this._codeAssistDataClose();
                return;
            }

            caData.enable = false;
            caData.child  = tmp[3];

            if (caData.parent != tmp[2] || ! appendThis && tmp[2] === 'this') {
                if (false && caData.cache[tmp[2]]) {
                    var cache = this._codeAssistData.cache[tmp[2]];

                    caData = this._codeAssistData = Jeeel.Hash.merge(caData, cache);
                }
                else {
                    caData.parent = tmp[2];

                    try {
                        var target = this._eval(caData.parent);
                    } catch(e) {
                        this._codeAssistWindowHide();
                        return;
                    }

                    try {
                        caData.pairs = Jeeel.Hash.getPairs(target, true);
                    } catch(e) {
                        this._codeAssistDataClose(true);
                        return;
                    }
                    
                    var pairs = caData.pairs;
                    
                    if (appendThis) {
                        pairs[pairs.length] = new Jeeel.Object.Item('clear', this.clear);
                        pairs[pairs.length] = new Jeeel.Object.Item('enableCodeAssist', this.enableCodeAssist);
                        pairs[pairs.length] = new Jeeel.Object.Item('enableHtmlExplorer', this.enableHtmlExplorer);
                        
                        for (i = 0, l = appendKeys.length; i < l; i++) {
                            pairs[pairs.length] = new Jeeel.Object.Item(appendKeys[i], null);
                        }
                    }
                    
                    caData.cache[tmp[2]] = {
                        parent: tmp[2],
                        pairs: caData.pairs
                    };
                }
            }

            if (caData.pairs.length < 1) {
                this._codeAssistWindowHide();
                return;
            }

            caData.selectIndex = -1;
            caData.index  = index;
            caData.enable = true;

            var i, l, keys = [];

            if (caData.child) {

                var regVal = rf.filter(caData.child);

                var reg = new RegExp('^' + regVal);

                for (i = 0, l = caData.pairs.length; i < l; i++) {

                    if ( ! caData.pairs[i].key.match(reg)) {
                        continue;
                    }

                    keys[keys.length] = caData.pairs[i].key;
                }
            } else {
                for (i = 0, l = caData.pairs.length; i < l; i++) {
                    keys[keys.length] = caData.pairs[i].key;
                }
            }

            caData.keys = keys;

            if (keys.length < 1) {
                this._codeAssistWindowHide();
                return;
            }

            var elm = this._consoleCodeAssistWindow;
            var divs = [];
            var self = this;

            if (caData.winChild) {
                caData.winChild.remove();
            }

            for (i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                var div = Jeeel.Document.createElement('div');
                div.innerHTML = key;

                div.onclick = function () {
                    self._replaceLog(arguments.callee.data);
                };

                div.onclick.data = key;

                divs[i] = div;
            }

            caData.winChild = new Jeeel.Dom.ElementOperator(divs);

            elm.appendChild(divs);
            this._codeAssistWindowShow();
        }
    })(),
    
    _setCodeData: function (index, divs) {
        var self = this;
        var key = this._codeAssistData.keys[index];
        var div = this._codeAssistData.winChild[index] || Jeeel.Document.createElement('div');
        div.innerHTML = key;

        div.onclick = function () {
            self._replaceLog(arguments.callee.data);
        };

        div.onclick.data = key;

        divs[index] = div;
    },
    
    /**
     * コード補完の候補を選択する
     */
    _selectCodeAssistData: function (advanceIndex) {
        var caData = this._codeAssistData;
        var index = caData.selectIndex - advanceIndex;
        
        if (index < 0) {
            index = caData.keys.length - 1;
        } else if (index >= caData.keys.length) {
            index = 0;
        }
        
        if (index === caData.selectIndex) {
            return;
        }
        
        caData.winChild.$GET(caData.selectIndex).setCss('backgroundColor', '#FFF');
        
        caData.winChild.$GET(index).setCss('backgroundColor', '#FFD700');
//        caData.winChild.$GET(index).get().;
        
        caData.selectIndex = index;
    },
    
    /**
     * 選択されているコード補完候補を使用して適用する
     */
    _selectCodeAssistDataExecute: function () {
        var caData = this._codeAssistData;
        var index = caData.selectIndex;
        
        if (caData.keys.length === 0) {
            return;
        } else if (index < 0) {
            index = 0;
        } else if(index >= caData.keys.length) {
            return;
        }
        
        caData.winChild[index].onclick();
        caData.cancel = true;
    },

    /**
     * 補完データを選択した時に現在の値を書き換える
     */
    _replaceLog: function (key) {
        var txt = this._consoleIn.getText();

        txt = txt.substring(0, this._codeAssistData.index) + key;

        this._setConsoleText(txt);

        this._consoleIn.setSelectionStart(txt.length);
    },
    
    _initKeyboard: function () {
        var keyboard = this._consoleKeyboard;
        
        var keyInputer = Jeeel.Document.createElement('div');
        var consoleOperator = Jeeel.Document.createElement('div');
        
        var button, type, keyTypes = [
//            {txt: '{' , dispatch: function (){}},
//            {txt: '}' , key: Jeeel.Code.KeyCode.RightBracket, shift: true, ctrl: false},
//            {txt: '[' , key: Jeeel.Code.KeyCode.LeftBracket, shift: false, ctrl: false},
//            {txt: ']' , key: Jeeel.Code.KeyCode.RightBracket, shift: false, ctrl: false}
        ], operatorTypes = [
            {txt: '↑' , dispatch: function (){this._consoleUp();}},
            {txt: '↓' , dispatch: function (){this._consoleDown();}}
        ];
        
        var self = this, consoleIn = this._consoleIn.getElement();
        
        for (var i = 0; i < keyTypes.length; i++) {
            type = keyTypes[i];
            
            button = Jeeel.Document.createElement('div');
            button.innerHTML = type.txt;
            button.onclick = function () {
                var op = new Jeeel.Dom.Event.Option();
                op.setKeyCodeArg(type.key)
                  .setCtrlKeyArg(type.ctrl)
                  .setShiftKeyArg(type.shift);
                
                Jeeel.Dom.Event.dispatchEvent(consoleIn, Jeeel.Dom.Event.Type.KEY_DOWN, op);
            };
            
            keyInputer.appendChild(button);
        }
        
        for (var i = 0; i < operatorTypes.length; i++) {
            type = operatorTypes[i];
            
            button = Jeeel.Document.createElement('div');
            button.className = 'button';
            button.innerHTML = type.txt;
            button.onclick = function () {
                arguments.callee.type.dispatch.call(self);
                Jeeel.Dom.Event.getEventObject().stop();
            };
            
            button.onclick.type = type;
            
            consoleOperator.appendChild(button);
        }
        
        keyboard.appendChild(keyInputer);
        keyboard.appendChild(consoleOperator);
    },
    
    _appendLogText: function (appendText) {
        
        var txt = this._consoleIn.getText() + appendText;
        
        this._setConsoleText(txt);

        this._consoleIn.setSelectionStart(txt.length);
    }
};
Jeeel.directory.Jeeel.Debug.Profiler = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Debug + 'Profiler/';
    }
};

/**
 * メソッドのプロファイリング機能を提供するスタティッククラス
 */
Jeeel.Debug.Profiler = {
  
    /**
     * メソッドの呼び出しの際に一時的に借りる名前
     *
     * @type String
     * @constant
     */
    TEMPORARY_METHOD_NAME: '@JEEEL-METHOD@',
    
    /**
     * プロファイルが完了しているものに対してチェックと入れるためのキー
     * 
     * @type String
     * @constant
     */
    PROFILE_CHECK_NAME: '@PROFILE-CHECK@',
    
    /**
     * メソッド実行ログ
     * 
     * @type Jeeel.Debug.Profiler.Profile[]
     * @private
     */
    _logs: [],
    
    /**
     * 1メソッドが現在までの掛かった時間の総合計
     * 
     * @type Hash
     * @private
     */
    _times: {},
    
    /**
     * 1メソッドが現在までに呼ばれた回数
     * 
     * @type Hash
     * @private
     */
    _counts: {},
    
    /**
     * 現在呼び出されているメソッドのチェイン階層
     * 
     * @type Integer
     * @private
     */
    _hierarchy: 0,
    
    /**
     * 現在アクセス中のデータ
     * 
     * @type Jeeel.Debug.Profiler.Profile
     * @private
     */
    _accessData: null,
    
    /**
     * メソッド呼び出しの書き込みデータ
     * 
     * @type Jeeel.Debug.Profiler.Profile
     * @private
     */
    _data: null,
    
    /**
     * 指定したオブジェクト以下のメソッドをプロファイリング対象にする
     * 
     * @param {Object} object プロファイリング対象のメソッドを保持するオブジェクト
     * @param {String} name オブジェクトの名前
     * @param {Boolean} [deepSet] オブジェクトのプロパティに対して再帰的にプロファイリングするかどうか
     * @return {Jeeel.Debug.Profiler} 自クラス
     */
    profiling: function (object, name, deepSet) {
      
        if ( ! object || object === this) {
            return this;
        }
        
        var type = typeof object;
        
        if (type !== 'object' && type !== 'function') {
            return this;
        } else if ('nodeType' in object) {
            return this;
        } else if ('Object' in object && 'Array' in object && 'String' in object && 'Number' in object && 'Boolean' in object && 'Function' in object) {
            return this;
        } else if ( ! object.hasOwnProperty || object.hasOwnProperty(this.PROFILE_CHECK_NAME) && object[this.PROFILE_CHECK_NAME]) {
            return this;
        }
        
        object[this.PROFILE_CHECK_NAME] = name;
        
        var property;
        
        for (var propertyName in object) {
            try {
                property = object[propertyName];
            } catch (e) {
                continue;
            }
            
            if ( ! property || propertyName === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            } else if ( ! property.hasOwnProperty || property.hasOwnProperty(this.PROFILE_CHECK_NAME) && property[this.PROFILE_CHECK_NAME]) {
                continue;
            }
            
            var fullName = (arguments[3] ? name + '#' + propertyName : name + '.' + propertyName);
            var propertyType = typeof property;
            
            if (deepSet) {
                this.profiling(property, fullName, deepSet);
            }

            if (property instanceof Function && ! property.toString().match(/\{(\n|\s)+\[native code\](\n|\s)+\}/)) {
                object[propertyName] = this._getProfilingClosure(name, propertyName, fullName, object, property);
                
                for (var key in property) {
                    try {
                        object[propertyName][key] = property[key];
                    } catch (e) {
                        continue;
                    }
                }
                
                object[propertyName].prototype = property.prototype;
                
                object[propertyName][this.PROFILE_CHECK_NAME] = fullName;
            }
        }
        
        if (deepSet && object instanceof Function) {
            this.profiling(object.prototype, name, deepSet, true);
        }
        
        return this;
    },
    
    /**
     * 現在までに呼び出されたメソッドのプロファイルを全て取得する
     * 
     * @return {Jeeel.Debug.Profiler.ProfileManager} プロファイル管理オブジェクト
     */
    getProfiles: function () {
        var manager = new this.ProfileManager();
        
        for (var i = 0, l = this._logs.length; i < l; i++) {
            manager.addProfile(this._logs[i]);
        }
        
        return manager;
    },
    
    getAverageProfileHash: function (compareFunction) {
        var methodName,
            avg, 
            tmp = [],
            res = {};

        for (var methodName in this._times) {
            if (methodName === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }

            avg = this._times[methodName] / this._counts[methodName];
            tmp[tmp.length] = [methodName, avg];
        }
        
        tmp.sort(compareFunction || function (a, b) {
            return b[1] - a[1];
        });
        
        for (var i = 0, l = tmp.length; i < l; i++) {
            res[tmp[i][0]] = tmp[i][1];
        }

        return res;
    },
    
    /**
     * 現在までの呼び出されたメソッドの平均呼び出し時間のプロファイルを取得する
     * 
     * @return {Jeeel.Debug.Profiler.ProfileManager} プロファイル管理オブジェクト
     */
    getAverageProfiles: function () {
        var manager = new this.ProfileManager();
        
        if ( ! this._logs.length) {
            return manager;
        }
        
        var avg, methodName;
        
        for (methodName in this._times) {
            if (methodName === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }
            
            avg = this._times[methodName] / this._counts[methodName];
            manager.addProfile(new this.Profile(methodName, avg));
        }
        
        return manager;
    },
    
    /**
     * 現在までに収集したプロファイルの中から一番時間がかかっているプロファイルを取得する
     * 
     * @return {Jeeel.Debug.Profiler.Profile} 最遅のメソッドプロファイル
     */
    getBottleneckProfile: function () {
        if ( ! this._logs.length) {
            return null;
        }
        
        var max = this._logs[0].time,
            l = this._logs.length,
            i = 1,
            j = 0;

        for (; i < l; i++) {
            if (max < this._logs[i].time) {
                max = this._logs[i].time;
                j = i;
            }
        }
        
        return this._logs[j];
    },
    
    /**
     * 現在までに呼び出されたメソッドの中で平均で一番時間が掛かっているメソッドのプロファイルを取得する
     * 
     * @return {Jeeel.Debug.Profiler.Profile} 平均が最遅のメソッドプロファイル
     */
    getBottleneckAverageProfile: function () {
        if ( ! this._logs.length) {
            return null;
        }
        
        var first = true,
            max, 
            avg, 
            key;

        for (var methodName in this._times) {
            if (methodName === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }
            
            avg = this._times[methodName] / this._counts[methodName];
            
            if (first) {
                max = avg;
                key = methodName;
                first = false;
            } else if (max < this._times[methodName]) {
                max = avg;
                key = methodName;
            }
        }
        
        return new this.Profile(key, max);
    },
    
    /**
     * プロファイリングのためのクロージャを取得する
     * 
     * @param {String} name メソッドの持ち主の名前
     * @param {String} property メソッド自身の名前
     * @param {String} fullName メソッドのネームスペース・クラスネームを含めた名前
     * @param {Object} owner メソッドの持ち主
     * @param {Function} func メソッド
     * @return {Function} プロファイリングクロージャ
     * @private
     */
    _getProfilingClosure: function (name, property, fullName, owner, func) {
        var self = this;
        
        return function () {
            var tmp,
                res, 
                time;

            if ( ! self._hierarchy) {
                self._accessData = self._data = new self.Profile(fullName);
            } else {
                tmp = self._accessData;

                self._accessData = tmp.calls[tmp.calls.length] = new self.Profile(fullName);
            }

            self._hierarchy++;

            time = (new Date()).getTime();

            try {
                
                // このクロージャインスタンスだったらインスタンスの作成を行う
                if (this instanceof arguments.callee) {
                  
                    owner[self.TEMPORARY_METHOD_NAME] = func;
                    
                    // 引数が5つまでは高速化のために直接記述
                    switch (arguments.length) {
                        case 0:
                            res = new owner[self.TEMPORARY_METHOD_NAME]();
                            break;
                            
                        case 1:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0]);
                            break;
                            
                        case 2:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0], arguments[1]);
                            break;
                            
                        case 3:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0], arguments[1], arguments[2]);
                            break;
                            
                        case 4:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0], arguments[1], arguments[2], arguments[3]);
                            break;
                            
                        case 5:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                            break;
                            
                        default:
                            res = (function (obj, methodName) {
                                methodName = 'new this["' + methodName + '"]';

                                return function () {
                                    var params = [];

                                    for (var i = arguments.length; i--;) {
                                        params[i] = "_" + i;
                                    }

                                    params = params.join(',');

                                    return Function(
                                        params,
                                        'return ' + methodName + '(' + params + ')'
                                    ).apply(obj, arguments);
                                };
                            })(owner, self.TEMPORARY_METHOD_NAME).apply(null, arguments);                
                            break;
                    }
                    
                    delete owner[self.TEMPORARY_METHOD_NAME];
                    
                } else {
                    res = func.apply(this, arguments);
                }
                
            } catch (e) {
                
                // エラー補足のための補助をする
                if ( ! e.jeeelStackTrace) {
                    e.jeeelStackTrace = [];
                }
                
                e.jeeelStackTrace[e.jeeelStackTrace.length] = fullName;
                
                throw e;
                
            } finally {
                time = (new Date()).getTime() - time;

                self._hierarchy--;

                if ( ! self._times[fullName]) {
                    self._counts[fullName] = 0;
                    self._times[fullName] = 0;
                }

                self._counts[fullName]++;
                self._times[fullName] += time;

                if ( ! self._hierarchy) {
                    self._data.time = time;

                    self._logs[self._logs.length] = self._data;
                } else {
                    self._accessData.time = time;
                    self._accessData = tmp;
                }
            }

            return res;
        };
    }
};

Jeeel.file.Jeeel.Debug.Profiler = ['Profile', 'ProfileManager'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Debug.Profiler, Jeeel.file.Jeeel.Debug.Profiler);
/**
 * コンストラクタ
 * 
 * @class プロファイル結果を保持するクラス
 * @param {String} methodName メソッド名
 * @param {Number} [time] メソッドの実行に掛かった時間
 */
Jeeel.Debug.Profiler.Profile = function (methodName, time) {
    var self = this;
    
    self.method = methodName;
    self.time = time || 0;
    self.calls = [];
};

Jeeel.Debug.Profiler.Profile.prototype = {
    /**
     * メソッド名
     * 
     * @type String
     */
    method: '',
    
    /**
     * このメソッドに処理に掛かった時間(ミリ秒)
     * 
     * @type Number
     */
    time: 0,
    
    /**
     * メソッド内で呼び出しを行ったメソッドのリスト
     * 
     * @type Jeeel.Debug.Profiler.Profile[]
     */
    calls: [],
    
    /**
     * このメソッド内で一番時間が掛かっているものを取得する
     * 
     * @param {Boolean} [deepGet] 再帰的に内部メソッドのボトルネックを取得するかどうか
     * @return {Jeeel.Debug.Profiler.Profile} 取得したプロファイル
     */
    getBottleneck: function (deepGet) {
        if ( ! this.calls.length) {
            return this;
        }
        
        var max = this.calls[0].time,
            l = this.calls.length,
            i = 1,
            j = 0;

        for (; i < l; i++) {
            if (max < this.calls[i].time) {
                max = this.calls[i].time;
                j = i;
            }
        }
        
        if (deepGet) {
            return this.calls[j].getBottleneck(deepGet);
        }
        
        return this.calls[j];
    },
    
    /**
     * このメソッド名を取得する
     * 
     * @return {String} メソッド名
     */
    toString: function () {
        return this.method;
    },
    
    /**
     * このメソッドに掛かった時間を取得する
     * 
     * @return {Integer} 掛かった時間
     */
    valueOf: function () {
        return this.time;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Debug.Profiler.Profile
};
/**
 * コンストラクタ
 * 
 * @class プロファイル管理クラス
 */
Jeeel.Debug.Profiler.ProfileManager = function () {
    this._profiles = [];
};

Jeeel.Debug.Profiler.ProfileManager.prototype = {
  
    /**
     * 管理プロファイルリスト
     * 
     * @type Jeeel.Debug.Profiler.Profile[]
     * @private
     */
    _profiles: [],
    
    /**
     * 管理プロファイルの数
     * 
     * @type Integer
     * @private
     */
    _length: 0,
    
    /**
     * プロファイルの追加を行う
     * 
     * @param {Jeeel.Debug.Profiler.Profile} profile 追加プロファイル
     * @return {Jeeel.Debug.Profiler.ProfileManager} 自インスタンス
     */
    addProfile: function (profile) {
        this._profiles[this._length] = profile;
        this._length++;
        
        return this;
    },
    
    /**
     * 管理プロファイル数を取得する
     * 
     * @return {Integer} 管理プロファイル数
     */
    getProfileLength: function () {
        return this._length;
    },
    
    /**
     * 管理プロファイルを全て取得する
     * 
     * @return {Jeeel.Debug.Profiler.Profile[]} 管理プロファイル
     */
    getProfiles: function () {
        return this._profiles;
    },

    /**
     * 管理プロファイルの中から一番時間がかかっているプロファイルを取得する
     * 
     * @return {Jeeel.Debug.Profiler.Profile} 最遅のメソッドプロファイル
     */
    getBottleneckProfile: function () {
        if ( ! this._length) {
            return null;
        }
        
        var max = this._profiles[0].time,
            l = this._length,
            i = 1,
            j = 0;

        for (; i < l; i++) {
            if (max < this._profiles[i].time) {
                max = this._profiles[i].time;
                j = i;
            }
        }
        
        return this._profiles[j];
    },
    
    searchProfile: function (pattern) {
        var manager = new this.constructor();
        
        for (var i = 0; i < this._length; i++) {
          
            if (this._profiles[i].method.match(pattern)) {
                manager.addProfile(this._profiles[i]);
            }
        }
        
        return manager;
    },
    
    /**
     * 管理プロファイルを並び変える
     * 
     * @param {Function} [compareFunction] 比較関数 Boolean callback(Jeeel.Debug.Profiler.Profile a, Jeeel.Debug.Profiler.Profile b)
     * @return {Jeeel.Debug.Profiler.ProfileManager} 自インスタンス
     */
    sort: function (compareFunction) {
        this._profiles.sort(compareFunction || function (a, b) {
            return b.time - a.time;
        });
        
        return this;
    },
    
    constructor: Jeeel.Debug.Profiler.ProfileManager
};
/**
 * コンストラクタ
 * 
 * @class ユニットテストを提供するクラス(通常継承して使用する)
 */
Jeeel.Debug.UnitTest = function () {
    
};

/**
 * 複数のユニットテストクラスを渡して実行を行う<br />
 * 結果はJeeel.Debug.ErrorMessageにて表示する<br />
 * ユニットテストクラスのコンストラクタにはそのクラスのコンストラクタを実装して名前を付けておくか、<br />
 * Jeeel.Debug.Debugger.setInformationにて情報を付与しておくと見やすくなる
 * 
 * @param {Jeeel.Debug.UnitTest|Function} var_args ユニットテスト継承のクラスもしくはインスタンスを順に渡す
 * @return {Boolean} 全てのテストが正常終了したかどうか
 * @throws {Error} 引数にユニットテストクラスかインスタンス以外を渡した場合に発生
 */
Jeeel.Debug.UnitTest.test = function (var_args) {
    
    var condition = true;
    
    for (var i = 0, l = arguments.length; i < l; i++) {
        var testCase = arguments[i];
        
        if (Jeeel.Type.isFunction(testCase)) {
            testCase = new testCase();
        }
        
        if ( ! (testCase instanceof Jeeel.Debug.UnitTest)) {
            throw new Error((i + 1) + 'つ目の引数がユニットテストクラスではありません。');
        }
        
        if (i) {
            Jeeel.Debug.ErrorMessage.dump('\n\n\n\n');
        }
        
        testCase.run();
        
        var asserts = testCase.getAsserts(),
            successes = testCase.getSuccesses(),
            errors = testCase.getErrors(),
            assertLength = asserts.length,
            successLength = successes.length,
            errorLength = errors.length,
            testCount = testCase.getTestCount(),
            assertCount = testCase.getAssertCount(),
            j;
            
        for (j = 0; j < assertLength; j++) {
            var assert = asserts[j];
            
            Jeeel.Debug.ErrorMessage.dump(assert.condition ? '.' : 'F');
        }
        
        Jeeel.Debug.ErrorMessage.dump('\n\nTime: ' + testCase.getTestTime() + ' milli seconds\n');
        
        if (errorLength) {
            condition = false;
            
            Jeeel.Debug.ErrorMessage.dump('\nThere were ' + errorLength + ' errors:\n\n');
            
            for (j = 0; j < errorLength; j++) {
                var error = errors[j];
                
                Jeeel.Debug.ErrorMessage.dump((j + 1) + ') ' + error.fullMethod + '\n');
                Jeeel.Debug.ErrorMessage.dump('error: ' + error.assert + '\n\n');
                
                if (error.message) {
                    Jeeel.Debug.ErrorMessage.dump(error.message + '\n\n');
                }
            }
            
            Jeeel.Debug.ErrorMessage.dump('\nFAILURES!\n');
            Jeeel.Debug.ErrorMessage.dump('Tests: ' + testCount +', Assertions: ' + assertCount + ',  Errors: ' + errorLength + '.');
        } else {
            Jeeel.Debug.ErrorMessage.dump('OK (' + testCount + ' tests, ' + assertCount + ' assertions)');
        }
    }
    
    return condition;
};

Jeeel.Debug.UnitTest.prototype = {
  
    /**
     * テストケースで失敗したアサート情報リスト
     * 
     * @type Hash[]
     * @private
     */
    _errors: [],
    
    /**
     * テストケースで成功したアサート情報リスト
     * 
     * @type Hash[]
     * @private
     */
    _successes: [],
    
    /**
     * テストケースのアサート情報リスト
     * 
     * @type Hash[]
     * @private
     */
    _asserts: [],
    
    /**
     * 実行テストメソッドのステータス
     * 
     * @type Hash
     * @private
     */
    _runState: {},
    
    /**
     * テストを実行する
     * 
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    run: function () {},
    
    /**
     * テストケース開始時に実行されるメソッド
     */
    setUpBeforeClass: function () {
        
    },
    
    /**
     * テストメソッド前に実行されるメソッド
     */
    setUp: function () {
        
    },
    
    /**
     * テストメソッド後に実行されるメソッド
     */
    tearDown: function () {
        
    },
    
    /**
     * テストケース終了後に実行されるメソッド
     */
    tearDownAfterClass: function () {
        
    },
    
    /**
     * trueかどうか確認する
     * 
     * @param {Boolean} condition 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertTrue: function (condition, message) {
        return this._setAssertResult(condition === true, 'assertTrue', message);
    },
    
    /**
     * falseかどうか確認する
     * 
     * @param {Boolean} condition 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertFalse: function (condition, message) {
        return this._setAssertResult(condition === false, 'assertFalse', message);
    },
    
    /**
     * nullかどうか確認する
     * 
     * @param {Mixied} value 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNull: function (value, message) {
        return this._setAssertResult(value === null, 'assertNull', message);
    },
    
    /**
     * nullじゃないかどうか確認する
     * 
     * @param {Mixied} value 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotNull: function (value, message) {
        return this._setAssertResult(value !== null, 'assertNotNull', message);
    },
    
    /**
     * undefined・nullかどうか確認する
     * 
     * @param {Mixied} value 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertEmpty: function (value, message) {
        return this._setAssertResult(Jeeel.Type.isEmpty(value), 'assertEmpty', message);
    },
    
    /**
     * undefined・nullじゃないかどうか確認する
     * 
     * @param {Mixied} value 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotEmpty: function (value, message) {
        return this._setAssertResult( ! Jeeel.Type.isEmpty(value), 'assertNotEmpty', message);
    },
    
    /**
     * 値が一致するかどうか確認する
     * 
     * @param {Mixied} expected 確認する値1
     * @param {Mixied} actual 確認する値2
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertEquals: function (expected, actual, message) {
        return this._setAssertResult(expected == actual, 'assertEquals', message);
    },
    
    /**
     * 値が一致しないかどうか確認する
     * 
     * @param {Mixied} expected 確認する値1
     * @param {Mixied} actual 確認する値2
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotEquals: function (expected, actual, message) {
        return this._setAssertResult(expected != actual, 'assertNotEquals', message);
    },
    
    /**
     * 値と型が一致するかどうか確認する
     * 
     * @param {Mixied} expected 確認する値1
     * @param {Mixied} actual 確認する値2
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertIdentical: function (expected, actual, message) {
        return this._setAssertResult(expected === actual, 'assertIdentical', message);
    },
    
    /**
     * 値と型が一致しないかどうか確認する
     * 
     * @param {Mixied} expected 確認する値1
     * @param {Mixied} actual 確認する値2
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotIdentical: function (expected, actual, message) {
        return this._setAssertResult(expected !== actual, 'assertNotIdentical', message);
    },
    
    /**
     * キーを保持するかどうか確認する
     * 
     * @param {String} key キー
     * @param {Hash} hash オブジェクト
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertHasKey: function (key, hash, message) {
        return this._setAssertResult(Jeeel.Type.keyExists(key, hash), 'assertHasKey', message);
    },
    
    /**
     * キーを保持しないかどうか確認する
     * 
     * @param {String} key キー
     * @param {Hash} hash オブジェクト
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotHasKey: function (key, hash, message) {
        return this._setAssertResult( ! Jeeel.Type.keyExists(key, hash), 'assertNotHasKey', message);
    },
    
    /**
     * instanceがtypeクラスかどうかを確認する
     * 
     * @param {Mixied} instance インスタンス
     * @param {Function} type クラスタイプ
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertIsA: function (instance, type, message) {
        return this._setAssertResult(Jeeel.Type.isFunction(type) && instance instanceof type, 'assertIsA', message);
    },
    
    /**
     * instanceがtypeクラスじゃないかどうかを確認する
     * 
     * @param {Mixied} instance インスタンス
     * @param {Function} type クラスタイプ
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertIsNotA: function (instance, type, message) {
        return this._setAssertResult(Jeeel.Type.isFunction(type) && ! (instance instanceof type), 'assertIsNotA', message);
    },
    
    /**
     * subjectがpatternに一致したかどうかを確認する
     * 
     * @param {RegExp} pattern 検索パターン
     * @param {String} subject 対象文字列
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertPattern: function (pattern, subject, message) {
        return this._setAssertResult(Jeeel.Type.isRegularExpression(pattern) && pattern.test(subject), 'assertPattern', message);
    },
    
    /**
     * subjectがpatternに一致しなかったかどうかを確認する
     * 
     * @param {RegExp} pattern 検索パターン
     * @param {String} subject 対象文字列
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNoPattern: function (pattern, subject, message) {
        return this._setAssertResult(Jeeel.Type.isRegularExpression(pattern) && ! pattern.test(subject), 'assertNoPattern', message);
    },
    
    /**
     * expect &lt; valueかどうか確認する
     * 
     * @param {Number} expect 比較値
     * @param {Number} value 対象値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertGreaterThan: function (expect, value, message) {
        return this._setAssertResult(expect < value, 'assertGreaterThan', message);
    },
    
    /**
     * expect &lt;= valueかどうか確認する
     * 
     * @param {Number} expect 比較値
     * @param {Number} value 対象値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertGreaterThanOrEqual: function (expect, value, message) {
        return this._setAssertResult(expect <= value, 'assertGreaterThanOrEqual', message);
    },
    
    /**
     * expect &gt; valueかどうか確認する
     * 
     * @param {Number} expect 比較値
     * @param {Number} value 対象値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertLessThan: function (expect, value, message) {
        return this._setAssertResult(expect > value, 'assertLessThan', message);
    },
    
    /**
     * expect &gt;= valueかどうか確認する
     * 
     * @param {Number} expect 比較値
     * @param {Number} value 対象値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertLessThanOrEqual: function (expect, value, message) {
        return this._setAssertResult(expect >= value, 'assertLessThanOrEqual', message);
    },
    
    /**
     * abs(expect - value) &lt; marginかどうかを確認する
     * 
     * @param {Number} expect 基準値
     * @param {Number} value 比較値
     * @param {Number} margin 幅
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertWithinMargin: function (expect, value, margin, message) {
        return this._setAssertResult(Math.abs(expect - value) < margin, 'assertWithinMargin', message);
    },
    
    /**
     * abs(expect - value) &gt;= marginかどうかを確認する
     * 
     * @param {Number} expect 基準値
     * @param {Number} value 比較値
     * @param {Number} margin 幅
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertOutsideMargin : function (expect, value, margin, message) {
        return this._setAssertResult(Math.abs(expect - value) >= margin, 'assertOutsideMargin', message);
    },

    /**
     * このテストケースで実行したアサートのリストを返す
     * 
     * @return {Hash[]} アサート連想配列のリスト(condition, method, fullMethod, assert, message)
     */
    getAsserts: function () {
        return this._asserts;
    },
    
    /**
     * このテストケースで成功したアサートのリストを返す
     * 
     * @return {Hash[]} 成功連想配列のリスト(method, fullMethod, assert, message)
     */
    getSuccesses: function () {
        return this._successes;
    },
    
    /**
     * このテストケースでエラーになったアサートのリストを返す
     * 
     * @return {Hash[]} エラー連想配列のリスト(method, fullMethod, assert, message)
     */
    getErrors: function () {
        return this._errors;
    },
    
    /**
     * テストメソッドの実行回数を返す
     * 
     * @return {Integer} 実行回数
     */
    getTestCount: function () {
        return this._runState.testCount || 0;
    },
    
    /**
     * アサートメソッドの実行回数を返す
     * 
     * @return {Integer} 実行回数
     */
    getAssertCount: function () {
        return this._runState.assertCount || 0;
    },
    
    /**
     * テスト実行時間を返す
     * 
     * @return {Integer} 実行時間(ミリ秒)
     */
    getTestTime: function () {
        return this._runState.time || 0;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Debug.UnitTest,
    
    /**
     * アサートの結果をセットする
     * 
     * @param {Boolean} condition 成功したかどうか
     * @param {String} assert アサート名
     * @param {String} [message] カスタムメッセージ
     * @private
     */
    _setAssertResult: function (condition, assert, message) {
        this._runState.assertCount++;
        
        this._asserts[this._asserts.length] = {
            condition: !!condition,
            method: this._runState.method.name,
            fullMethod: this._runState.method.fullName,
            assert: assert,
            message: message || ''
        };
        
        if (condition) {
            this._setSuccess(assert, message);
        } else {
            this._setError(assert, message);
        }
        
        return this;
    },
    
    /**
     * 成功をセットする
     * 
     * @param {String} assert アサート名
     * @param {String} [message] カスタムメッセージ
     * @private
     */
    _setSuccess: function (assert, message) {
        this._successes[this._successes.length] = {
            method: this._runState.method.name,
            fullMethod: this._runState.method.fullName,
            assert: assert,
            message: message || ''
        };
    },
    
    /**
     * エラーをセットする
     * 
     * @param {String} assert アサート名
     * @param {String} [message] カスタムメッセージ
     * @private
     */
    _setError: function (assert, message) {
        this._errors[this._errors.length] = {
            method: this._runState.method.name,
            fullMethod: this._runState.method.fullName,
            assert: assert,
            message: message || ''
        };
    },
    
    _init: function () {
        var testMethodPattern = /^test.+$/;
        
        this.run = function () {
            var constructor = this.constructor,
                debugInfo = constructor[Jeeel.Debug.Debugger.INFORMATION_NAME];
            
            this._runState = {
                className: debugInfo && debugInfo.name || constructor.name,
                testCount: 0,
                assertCount: 0
            };
            
            this._asserts = [];
            this._successes = [];
            this._errors = [];
            
            this.setUpBeforeClass();
            
            var date = new Date();

            for (var key in this) {
                if (key.match(testMethodPattern) && Jeeel.Type.isFunction(this[key])) {
                    
                    this._runState.method = {
                        name: key,
                        fullName: this._runState.className ? this._runState.className + '#' + key : key
                    };
                    
                    this._runState.testCount++;
                    
                    this.setUp();
                    this[key]();
                    this.tearDown();
                }
            }
            
            this._runState.time = new Date() - date;
            
            this.tearDownAfterClass();
            
            return this;
        };
        
        delete this._init;
    }
};

Jeeel.Debug.UnitTest.prototype._init();

Jeeel.directory.Jeeel.Debug.Debugger = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Debug + 'Debugger/';
    }
};

/**
 * 専門的なデバッグを行うためのモジュール等を保持するネームスペース
 */
Jeeel.Debug.Debugger = {

    /**
     * 内部参照関数を作るための文字列定数<br />
     * 内部参照をしたい場所でevalで展開する
     *
     * @type String
     * @constant
     */
    INSPECTOR: '(function (){return function (___$){try{return eval(___$);}catch(e){return e.message;}}})();',

    /**
     * 解析情報を設定する時の名前
     *
     * @type String
     * @constant
     */
    INFORMATION_NAME: '_jeeelInfo',

    /**
     * 内部の変数などを動的に参照するブレークポイントを設定する<br />
     * このメソッドを呼んだ際のプロンプトに変数名を入れると変数の値がdumpされる<br />
     * なおこのメソッドにignoreをつけると全ての呼び出し時の動作が無効になる
     *
     * @param {Function} inspector このオブジェクトのメンバのINSPECTORを関数内部でevalした関数
     * @param {Mixied} [self] 参照変数の際のthisを示す値
     * @param {String} [title] この関数を区別するために表記するタイトル
     * @throws {Error} inspectorがメソッドではない場合に発生
     */
    inspect: function (inspector, self, title) {

        if ( ! Jeeel.Type.isFunction(inspector)) {
            throw new Error('inspectorがメソッドではありません。');
        }

        var expression, result;

        if ('ignore' in arguments.callee) {
            return;
        }

        while(true) {

            var message = "";

            if (title) {
                message += title + '\n';
            }

            if (expression) {
                expression += ' = ' + result + ';';
            } else {
                expression = '';
            }

            message += '変数名を入力:';

            expression = Jeeel.Debug.Debugger.showPrompt(message, expression);

            if ( ! expression) {
                return;
            }

            result = inspector.call(self, expression);
        }
    },
    
    /**
     * @ignore
     */
    getLocalVariableList: function (inspector, thisArg) {
        var variableNames = this.getLocalVariableNames(arguments.callee.caller);
        var name, list = {};
        
        for (var i = 0, l = variableNames.length; i < l; i++) {
            name = variableNames[i];
            
            list[name] = inspector.call(thisArg, name);
        }
        
        return list;
    },
    
    /**
     * @ignore
     */
    getLocalVariableNames: function (func) {
        var source = func.toString();
        
        // 文字列、コメント、正規表現の削除
        source = source.replace(/(^|[^\\])'[^']*'/g, '$1')
                       .replace(/(^|[^\\])"[^"]*"/g, '$1');
                       
        var args = source.match(/function ?([a-zA-Z_$][a-zA-Z0-9_$]*)?\(([^)]*)\)/)[2].split(',');
        var reg = /var\s+(\w+)/g;
        var match = null;
        var variables = [];
        
        while(match = reg.exec(source)) {
            variables[variables.length] = match[1];
        }
        
        return variables;
    },

    /**
     * HTML要素をbodyの最初に差し込む
     *
     * @param {Element} element 差し込む要素
     * @return {Element} 差し込んだ要素
     */
    elementInsertTop: function (element) {
        var body  = Jeeel.Document.getBody();
        var first = body.firstChild;

        if (first) {
            body.insertBefore(element, first);
        } else {
            body.appendChild(element);
        }
        
        return element;
    },

    /**
     * JavaScriptソースの表示を行う
     *
     * @param {String} url JavaScriptソースの相対URL
     * @return {Boolean} 常にtrue
     */
    showSource: function (url) {
        Jeeel.Window.createDialogOpener(Jeeel.HOST + Jeeel.BASE_URL + url)
                  .setOption('dialogWidth', 600)
                  .setOption('dialogHeight', 300)
                  .open();

        return true;
    },

    /**
     * プロンプトの表示を行う
     *
     * @param {String} title プロンプトのタイトル
     * @param {String} message プロンプトの初期メッセージ
     */
    showPrompt: function (title, message) {
        var callback = function (args, selfWindow) {
            var html = '<div><p style="float:left;width: 440px;margin: 0; padding: 0;">ダイアログプロンプト</p><div style="">'
                     + '<button onclick="closeDialog(document.getElementById(\'result\').value);">OK</button>'
                     + '</div></div><br/><div><p style="float:left;width: 440px;margin: 0; padding: 0;">' + args.title
                     + '</p><div style="">'
                     + '<button onclick="closeDialog(false);">CANCEL</button></div></div>'
                     + '<br /><textarea id="result" style="width:560px;height:200px;">'
                     + args.message + '</textarea>';
            
            selfWindow.document.body.innerHTML = html;
        };
        
        return Jeeel.Window.createDialogOpener('')
                         .setArgument('title', title)
                         .setArgument('message', message)
                         .setOption('dialogWidth', 600)
                         .setOption('dialogHeight', 300)
                         .openTemplate(callback);
    },

    /**
     * サーバ側のスクリプトを走らせる
     *
     * @param {String} script サーバー側で走らせるスクリプト文字列
     * @param {Hash} [params] サーバー側に渡すパラメータ
     * @param {Function} [callback] クロスドメイン時のコールバック
     * @return {Mixied} サーバー側からの戻り値をデコードしたもの
     */
    evalServer: function (script, params, callback) {

        if ( ! params) {
            params = {};
        }

        if ( ! Jeeel.Type.isHash(params)) {
            throw new Error('paramsはHashでなければなりません。');
        }

        params = {params: params};

        if (script) {
            params.script = script;
        }
        
        if (Jeeel.CROSS_DOMAIN) {
            return this._jsonpDebug('evalServer', callback, params);
        }

        var res = Jeeel.Net.Ajax.serverResponse(Jeeel.HOST + Jeeel.DEBUG_URL, params);

        if (Jeeel.Type.isString(res)) {

            try {
                res = Jeeel.Json.decode(res);
            } catch(e) {
                res = Jeeel.String.stripTags(res);
            }

            return res;
        }

        Jeeel.Debug.ErrorMessage.dumpStripTags(res.response);

        return false;
    },

    /**
     * サーバー側でSQLを実行する
     *
     * @param {String} sql サーバー側実行するSQL文字列
     * @param {Function} [callback] クロスドメイン時のコールバック
     * @return {Mixied} サーバー側からの戻り値をデコードしたもの
     */
    evalSql: function (sql, callback) {

        if (sql) {
            sql = {sql: sql};
        }
        
        if (Jeeel.CROSS_DOMAIN) {
            return this._jsonpDebug('evalServer', callback, sql);
        }

        var res = Jeeel.Net.Ajax.serverResponse(Jeeel.HOST + Jeeel.SQL_DEBUG_URL, sql);

        if (Jeeel.Type.isString(res)) {
          
            try {
                res = Jeeel.Json.decode(res);
            } catch(e) {
                res = Jeeel.String.stripTags(res);
            }

            return res;
        }

        Jeeel.Debug.ErrorMessage.dumpStripTags(res.response);

        return false;
    },

    /**
     * メールを送信する
     * 
     * @param {String} to メール送信先
     * @param {Mixied} body メール本文
     * @param {Boolean} [isHtml] HTMLメールとして送信を行うかどうかを示す(デフォルトはfalse)
     * @param {Function} [callback] クロスドメイン時のコールバック
     * @return {Boolean} メール送信が成功ならばtrueそれ以外はfalseを返す
     */
    sendMail: function (to, body, isHtml, callback) {
      
        var validator = Jeeel.Validator.Helper.create(to)
                                            .email();

        if ( ! validator.isValid()) {
            return false;
        }

        var params = {to: to, body: body};

        if (isHtml) {
            params.type = 'html';
        } else {
            params.type = 'text';
        }
        
        if (Jeeel.CROSS_DOMAIN) {
            return this._jsonpDebug('evalServer', callback, params);
        }

        var res = Jeeel.Net.Ajax.serverResponse(Jeeel.HOST + Jeeel.MAIL_URL, params);

        if (Jeeel.Type.isString(res)) {

            try {
                res = Jeeel.Json.decode(res);
            } catch(e) {
                res = Jeeel.String.stripTags(res);
            }

            return res;
        }

        Jeeel.Debug.ErrorMessage.dumpStripTags(res.response);

        return false;
    },

    /**
     * 識別子をファイルとしてブラウザに読み込ませる
     *
     * @param {Mixied} value 読み込ませる値
     * @param {String} [fileName] 指定した名前で認識させたい時に指定する
     * @return {Boolean} 正常終了ならばtrueそれ以外はfalseを返す
     */
    fileOpen: function (value, fileName) {

        try {
            var form = Jeeel.Net.Submit.newForm();
            
            form.setMethod('POST')
                .setAction(Jeeel.HOST + Jeeel.FILE_OPEN_URL)
                .set('value', value);

            if (Jeeel.Type.isString(fileName)) {
                form.set('file', fileName);
            }

            form.execute();
        } catch (e) {
            return false;
        }

        return true;
    },
    
    /**
     * 呼び出し元のメソッドのトレースを取得する
     *
     * @return {Jeeel.Object.Technical.Trace[]} トレース内容のリスト
     */
    getTrace: function () {
        var res = [];
        var func = arguments.callee;

        while(func.caller) {

            func = func.caller;

            res[res.length] = new Jeeel.Object.Technical.Trace(func);
        }

        return res;
    },

    /**
     * 指定したオブジェクトに解析情報を設定する
     *
     * @param {Mixied} object 解析情報を設定するオブジェクト
     * @param {String} name オブジェクトに付ける名前
     * @param {Boolean} [deepSet] 再帰的に情報を設定するかどうか
     * @return {Boolean} 解析情報の設定が正しく行われたかどうか
     */
    setInformation: function (object, name, deepSet) {

        if (Jeeel.Type.isPrimitive(object)) {
            return false;
        } else if (object instanceof Jeeel.Object.Technical.Information) {
            return false;
        } else if (Jeeel.Type.isElement(object) || Jeeel.Type.isDocument(object) || Jeeel.Type.isWindow(object)) {
            return false;
        } else if (this.INFORMATION_NAME in object) {
            return false;
        }

        if (Jeeel.Type.isFunction(object) && object.prototype) {
            object.prototype.constructor = object;
        }
        
        object[this.INFORMATION_NAME] = new Jeeel.Object.Technical.Information(name, arguments[3]);

        if (deepSet) {
            for (var property in object) {
                if (property === 'constructor') {
                    continue;
                } else if ( ! object.hasOwnProperty(property)) {
                    continue;
                }
                
                try {
                    arguments.callee.call(this, object[property], name + '.' + property, deepSet, object);
                } catch (e) {}
            }
        }

        return true;
    },
    
    /**
     * Element固有のIDを定義する(IEのuniqueIDを他ブラウザで再現)
     * 
     * @return {Boolean} 定義が行われたかどうか
     */
    defineUniqueId: function () {
        
        if (Jeeel._doc.uniqueID) {
            return false;
        } else if (typeof HTMLElement !== 'function') {
            return false;
        } else if ( ! Object.prototype.__defineGetter__ || ! Object.defineProperty) {
            return false;
        }
        
        var nextUniqueID = 1;
        
        if (Object.prototype.__defineGetter__) {
            HTMLElement.prototype.__defineGetter__('uniqueID', function () {
                var uniqueID = 'id' + nextUniqueID++;

                this.__defineGetter__("uniqueID", function (){return uniqueID});

                return uniqueID;
            });
        } else {
            Object.defineProperty(HTMLElement.prototype, 'uniqueID', {
                get: function () {
                    var uniqueID = 'id' + nextUniqueID++;

                    Object.defineProperty(this, "uniqueID", {get: function (){return uniqueID}});

                    return uniqueID;
                }
            });
        }
        
        return true;
    },
    
    /**
     * このクラスのevalServer, evalSql, sendMailをJsonp通信で実行する
     * 
     * @param {String} callMethodName 実行するメソッド名
     * @param {Function} [callback] Jsonp通信の結果のコールバック
     * @param {Hash} [params] サーバー側に引き渡す値
     * @return {Boolean} 正常終了ならばtrueそれ以外はfalseを返す
     * @private
     */
    _jsonpDebug: function (callMethodName, callback, params) {
        
        callback = callback || Jeeel.Debug.Console.log;
        params = params || {};
        
        var url;
        
        switch(callMethodName) {
            case 'evalServer':
                url = Jeeel.DEBUG_URL;
                break;
                
            case 'evalSql':
                url = Jeeel.SQL_DEBUG_URL;
                break;
                
            case 'sendMail':
                url = Jeeel.MAIL_URL;
                break;
                
            default:
                return false;
                break;
        }
        
        url = url.match(/\/([a-z\-]+)\/?$/)[1];
        
        var jsonp = new Jeeel.Net.Jsonp(Jeeel.HOST + Jeeel.JSONP_URL);
        
        jsonp.setAll(params || {})
             .set('exec-action', url)
             .setCallback('callback', callback)
             .execute();

        return true;
    }
};

Jeeel.file.Jeeel.Debug.Debugger = ['Observer', 'StackTracer', 'Profiler'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Debug.Debugger, Jeeel.file.Jeeel.Debug.Debugger);

(function () {
  
    if (typeof window === 'undefined') {
        return;
    }

    var Jeeel = window.Jeeel;

    var listener =  function () {
        var state = document.readyState.toLowerCase();
        
        if (state.match(/loaded|complete/) && ((Jeeel.Object || {}).Technical || {}).Information) {
            if (Jeeel === window.Jeeel) {
                Jeeel.Debug.Debugger.setInformation(Jeeel, 'Jeeel', true, window);
            }
        } else {
            setTimeout(arguments.callee, 1);
        }
    };

    setTimeout(listener, 1);

})();

/**
 * 未完成
 *
 * @ignore
 */
Jeeel.Debug.Debugger.Observer = function () {
    this._listeners = [];
    this._observing = false;
};

Jeeel.Debug.Debugger.Observer.prototype = {

    /**
     * @type Function[]
     * @private
     */
    _listeners: [],

    /**
     * @type Boolean
     * @private
     */
    _observing: false,

    observe: function (object, name, deepObserve) {

        var self = this;
        
        name = name || object.constructor.name;

        for (var property in object) {

            if (Jeeel.Type.isFunction(object[property])) {
                if ('_jeeel_observe' in object[property]) {
                    return;
                } else if ('ignore' in object[property]) {
                    continue;
                }

                var method = object[property];

                object[property] = (function (name_, property_, method_) {

                    return function () {
                        if (self._observing) {
                            self._notifyBeforeCall(name_, property_, arguments);
                        }

                        var rv =  method_.apply(this, arguments);

                        if (self._observing) {
                            self._notifyAfterCall(name_, property_, arguments);
                        }
                        
                        return rv;
                    };
                })(name, property, method);

                for (var staticProperty in method) {
                    object[property][staticProperty] = method[staticProperty];
                }

                object[property].prototype = method.prototype;
                object[property]._jeeel_observe = true;
            }
            
            if (deepObserve) {
                var ObjName;

                if (Jeeel.Type.isHash(object[property])) {
                    ObjName = name + '.' + property;
                    arguments.callee.call(self, object[property], ObjName, deepObserve);
                }
                else if (Jeeel.Type.isFunction(object[property])) {
                    ObjName = name + '#' + property;
                    arguments.callee.call(self, object[property], ObjName, deepObserve);
                }
            }
        }
    },

    addListener: function (listener) {
        this._listeners.push(listener);

        return this;
    },

    start: function () {
        this._observing = true;

        return this;
    },

    stop: function () {
        this._observing = false;

        return this;
    },

    _notifyBeforeCall: function (name, property, args) {
        this._observing = false;

        for(var i = 0; i < this._listeners.length; i++) {
            this._listeners[i].beforeCall(name, property, args);
        }

        this._observing = true;
    },

    _notifyAfterCall: function (name, property, args) {
        this._observing = false;

        for(var i = 0; i < this._listeners.length; i++) {
            this._listeners[i].afterCall(name, property, args);
        }

        this._observing = true;
    }
};

/**
 * 未完成
 *
 * @ignore
 */
Jeeel.Debug.Debugger.StackTracer = function () {
    this._stack = [];
};

Jeeel.Debug.Debugger.StackTracer.StackObj = function (name, property, args) {
    this.parent = name;
    this.method = property;
    this.args   = args;
    this.toString = function () {
        return this.parent + '::' + this.method;
    };
};

Jeeel.Debug.Debugger.StackTracer.prototype = {
    _stack: [],

    beforeCall: function (name, property, args) {
        var obj = new Jeeel.Debug.Debugger.StackTracer.StackObj(name, property, args);
        this._stack.push(obj);
    },

    afterCall: function (name, property, args) {
        this._stack.pop();
    }
};


/**
 * 未完成
 *
 * @ignore
 */
Jeeel.Debug.Debugger.Profiler = function () {
    this._records = {};
    this._start = null;
};

Jeeel.Debug.Debugger.Profiler.prototype = {

    _records: {},
    _start: null,

    beforeCall: function (name, property, args) {
        this._start = new Date();
    },

    afterCall: function (name, property, args) {
        var key = name + "::" + property;

        if (typeof this._records[key] == "undefined"){
            this._records[key] = [];
        }
        
        this._records[key].push( (new Date()) - this._start);
    }
};

(function (createPacker) {

    /**
     * 未完成
     */
    Jeeel.Debug.Compressor = {
        
        _packer: null,
        
        /**
         * スクリプトを圧縮する
         * 
         * @param {String} script JavaScript文字列
         * @param {Boolean} [base64] Base64圧縮を行うかどうか
         * @param {Boolean} [shrink] 関数の引数を変更するかどうか
         * @return {String} 圧縮後のスクリプト
         */
        compress: function (script, base64, shrink) {
            return this._getPacker().pack(script, !!base64, !!shrink);
        },
        
        _getPacker: function() {
            if (this._packer) {
                return this._packer;
            }
            
            return this._packer = createPacker();
        }
    };

})(function() {
  
    var base2 = {
        name: "base2",
        version: "1.0.1(pre)",
        exports: "Base, Package, Abstract, Module, Enumerable, Map, Collection, RegGrp, " + "assert, assertArity, assertType, " + "assignID, copy, counter, detect, extend, forEach, format, instanceOf, match, rescape, slice, trim, " + "I, K, Undefined, Null, True, False, bind, delegate, flip, not, partial, unbind",
        global: this,
        namespace: "var global=base2.global;function base(o,a){return o.base.apply(o,a)};",
        detect: new function(_) {
            var global = _;
            var jscript /*@cc_on=@_jscript_version@*/;

            if (_.navigator) {
                var element = document.createElement("span");
                var userAgent = navigator.platform + " " + navigator.userAgent;
                if (!jscript)
                    userAgent = userAgent.replace(/MSIE\s[\d.]+/, "");
                userAgent = userAgent.replace(/([a-z])[\s\/](\d)/gi, "$1$2");
            }

            return function(a) {
                var r = false;
                var b = a.charAt(0) == "!";
                if (b)
                    a = a.slice(1);
                if (a.charAt(0) == "(") {
                    try {
                        eval("r=!!" + a)
                    } catch (error) {
                    }
                } else {
                    r = new RegExp("(" + a + ")", "i").test(userAgent)
                }
                return !!(b ^ r)
            }
        }(this)
    };

    new function(_) {
        var detect = base2.detect;
        var slice = Array.slice || (function(b) {
            return function(a) {
                return b.apply(a, b.call(arguments, 1));
            }
        })(Array.prototype.slice);

        var Undefined = K(), Null = K(null), True = K(true), False = K(false);
        var _0 = /%([1-9])/g;
        var _1 = /^\s\s*/;
        var _2 = /\s\s*$/;
        var _3 = /([\/()[\]{}|*+-.,^$?\\])/g;
        var _4 = /eval/.test(detect) ? /\bbase\s*\(/ : /.*/;
        var _5 = ["constructor", "toString", "valueOf"];
        var _6 = String(new RegExp);
        var _7 = 1;

        _8();

        eval(base2.namespace);

        var _9 = function(a, b) {
            base2.__prototyping = true;
            var c = new this;
            extend(c, a);
            delete base2.__prototyping;
            var d = c.constructor;

            var _10 = function () {
                if (!base2.__prototyping) {
                    if (this.constructor == arguments.callee || this.__constructing) {
                        this.__constructing = true;
                        d.apply(this, arguments);
                        delete this.__constructing;
                    } else {
                        return extend(arguments[0], c);
                    }
                }

                return this;
            };

            c.constructor = _10;

            for (var i in Base) {
                _10[i] = this[i];
            }

            _10.toString = K(String(d));
            _10.ancestor = this;
            _10.base = Undefined;
            _10.init = Undefined;
            extend(_10, b);
            _10.prototype = c;
            _10.init();

            return _10;
        };

        var Base = _9.call(
            Object, {
                constructor: function() {
                    if (arguments.length > 0) {
                        this.extend(arguments[0]);
                    }
                },

                base: function() {
                },

                extend: delegate(extend)

            }, Base = {
                ancestorOf: delegate(_11),
                extend: _9,
                forEach: delegate(_8),
                implement: function(a) {
                    if (typeof a == "function") {
                        if (_11(Base, a)) {
                            a(this.prototype)
                        }
                    } else {
                        extend(this.prototype, a)
                    }
                    return this;
                }
            }
        );

        var Package = Base.extend({constructor: function(d, e) {
                this.extend(e);
                if (this.init)
                    this.init();
                if (this.name != "base2") {
                    if (!this.parent)
                        this.parent = base2;
                    this.parent.addName(this.name, this);
                    this.namespace = format("var %1=%2;", this.name, String(this).slice(1, -1))
                }
                var f = /[^\s,]+/g;
                if (d) {
                    d.imports = Array2.reduce(this.imports.match(f), function(a, b) {
                        eval("var ns=base2." + b);
                        assert(ns, format("Package not found: '%1'.", b));
                        return a += ns.namespace
                    }, base2.namespace + JavaScript.namespace);
                    d.exports = Array2.reduce(this.exports.match(f), function(a, b) {
                        var c = this.name + "." + b;
                        this.namespace += "var " + b + "=" + c + ";";
                        return a += "if(!" + c + ")" + c + "=" + b + ";"
                    }, "", this)
                }
            },exports: "",imports: "",name: "",namespace: "",parent: null,addName: function(a, b) {
                if (!this[a]) {
                    this[a] = b;
                    this.exports += ", " + a;
                    this.namespace += format("var %1=%2.%1;", a, this.name)
                }
            },addPackage: function(a) {
                this.addName(a, new Package(null, {name: a,parent: this}))
            },toString: function() {
                return format("[%1]", this.parent ? String(this.parent).slice(1, -1) + "." + this.name : this.name)
            }}
        );

        var Abstract = Base.extend({constructor: function() {
                throw new TypeError("Class cannot be instantiated.");
            }});
        var Module = Abstract.extend(null, {extend: function(a, b) {
                var c = this.base();
                _12(c, this);
                c.implement(a);
                extend(c, b);
                c.init();
                return c
            },implement: function(c) {
                var d = this;
                if (typeof c == "function") {
                    d.base(c);
                    if (_11(Module, c)) {
                        _12(d, c)
                    }
                } else {
                    var e = {};
                    _8(Object, c, function(a, b) {
                        if (b.charAt(0) == "@") {
                            if (detect(b.slice(1))) {
                                forEach(a, arguments.callee)
                            }
                        } else if (!Module[b] && typeof a == "function" && a.call) {
                            function _13() {
                                return d[b].apply(d, [this].concat(slice(arguments)))
                            }
                            ;
                            _13.__base = _4.test(a);
                            e[b] = _13
                        }
                    });
                    extend(d.prototype, e);
                    extend(d, c)
                }
                return d
            }});
        function _12(a, b) {
            for (var c in b) {
                var method = b[c];
                if (!Module[c] && typeof method == "function" && method.call) {
                    a[c] = method
                }
            }
        }
        ;
        var Enumerable = Module.extend({every: function(c, d, e) {
                var f = true;
                try {
                    this.forEach(c, function(a, b) {
                        f = d.call(e, a, b, c);
                        if (!f)
                            throw StopIteration;
                    })
                } catch (error) {
                    if (error != StopIteration)
                        throw error;
                }
                return !!f
            },filter: function(d, e, f) {
                var i = 0;
                return this.reduce(d, function(a, b, c) {
                    if (e.call(f, b, c, d)) {
                        a[i++] = b
                    }
                    return a
                }, [])
            },invoke: function(b, c) {
                var d = slice(arguments, 2);
                return this.map(b, (typeof c == "function") ? function(a) {
                    return (a == null) ? undefined : c.apply(a, d)
                } : function(a) {
                    return (a == null) ? undefined : a[c].apply(a, d)
                })
            },map: function(c, d, e) {
                var f = [], i = 0;
                this.forEach(c, function(a, b) {
                    f[i++] = d.call(e, a, b, c)
                });
                return f
            },pluck: function(b, c) {
                return this.map(b, function(a) {
                    return (a == null) ? undefined : a[c]
                })
            },reduce: function(c, d, e, f) {
                var g = arguments.length > 2;
                this.forEach(c, function(a, b) {
                    if (g) {
                        e = d.call(f, e, a, b, c)
                    } else {
                        e = a;
                        g = true
                    }
                });
                return e
            },some: function(a, b, c) {
                return !this.every(a, not(b), c)
            }}, {forEach: forEach});
        var _14 = "#";
        var Map = Base.extend({constructor: function(a) {
                this.merge(a)
            },copy: delegate(copy),forEach: function(a, b) {
                for (var c in this)
                    if (c.charAt(0) == _14) {
                        a.call(b, this[c], c.slice(1), this)
                    }
            },get: function(a) {
                return this[_14 + a]
            },getKeys: function() {
                return this.map(flip(I))
            },getValues: function() {
                return this.map(I)
            },has: function(a) { /*@cc_on@*/ /*@if(@_jscript_version<5.5)return $Legacy.has(this,_14+a);@else@*/
                return _14 + a in this; /*@end@*/
            },merge: function(b) {
                var c = flip(this.put);
                forEach(arguments, function(a) {
                    forEach(a, c, this)
                }, this);
                return this
            },remove: function(a) {
                delete this[_14 + a]
            },put: function(a, b) {
                if (arguments.length == 1)
                    b = a;
                this[_14 + a] = b
            },size: function() {
                var a = 0;
                for (var b in this)
                    if (b.charAt(0) == _14)
                        a++;
                return a
            },union: function(a) {
                return this.merge.apply(this.copy(), arguments)
            }});
        Map.implement(Enumerable);
        var _15 = "~";
        var Collection = Map.extend({constructor: function(a) {
                this[_15] = new Array2;
                this.base(a)
            },add: function(a, b) {
                assert(!this.has(a), "Duplicate key '" + a + "'.");
                this.put.apply(this, arguments)
            },copy: function() {
                var a = this.base();
                a[_15] = this[_15].copy();
                return a
            },forEach: function(a, b) {
                var c = this[_15];
                var d = c.length;
                for (var i = 0; i < d; i++) {
                    a.call(b, this[_14 + c[i]], c[i], this)
                }
            },getAt: function(a) {
                if (a < 0)
                    a += this[_15].length;
                var b = this[_15][a];
                return (b === undefined) ? undefined : this[_14 + b]
            },getKeys: function() {
                return this[_15].concat()
            },indexOf: function(a) {
                return this[_15].indexOf(String(a))
            },insertAt: function(a, b, c) {
                assert(Math.abs(a) < this[_15].length, "Index out of bounds.");
                assert(!this.has(b), "Duplicate key '" + b + "'.");
                this[_15].insertAt(a, String(b));
                this.put.apply(this, slice(arguments, 1))
            },item: Undefined,put: function(a, b) {
                if (arguments.length == 1)
                    b = a;
                if (!this.has(a)) {
                    this[_15].push(String(a))
                }
                var c = this.constructor;
                if (c.Item && !instanceOf(b, c.Item)) {
                    b = c.create.apply(c, arguments)
                }
                this[_14 + a] = b
            },putAt: function(a, b) {
                assert(Math.abs(a) < this[_15].length, "Index out of bounds.");
                arguments[0] = this[_15].item(a);
                this.put.apply(this, arguments)
            },remove: function(a) {
                if (this.has(a)) {
                    this[_15].remove(String(a));
                    delete this[_14 + a]
                }
            },removeAt: function(a) {
                this[_15].removeAt(a);
                delete this[_14 + key]
            },reverse: function() {
                this[_15].reverse();
                return this
            },size: function() {
                return this[_15].length
            },sort: function(c) {
                if (c) {
                    var d = this;
                    this[_15].sort(function(a, b) {
                        return c(d[_14 + a], d[_14 + b], a, b)
                    })
                } else
                    this[_15].sort();
                return this
            },toString: function() {
                return String(this[_15])
            }}, {Item: null,init: function() {
                this.prototype.item = this.prototype.getAt
            },create: function(a, b) {
                return this.Item ? new this.Item(a, b) : b
            },extend: function(a, b) {
                var c = this.base(a);
                c.create = this.create;
                extend(c, b);
                if (!c.Item) {
                    c.Item = this.Item
                } else if (typeof c.Item != "function") {
                    c.Item = (this.Item || Base).extend(c.Item)
                }
                c.init();
                return c
            }});
        var _16 = /\\(\d+)/g, _17 = /\\./g, _18 = /\(\?[:=!]|\[[^\]]+\]/g, _19 = /\(/g, _20 = /\$(\d+)/, _21 = /^\$\d+$/;
        var RegGrp = Collection.extend({constructor: function(a, b) {
                this.base(a);
                if (typeof b == "string") {
                    this.global = /g/.test(b);
                    this.ignoreCase = /i/.test(b)
                }
            },global: true,ignoreCase: false,exec: function(h, j) {
                var k = (this.global ? "g" : "") + (this.ignoreCase ? "i" : "");
                h = String(h) + "";
                if (arguments.length == 1) {
                    var l = this;
                    var m = this[_15];
                    j = function(a) {
                        if (a) {
                            var b, c = 1, i = 0;
                            while ((b = l[_14 + m[i++]])) {
                                var d = c + b.length + 1;
                                if (arguments[c]) {
                                    var e = b.replacement;
                                    switch (typeof e) {
                                        case "function":
                                            var f = slice(arguments, c, d);
                                            var g = arguments[arguments.length - 2];
                                            return e.apply(l, f.concat(g, h));
                                        case "number":
                                            return arguments[c + e];
                                        default:
                                            return e
                                    }
                                }
                                c = d
                            }
                        }
                        return ""
                    }
                }
                return h.replace(new RegExp(this, k), j)
            },insertAt: function(a, b, c) {
                if (instanceOf(b, RegExp)) {
                    arguments[1] = b.source
                }
                return base(this, arguments)
            },test: function(a) {
                return this.exec(a) != a
            },toString: function() {
                var e = 0;
                return "(" + this.map(function(c) {
                    var d = String(c).replace(_16, function(a, b) {
                        return "\\" + (1 + Number(b) + e)
                    });
                    e += c.length + 1;
                    return d
                }).join(")|(") + ")"
            }}, {IGNORE: "$0",init: function() {
                forEach("add,get,has,put,remove".split(","), function(b) {
                    _22(this, b, function(a) {
                        if (a && a.source) {
                            arguments[0] = a.source
                        }
                        return base(this, arguments)
                    })
                }, this.prototype)
            },Item: {constructor: function(a, b) {
                    a = (a && a.source) ? a.source : String(a);
                    if (typeof b == "number")
                        b = String(b);
                    else if (b == null)
                        b = "";
                    if (typeof b == "string" && _20.test(b)) {
                        if (_21.test(b)) {
                            b = parseInt(b.slice(1))
                        } else {
                            var Q = /'/.test(b.replace(/\\./g, "")) ? '"' : "'";
                            b = b.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\$(\d+)/g, Q + "+(arguments[$1]||" + Q + Q + ")+" + Q);
                            b = new Function("return " + Q + b.replace(/(['"])\1\+(.*)\+\1\1$/, "$1") + Q)
                        }
                    }
                    this.length = RegGrp.count(a);
                    this.replacement = b;
                    this.toString = K(a)
                },length: 0,replacement: ""},count: function(a) {
                a = String(a).replace(_17, "").replace(_18, "");
                return match(a, _19).length
            }});
        var JavaScript = {name: "JavaScript",version: base2.version,exports: "Array2, Date2, String2",namespace: "",bind: function(c) {
                forEach(this.exports.match(/\w+/g), function(a) {
                    var b = a.slice(0, -1);
                    extend(c[b], this[a]);
                    this[a](c[b].prototype)
                }, this)
            }};
        if ((new Date).getYear() > 1900) {
            Date.prototype.getYear = function() {
                return this.getFullYear() - 1900
            };
            Date.prototype.setYear = function(a) {
                return this.setFullYear(a + 1900)
            }
        }
        Function.prototype.prototype = {};
        if ("".replace(/^/, K("$$")) == "$") {
            extend(String.prototype, "replace", function(a, b) {
                if (typeof b == "function") {
                    var c = b;
                    b = function() {
                        return String(c.apply(null, arguments)).split("$").join("$$")
                    }
                }
                return this.base(a, b)
            })
        }
        var Array2 = _23(Array, Array, "concat,join,pop,push,reverse,shift,slice,sort,splice,unshift", [Enumerable, {combine: function(d, e) {
                    if (!e)
                        e = d;
                    return this.reduce(d, function(a, b, c) {
                        a[b] = e[c];
                        return a
                    }, {})
                },contains: function(a, b) {
                    return this.indexOf(a, b) != -1
                },copy: function(a) {
                    var b = this.slice(a);
                    if (!b.swap)
                        this(b);
                    return b
                },flatten: function(c) {
                    return this.reduce(c, function(a, b) {
                        if (this.like(b)) {
                            this.reduce(b, arguments.callee, a, this)
                        } else {
                            a.push(b)
                        }
                        return a
                    }, [], this)
                },forEach: _24,indexOf: function(a, b, c) {
                    var d = a.length;
                    if (c == null) {
                        c = 0
                    } else if (c < 0) {
                        c = Math.max(0, d + c)
                    }
                    for (var i = c; i < d; i++) {
                        if (a[i] === b)
                            return i
                    }
                    return -1
                },insertAt: function(a, b, c) {
                    this.splice(a, b, 0, c);
                    return c
                },item: function(a, b) {
                    if (b < 0)
                        b += a.length;
                    return a[b]
                },lastIndexOf: function(a, b, c) {
                    var d = a.length;
                    if (c == null) {
                        c = d - 1
                    } else if (from < 0) {
                        c = Math.max(0, d + c)
                    }
                    for (var i = c; i >= 0; i--) {
                        if (a[i] === b)
                            return i
                    }
                    return -1
                },map: function(c, d, e) {
                    var f = [];
                    this.forEach(c, function(a, b) {
                        f[b] = d.call(e, a, b, c)
                    });
                    return f
                },remove: function(a, b) {
                    var c = this.indexOf(a, b);
                    if (c != -1)
                        this.removeAt(a, c);
                    return b
                },removeAt: function(a, b) {
                    return this.splice(a, b, 1)
                },swap: function(a, b, c) {
                    var d = a[b];
                    a[b] = a[c];
                    a[c] = d;
                    return a
                }}]);
        Array2.reduce = Enumerable.reduce;
        Array2.like = function(a) {
            return !!(a && typeof a == "object" && typeof a.length == "number")
        };
        var _25 = /^((-\d+|\d{4,})(-(\d{2})(-(\d{2}))?)?)?T((\d{2})(:(\d{2})(:(\d{2})(\.(\d{1,3})(\d)?\d*)?)?)?)?(([+-])(\d{2})(:(\d{2}))?|Z)?$/;
        var _26 = {FullYear: 2,Month: 4,Date: 6,Hours: 8,Minutes: 10,Seconds: 12,Milliseconds: 14};
        var _27 = {Hectomicroseconds: 15,UTC: 16,Sign: 17,Hours: 18,Minutes: 20};
        var _28 = /(((00)?:0+)?:0+)?\.0+$/;
        var _29 = /(T[0-9:.]+)$/;
        var Date2 = _23(Date, function(a, b, c, h, m, s, d) {
            switch (arguments.length) {
                case 0:
                    return new Date;
                case 1:
                    return new Date(a);
                default:
                    return new Date(a, b, arguments.length == 2 ? 1 : c, h || 0, m || 0, s || 0, d || 0)
            }
        }, "", [{toISOString: function(c) {
                    var d = "####-##-##T##:##:##.###";
                    for (var e in _26) {
                        d = d.replace(/#+/, function(a) {
                            var b = c["getUTC" + e]();
                            if (e == "Month")
                                b++;
                            return ("000" + b).slice(-a.length)
                        })
                    }
                    return d.replace(_28, "").replace(_29, "$1Z")
                }}]);
        Date2.now = function() {
            return (new Date).valueOf()
        };
        Date2.parse = function(a, b) {
            if (arguments.length > 1) {
                assertType(b, "number", "defaultDate should be of type 'number'.")
            }
            var c = String(a).match(_25);
            if (c) {
                if (c[_26.Month])
                    c[_26.Month]--;
                if (c[_27.Hectomicroseconds] >= 5)
                    c[_26.Milliseconds]++;
                var d = new Date(b || 0);
                var e = c[_27.UTC] || c[_27.Hours] ? "UTC" : "";
                for (var f in _26) {
                    var value = c[_26[f]];
                    if (!value)
                        continue;
                    d["set" + e + f](value);
                    if (d["get" + e + f]() != c[_26[f]]) {
                        return NaN
                    }
                }
                if (c[_27.Hours]) {
                    var g = Number(c[_27.Sign] + c[_27.Hours]);
                    var h = Number(c[_27.Sign] + (c[_27.Minutes] || 0));
                    d.setUTCMinutes(d.getUTCMinutes() + (g * 60) + h)
                }
                return d.valueOf()
            } else {
                return Date.parse(a)
            }
        };
        var String2 = _23(String, function(a) {
            return new String(arguments.length == 0 ? "" : a)
        }, "charAt,charCodeAt,concat,indexOf,lastIndexOf,match,replace,search,slice,split,substr,substring,toLowerCase,toUpperCase", [{trim: trim}]);
        function _23(c, d, e, f) {
            var g = Module.extend();
            forEach(e.match(/\w+/g), function(a) {
                g[a] = unbind(c.prototype[a])
            });
            forEach(f, g.implement, g);
            var h = function() {
                return g(this.constructor == g ? d.apply(null, arguments) : arguments[0])
            };
            h.prototype = g.prototype;
            forEach(g, function(a, b) {
                if (c[b]) {
                    delete g.prototype[b]
                }
                h[b] = g[b]
            });
            h.ancestor = Object;
            delete h.extend;
            if (c != Array)
                delete h.forEach;
            return h
        }
        ;
        function extend(a, b) {
            if (a && b) {
                if (arguments.length > 2) {
                    var c = b;
                    b = {};
                    b[c] = arguments[2]
                }
                var d = (typeof b == "function" ? Function : Object).prototype;
                var i = _5.length, c;
                if (base2.__prototyping) {
                    while ((c = _5[--i])) {
                        var f = b[c];
                        if (f != d[c]) {
                            if (_4.test(f)) {
                                _22(a, c, f)
                            } else {
                                a[c] = f
                            }
                        }
                    }
                }
                for (c in b) {
                    if (d[c] === undefined) {
                        var f = b[c];
                        if (c.charAt(0) == "@" && detect(c.slice(1))) {
                            arguments.callee(a, f);
                            continue
                        }
                        var h = a[c];
                        if (h && typeof f == "function") {
                            if (f != h && (!h.method || !_11(f, h))) {
                                if (f.__base || _4.test(f)) {
                                    _22(a, c, f)
                                } else {
                                    a[c] = f
                                }
                            }
                        } else {
                            a[c] = f
                        }
                    }
                }
            }
            return a
        }
        ;
        function _11(a, b) {
            while (b) {
                if (!b.ancestor)
                    return false;
                b = b.ancestor;
                if (b == a)
                    return true
            }
            return false
        }
        ;
        function _22(c, d, e) {
            var f = c[d];
            function _30() {
                var a = this.base;
                this.base = f;
                var b = e.apply(this, arguments);
                this.base = a;
                return b
            }
            ;
            _30.ancestor = f;
            _30.method = e;
            _30.toString = function() {
                return String(e)
            };
            c[d] = _30
        }
        ;
        if (typeof StopIteration == "undefined") {
            StopIteration = new Error("StopIteration")
        }
        function forEach(a, b, c, d) {
            if (a == null)
                return;
            if (!d) {
                if (typeof a == "function" && a.call) {
                    d = Function
                } else if (typeof a.forEach == "function" && a.forEach != arguments.callee) {
                    a.forEach(b, c);
                    return
                } else if (typeof a.length == "number") {
                    _24(a, b, c);
                    return
                }
            }
            _8(d || Object, a, b, c)
        }
        ;
        function _24(a, b, c) {
            if (a == null)
                return;
            var d = a.length, i;
            if (typeof a == "string") {
                for (i = 0; i < d; i++) {
                    b.call(c, a.charAt(i), i, a)
                }
            } else {
                for (i = 0; i < d; i++) { /*@cc_on@*/ /*@if(@_jscript_version<5.2)if(a[i]!==undefined||$Legacy.has(a,i))@else@*/
                    if (i in a) /*@end@*/
                        b.call(c, a[i], i, a)
                }
            }
        }
        ;
        function _8(g, h, j, k) {
            var l = function() {
                this.i = 1
            };
            l.prototype = {i: 1};
            var m = 0;
            for (var i in new l)
                m++;
            _8 = (m > 1) ? function(a, b, c, d) {
                var e = {};
                for (var f in b) {
                    if (!e[f] && a.prototype[f] === undefined) {
                        e[f] = true;
                        c.call(d, b[f], f, b)
                    }
                }
            } : function(a, b, c, d) {
                for (var e in b) {
                    if (a.prototype[e] === undefined) {
                        c.call(d, b[e], e, b)
                    }
                }
            };
            _8(g, h, j, k)
        }
        ;
        function instanceOf(a, b) {
            if (typeof b != "function") {
                throw new TypeError("Invalid 'instanceOf' operand.");
            }
            if (a == null)
                return false; /*@cc_on@*/ /*@if(@_jscript_version<5.1)if($Legacy.instanceOf(a,b))return true;@else@*/
            if (a instanceof b)
                return true; /*@end@*/
            if (Base.ancestorOf == b.ancestorOf)
                return false;
            var c = a.constructor;
            if (typeof c != "function")
                return false;
            if (Base.ancestorOf == c.ancestorOf)
                return b == Object;
            switch (b) {
                case Array:
                    return !!(typeof a == "object" && a.join && a.splice);
                case Function:
                    return !!(typeof a == "function" && a.call);
                case RegExp:
                    return c.prototype.toString() == _6;
                case Date:
                    return !!a.getTimezoneOffset;
                case String:
                case Number:
                case Boolean:
                    return typeof a == typeof b.prototype.valueOf();
                case Object:
                    return true
            }
            return false
        }
        ;
        function assert(a, b, c) {
            if (!a) {
                throw new (c || Error)(b || "Assertion failed.");
            }
        }
        ;
        function assertArity(a, b, c) {
            if (b == null)
                b = a.callee.length;
            if (a.length < b) {
                throw new SyntaxError(c || "Not enough arguments.");
            }
        }
        ;
        function assertType(a, b, c) {
            if (b && (typeof b == "function" ? !instanceOf(a, b) : typeof a != b)) {
                throw new TypeError(c || "Invalid type.");
            }
        }
        ;
        function assignID(a) {
            if (!a.base2ID)
                a.base2ID = "b2_" + counter();
            return a.base2ID
        }
        ;
        function counter() {
            return _7++
        }
        ;
        function copy(a) {
            var b = function() {
            };
            b.prototype = a;
            return new b
        }
        ;
        function format(c) {
            var d = arguments;
            var e = new RegExp("%([1-" + arguments.length + "])", "g");
            return String(c).replace(e, function(a, b) {
                return b < d.length ? d[b] : a
            })
        }
        ;
        function match(a, b) {
            return String(a).match(b) || []
        }
        ;
        function rescape(a) {
            return String(a).replace(_3, "\\$1")
        }
        ;
        function trim(a) {
            return String(a).replace(_1, "").replace(_2, "")
        }
        ;
        function I(i) {
            return i
        }
        ;
        function K(k) {
            return function() {
                return k
            }
        }
        ;
        function bind(a, b) {
            var c = slice(arguments, 2);
            var d = function() {
                return a.apply(b, c.concat(slice(arguments)))
            };
            d._31 = assignID(a);
            return d
        }
        ;
        function delegate(a, b) {
            return function() {
                return a.apply(b, [this].concat(slice(arguments)))
            }
        }
        ;
        function flip(a) {
            return function() {
                return a.apply(this, Array2.swap(arguments, 0, 1))
            }
        }
        ;
        function not(a) {
            return function() {
                return !a.apply(this, arguments)
            }
        }
        ;
        function partial(a) {
            var b = slice.call(arguments, 1);
            return function() {
                return a.apply(this, b.concat(slice(arguments)))
            }
        }
        ;
        function unbind(b) {
            return function(a) {
                return b.apply(a, slice(arguments, 1))
            }
        }
        ;
        base2 = new Package(this, base2);
        eval(this.exports);
        base2.extend = extend;
        forEach(Enumerable, function(a, b) {
            if (!Module[b])
                base2.addName(b, bind(a, Enumerable))
        });
        JavaScript = new Package(this, JavaScript);
        eval(this.exports)
    };
    new function(_) {
        var DOM = new base2.Package(this, {name: "DOM",version: "1.0 (beta 1)",exports: "Interface, Binding, Node, Document, Element, AbstractView, Event, EventTarget, DocumentEvent, " + "NodeSelector, DocumentSelector, ElementSelector, StaticNodeList, " + "ViewCSS, HTMLDocument, HTMLElement, Selector, Traversal, XPathParser",bind: function(a) {
                if (a && a.nodeType) {
                    var b = assignID(a);
                    if (!arguments.callee[b]) {
                        switch (a.nodeType) {
                            case 1:
                                if (typeof a.className == "string") {
                                    (HTMLElement.bindings[a.tagName] || HTMLElement).bind(a)
                                } else {
                                    Element.bind(a)
                                }
                                break;
                            case 9:
                                if (a.writeln) {
                                    HTMLDocument.bind(a)
                                } else {
                                    Document.bind(a)
                                }
                                break;
                            default:
                                Node.bind(a)
                        }
                        arguments.callee[b] = true
                    }
                }
                return a
            },"@MSIE5.+win": {bind: function(a) {
                    if (a && a.writeln) {
                        a.nodeType = 9
                    }
                    return this.base(a)
                }}});
        eval(this.imports);
        var _32 = detect("MSIE");
        var _33 = detect("MSIE5");
        if (detect("MSIE[56].+win") && !detect("SV1")) {
            var closures = {};
            extend(base2, "bind", function(b, c) {
                if (!c || c.nodeType != 1) {
                    return this.base(b, c)
                }
                var d = c.uniqueID;
                var e = assignID(b);
                closures[e] = b;
                b = null;
                c = null;
                if (!closures[d])
                    closures[d] = {};
                var f = closures[d][e];
                if (f)
                    return f;
                var g = function() {
                    var a = document.all[d];
                    return a ? closures[e].apply(a, arguments) : undefined
                };
                g._31 = e;
                closures[d][e] = g;
                return g
            });
            attachEvent("onunload", function() {
                closures = null
            })
        }
        var Interface = Module.extend(null, {implement: function(c) {
                if (typeof c == "object") {
                    forEach(c, function(a, b) {
                        if (b.charAt(0) == "@") {
                            forEach(a, arguments.callee, this)
                        } else if (!this[b] && typeof a == "function") {
                            this.createDelegate(b, a.length)
                        }
                    }, this)
                }
                return this.base(c)
            },createDelegate: function(a, b) {
                if (!this[a]) {
                    var c = "var fn=function _%1(%2){%3.base=%3.%1.ancestor;var m=%3.base?'base':'%1';return %3[m](%4)}";
                    var d = "abcdefghij".split("").slice(-b);
                    eval(format(c, a, d, d[0], d.slice(1)));
                    this[a] = fn
                }
            }});
        var Binding = Interface.extend(null, {extend: function(d, a) {
                if (a && a.bind != Function.bind) {
                    var c = a.bind;
                    delete a.bind
                }
                var b = this.base(d, a);
                b.bind = this.bind;
                if (c)
                    extend(b, "bind", c);
                return b
            },bind: function(b) {
                return extend(b, this.prototype)
            }});
        var Node = Binding.extend({"@!(element.compareDocumentPosition)": {compareDocumentPosition: function(a, b) {
                    if (Traversal.contains(a, b)) {
                        return 4 | 16
                    } else if (Traversal.contains(b, a)) {
                        return 2 | 8
                    }
                    var c = _34(a);
                    var d = _34(b);
                    if (c < d) {
                        return 4
                    } else if (c > d) {
                        return 2
                    }
                    return 0
                }}});
        var _34 = document.documentElement.sourceIndex ? function(a) {
            return a.sourceIndex
        } : function(a) {
            var b = 0;
            while (a) {
                b = Traversal.getNodeIndex(a) + "." + b;
                a = a.parentNode
            }
            return b
        };
        var Document = Node.extend(null, {bind: function(b) {
                extend(b, "createElement", function(a) {
                    return DOM.bind(this.base(a))
                });
                AbstractView.bind(b.defaultView);
                if (b != window.document)
                    new DOMContentLoadedEvent(b);
                return this.base(b)
            },"@!(document.defaultView)": {bind: function(a) {
                    a.defaultView = Traversal.getDefaultView(a);
                    return this.base(a)
                }}});
        var _35 = /^(href|src|type|value)$/;
        var _36 = {"class": "className","for": "htmlFor"};
        var Element = Node.extend({"@MSIE.+win": {getAttribute: function(a, b, c) {
                    if (a.className === undefined) {
                        return this.base(a, b)
                    }
                    var d = _37(a, b);
                    if (d && d.specified) {
                        if (_35.test(b)) {
                            return this.base(a, b, 2)
                        } else if (b == "style") {
                            return a.style.cssText
                        } else {
                            return d.nodeValue
                        }
                    }
                    return null
                },setAttribute: function(a, b, c) {
                    if (a.className === undefined) {
                        this.base(a, b, c)
                    } else if (b == "style") {
                        a.style.cssText = c
                    } else {
                        this.base(a, _36[b] || b, String(c))
                    }
                }},"@!(element.hasAttribute)": {hasAttribute: function(a, b) {
                    return this.getAttribute(a, b) != null
                }}});
        extend(Element.prototype, "cloneNode", function(a) {
            var b = this.base(a || false);
            b.base2ID = undefined;
            return b
        });
        if (_32) {
            var names = "colSpan,rowSpan,vAlign,dateTime,accessKey,tabIndex,encType,maxLength,readOnly,longDesc";
            extend(_36, Array2.combine(names.toLowerCase().split(","), names.split(",")));
            var _37 = _33 ? function(a, b) {
                return a.attributes[b] || a.attributes[_36[b.toLowerCase()]]
            } : function(a, b) {
                return a.getAttributeNode(b)
            }
        }
        var TEXT = _32 ? "innerText" : "textContent";
        var Traversal = Module.extend({getDefaultView: function(a) {
                return this.getDocument(a).defaultView
            },getNextElementSibling: function(a) {
                while (a && (a = a.nextSibling) && !this.isElement(a))
                    continue;
                return a
            },getNodeIndex: function(a) {
                var b = 0;
                while (a && (a = a.previousSibling))
                    b++;
                return b
            },getOwnerDocument: function(a) {
                return a.ownerDocument
            },getPreviousElementSibling: function(a) {
                while (a && (a = a.previousSibling) && !this.isElement(a))
                    continue;
                return a
            },getTextContent: function(a) {
                return a[TEXT]
            },isEmpty: function(a) {
                a = a.firstChild;
                while (a) {
                    if (a.nodeType == 3 || this.isElement(a))
                        return false;
                    a = a.nextSibling
                }
                return true
            },setTextContent: function(a, b) {
                return a[TEXT] = b
            },"@MSIE": {getDefaultView: function(a) {
                    return this.getDocument(a).parentWindow
                },"@MSIE5": {getOwnerDocument: function(a) {
                        return a.ownerDocument || a.document
                    }}}}, {contains: function(a, b) {
                while (b && (b = b.parentNode) && a != b)
                    continue;
                return !!b
            },getDocument: function(a) {
                return this.isDocument(a) ? a : this.getOwnerDocument(a)
            },isDocument: function(a) {
                return !!(a && a.documentElement)
            },isElement: function(a) {
                return !!(a && a.nodeType == 1)
            },"@(element.contains)": {contains: function(a, b) {
                    return a != b && (this.isDocument(a) ? a == this.getOwnerDocument(b) : a.contains(b))
                }},"@MSIE5": {isElement: function(a) {
                    return !!(a && a.nodeType == 1 && a.tagName != "!")
                }}});
        var AbstractView = Binding.extend();
        var Event = Binding.extend({"@!(document.createEvent)": {initEvent: function(a, b, c, d) {
                    a.type = b;
                    a.bubbles = c;
                    a.cancelable = d;
                    a.timeStamp = new Date().valueOf()
                },"@MSIE": {initEvent: function(a, b, c, d) {
                        this.base(a, b, c, d);
                        a.cancelBubble = !a.bubbles
                    },preventDefault: function(a) {
                        if (a.cancelable !== false) {
                            a.returnValue = false
                        }
                    },stopPropagation: function(a) {
                        a.cancelBubble = true
                    }}}}, {"@!(document.createEvent)": {"@MSIE": {"@Mac": {bind: function(a) {
                            return this.base(extend(copy(a), {preventDefault: function() {
                                    if (this.cancelable !== false) {
                                        this.returnValue = false
                                    }
                                }}))
                        }},"@Windows": {bind: function(a) {
                            if (!a.timeStamp) {
                                a.bubbles = !!_38[a.type];
                                a.cancelable = !!_39[a.type];
                                a.timeStamp = new Date().valueOf()
                            }
                            if (!a.target) {
                                a.target = a.srcElement
                            }
                            a.relatedTarget = a[(a.type == "mouseout" ? "to" : "from") + "Element"];
                            return this.base(a)
                        }}}}});
        if (_32) {
            var _38 = "abort,error,select,change,resize,scroll";
            var _39 = "click,mousedown,mouseup,mouseover,mousemove,mouseout,keydown,keyup,submit,reset";
            _38 = Array2.combine((_38 + "," + _39).split(","));
            _39 = Array2.combine(_39.split(","))
        }
        var EventTarget = Interface.extend({"@!(element.addEventListener)": {addEventListener: function(a, b, c, d) {
                    var e = assignID(a);
                    var f = c._31 || assignID(c);
                    var g = _40[e];
                    if (!g)
                        g = _40[e] = {};
                    var h = g[b];
                    var i = a["on" + b];
                    if (!h) {
                        h = g[b] = {};
                        if (i)
                            h[0] = i
                    }
                    h[f] = c;
                    if (i !== undefined) {
                        a["on" + b] = delegate(_40.handleEvent)
                    }
                },dispatchEvent: function(a, b) {
                    return _40.handleEvent(a, b)
                },removeEventListener: function(a, b, c, d) {
                    var e = _40[a.base2ID];
                    if (e && e[b]) {
                        delete e[b][c.base2ID]
                    }
                },"@MSIE.+win": {addEventListener: function(a, b, c, d) {
                        if (typeof c == "function") {
                            c = bind(c, a)
                        }
                        this.base(a, b, c, d)
                    },dispatchEvent: function(a, b) {
                        b.target = a;
                        try {
                            return a.fireEvent(b.type, b)
                        } catch (error) {
                            return this.base(a, b)
                        }
                    }}}});
        var _40 = new Base({handleEvent: function(a, b) {
                var c = true;
                var d = _40[a.base2ID];
                if (d) {
                    b = Event.bind(b);
                    var e = d[b.type];
                    for (var i in e) {
                        var listener = e[i];
                        if (listener.handleEvent) {
                            var result = listener.handleEvent(b)
                        } else {
                            result = listener.call(a, b)
                        }
                        if (result === false || b.returnValue === false)
                            c = false
                    }
                }
                return c
            },"@MSIE": {handleEvent: function(a, b) {
                    if (a.Infinity) {
                        a = a.document.parentWindow;
                        if (!b)
                            b = a.event
                    }
                    return this.base(a, b || Traversal.getDefaultView(a).event)
                }}});
        var DocumentEvent = Interface.extend({"@!(document.createEvent)": {createEvent: function(a, b) {
                    return Event.bind({})
                },"@(document.createEventObject)": {createEvent: function(a, b) {
                        return Event.bind(a.createEventObject())
                    }}},"@(document.createEvent)": {"@!(document.createEvent('Events'))": {createEvent: function(a, b) {
                        return this.base(a, b == "Events" ? "UIEvents" : b)
                    }}}});
        var DOMContentLoadedEvent = Base.extend({constructor: function(b) {
                var c = false;
                this.fire = function() {
                    if (!c) {
                        c = true;
                        setTimeout(function() {
                            var a = DocumentEvent.createEvent(b, "Events");
                            Event.initEvent(a, "DOMContentLoaded", false, false);
                            EventTarget.dispatchEvent(b, a)
                        }, 1)
                    }
                };
                EventTarget.addEventListener(b, "DOMContentLoaded", function() {
                    c = true
                }, false);
                EventTarget.addEventListener(Traversal.getDefaultView(b), "load", this.fire, false)
            },"@(attachEvent)": {constructor: function() {
                    this.base(document);
                    Traversal.getDefaultView(document).attachEvent("onload", this.fire)
                }},"@MSIE.+win": {constructor: function(a) {
                    this.base(a);
                    if (a.readyState != "complete") {
                        var b = this;
                        a.write("<script id=__ready defer src=//:><\/script>");
                        a.all.__ready.onreadystatechange = function() {
                            if (this.readyState == "complete") {
                                this.removeNode();
                                b.fire()
                            }
                        }
                    }
                }},"@KHTML": {constructor: function(a) {
                    this.base(a);
                    if (a.readyState != "complete") {
                        var b = this;
                        var c = setInterval(function() {
                            if (/loaded|complete/.test(a.readyState)) {
                                clearInterval(c);
                                b.fire()
                            }
                        }, 100)
                    }
                }}});
        new DOMContentLoadedEvent(document);
        Document.implement(DocumentEvent);
        Document.implement(EventTarget);
        Element.implement(EventTarget);
        var _41 = /^\d+(px)?$/i;
        var _42 = /(width|height|top|bottom|left|right|fontSize)$/;
        var _43 = /^(color|backgroundColor)$/;
        var ViewCSS = Interface.extend({"@!(document.defaultView.getComputedStyle)": {"@MSIE": {getComputedStyle: function(b, c, d) {
                        var e = c.currentStyle;
                        var f = {getPropertyValue: function(a) {
                                return this[ViewCSS.toCamelCase(a)]
                            }};
                        for (var i in e) {
                            if (_42.test(i)) {
                                f[i] = _44(c, f[i]) + "px"
                            } else if (_43.test(i)) {
                                f[i] = _45(c, i == "color" ? "ForeColor" : "BackColor")
                            } else {
                                f[i] = e[i]
                            }
                        }
                        return f
                    }}}}, {toCamelCase: function(c) {
                return c.replace(/\-([a-z])/g, function(a, b) {
                    return b.toUpperCase()
                })
            }});
        function _44(a, b) {
            if (_41.test(b))
                return parseInt(b);
            var c = a.style.left;
            var d = a.runtimeStyle.left;
            a.runtimeStyle.left = a.currentStyle.left;
            a.style.left = b || 0;
            b = a.style.pixelLeft;
            a.style.left = c;
            a.runtimeStyle.left = d;
            return b
        }
        ;
        function _45(a, b) {
            var c = a.document.body.createTextRange();
            c.moveToElementText(a);
            var d = c.queryCommandValue(b);
            return format("rgb(%1,%2,%3)", d & 0xff, (d & 0xff00) >> 8, (d & 0xff0000) >> 16)
        }
        ;
        AbstractView.implement(ViewCSS);
        var NodeSelector = Interface.extend({"@!(element.querySelector)": {querySelector: function(a, b) {
                    return new Selector(b).exec(a, 1)
                },querySelectorAll: function(a, b) {
                    return new Selector(b).exec(a)
                }}});
        extend(NodeSelector.prototype, {querySelector: function(a) {
                return DOM.bind(this.base(a))
            },querySelectorAll: function(b) {
                return extend(this.base(b), "item", function(a) {
                    return DOM.bind(this.base(a))
                })
            }});
        var DocumentSelector = NodeSelector.extend();
        var ElementSelector = NodeSelector.extend({"@!(element.matchesSelector)": {matchesSelector: function(a, b) {
                    return new Selector(b).test(a)
                }}});
        var StaticNodeList = Base.extend({constructor: function(b) {
                b = b || [];
                this.length = b.length;
                this.item = function(a) {
                    return b[a]
                }
            },length: 0,forEach: function(a, b) {
                for (var i = 0; i < this.length; i++) {
                    a.call(b, this.item(i), i, this)
                }
            },item: Undefined,"@(XPathResult)": {constructor: function(b) {
                    if (b && b.snapshotItem) {
                        this.length = b.snapshotLength;
                        this.item = function(a) {
                            return b.snapshotItem(a)
                        }
                    } else
                        this.base(b)
                }}});
        StaticNodeList.implement(Enumerable);
        var CSSParser = RegGrp.extend({constructor: function(a) {
                this.base(a);
                this.cache = {};
                this.sorter = new RegGrp;
                this.sorter.add(/:not\([^)]*\)/, RegGrp.IGNORE);
                this.sorter.add(/([ >](\*|[\w-]+))([^: >+~]*)(:\w+-child(\([^)]+\))?)([^: >+~]*)/, "$1$3$6$4")
            },cache: null,ignoreCase: true,escape: function(b) {
                var c = /'/g;
                var d = this._46 = [];
                return this.optimise(this.format(String(b).replace(CSSParser.ESCAPE, function(a) {
                    d.push(a.slice(1, -1).replace(c, "\\'"));
                    return "\x01" + d.length
                })))
            },format: function(a) {
                return a.replace(CSSParser.WHITESPACE, "$1").replace(CSSParser.IMPLIED_SPACE, "$1 $2").replace(CSSParser.IMPLIED_ASTERISK, "$1*$2")
            },optimise: function(a) {
                return this.sorter.exec(a.replace(CSSParser.WILD_CARD, ">* "))
            },parse: function(a) {
                return this.cache[a] || (this.cache[a] = this.unescape(this.exec(this.escape(a))))
            },unescape: function(c) {
                var d = this._46;
                return c.replace(/\x01(\d+)/g, function(a, b) {
                    return d[b - 1]
                })
            }}, {ESCAPE: /'(\\.|[^'\\])*'|"(\\.|[^"\\])*"/g,IMPLIED_ASTERISK: /([\s>+~,]|[^(]\+|^)([#.:@])/g,IMPLIED_SPACE: /(^|,)([^\s>+~])/g,WHITESPACE: /\s*([\s>+~(),]|^|$)\s*/g,WILD_CARD: /\s\*\s/g,_47: function(c, d, e, f, g, h, i, j) {
                f = /last/i.test(c) ? f + "+1-" : "";
                if (!isNaN(d))
                    d = "0n+" + d;
                else if (d == "even")
                    d = "2n";
                else if (d == "odd")
                    d = "2n+1";
                d = d.split(/n\+?/);
                var a = d[0] ? (d[0] == "-") ? -1 : parseInt(d[0]) : 1;
                var b = parseInt(d[1]) || 0;
                var k = a < 0;
                if (k) {
                    a = -a;
                    if (a == 1)
                        b++
                }
                var l = format(a == 0 ? "%3%7" + (f + b) : "(%4%3-%2)%6%1%70%5%4%3>=%2", a, b, e, f, h, i, j);
                if (k)
                    l = g + "(" + l + ")";
                return l
            }});
        var XPathParser = CSSParser.extend({constructor: function() {
                this.base(XPathParser.rules);
                this.sorter.putAt(1, "$1$4$3$6")
            },escape: function(a) {
                return this.base(a).replace(/,/g, "\x02")
            },unescape: function(a) {
                return this.base(a.replace(/\[self::\*\]/g, "").replace(/(^|\x02)\//g, "$1./").replace(/\x02/g, " | "))
            },"@opera": {unescape: function(a) {
                    return this.base(a.replace(/last\(\)/g, "count(preceding-sibling::*)+count(following-sibling::*)+1"))
                }}}, {init: function() {
                this.values.attributes[""] = "[@$1]";
                forEach(this.types, function(a, b) {
                    forEach(this.values[b], a, this.rules)
                }, this)
            },optimised: {pseudoClasses: {"first-child": "[1]","last-child": "[last()]","only-child": "[last()=1]"}},rules: extend({}, {"@!KHTML": {"(^|\\x02) (\\*|[\\w-]+)#([\\w-]+)": "$1id('$3')[self::$2]","([ >])(\\*|[\\w-]+):([\\w-]+-child(\\(([^)]+)\\))?)": function(a, b, c, d, e, f) {
                        var g = (b == " ") ? "//*" : "/*";
                        if (/^nth/i.test(d)) {
                            g += _47(d, f, "position()")
                        } else {
                            g += XPathParser.optimised.pseudoClasses[d]
                        }
                        return g + "[self::" + c + "]"
                    }}}),types: {identifiers: function(a, b) {
                    this[rescape(b) + "([\\w-]+)"] = a
                },combinators: function(a, b) {
                    this[rescape(b) + "(\\*|[\\w-]+)"] = a
                },attributes: function(a, b) {
                    this["\\[([\\w-]+)\\s*" + rescape(b) + "\\s*([^\\]]*)\\]"] = a
                },pseudoClasses: function(a, b) {
                    this[":" + b.replace(/\(\)$/, "\\(([^)]+)\\)")] = a
                }},values: {identifiers: {"#": "[@id='$1'][1]",".": "[contains(concat(' ',@class,' '),' $1 ')]"},combinators: {" ": "/descendant::$1",">": "/child::$1","+": "/following-sibling::*[1][self::$1]","~": "/following-sibling::$1"},attributes: {"*=": "[contains(@$1,'$2')]","^=": "[starts-with(@$1,'$2')]","$=": "[substring(@$1,string-length(@$1)-string-length('$2')+1)='$2']","~=": "[contains(concat(' ',@$1,' '),' $2 ')]","|=": "[contains(concat('-',@$1,'-'),'-$2-')]","!=": "[not(@$1='$2')]","=": "[@$1='$2']"},pseudoClasses: {"empty": "[not(child::*) and not(text())]","first-child": "[not(preceding-sibling::*)]","last-child": "[not(following-sibling::*)]","not()": _48,"nth-child()": _47,"nth-last-child()": _47,"only-child": "[not(preceding-sibling::*) and not(following-sibling::*)]","root": "[not(parent::*)]"}},"@opera": {init: function() {
                    this.optimised.pseudoClasses["last-child"] = this.values.pseudoClasses["last-child"];
                    this.optimised.pseudoClasses["only-child"] = this.values.pseudoClasses["only-child"];
                    this.base()
                }}});
        var _49 = new XPathParser;
        function _48(a, b) {
            return "[not(" + _49.exec(trim(b)).replace(/\[1\]/g, "").replace(/^(\*|[\w-]+)/, "[self::$1]").replace(/\]\[/g, " and ").slice(1, -1) + ")]"
        }
        ;
        function _47(a, b, c) {
            return "[" + CSSParser._47(a, b, c || "count(preceding-sibling::*)+1", "last()", "not", " and ", " mod ", "=") + "]"
        }
        ;
        var _50 = ":(checked|disabled|enabled|contains)|^(#[\\w-]+\\s*)?\\w+$";
        if (detect("KHTML")) {
            if (detect("WebKit5")) {
                _50 += "|nth\\-|,"
            } else {
                _50 = "."
            }
        }
        _50 = new RegExp(_50);
        var _51;
        var Selector = Base.extend({constructor: function(a) {
                this.toString = K(trim(a))
            },exec: function(a, b) {
                return Selector.parse(this)(a, b)
            },test: function(a) {
                var b = new Selector(this + "[-base2-test]");
                a.setAttribute("-base2-test", true);
                var c = b.exec(Traversal.getOwnerDocument(a), true);
                a.removeAttribute("-base2-test");
                return c == a
            },toXPath: function() {
                return Selector.toXPath(this)
            },"@(XPathResult)": {exec: function(a, b) {
                    if (_50.test(this)) {
                        return this.base(a, b)
                    }
                    var c = Traversal.getDocument(a);
                    var d = b ? 9 : 7;
                    var e = c.evaluate(this.toXPath(), a, null, d, null);
                    return b ? e.singleNodeValue : e
                }},"@MSIE": {exec: function(a, b) {
                    if (typeof a.selectNodes != "undefined" && !_50.test(this)) {
                        var c = b ? "selectSingleNode" : "selectNodes";
                        return a[c](this.toXPath())
                    }
                    return this.base(a, b)
                }},"@(true)": {exec: function(a, b) {
                    try {
                        var c = this.base(a || document, b)
                    } catch (error) {
                        throw new SyntaxError(format("'%1' is not a valid CSS selector.", this));
                    }
                    return b ? c : new StaticNodeList(c)
                }}}, {toXPath: function(a) {
                if (!_51)
                    _51 = new XPathParser;
                return _51.parse(a)
            }});
        new function(_) {
            var _52 = {"=": "%1=='%2'","!=": "%1!='%2'","~=": /(^| )%1( |$)/,"|=": /^%1(-|$)/,"^=": /^%1/,"$=": /%1$/,"*=": /%1/};
            _52[""] = "%1!=null";
            var _53 = {"checked": "e%1.checked","contains": "e%1[TEXT].indexOf('%2')!=-1","disabled": "e%1.disabled","empty": "Traversal.isEmpty(e%1)","enabled": "e%1.disabled===false","first-child": "!Traversal.getPreviousElementSibling(e%1)","last-child": "!Traversal.getNextElementSibling(e%1)","only-child": "!Traversal.getPreviousElementSibling(e%1)&&!Traversal.getNextElementSibling(e%1)","root": "e%1==Traversal.getDocument(e%1).documentElement"};
            var _54 = detect("(element.sourceIndex)");
            var _55 = "var p%2=0,i%2,e%2,n%2=e%1.";
            var _56 = _54 ? "e%1.sourceIndex" : "assignID(e%1)";
            var _57 = "var g=" + _56 + ";if(!p[g]){p[g]=1;";
            var _58 = "r[r.length]=e%1;if(s)return e%1;";
            var _59 = "r.sort(sorter);";
            var _60 = "fn=function(e0,s){indexed++;var r=[],p={},reg=[%1]," + "d=Traversal.getDocument(e0),c=d.body?'toUpperCase':'toString';";
            var byId = _32 ? function(a, b) {
                var c = a.all[b] || null;
                if (!c || c.id == b)
                    return c;
                for (var i = 0; i < c.length; i++) {
                    if (c[i].id == b)
                        return c[i]
                }
                return null
            } : function(a, b) {
                return a.getElementById(b)
            };
            var indexed = 1;
            function register(a) {
                if (a.rows) {
                    a.b2_length = a.rows.length;
                    a.b2_lookup = "rowIndex"
                } else if (a.cells) {
                    a.b2_length = a.cells.length;
                    a.b2_lookup = "cellIndex"
                } else if (a.b2_indexed != indexed) {
                    var b = 0;
                    var c = a.firstChild;
                    while (c) {
                        if (c.nodeType == 1 && c.nodeName != "!") {
                            c.b2_index = ++b
                        }
                        c = c.nextSibling
                    }
                    a.b2_length = b;
                    a.b2_lookup = "b2_index"
                }
                a.b2_indexed = indexed;
                return a
            }
            ;
            var sorter = _54 ? function(a, b) {
                return a.sourceIndex - b.sourceIndex
            } : Node.compareDocumentPosition;
            var fn;
            var reg;
            var _61;
            var _62;
            var _63;
            var _64;
            var _65 = {};
            var parser = new CSSParser({"^ \\*:root": function(a) {
                    _62 = false;
                    var b = "e%2=d.documentElement;if(Traversal.contains(e%1,e%2)){";
                    return format(b, _61++, _61)
                }," (\\*|[\\w-]+)#([\\w-]+)": function(a, b, c) {
                    _62 = false;
                    var d = "var e%2=byId(d,'%4');if(e%2&&";
                    if (b != "*")
                        d += "e%2.nodeName=='%3'[c]()&&";
                    d += "Traversal.contains(e%1,e%2)){";
                    if (_63)
                        d += format("i%1=n%1.length;", _63);
                    return format(d, _61++, _61, b, c)
                }," (\\*|[\\w-]+)": function(a, b) {
                    _64++;
                    _62 = b == "*";
                    var c = _55;
                    c += (_62 && _33) ? "all" : "getElementsByTagName('%3')";
                    c += ";for(i%2=0;(e%2=n%2[i%2]);i%2++){";
                    return format(c, _61++, _63 = _61, b)
                },">(\\*|[\\w-]+)": function(a, b) {
                    var c = _32 && _63;
                    _62 = b == "*";
                    var d = _55;
                    d += c ? "children" : "childNodes";
                    if (!_62 && c)
                        d += ".tags('%3')";
                    d += ";for(i%2=0;(e%2=n%2[i%2]);i%2++){";
                    if (_62) {
                        d += "if(e%2.nodeType==1){";
                        _62 = _33
                    } else {
                        if (!c)
                            d += "if(e%2.nodeName=='%3'[c]()){"
                    }
                    return format(d, _61++, _63 = _61, b)
                },"\\+(\\*|[\\w-]+)": function(a, b) {
                    var c = "";
                    if (_62 && _32)
                        c += "if(e%1.tagName!='!'){";
                    _62 = false;
                    c += "e%1=Traversal.getNextElementSibling(e%1);if(e%1";
                    if (b != "*")
                        c += "&&e%1.nodeName=='%2'[c]()";
                    c += "){";
                    return format(c, _61, b)
                },"~(\\*|[\\w-]+)": function(a, b) {
                    var c = "";
                    if (_62 && _32)
                        c += "if(e%1.tagName!='!'){";
                    _62 = false;
                    _64 = 2;
                    c += "while(e%1=e%1.nextSibling){if(e%1.b2_adjacent==indexed)break;if(";
                    if (b == "*") {
                        c += "e%1.nodeType==1";
                        if (_33)
                            c += "&&e%1.tagName!='!'"
                    } else
                        c += "e%1.nodeName=='%2'[c]()";
                    c += "){e%1.b2_adjacent=indexed;";
                    return format(c, _61, b)
                },"#([\\w-]+)": function(a, b) {
                    _62 = false;
                    var c = "if(e%1.id=='%2'){";
                    if (_63)
                        c += format("i%1=n%1.length;", _63);
                    return format(c, _61, b)
                },"\\.([\\w-]+)": function(a, b) {
                    _62 = false;
                    reg.push(new RegExp("(^|\\s)" + rescape(b) + "(\\s|$)"));
                    return format("if(e%1.className&&reg[%2].test(e%1.className)){", _61, reg.length - 1)
                },":not\\((\\*|[\\w-]+)?([^)]*)\\)": function(a, b, c) {
                    var d = (b && b != "*") ? format("if(e%1.nodeName=='%2'[c]()){", _61, b) : "";
                    d += parser.exec(c);
                    return "if(!" + d.slice(2, -1).replace(/\)\{if\(/g, "&&") + "){"
                },":nth(-last)?-child\\(([^)]+)\\)": function(a, b, c) {
                    _62 = false;
                    b = format("e%1.parentNode.b2_length", _61);
                    var d = "if(p%1!==e%1.parentNode)p%1=register(e%1.parentNode);";
                    d += "var i=e%1[p%1.b2_lookup];if(";
                    return format(d, _61) + CSSParser._47(a, c, "i", b, "!", "&&", "%", "==") + "){"
                },":([\\w-]+)(\\(([^)]+)\\))?": function(a, b, c, d) {
                    return "if(" + format(_53[b] || "throw", _61, d || "") + "){"
                },"\\[([\\w-]+)\\s*([^=]?=)?\\s*([^\\]]*)\\]": function(a, b, c, d) {
                    var e = _36[b] || b;
                    if (c) {
                        var f = "e%1.getAttribute('%2',2)";
                        if (!_35.test(b)) {
                            f = "e%1.%3||" + f
                        }
                        b = format("(" + f + ")", _61, b, e)
                    } else {
                        b = format("Element.getAttribute(e%1,'%2')", _61, b)
                    }
                    var g = _52[c || ""];
                    if (instanceOf(g, RegExp)) {
                        reg.push(new RegExp(format(g.source, rescape(parser.unescape(d)))));
                        g = "reg[%2].test(%1)";
                        d = reg.length - 1
                    }
                    return "if(" + format(g, b, d) + "){"
                }});
            Selector.parse = function(a) {
                if (!_65[a]) {
                    reg = [];
                    fn = "";
                    var b = parser.escape(a).split(",");
                    for (var i = 0; i < b.length; i++) {
                        _62 = _61 = _63 = 0;
                        _64 = b.length > 1 ? 2 : 0;
                        var c = parser.exec(b[i]) || "throw;";
                        if (_62 && _32) {
                            c += format("if(e%1.tagName!='!'){", _61)
                        }
                        var d = (_64 > 1) ? _57 : "";
                        c += format(d + _58, _61);
                        c += Array(match(c, /\{/g).length + 1).join("}");
                        fn += c
                    }
                    if (b.length > 1)
                        fn += _59;
                    eval(format(_60, reg) + parser.unescape(fn) + "return s?null:r}");
                    _65[a] = fn
                }
                return _65[a]
            }
        };
        Document.implement(DocumentSelector);
        Element.implement(ElementSelector);
        var HTMLDocument = Document.extend(null, {"@(document.activeElement===undefined)": {bind: function(b) {
                    b.activeElement = null;
                    EventTarget.addEventListener(b, "focus", function(a) {
                        b.activeElement = a.target
                    }, false);
                    return this.base(b)
                }}});
        var HTMLElement = Element.extend({addClass: function(a, b) {
                if (!this.hasClass(a, b)) {
                    a.className += (a.className ? " " : "") + b
                }
            },hasClass: function(a, b) {
                var c = new RegExp("(^|\\s)" + b + "(\\s|$)");
                return c.test(a.className)
            },removeClass: function(a, b) {
                var c = new RegExp("(^|\\s)" + b + "(\\s|$)", "g");
                a.className = a.className.replace(c, "$2")
            },toggleClass: function(a, b) {
                if (this.hasClass(a, b)) {
                    this.removeClass(a, b)
                } else {
                    this.addClass(a, b)
                }
            }}, {bindings: {},tags: "*",extend: function() {
                var b = base(this, arguments);
                var c = (b.tags || "").toUpperCase().split(",");
                forEach(c, function(a) {
                    HTMLElement.bindings[a] = b
                });
                return b
            },"@!(element.ownerDocument)": {bind: function(a) {
                    a.ownerDocument = Traversal.getOwnerDocument(a);
                    return this.base(a)
                }}});
        eval(this.exports)
    };
    new function(_) {
        var JSB = new base2.Package(this, {name: "JSB",version: "0.7",imports: "DOM",exports: "Behavior, Rule, RuleList"});
        eval(this.imports);
        var Behavior = Abstract.extend();
        var Call = Base.extend({constructor: function(a, b, c, d) {
                this.release = function() {
                    b.apply(a, c)
                };
                this.rank = d || (100 + Call.list.length)
            }}, {list: [],defer: function(a, b) {
                return function() {
                    if (Call.list) {
                        Call.list.push(new Call(this, a, arguments, b))
                    } else {
                        a.apply(this, arguments)
                    }
                }
            },init: function() {
                EventTarget.addEventListener(document, "DOMContentLoaded", function() {
                    if (Call.list) {
                        DOM.bind(document);
                        Call.list.sort(function(a, b) {
                            return a.rank - b.rank
                        });
                        invoke(Call.list, "release");
                        delete Call.list;
                        setTimeout(function() {
                            var a = DocumentEvent.createEvent(document, "Events");
                            Event.initEvent(a, "ready", false, false);
                            EventTarget.dispatchEvent(document, a)
                        }, 1)
                    }
                }, false)
            }});
        var _66 = /^on[a-z]+$/;
        var Rule = Base.extend({constructor: function(e, f) {
                e = new Selector(e);
                if (Behavior.ancestorOf(f)) {
                    f = f.prototype
                }
                var g = {}, h = {}, i = f.style, j = {};
                forEach(f, function(a, b) {
                    if (b.charAt(0) == "@") {
                        if (detect(b.slice(1))) {
                            forEach(a, arguments.callee)
                        }
                    } else if (typeof a == "function" && _66.test(b)) {
                        h[b.slice(2)] = a
                    } else if (b != "style") {
                        g[b] = a
                    }
                });
                function addBehavior(a) {
                    var b = assignID(a);
                    if (!j[b]) {
                        j[b] = true;
                        DOM.bind(a);
                        extend(a, g);
                        extend(a.style, i);
                        for (var c in h) {
                            var target = a;
                            var d = h[c];
                            if (c.indexOf("document") == 0) {
                                target = document;
                                c = c.slice(8);
                                d = bind(d, a)
                            }
                            target.addEventListener(c, d, false)
                        }
                    }
                }
                ;
                this.refresh = Call.defer(function() {
                    e.exec(document).forEach(addBehavior)
                });
                this.toString = K(String(e));
                this.refresh()
            },refresh: Undefined});
        var RuleList = Collection.extend({constructor: function(a) {
                this.base(a);
                this.globalize()
            },globalize: Call.defer(function() {
                var e = /[^\s,]+/g;
                var f = /^#[\w-]+$/;
                forEach(this, function(c, d) {
                    forEach(match(d, e), function(a) {
                        if (f.test(a)) {
                            var b = ViewCSS.toCamelCase(a.slice(1));
                            window[b] = Document.querySelector(document, a)
                        }
                    })
                })
            }, 10),refresh: function() {
                this.invoke("refresh")
            }}, {Item: Rule});
        eval(this.exports)
    };
    eval(base2.namespace);
    var DEFAULT = "@0";
    var IGNORE = RegGrp.IGNORE;
    var Colorizer = RegGrp.extend({constructor: function(c, d, e) {
            this.extend(e);
            this.patterns = c || {};
            var f = {}, i;
            forEach(c, function(a, b) {
                f[b] = d[b] || DEFAULT
            });
            forEach(d, function(a, b) {
                f[b] = d[b]
            });
            this.base(f)
        },patterns: null,tabStop: 4,urls: true,copy: function() {
            var a = this.base();
            a.patterns = copy(this.patterns);
            return a
        },exec: function(a, b) {
            a = this.base(this.escape(a));
            if (!b) {
                a = this._67(a);
                if (this.urls)
                    a = Colorizer.urls.exec(a)
            }
            return this.unescape(a)
        },escape: function(a) {
            return String(a).replace(/</g, "\x01").replace(/&/g, "\x02")
        },put: function(c, d) {
            if (!instanceOf(c, RegGrp.Item)) {
                if (typeof d == "string") {
                    d = d.replace(/@(\d)/, function(a, b) {
                        return format(Colorizer.FORMAT, c, b)
                    })
                }
                c = this.patterns[c] || Colorizer.patterns[c] || c;
                if (instanceOf(c, RegExp))
                    c = c.source;
                c = this.escape(c)
            }
            return this.base(c, d)
        },unescape: function(a) {
            return a.replace(/\x01/g, "&lt;").replace(/\x02/g, "&amp;")
        },_67: function(c) {
            var d = this.tabStop;
            if (d > 0) {
                var e = Array(d + 1).join(" ");
                return c.replace(Colorizer.TABS, function(a) {
                    a = a.replace(Colorizer.TAB, e);
                    if (d > 1) {
                        var b = (a.length - 1) % d;
                        if (b)
                            a = a.slice(0, -b)
                    }
                    return a.replace(/ /g, "&nbsp;")
                })
            }
            return c
        },"@MSIE": {_67: function(a) {
                return this.base(a).replace(/\r?\n/g, "<br>")
            }}}, {version: "0.8",FORMAT: '<span class="%1">$%2</span>',DEFAULT: DEFAULT,IGNORE: IGNORE,TAB: /\t/g,TABS: /\n([\t \xa0]+)/g,init: function() {
            forEach(this.patterns, function(c, d, e) {
                if (instanceOf(c, Array)) {
                    e[d] = reduce(c, function(a, b) {
                        a.add(e[b]);
                        return a
                    }, new RegGrp)
                }
            });
            this.urls = this.patterns.urls.copy();
            this.urls.putAt(0, '<a href="mailto:$0">$0</a>');
            this.urls.putAt(1, '<a href="$0">$0</a>')
        },addScheme: function(a, b, c, d) {
            this[a] = new this(b, c, d)
        },patterns: {block_comment: /\/\*[^*]*\*+([^\/][^*]*\*+)*\//,email: /([\w.+-]+@[\w.-]+\.\w+)/,line_comment: /\/\/[^\r\n]*/,number: /\b\-?(0|[1-9]\d*)(\.\d+)?([eE][-+]?\d+)?\b/,string1: /'(\\.|[^'\\])*'/,string2: /"(\\.|[^"\\])*"/,url: /(http:\/\/+[\w\/\-%&#=.,?+$]+)/,comment: ["block_comment", "line_comment"],string: ["string1", "string2"],urls: ["email", "url"]},urls: null});
    base2.addPackage("code");
    base2.code.addName("Colorizer", Colorizer);
    with (base2.code.Colorizer)
        addScheme("xml", {attribute: /(\w+)=("[^"]*"|'[^']*')/,cdata: /<!\[CDATA\[([^\]]|\][^\]]|\]\][^>])*\]\]>/,comment: /<!\s*(--([^-]|[\r\n]|-[^-])*--\s*)>/,entity: /&#?\w+;/,"processing-instruction": /<\?[\w-]+[^>]+>/,tag: /(<\/?)([\w:-]+)/,text: /[>;][^<>&]*/}, {cdata: IGNORE,tag: "$1@2",attribute: '@1=<span class="attribute value">$2</span>',text: IGNORE}, {tabStop: 1});
    with (base2)
        code.Colorizer.addScheme("html", {conditional: /<!(--)?\[[^\]]*\]>|<!\[endif\](--)?>/,doctype: /<!(DOCTYPE|doctype)[^>]+>/,inline: /<(script|style)([^>]*)>((\\.|[^\\])*)<\/\1>/}, {inline: function(a, b, c, d) {
                return format(this.INLINE, b, this.exec(c, true), d)
            }}, {INLINE: '&lt;<span class="tag">%1</span>%2&gt;%3&lt;/<span class="tag">%1</span>&gt;',tabStop: 1});
    with (base2.code.Colorizer)
        html.merge(xml);
    with (base2.code.Colorizer)
        addScheme("css", {at_rule: /@[\w\s]+/,bracketed: /\([^'\x22)]*\)/,comment: patterns.block_comment,property: /(\w[\w-]*\s*):([^;}]+)/,special: /(\-[\w-]*\s*):/,selector: /([\w-:\[.#][^{};]*)\{/}, {bracketed: IGNORE,selector: "@1{",special: "@1:",property: '@1:<span class="property value">$2</span>'});
    with (base2.code.Colorizer)
        addScheme("javascript", {conditional: /\/\*@if\s*\([^\)]*\)|\/\*@[\s\w]*|@\*\/|\/\/@\w+|@else[\s\w]*/,global: /\b(clearInterval|clearTimeout|constructor|document|escape|hasOwnProperty|Infinity|isNaN|NaN|parseFloat|parseInt|prototype|setInterval|setTimeout|toString|unescape|valueOf|window)\b/,keyword: /\b(&&|\|\||arguments|break|case|continue|default|delete|do|else|false|for|function|if|in|instanceof|new|null|return|switch|this|true|typeof|var|void|while|with|undefined)\b/,regexp: /([\[(\^=,{}:;&|!*?]\s*)(\/(\\\/|[^\/*])(\\.|[^\/\n\\])*\/[mgi]*)/,special: /\b(assert\w*|alert|catch|confirm|console|debug|debugger|eval|finally|prompt|throw|try)\b/}, {comment: DEFAULT,string: DEFAULT,regexp: "$1@2",number: DEFAULT});
    with (base2)
        with (code)
            Colorizer["html-multi"] = Colorizer.html.union({inline: function(a, b, c, d) {
                    var e = b == "style" ? "css" : "javascript";
                    d = Colorizer[e].exec(d, true);
                    d = format('<span class="%1">%2</span>', e, d);
                    return format(this.INLINE, b, this.exec(c, true), d)
                }});
    with (base2.code.Colorizer.javascript) {
        add("\\b(" + (base2.exports + ",base,base2,merge,union,implement,Array2,Date2,String2").match(/[^\s,]+/g).join("|") + ")\\b", '<span class="base2">$0</span>');
        insertAt(0, /("@[^"]+"):/, '<span class="special">$1</span>:');
        tabStop = 2
    }
    eval(base2.namespace);
    eval(DOM.namespace);
    eval(JSB.namespace);
    var bindings = new RuleList;
    bindings.add("pre", {ondocumentready: function() {
            if (this.hasClass("js")) {
                this.addClass("javascript")
            }
            var a = this.className.split(/\s+/);
            for (var i = 0; i < a.length; i++) {
                var b = a[i];
                var c = Colorizer[b];
                if (c instanceof Colorizer) {
                    var d = Traversal.getTextContent(this);
                    this.innerHTML = c.exec(d);
                    this.addClass("highlight");
                    if (b == "html-multi")
                        this.addClass("html");
                    break
                }
            }
        }});
    function updateFlag() {
        this.nextSibling.style.color = this.value ? "#898E79" : "#A03333"
    }
    ;
    bindings.add("input.required,textarea.required", {ondocumentready: updateFlag,ondocumentmouseup: updateFlag,ondocumentkeyup: updateFlag});

    eval(base2.namespace);
    eval(JavaScript.namespace);

    var IGNORE = RegGrp.IGNORE;
    var REMOVE = "";
    var SPACE = " ";
    var WORDS = /\w+/g;

     var Packer = Base.extend({
      minify: function(script) {
        script = script.replace(Packer.CONTINUE, "");
        script = Packer.data.exec(script);
        script = Packer.whitespace.exec(script);
        script = Packer.clean.exec(script);
        return script;
      },

      pack: function(script, base62, shrink) {
        script = this.minify(script + "\n");
        if (shrink) script = this._shrinkVariables(script);
        if (base62) script = this._base62Encode(script);	
        return script;
      },

      _base62Encode: function(script) {
        var words = new Words(script);
        var encode = function(word) {
          return words.get(word).encoded;
        };

        /* build the packed script */

        var p = this._escape(script.replace(WORDS, encode));		
        var a = Math.min(Math.max(words.size(), 2), 62);
        var c = words.size();
        var k = words;
        var e = Packer["ENCODE" + (a > 10 ? a > 36 ? 62 : 36 : 10)];
        var r = a > 10 ? "e(c)" : "c";

        // the whole thing
        return format(Packer.UNPACK, p,a,c,k,e,r);
      },

      _escape: function(script) {
        // single quotes wrap the final string so escape them
        // also escape new lines required by conditional comments
        return script.replace(/([\\'])/g, "\\$1").replace(/[\r\n]+/g, "\\n");
      },

      _shrinkVariables: function(script) {
        // Windows Scripting Host cannot do regexp.test() on global regexps.
        var global = function(regexp) {
          // This function creates a global version of the passed regexp.
          return new RegExp(regexp.source, "g");
        };

        var data = []; // encoded strings and regular expressions
        var REGEXP = /^[^'"]\//;
        var store = function(string) {
          var replacement = "#" + data.length;
          if (REGEXP.test(string)) {
            replacement = string.charAt(0) + replacement;
            string = string.slice(1);
          }
          data.push(string);
          return replacement;
        };

        // Base52 encoding (a-Z)
        var encode52 = function(c) {
          return (c < 52 ? '' : arguments.callee(parseInt(c / 52))) +
            ((c = c % 52) > 25 ? String.fromCharCode(c + 39) : String.fromCharCode(c + 97));
        };

        // identify blocks, particularly identify function blocks (which define scope)
        var BLOCK = /(function\s*[\w$]*\s*\(\s*([^\)]*)\s*\)\s*)?(\{([^{}]*)\})/;
        var VAR_ = /var\s+/g;
        var VAR_NAME = /var\s+[\w$]+/g;
        var COMMA = /\s*,\s*/;
        var blocks = []; // store program blocks (anything between braces {})
        // encoder for program blocks
        var encode = function(block, func, args) {
          if (func) { // the block is a function block

            // decode the function block (THIS IS THE IMPORTANT BIT)
            // We are retrieving all sub-blocks and will re-parse them in light
            // of newly shrunk variables
            block = decode(block);

            // create the list of variable and argument names 
            var vars = match(block, VAR_NAME).join(",").replace(VAR_, "");
            var ids = Array2.combine(args.split(COMMA).concat(vars.split(COMMA)));

            // process each identifier
            var count = 0, shortId;
            forEach (ids, function(id) {
              id = trim(id);
              if (id && id.length > 1) { // > 1 char
                id = rescape(id);
                // find the next free short name (check everything in the current scope)
                do shortId = encode52(count++);
                while (new RegExp("[^\\w$.]" + shortId + "[^\\w$:]").test(block));
                // replace the long name with the short name
                var reg = new RegExp("([^\\w$.])" + id + "([^\\w$:])");
                while (reg.test(block)) block = block.replace(global(reg), "$1" + shortId + "$2");
                var reg = new RegExp("([^{,\\w$.])" + id + ":", "g");
                block = block.replace(reg, "$1" + shortId + ":");
              }
            });
          }
          var replacement = "~" + blocks.length + "~";
          blocks.push(block);
          return replacement;
        };

        // decoder for program blocks
        var ENCODED = /~(\d+)~/;
        var decode = function(script) {
          while (ENCODED.test(script)) {
            script = script.replace(global(ENCODED), function(match, index) {
              return blocks[index];
            });
          }
          return script;
        };

        // encode strings and regular expressions
        script = Packer.data.exec(script, store);

        // remove closures (this is for base2 namespaces only)
        script = script.replace(/new function\(_\)\s*\{/g, "{;#;");

        // encode blocks, as we encode we replace variable and argument names
        while (BLOCK.test(script)) {
          script = script.replace(global(BLOCK), encode);
        }

        // put the blocks back
        script = decode(script);

        // put back the closure (for base2 namespaces only)
        script = script.replace(/\{;#;/g, "new function(_){");

        // put strings and regular expressions back
        script = script.replace(/#(\d+)/g, function(match, index) {		
          return data[index];
        });

        return script;
      }
    }, {
      CONTINUE: /\\\r?\n/g,

      ENCODE10: "String",
      ENCODE36: "function(c){return c.toString(a)}",
      ENCODE62: "function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))}",

      UNPACK: "eval(function(p,a,c,k,e,r){e=%5;if(!''.replace(/^/,String)){while(c--)r[%6]=k[c]" +
              "||%6;k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p." +
          "replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('%1',%2,%3,'%4'.split('|'),0,{}))",

      init: function() {
        this.data = reduce(this.data, function(data, replacement, expression) {
          data.put(this.javascript.exec(expression), replacement);
          return data;
        }, new RegGrp, this);
        this.clean = this.data.union(this.clean);
        this.whitespace = this.data.union(this.whitespace);
      },

      clean: {
        "\\(\\s*;\\s*;\\s*\\)": "(;;)", // for (;;) loops
        "throw[^};]+[};]": IGNORE, // a safari 1.3 bug
        ";+\\s*([};])": "$1"
      },

      data: {
        // strings
        "STRING1": IGNORE,
        'STRING2': IGNORE,
        "CONDITIONAL": IGNORE, // conditional comments
        "(COMMENT1)\\n\\s*(REGEXP)?": "\n$3",
        "(COMMENT2)\\s*(REGEXP)?": " $3",
        "([\\[(\\^=,{}:;&|!*?])\\s*(REGEXP)": "$1$2"
      },

      javascript: new RegGrp({
        COMMENT1:    /(\/\/|;;;)[^\n]*/.source,
        COMMENT2:    /\/\*[^*]*\*+([^\/][^*]*\*+)*\//.source,
        CONDITIONAL: /\/\*@|@\*\/|\/\/@[^\n]*\n/.source,
        REGEXP:      /\/(\\[\/\\]|[^*\/])(\\.|[^\/\n\\])*\/[gim]*/.source,
        STRING1:     /'(\\.|[^'\\])*'/.source,
        STRING2:     /"(\\.|[^"\\])*"/.source
      }),

      whitespace: {
        "(\\d)\\s+(\\.\\s*[a-z\\$_\\[(])": "$1 $2", // http://dean.edwards.name/weblog/2007/04/packer3/#comment84066
        "([+-])\\s+([+-])": "$1 $2", // c = a++ +b;
        "\\b\\s+\\$\\s+\\b": " $ ", // var $ in
        "\\$\\s+\\b": "$ ", // object$ in
        "\\b\\s+\\$": " $", // return $object
        "\\b\\s+\\b": SPACE,
        "\\s+": REMOVE
      }
    });

    var Words = Collection.extend({
        constructor: function(script) {
            this.base();
            forEach(script.match(WORDS), this.add, this);
            this.encode();
        },

        add: function(word) {
            if (!this.has(word))
                this.base(word);
            word = this.get(word);
            word.count++;
            return word;
        },

        encode: function() {
            // sort by frequency
            this.sort(function(word1, word2) {
                return word2.count - word1.count;
            });

            eval("var a=62,e=" + Packer.ENCODE62);
            var encode = e;
            var encoded = new Collection; // a dictionary of base62 -> base10
            var count = this.size();
            for (var i = 0; i < count; i++) {
                encoded.put(encode(i), i);
            }

            var empty = function() {
                return ""
            };
            var index = 0;
            forEach(this, function(word) {
                if (encoded.has(word)) {
                    word.index = encoded.get(word);
                    word.toString = empty;
                } else {
                    while (this.has(encode(index)))
                        index++;
                    word.index = index++;
                }
                word.encoded = encode(word.index);
            }, this);

            // sort by encoding
            this.sort(function(word1, word2) {
                return word1.index - word2.index;
            });
        },

        toString: function() {
            return this.getValues().join("|");
        }
    }, {
        Item: {
            constructor: function(word) {
                this.toString = function() {
                    return word
                };
            },

            count: 0,
            encoded: "",
            index: -1
        }
    });

    return new Packer();
});