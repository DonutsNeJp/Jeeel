/**
 * @fileOverview 汎用性がある機能の集まりです。<br />
 *                 FireFox, Safari, Chrome, Opera, IE6以上に対応しています。(個々のビルド段階のバグは考慮していません)<br />
 *                 jeeelConfigを定義すると以下の設定を変更できます。<br />
 *                 jeeelConfig.manualLoadをtrueにすると自動読み込みが無効になります。<br />
 *                 jeeelConfig.cleanをtrueにするとグローバル変数がJeeelのみの定義になります。<br />
 *                 jeeelConfig.debugをtrueにするとデバッグが有効になります。また、デバッグメソッドへのショートカットが作成されます。<br />
 *                 jeeelConfig.extendを定義し機能ごとに論理値を埋め込むと拡張機能が追加されます。(gui, webStorage, database, worker, geolocation, file, media, graphics, net)<br />
 *                 jeeelConfig.fullをtrueにすると全ての機能が有効になります。(上記のモード定義より優先される)<br />
 *                 もしくはURLにクエリを付けることでも設定を変更できます。<br />
 *                 この場合はtrue or falseではなく、1 or 0で記述する必要があります。<br >
 *                 キーはml(manualLoad), cl(clean), dbg(debug), ext(extend), full(full)となります。<br />
 *                 更にextはext[gui]=1等と記述する必要があります。<br />
 *                 extに使用できるキーはgui(gui), ws(webStorage), db(database), wk(worker), geo(geolocation), file(file), md(media), grp(graphics), net(net)<br />
 *                 また、エラーを詳細に表示する機能も追加されます。<br />
 *                 このライブラリ内ではいくつかの疑似的型表現を用いています。<br />
 *                 以下の型表現がそれにあたり、外部で定義されているものとは異なることに注意してください。<br />
 *                 Integer: 整数値<br />
 *                 Digit: 整数値もしくは整数値文字列<br />
 *                 Hash: 配列及び連想配列(基本的には基本型と関数以外すべて)<br />
 *                 Primitive: 基本型(真偽値・数値・文字列値・null・undefined)<br />
 *                 Mixied: なんでも良い<br />
 *                 引数にvar_argsがあったらそれは可変引数を示します。<br />
 *                 var_argsを含めて順に引数を必要数渡します。
 *
 * @name Jeeel.js(Javascript Easy Error and Exception handling Library: Japanease Eeel)
 * @author Masato Shimada
 * @version 2.0.0 RC13
 * @license <a href="http://ja.wikipedia.org/wiki/MIT_License">MIT License</a>
 * @copylight (c) 2012 Donuts, Masato Shimada
 */

(function (global) {

    /**
     * @namespace 汎用メソッド等を提供するネームスペース
     * @name Jeeel
     * @see Jeeel.Dom
     * @see Jeeel.Net
     * @see Jeeel.Session
     * @see Jeeel.Object
     * @see Jeeel.Debug
     * @see Jeeel.Type
     * @see Jeeel.UserAgent
     * @see Jeeel.Function
     * @see Jeeel.Timer
     * @see Jeeel.String
     * @see Jeeel.Number
     * @see Jeeel.Hash
     * @see Jeeel.Json
     * @see Jeeel.Loader
     * @see Jeeel.Class
     * @see Jeeel.Template
     * @see Jeeel.Gui
     * @see Jeeel.Graphics
     * @see Jeeel.Framework
     * @example
     * Jeeelは幾つかの大きな機能を柱に構成されている
     * また良く使う機能はショートカットが存在しており記述量を少なくできる
     * 
     * グローバルショートカット一覧
     * $ID('id'); // 指定したIDの要素を取得する。document.getElementByIdに相当
     * $CLASS('class'); // 指定したCLASSの要素のリストを取得する。document.getElementsByClassNameに相当(但し戻り値はNodeListではなく配列になる)
     * $TAG('tag'); // 指定したタグ名の要素リストを取得する。document.getElementsByTagNameに相当(但し戻り値はNodeListではなく配列になる)
     * $NAME('name'); // 指定した名前の要素リストを取得する。document.getElementsByNameに相当(但し戻り値はNodeListではなく配列になる)
     * $QUERY('#id .class'); // 指定したセレクタから要素のリストを取得する。document.querySelectorAllに相当(但し戻り値はNodeListではなく配列になる)
     * $ELM($ID('id')); // Jeeel.Dom.Elementのインスタンスを生成する。Jeeel.Dom.Element.createと同等
     * $ELMOP('#id .class'); // Jeeel.Dom.ElementOperatorのインスタンスを生成する。Jeeel.Dom.ElementOperator.createと同等
     * $FORM('test-form'); // Jeeel.Net.Formのインスタンスを生成する。Jeeel.Net.Form.createと同等
     * $AJAX('/test/'); // Jeeel.Net.Ajaxのインスタンスを生成する。Jeeel.Net.Ajax.createと同等
     * $PRM({a, 2, b: 7}); // Jeeel.Parameterのインスタンスを生成する。Jeeel.Parameter.createと同等
     * $BIND(Test.func, Test); // Jeeel.Functionのインスタンスを生成しthisの束縛も行う。Jeeel.Function.create + Jeeel.Function#bindと同等
     * 
     * createConsole(); // JSコンソールを生成する。Jeeel.Debug.Console.createと同等
     * 
     * Jeeel名前空間ショートカット一覧
     * Jeeel.addLoadEvent(Test.onload, Test); // ドキュメントが全て読み込まれたときのイベントを追加する。body.onloadやwindow.onloadに相当
     * Jeeel.errorDump(1, 4, 5); // デバッグモードが有効な場合に限り可変引数で指定した値を文字列としてダンプする
     * Jeeel.errorHtmlDump('<p>test</p>'); // デバッグモードが有効な場合に限り可変引数で指定した値をHTMLとしてダンプする
     * Jeeel.errorDumpConsole({a: [1, 2, 3, 4]}); // デバッグモードが有効な場合に限り可変引数で指定した値をオブジェクトとしてダンプする
     * Jeeel.Document; // Jeeel.Dom.Documentのインスタンス
     * Jeeel.Window; // Jeeel.Dom.Windowのインスタンス
     * 
     * ・DOM操作機能(Jeeel.Dom)
     * ・通信管理機能(Jeeel.Net)
     * ・セッション管理機能(Jeeel.Session)
     * ・日付を初めとする特殊値の管理操作機能(Jeeel.Object)
     * ・デバッグ機能(Jeeel.Debug)
     * ・ユーティリティ機能
     * 
     * DOM操作機能(Jeeel.Dom)
     * この機能は一部拡張機能を除き全てJeeel.Dom以下に保持されている
     * 拡張機能とはGUIを強化するJeeel.Gui以下やcanvasやSVGを管理するグラフィックス系のJeeel.Graphics以下などがある
     * この機能で提供するものは大よそ以下の機能になる
     * ・イベント管理
     * ・アニメーション
     * ・要素の移動、削除、スタイル変化
     * ・要素生成
     * ・要素情報操作
     * ・要素検索(IDやclassなどの単体からセレクタまで)
     * ・ウィンドウ操作
     * 
     * 通信管理機能(Jeeel.Net)
     * この機能は数こそ少ないが通信に関係する強力な補助ツールである
     * デバッグに属する機能とJeeel自体を操作する特殊な機能以外は全てJeeel.Net以下に保持される
     * この機能が提供する機能は大よそ以下の機能になる
     * ・Ajax通信(同期・非同期を含めたXMLHttpRequestを利用した通信)
     * ・Form要素もしくはそれに見立てた要素に対しての操作
     * ・JSONP通信
     * ・ビーコン
     * 
     * セッション管理機能(Jeeel.Session)
     * この機能はクッキーを初めとして擬似セッションを含めたセッション管理を行う機能である
     * 機能は全てJeeel.Session以下に属する
     * この機能が提供する機能は大よそ以下の機能になる
     * ・cookie管理
     * ・window.nameを利用した擬似セッションの管理
     * ・localStorage, sessionStorageを使用した擬似セッションの管理
     * 
     * 日付を初めとする特殊値の管理操作機能(Jeeel.Object)
     * この機能は日付や色を初めてするやや扱いが面倒な値を管理する機能を保有する
     * この機能はJeeel.Object以下に属する
     * この機能が提供する機能は大よそ以下の機能になる
     * ・日付の取得、改変、整形、日付移動などの日付やタイムゾーンに関する操作
     * ・色のRGB、HSLの相互変換、色同士のブレンド、書式変換に関する操作
     * ・幅、高さを合わせて保持したり、X座標、Y座標を合わせて保持する型に近い動作を提供する機能
     * 
     * デバッグ機能(Jeeel.Debug)
     * Jeeelの代名詞とも言える機能
     * デバッグ機能の弱いブラウザや環境に対してJSのみでデバッグ機能を提供する
     * この機能はJeeel.Debug以下に属する
     * この機能が提供する機能は大よそ以下の機能になる
     * ・JSコンソール
     * ・メッセージダンパー
     * ・タイマー
     * ・プロファイラ
     * 
     * ユーティリティ機能
     * 上記に入らなかった機能をまとめたようなもの
     * その中でも以下のクラスが筆頭に上がる
     * Jeeel.Type // 型の判定に特化したクラス
     * Jeeel.UserAgent // ブラウザ情報やURL情報などに特化したクラス
     * Jeeel.Function // 関数のthisの固定化や遅延実行など関数実行に特化したクラス
     * Jeeel.Timer // タイマーを使用した遅延実行や繰り返し実行に特化したクラス
     * Jeeel.String // 文字列操作に特化したクラス、ネームスペース
     * Jeeel.Number // 数値操作に特化したクラス、ネームスペース
     * Jeeel.Hash // 配列・連想配列操作に特化したクラス、ネームスペース
     * Jeeel.Json // JSONのエンコード、デコードを行うクラス
     * Jeeel.Loader // JSやCSSの読み込み・追加などに特化したクラス
     * Jeeel.Class // オブジェクト指向の継承などに特化したクラス
     * Jeeel.Template // Smartyの様なテンプレートエンジンクラス
     * 
     * 
     * これらの機能の他に拡張機能として以下が使用されることが多い
     * 
     * Jeeel.Gui // GUIのパーツを提供する
     * Jeeel.Graphics // canvasやSVGなどのグラフィカルな機能を使いやすく提供する
     * Jeeel.Framework // JS側で大規模なアプリを作成する手助けを行う機能の集まり
     */
    var Jeeel = {

        /**
         * 現在のJeeelのバージョン<br />
         * 1.0.0<br />
         * | | |<br />
         * A B C<br />
         * <br />
         * Aバージョンは互換性が無いバージョンを示す<br />
         * Bバージョンは新規機能追加を示す<br />
         * Cバージョンは既存機能追加・微調整・バグ修正を示す
         *
         * @type String
         * @constant
         */
        VERSION: '2.0.0 RC13',

        /**
         * Jeeelのscriptタグに付くclass名
         *
         * @type String
         * @constant
         */
        SCRIPT_CLASS: 'jeeel-script-class',

        /**
         * Jeeelのscriptタグに付くid名(実際にはこれにインデックス番号が付く)
         *
         * @type String
         * @constant
         */
        SCRIPT_ID: 'jeeel-script-id',

        /**
         * Jeeelファイルが置かれているホスト<br />
         * 通常は空文字にする
         *
         * @type String
         * @constant
         */
        HOST: 'http://localhost',

        /**
         * Jeeelファイルが置かれている相対URL<br />
         * 通常は指定しなくても良い
         *
         * @type String
         * @constant
         */
        BASE_URL: '',

        /**
         * Jeeelファイルに渡されているゲットパラメータ<br />
         * 通常は指定しなくても良い
         *
         * @type String
         * @constant
         */
        QUERY: '',

        /**
         * コンフィグ
         * 
         * @type String
         * @constant
         */
        CONFIG: global.jeeelConfig ? global.jeeelConfig : {},

        /**
         * クロスドメインかどうか
         * 
         * @type Boolean
         * @constant
         */
        CROSS_DOMAIN: false,

        /**
         * サーバー側のevalを使用できる相対URL<br />
         * 以下のパラメータを受け取り実行した後結果を返す機能をサーバーに実装
         *
         * <pre>
         * パラメータ {
         * &nbsp;   script: サーバー言語スクリプト,
         * &nbsp;   params: サーバ側に渡す任意パラメータ
         * }
         * </pre>
         *
         * @type String
         * @constant
         */
        DEBUG_URL: '/dev/debug/eval/',

        /**
         * サーバー側でSQLを実行できる相対URL<br />
         * 以下のパラメータを受け取り実行した後結果を返す機能をサーバーに実装
         *
         * <pre>
         * パラメータ {
         * &nbsp;   sql: SQL文字列
         * }
         * </pre>
         *
         * @type String
         * @constant
         */
        SQL_DEBUG_URL: '/dev/debug/eval-sql/',

        /**
         * サーバー側でメール送信を出来る相対URL<br />
         * 以下のパラメータを処理してメール送信する機能をサーバーに実装
         *
         * <pre>
         * パラメータ {
         * &nbsp;   to  : 送信先,
         * &nbsp;   body: 送信内容,
         * &nbsp;   type: メールのタイプ
         * }
         * </pre>
         *
         * @type String
         * @constant
         */
        MAIL_URL: '/dev/debug/mail/',

        /**
         * サーバー側でパラメータを表記した文字列をファイルとして読み込ませるための相対URL<br />
         * 以下のパラメータを処理してファイルを渡す機能をサーバーに実装
         *
         * <pre>
         * パラメータ {
         * &nbsp;   file : ファイル名(省略可能),
         * &nbsp;   value: ファイルに変換するパラメータ
         * }
         * </pre>
         *
         * @type String
         * @constant
         */
        FILE_OPEN_URL: '/dev/debug/file-open/',

        /**
         * Jsonp通信を行うための相対URL<br />
         * 以下のパラメータを処理してファイルを渡す機能をサーバーに実装
         *
         * <pre>
         * パラメータ {
         * &nbsp;   exec-action: 実行アクション名,
         * &nbsp;   callback: コールバック関数名
         * }
         * </pre>
         *
         * @type String
         * @constant
         */
        JSONP_URL: '/dev/debug/jsonp/',

        /**
         * このJeeelオブジェクト固有ID
         * 
         * @type String
         * @constant
         */
        UNIQUE_ID: null,

        /**
         * 現在の階層のDocumentで作成したJeeel.Dom.Document
         *
         * @type Jeeel.Dom.Document
         * @readOnly
         * @see Jeeel.Dom.Document
         */
        Document: null,

        /**
         * 現在の階層のWindowで作成したJeeel.Dom.Window
         *
         * @type Jeeel.Dom.Window
         * @readOnly
         * @see Jeeel.Dom.Window
         */
        Window: null,
        
        /**
         * 内部のURL等に対して制御を行うためのJeeel.Framework.Acl
         * 
         * @type Jeeel.Framework.Acl
         * @readOnly
         * @see Jeeel.Framework.Acl
         */
        Acl: null,
        
        /**
         * Jeeelのバックアップ
         * 
         * @type Mixied
         * @private
         */
        _backup: global.Jeeel || null,

        /**
         * Jsonp通信のためのキャッシュ
         * 
         * @private
         * @ignore
         */
        _jsp: {

        },

        /**
         * Jeeel系のサブクラス保存のための媒体
         * 
         * @type Hash
         * @private
         */
        _Object: {
            Jeeel: {}
        },

        /**
         * IEのための高速化手法
         * 
         * @type Document
         * @readOnly
         * @private
         */
        _doc: (global.document ? global.document : null),

        /**
         * IEのための高速化手法
         * 
         * @type Global
         * @readOnly
         * @private
         */
        _global: global,

        /**
         * 様々な判断用途で使用するdivタグ
         * 
         * @type Element
         * @readOnly
         * @private
         */
        _elm: global.document && global.document.createElement('div') || null,

        /**
         * 自動的にスクリプトを読み込むのを設定に関わらず無効化するかどうか
         * 
         * @type Boolean
         * @readOnly
         * @private
         */
        _disableAuto: true,

        /**
         * 自動的にスクリプトを読み込むかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        _auto: !(global.jeeelConfig && global.jeeelConfig.manualLoad),

        /**
         * グローバル変数をJeeelのみにするかどうか
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        _cleanMode: !!(global.jeeelConfig && global.jeeelConfig.clean),

        /**
         * デバッグを使用できるようにするかどうか(_cleanModeがtrueの場合はショートカットが作成されない)
         *
         * @type Boolean
         * @readOnly
         * @private
         */
        _debugMode: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.debug)),

        /**
         * 拡張機能を機能ごとに使用するかどうかを設定する
         *
         * @type Hash
         * @readOnly
         * @private
         */
        _extendMode: {
            /**
             * GUIの拡張機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            Gui: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.gui)),

            /**
             * Web Storage(localStorage)の拡張機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            WebStorage: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.webStorage)),

            /**
             * Indexed Database APIの拡張機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            Database: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.database)),

            /**
             * WebWorkersの拡張機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            Worker: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.worker)),

            /**
             * Geolocation APIの拡張機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            Geolocation: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.geolocation)),

            /**
             * File APIの拡張機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            File: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.file)),

            /**
             * メディア系の拡張機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            Media: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.media)),

            /**
             * グラフィックス系の拡張機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            Graphics: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.graphics)),

            /**
             * ネットワーク系の拡張機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            Net: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.net)),
            
            /**
             * 大規模アプリケーションのための機能を使用するかどうか
             *
             * @type Boolean
             * @readOnly
             * @private
             */
            Framework: !!(global.jeeelConfig && (global.jeeelConfig.full || global.jeeelConfig.extend && global.jeeelConfig.extend.framework))
        },

        /**
         * 読み込むディレクトリを示す
         */
        directory: {

        },

        /**
         * 読み込むファイルを示す
         */
        file: {

        }
    };

    // グローバルに設定
    global.Jeeel = Jeeel;
    
})(typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : (typeof this !== 'undefined' ? this : {})));

/**
 * @ignore
 */
Jeeel._Object.Jeeel.getInputName = function (name) {
    var names1 = decodeURIComponent(name).split('][');
    var names2 = names1[0].split('[');

    if (names2.length === 1) {
        return [name];
    }

    var i, l, names = [];

    for (i = 0, l = names2.length; i < l; i++) {
        names[names.length] = names2[i];
    }

    for (i = 1, l = names1.length; i < l; i++) {
        names[names.length] = names1[i];
    }

    names[names.length-1] = names[names.length-1].replace(']', '');

    return names;
};

/**
 * Jeeel.jsの個別読み込みを行う
 * 
 * @param {String} dir ディレクトリ
 * @param {String} file ソース
 */
Jeeel._import = function (dir, file) {
    if ( ! Jeeel._doc) {
        if (typeof importScripts !== 'undefined') {
            importScripts(dir + file + '.js');
        }

        return;
    }

    if ( ! this._import.index) {
        this._import.index = 1;
    }

    var index = this._import.index;
    var src = dir + file + '.js?' + this.QUERY;

    Jeeel._doc.write('<script type="text/javascript" id="' + this.SCRIPT_ID + '-' + index + '" class="' + this.SCRIPT_CLASS + '" src="' + src + '"></script>\n');

    this._import.index++;
};

/**
 * Jeeel.jsのディレクトリ別、自動読み込みを行う
 * 
 * @param {String} dir ディレクトリ
 * @param {Array} files ソースのリスト
 */
Jeeel._autoImports = function (dir, files) {
    if (this._auto) {
        for (var i = 0, l = files.length; i < l; i++) {
            this._import(dir, files[i]);
        }
    }
};

/**
 * Jeeelの名前で衝突していた値を取得する
 * 
 * @return {Mixied} 衝突値
 */
Jeeel.getConflictValue = function () {
    return this._backup;
};

/**
 * ディレクトリに対してのforeach
 *
 * @param {Object} directory ディレクトリ
 * @param {Function} callBack コールバックメソッド(要素、キー、配列)
 */
Jeeel.directoryForEach = function (directory, callBack) {
    for (var key in directory) {
        if (key !== 'toString') {
            callBack.call(this, directory[key], key, directory);
        }
    }
};

/**
 * ファイルに対してのforeach
 *
 * @param {Array} file ファイル
 * @param {Function} callBack コールバックメソッド(要素、キー、配列)
 */
Jeeel.fileForEach = function (file, callBack) {
    for (var key in file) {
        if (isNaN(key) && key !== 'length') {
            callBack.call(this, file[key], key, file);
        }
    }
};

/**
 * ファイルの相対パスを全て返す
 *
 * @return {String} ファイルパスを示す文字列
 */
Jeeel.getFilePath = function () {
    var paths = (arguments.length === 0 ? [this.directory.Jeeel + 'Jeeel.js\n'] : []);
    var directory = (arguments.length === 0 ? this.directory : arguments[0]);
    var file = (arguments.length === 0 ? this.file : arguments[1]);

    Jeeel.directoryForEach(directory,
        function (dir, key) {

            for (var i = 0, l = file[key].length; i < l; i++) {

                var subKey = file[key][i];

                if ( ! this._debugMode && subKey === 'Debug') {
                    continue;
                } else if ( ! this._debugMode && key === 'Technical' && Jeeel.Hash.inHash(subKey, ['Information', 'Trace'], true)) {
                    continue;
                } else if ( ! this._extendMode.Gui && subKey === 'Gui') {
                    continue;
                } else if ( ! this._extendMode.WebStorage && subKey === 'WebStorage') {
                    continue;
                } else if ( ! this._extendMode.Database && subKey === 'Database') {
                    continue;
                } else if ( ! this._extendMode.Worker && subKey === 'Worker') {
                    continue;
                } else if ( ! this._extendMode.Geolocation && subKey === 'Geolocation') {
                    continue;
                } else if ( ! this._extendMode.File && subKey === 'File') {
                    continue;
                } else if ( ! this._extendMode.Media && subKey === 'Media') {
                    continue;
                } else if ( ! this._extendMode.Graphics && subKey === 'Graphics') {
                    continue;
                } else if ( ! this._extendMode.Framework && subKey === 'Framework') {
                    continue;
                } else if ( ! this._extendMode.Net && Jeeel.Hash.inHash(subKey, ['Comet', 'Socket'], true)) {
                    continue;
                }

                paths[paths.length] = dir + subKey+'.js\n';

                if (dir[subKey] && file[key][subKey]) {
                    var dirTmp = {};
                    var fileTmp = {};
                    dirTmp[subKey] = dir[subKey];
                    fileTmp[subKey] = file[key][subKey];

                    paths[paths.length] = this.getFilePath(dirTmp, fileTmp);
                }
            }
        }
    );

    return paths.join('');
};

/**
 * ファイルをスクリプトタグで囲った状態で全て返す
 *
 * @return {String} スクリプトタグで囲われたファイルパスを示す文字列
 */
Jeeel.getScript = function () {
    var paths = (arguments.length === 0 ? ['<script type="text/javascript" class="'+Jeeel.SCRIPT_CLASS+'" src="'+this.directory.Jeeel+'Jeeel.js"></script>\n'] : []);
    var directory = (arguments.length === 0 ? this.directory : arguments[0]);
    var file = (arguments.length === 0 ? this.file : arguments[1]);

    Jeeel.directoryForEach(directory,
        function (dir, key) {

            for (var i = 0, l = file[key].length; i < l; i++) {

                var subKey = file[key][i];

                if ( ! this._debugMode && subKey === 'Debug') {
                    continue;
                } else if ( ! this._debugMode && key === 'Technical' && Jeeel.Hash.inHash(subKey, ['Information', 'Trace'], true)) {
                    continue;
                } else if ( ! this._extendMode.Gui && subKey === 'Gui') {
                    continue;
                } else if ( ! this._extendMode.WebStorage && subKey === 'WebStorage') {
                    continue;
                } else if ( ! this._extendMode.Database && subKey === 'Database') {
                    continue;
                } else if ( ! this._extendMode.Worker && subKey === 'Worker') {
                    continue;
                } else if ( ! this._extendMode.Geolocation && subKey === 'Geolocation') {
                    continue;
                } else if ( ! this._extendMode.File && subKey === 'File') {
                    continue;
                } else if ( ! this._extendMode.Media && subKey === 'Media') {
                    continue;
                } else if ( ! this._extendMode.Graphics && subKey === 'Graphics') {
                    continue;
                } else if ( ! this._extendMode.Framework && subKey === 'Framework') {
                    continue;
                } else if ( ! this._extendMode.Net && Jeeel.Hash.inHash(subKey, ['Comet', 'Socket'], true)) {
                    continue;
                }

                paths[paths.length] = '<script type="text/javascript" class="' + Jeeel.SCRIPT_CLASS + '" src="' + dir + subKey + '.js"></script>\n';

                if (dir[subKey] && file[key][subKey]) {
                    var dirTmp = {};
                    var fileTmp = {};
                    dirTmp[subKey] = dir[subKey];
                    fileTmp[subKey] = file[key][subKey];

                    paths[paths.length] = this.getScript(dirTmp, fileTmp);
                }
            }
        }
    );

    return paths.join('');
};

/**
 * 全てのファイルを接続した状態で返す
 *
 * @param {Boolean} [minimize] 必要最小限のファイルのみ接続するかどうか
 * @param {Boolean} [disableDebug] デバッグ関連のファイル読み込みを無効にするかどうか
 * @param {Boolean} [disableExtend] 追加関連のファイル読み込みを無効にするかどうか
 * @return {String} 全てのファイルを接続した文字列
 */
Jeeel.getJoinScript = function (minimize, disableDebug, disableExtend) {
    var debugTmp = this._debugMode;
    var geneTmp  = this._extendMode;

    if (minimize) {
        this._debugMode = false;
        this._extendMode = {};
    }

    if (disableDebug) {
        this._debugMode = false;
    }

    if (disableExtend) {
        this._extendMode = {};
    }

    var files = this.getFilePath().replace(/\n$/g, '').split('\n');
    var script = [];

    for (var i = 0, l = files.length; i < l; i++) {
        script[i] = Jeeel.Net.Ajax.serverResponse(files[i]);
    }

    this._debugMode  = debugTmp;
    this._extendMode = geneTmp;

    var url = Jeeel.UserAgent.getBaseUrl();

    return script.join('').replace('_disableAuto: false', '_disableAuto: true').replace("HOST: ''", "HOST: '" + url + "'");
};

/**
 * 全てのファイルを接続し、圧縮した状態で返す
 *
 * @param {Boolean} [minimize] 必要最小限のファイルのみ接続するかどうか
 * @param {Boolean} [disableDebug] デバッグ関連のファイル読み込みを無効にするかどうか
 * @param {Boolean} [disableExtend] 追加関連のファイル読み込みを無効にするかどうか
 * @return {String} 全てのファイルを接続・圧縮した文字列
 */
Jeeel.getCompressScript = function (minimize, disableDebug, disableExtend) {
    return Jeeel.Debug.Compressor.compress(this.getJoinScript(minimize, disableDebug, disableExtend), true);
};

/**
 * デバッグモードが有効である場合に限りエラーをダンプする
 *
 * @param {Mixied} var_args エラー出力する値の可変引数
 * @return {Boolean} エラーをダンプしたかどうか
 */
Jeeel.errorDump = function (var_args) {
    if ( ! Jeeel._debugMode || ! Jeeel.Debug) {
        return false;
    }

    Jeeel.Debug.ErrorMessage.dump.apply(null, arguments);
    return true;
};

/**
 * デバッグモードが有効である場合に限りエラーをHTMLとしてダンプする
 *
 * @param {Mixied} var_args エラー出力する値の可変引数
 * @return {Boolean} エラーをダンプしたかどうか
 */
Jeeel.errorHtmlDump = function (var_args) {
    if ( ! Jeeel._debugMode || ! Jeeel.Debug) {
        return false;
    }

    Jeeel.Debug.ErrorMessage.dumpHtml.apply(null, arguments);
    return true;
};

/**
 * デバッグモードが有効である場合に限りエラーをConsoleにダンプする
 *
 * @param {Mixied} var_args エラー出力する値の可変引数
 * @return {Boolean} エラーをダンプしたかどうか
 */
Jeeel.errorDumpConsole = function (var_args) {
    if ( ! Jeeel._debugMode || ! Jeeel.Debug) {
        return false;
    }

    Jeeel.Debug.Console.log.apply(null, arguments);
    return true;
};

/**
 * Domが完成した時に呼び出されるイベントの登録を行う
 *
 * @param {Function} listener 登録イベント
 * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはJeeel.Windowになる)
 */
Jeeel.addLoadEvent = function (listener, thisArg) {
    Jeeel.Window.addEventListener(Jeeel.Dom.Event.Type.LOAD, listener, thisArg);
};

Jeeel.directory.Jeeel = {

    /**
      * 自身を文字列参照された場合の変換
      *
      * @return {String} 自身のディレクトリ
      * @private
      */
    toString: function () {
        return Jeeel.BASE_URL + 'Jeeel/';
    }
};

(function (global) {
    if (typeof Jeeel === 'undefined') {
        return;
    }

    // クロスドメインの判定
    if (Jeeel.HOST && Jeeel.HOST.match(/^https?:\/\//) && global.location) {
        var host = (global.location.protocol + '//' + global.location.host).replace(/([\/()\[\]{}|*+-.,\^$?\\])/g, '\\$1');

        if ( ! Jeeel.HOST.match(new RegExp('^' + host))) {
            Jeeel.CROSS_DOMAIN = true;
        }
    }

    // ユニークIDを設定する
    Jeeel.UNIQUE_ID = 'Jeeel-' + (Jeeel.VERSION + Math.random()).replace(/\D/g, '');
    Jeeel.SCRIPT_ID = Jeeel.SCRIPT_ID + '-' + Jeeel.UNIQUE_ID;
    
    var jeeelMatch, jeeelRegExp, src;

    // ベースURL・QUERYとクラス、IDの設定(Worker内の場合はURLとQUERYのみ設定)
    if (Jeeel._doc) {
        
        jeeelRegExp = /^(.*?)\/(?:Jeeel\/)?Jeeel(?:-Set(?:-Min)?)?\.js(\?.*)?$/i;
        
        var scripts = Jeeel._doc.getElementsByTagName('script');

        for (var i = scripts.length; i--;) {
            var script = scripts[i];
            
            src = script.getAttribute('src');

            if ( ! src || ! (jeeelMatch = src.match(jeeelRegExp))) {
                continue;
            }

            script.className = Jeeel.SCRIPT_CLASS;
            script.id = Jeeel.SCRIPT_ID + '-0';

            Jeeel.BASE_URL = jeeelMatch[1] + '/';
            Jeeel.QUERY = jeeelMatch[2] && jeeelMatch[2].replace(/^\?/, '') || '';
            
            break;
        }
    } else if (Jeeel._global && Jeeel._global.importScripts && Jeeel._global.location) {
        
        jeeelRegExp = /^(.*?)\/(?:Jeeel\/)?Worker\/Thread\.js(\?.*)?$/i;
        
        src = Jeeel._global.location.pathname + Jeeel._global.location.search;
        
        jeeelMatch = (src || '').match(jeeelRegExp);

        if (jeeelMatch) {
            Jeeel.BASE_URL = jeeelMatch[1] + '/';
            Jeeel.QUERY = jeeelMatch[2] && jeeelMatch[2].replace(/^\?/, '') || '';
        }
    }
    
    // クエリから設定内容の取得
    if (Jeeel.QUERY) {
        var config = Jeeel.QUERY.split('&');
        var full = false;

        for (var j = config.length; j--;) {
            var tmp = config[j].split('=');
            var names = Jeeel._Object.Jeeel.getInputName(tmp[0]);

            switch (names[0]) {
                case 'ml':
                    Jeeel._auto = !(+tmp[1]);
                    break;

                case 'cl':
                    Jeeel._cleanMode = !!(+tmp[1]);
                    break;

                case 'dbg':
                    Jeeel._debugMode = !!(+tmp[1]);
                    break;

                case 'ext':
                    switch (names[1]) {
                        case 'gui':
                            Jeeel._extendMode.Gui = !!(+tmp[1]);
                            break;

                        case 'ws':
                            Jeeel._extendMode.WebStorage = !!(+tmp[1]);
                            break;

                        case 'db':
                            Jeeel._extendMode.Database = !!(+tmp[1]);
                            break;

                        case 'wk':
                            Jeeel._extendMode.Worker = !!(+tmp[1]);
                            break;

                        case 'geo':
                            Jeeel._extendMode.Geolocation = !!(+tmp[1]);
                            break;

                        case 'file':
                            Jeeel._extendMode.File = !!(+tmp[1]);
                            break;

                        case 'md':
                            Jeeel._extendMode.Media = !!(+tmp[1]);
                            break;

                        case 'grp':
                            Jeeel._extendMode.Graphics = !!(+tmp[1]);
                            break;

                        case 'net':
                            Jeeel._extendMode.Net = !!(+tmp[1]);
                            break;

                        case 'fw':
                            Jeeel._extendMode.Framework = !!(+tmp[1]);
                            break;
                    }
                    break;

                case 'full':
                    full = !!(+tmp[1]);
                    break;
            }
        }

        // FULLモードの際は全て上書きする
        if (full) {
            Jeeel._debugMode = Jeeel._extendMode.Gui
                              = Jeeel._extendMode.WebStorage
                              = Jeeel._extendMode.Database
                              = Jeeel._extendMode.Worker
                              = Jeeel._extendMode.Geolocation
                              = Jeeel._extendMode.File
                              = Jeeel._extendMode.Media
                              = Jeeel._extendMode.Graphics
                              = Jeeel._extendMode.Net
                              = Jeeel._extendMode.Framework
                              = true;
        }
    }

    // 不要な物を廃棄する
    script = scripts = jeeelMatch = jeeelRegExp = full = config = tmp = names = host = null;

    if (Jeeel._disableAuto) {
        Jeeel._auto = false;
    }

    Jeeel.file.Jeeel = ['Class', 'Function', 'Type', 'String', 'Number', 'Language', 'Method', 'Hash', 'Filter', 'Parameter', 'UserAgent', 'Dom', 'Net', 'Code', 'Loader', 'Json', 'Session', 'Template', 'Timer', 'DataStructure', 'Object', 'Validator', 'Storage', 'External', 'Deferred', 'Config', 'Error', 'Util'];

    if (Jeeel._extendMode.Gui && Jeeel._doc) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Gui';
    }

    if (Jeeel._extendMode.Worker && global && global.Worker) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Worker';
    }

    if (Jeeel._extendMode.Database && global && global.openDatabase) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Database';
    }

    if (Jeeel._extendMode.File && global && global.FileReader) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'File';
    }

    if (Jeeel._extendMode.Media && global && global.Audio) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Media';
    }

    if (Jeeel._extendMode.Graphics) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Graphics';
    }
    
    if (Jeeel._extendMode.Framework) {
        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Framework';
    }

    if (Jeeel._debugMode) {
        if ( ! Jeeel._extendMode.Gui && Jeeel._doc) {
            Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Gui';
        }

        Jeeel.file.Jeeel[Jeeel.file.Jeeel.length] = 'Debug';
    }

    // 自動ロードを始動
    if (Jeeel._auto) {
        Jeeel._tmp = function () {
            Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[10]);
            Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[11]);
            Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[12]);
            
            Jeeel._tmp = function () {
                for (var i = 13, l = Jeeel.file.Jeeel.length; i < l; i++) {
                    Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[i]);
                }

                delete Jeeel._tmp;
            };
        };

        for (i = 0; i <= 9; i++) {
            Jeeel._import(Jeeel.directory.Jeeel, Jeeel.file.Jeeel[i]);
        }
    }

    // グローバル関数・変数の設定
    if (Jeeel._cleanMode) {
        return;
    }

    // undefinedが未定義の特殊なブラウザに対してundefinedを定義する
    if ( ! ('undefined' in global)) {
      
        /**
         * @ignore
         */
        global.undefined = void 0;
    }

    if (Jeeel._debugMode && (typeof Jeeel.DEBUG_URL === 'string') && (typeof global.evalServer === 'undefined')) {

        /**
         * サーバ側のスクリプトを走らせる
         *
         * @param {String} script サーバー側で走らせるスクリプト文字列
         * @param {Hash} [params] サーバー側に渡すパラメータ
         * @param {Function} [callback] クロスドメイン時のコールバック
         * @return {Mixied} サーバー側からの戻り値をデコードしたもの
         * @name evalServer
         * @function
         */
        function evalServer(script, params, callback) {
            return Jeeel.Debug.Debugger.evalServer(script, params, callback);
        }
        
        global.evalServer = evalServer;
    }

    if (Jeeel._debugMode && (typeof Jeeel.SQL_DEBUG_URL === 'string') && (typeof global.evalSql === 'undefined')) {

        /**
         * サーバー側でSQLを実行する
         *
         * @param {String} sql サーバー側実行するSQL文字列
         * @param {Function} [callback] クロスドメイン時のコールバック
         * @return {Mixied} サーバー側からの戻り値をデコードしたもの
         * @name evalSql
         * @function
         */
        function evalSql(sql, callback) {
            return Jeeel.Debug.Debugger.evalSql(sql, callback);
        }
        
        global.evalSql = evalSql;
    }

    if (Jeeel._debugMode && (typeof Jeeel.MAIL_URL === 'string') && (typeof global.sendMail === 'undefined')) {

        /**
         * メールを送信する
         *
         * @param {String} to メール送信先
         * @param {Mixied} body メール本文
         * @param {Boolean} [isHtml] HTMLメールとして送信を行うかどうかを示す(デフォルトはfalse)
         * @param {Function} [callback] クロスドメイン時のコールバック
         * @return {Boolean} メール送信が成功ならばtrueそれ以外はfalseを返す
         * @name sendMail
         * @function
         */
        function sendMail(to, body, isHtml, callback) {
            return Jeeel.Debug.Debugger.sendMail(to, body, isHtml, callback);
        }
        
        global.sendMail = sendMail;
    }

    if (Jeeel._debugMode && (typeof Jeeel.FILE_OPEN_URL === 'string') && (typeof global.fileOpen === 'undefined')) {

        /**
         * 識別子をファイルとしてブラウザに読み込ませる
         *
         * @param {Mixied} value 読み込ませる値
         * @param {String} [fileName] 指定した名前で認識させたい時に指定する
         * @name fileOpen
         * @function
         */
        function fileOpen(value, fileName) {
            return Jeeel.Debug.Debugger.fileOpen(value, fileName);
        }
        
        global.fileOpen = fileOpen;
    }

    if (Jeeel._debugMode && (typeof global.createConsole === 'undefined')) {

        /**
         * コンソールを生成する
         * 
         * @name createConsole
         * @function
         * @see Jeeel.Debug.Console
         */
        function createConsole() {
            Jeeel.Debug.Console.create();
        }
        
        global.createConsole = createConsole;
    }

    if (typeof global.$ID === 'undefined') {

        /**
         * idからElementを取得する
         *
         * @param {String} id 検索ID
         * @param {Document|Element} [target] 検索対象(省略時は現階層のDocument)
         * @return {Element} 取得したElement
         * @name $ID
         * @function
         * @see Jeeel.Dom.Document#getElementById
         * @see Jeeel.Dom.Element#getElementById
         */
        function $ID(id, target) {

            if (Jeeel.Type.isDocument(target) && Jeeel._doc !== target) {
                return Jeeel.Dom.Document.create(target).getElementById(id);
            } else if (Jeeel.Type.isElement(target)) {
                return Jeeel.Dom.Element.create(target).getElementById(id);
            }

            return Jeeel.Document.getElementById(id);
        }
        
        global.$ID = $ID;
    }

    if (typeof global.$CLASS === 'undefined') {

        /**
         * classからElementを全て取得する
         *
         * @param {String} className 検索Class
         * @param {Document|Element} [target] 検索対象(省略時は現階層のDocument)
         * @return {Element[]} 取得したElement配列
         * @name $CLASS
         * @function
         * @see Jeeel.Dom.Document#getElementsByClassName
         * @see Jeeel.Dom.Element#getElementsByClassName
         */
        function $CLASS(className, target) {

            if (Jeeel.Type.isDocument(target) && Jeeel._doc !== target) {
                return Jeeel.Dom.Document.create(target).getElementsByClassName(className);
            } else if (Jeeel.Type.isElement(target)) {
                return Jeeel.Dom.Element.create(target).getElementsByClassName(className);
            }

            return Jeeel.Document.getElementsByClassName(className);
        }
        
        global.$CLASS = $CLASS;
    }

    if (typeof global.$NAME === 'undefined') {

        /**
         * nameからElementを全て取得する
         *
         * @param {String} name 検索Name
         * @param {Document|Element} [target] 検索対象(省略時は現階層のDocument)
         * @return {Element[]} 取得したElement配列
         * @name $NAME
         * @function
         * @see Jeeel.Dom.Document#getElementsByName
         * @see Jeeel.Dom.Element#getElementsByName
         */
        function $NAME(name, target) {

            if (Jeeel.Type.isDocument(target) && Jeeel._doc !== target) {
                return Jeeel.Dom.Document.create(target).getElementsByName(name);
            } else if (Jeeel.Type.isElement(target)) {
                return Jeeel.Dom.Element.create(target).getElementsByName(name);
            }

            return Jeeel.Document.getElementsByName(name);
        }
        
        global.$NAME = $NAME;
    }

    if (typeof global.$TAG === 'undefined') {

        /**
         * タグ名からElementを全て取得する
         *
         * @param {String} tagName 検索Tag
         * @param {Document|Element} [target] 検索対象(省略時は現階層のDocument)
         * @return {Element[]} 取得したElement配列
         * @name $TAG
         * @function
         * @see Jeeel.Dom.Document#getElementsByTagName
         * @see Jeeel.Dom.Element#getElementsByTagName
         */
        function $TAG(tagName, target) {

            if (Jeeel.Type.isDocument(target) && Jeeel._doc !== target) {
                return Jeeel.Dom.Document.create(target).getElementsByTagName(tagName);
            } else if (Jeeel.Type.isElement(target)) {
                return Jeeel.Dom.Element.create(target).getElementsByTagName(tagName);
            }

            return Jeeel.Document.getElementsByTagName(tagName);
        }
        
        global.$TAG = $TAG;
    }
    
    if (typeof global.$QUERY === 'undefined') {

        /**
         * セレクタからElementを全て取得する
         *
         * @param {String} selector 検索セレクタ
         * @param {Document|Element} [target] 検索対象(省略時は現階層のDocument)
         * @return {Element[]} 取得したElement配列
         * @see Jeeel.Dom.Selector
         * @name $QUERY
         * @function
         * @see Jeeel.Dom.Document#getElementsBySelector
         * @see Jeeel.Dom.Element#getElementsBySelector
         */
        function $QUERY(selector, target) {

            if (Jeeel.Type.isDocument(target) && Jeeel._doc !== target) {
                return Jeeel.Dom.Document.create(target).getElementsBySelector(selector);
            } else if (Jeeel.Type.isElement(target)) {
                return Jeeel.Dom.Element.create(target).getElementsBySelector(selector);
            }

            return Jeeel.Document.getElementsBySelector(selector);
        }
        
        global.$QUERY = $QUERY;
    }

    if (typeof global.$PRM === 'undefined') {

        /**
         * Jeeel.Parameterインスタンスの作成
         *
         * @param {Hash} [params] 入力パラメータ
         * @return {Jeeel.Parameter} インスタンス
         * @throws {Error} paramsが配列式でない場合に起こる
         * @name $PRM
         * @function
         * @see Jeeel.Parameter
         */
        function $PRM(params) {
            return new Jeeel.Parameter(params);
        }
        
        global.$PRM = $PRM;
    }

    if (typeof global.$ELM === 'undefined') {

        /**
         * Jeeel.Dom.Elementインスタンスの作成
         *
         * @param {Element} element 対象Element
         * @return {Jeeel.Dom.Element} 作成したインスタンス
         * @name $ELM
         * @function
         * @see Jeeel.Dom.Element
         */
        function $ELM(element) {
            return new Jeeel.Dom.Element(element);
        }
        
        global.$ELM = $ELM;
    }

    if (typeof global.$ELMOP === 'undefined') {

        /**
         * Jeeel.Dom.ElementOperatorインスタンスの作成
         *
         * @param {String|Element|Element[]} elementList セレクタ文字列、対象Elementまたは複数のElementリスト
         * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
         * @name $ELMOP
         * @function
         * @see Jeeel.Dom.ElementOperator
         */
        function $ELMOP(elementList) {
            return new Jeeel.Dom.ElementOperator(elementList);
        }
        
        global.$ELMOP = $ELMOP;
    }

    if (typeof global.$BIND === 'undefined') {

        /**
         * Jeeel.Functionを使用したthisのバインド
         *
         * @param {Function} func 対象の関数
         * @param {Mixied} [thisArg] バインドするthis
         * @return {Jeeel.Function} 作成したインスタンス
         * @name $BIND
         * @function
         * @see Jeeel.Function#bind
         */
        function $BIND(func, thisArg) {
            return Jeeel.Function.create(func).bind(thisArg);
        }
        
        global.$BIND = $BIND;
    }

    if (typeof global.$AJAX === 'undefined') {

        /**
         * Jeeel.Net.Ajaxインスタンスの作成
         *
         * @param {String} url Ajax対象URL文字列
         * @param {String} [method] HTTPメソッド(getまたはpost、大文字小文字は問わない、初期値はPOST)
         * @return {Jeeel.Net.Ajax} 作成したインスタンス
         * @name $AJAX
         * @function
         * @see Jeeel.Net.Ajax
         */
        function $AJAX(url, method) {
            return new Jeeel.Net.Ajax(url, method);
        }
        
        global.$AJAX = $AJAX;
    }

    if (typeof global.$FORM === 'undefined') {

        /**
         * Jeeel.Net.Formインスタンスの作成
         *
         * @param {String|Element} form フォームを示すIDもしくはフォーム自身
         * @return {Jeeel.Net.Form} 作成したインスタンス
         * @name $FORM
         * @function
         * @see Jeeel.Net.Form
         */
        function $FORM(form) {
            return new Jeeel.Net.Form(form);
        }
        
        global.$FORM = $FORM;
    }
})(Jeeel._global);
Jeeel.directory.Jeeel.Class = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Class/';
    }
};

/**
 * @staticClass クラスの継承等を行う機能を保持したスタティッククラス
 * @example
 * クラスの概念をJavaScriptに取り入れるためのクラス
 * 主に継承を使いたい時に使用する
 * 他にもインターフェースやMixinなども保持しているが使うのは稀である
 * 
 * 例：
 * var A = function () {
 *     this._test = 'A';
 * };
 * 
 * A.prototype = {
 * 
 *     _test: '',
 *     
 *     getTest: function () {
 *         return this._test;
 *     }
 * };
 * 
 * var B = function () {
 *     this._test = 'B';
 * };
 * 
 * Jeeel.Class.extend(B, A); // Bに対してAを継承させる、B: サブクラス, A: スーパークラス
 * 
 * var b = new B();
 * b.getTest(); // "B"が返ってくる
 */
Jeeel.Class = {
    
    /**
     * 新しいクラスを定義して返す
     * 
     * @param {Object} properties 定義クラスのプロパティ
     * @param {Function} [superClass] 継承元クラス(デフォルトはObject)
     * @return {Function} 定義したクラス
     */
    define: function (properties, superClass) {
        var subClass = function () {
            if (this._super && this._super.hasOwnProperty('__construct')) {
                this._super.__construct.apply(this, arguments);
            }
            
            if (subClass.prototype.hasOwnProperty('__construct')) {
                subClass.prototype.__construct.apply(this, arguments);
            }
        };
        
        this.extend(subClass, superClass || Object);
        
        for (var key in properties) {
            if (properties.hasOwnProperty(key)) {
                subClass.prototype[key] = properties[key];
            }
        }
        
        var list = ['toString', 'valueOf'];

        for (var i = list.length; i--;) {
            if (properties[list[i]] !== Object.prototype[list[i]]) {
                subClass.prototype[list[i]] = properties[list[i]];
            }
        }
        
        return subClass;
    },
    
    /**
     * クラスの継承を行う<br />
     * 継承後には_superがプロパティに反映される
     * 
     * @param {Function} subClass 継承先クラス
     * @param {Function} superClass 継承元クラス
     * @return {Function} 継承先クラス(Jeeel.Class.Abstractも同時に疑似継承する)
     * @example 
     * var Person = function () {
     * };
     * 
     * Person.prototype = {
     *     _age: 0,
     *     _weight: 0,
     *     _height: 0,
     *     _gender: '不明',
     *     
     *     getStatus: function () {
     *         return '性別: ' + this._gender + '\n'
     *              + '年齢: ' + this._age + '歳\n'
     *              + '身長: ' + this._height + 'cm\n'
     *              + '体重: ' + this._weight + 'kg\n';
     *     }
     * };
     * 
     * var Man = function (age, height, weight) {
     *     this._age = age;
     *     this._height = height;
     *     this._weight = weight;
     * };
     * 
     * Man.prototype = {
     *    _gender: '男'
     * }; 
     * 
     * Jeeel.Class.extend(Man, Person);
     * 
     * var man = new Man(25, 172, 56);
     * var status = man.getStatus();
     * 
     * // statusの値
     * 性別: 男
     * 年齢: 25歳
     * 身長: 172cm
     * 体重: 56kg
     */
    extend: function (subClass, superClass) {
        this.Abstract.prototype = superClass.prototype;
        var prototypeObject = subClass.prototype;
        
        subClass.prototype = new this.Abstract(superClass);
        
        if (prototypeObject) {
            for (var property in prototypeObject) {
                subClass.prototype[property] = prototypeObject[property];
            }
            
            var list = ['toString', 'valueOf'];
            
            for (var i = 0, l = list.length; i < l; i++) {
                if (prototypeObject[list[i]] !== Object.prototype[list[i]]) {
                    subClass.prototype[list[i]] = prototypeObject[list[i]];
                }
            }
            
            subClass.prototype.constructor = subClass;
        }
        
        this.Abstract.prototype = null;
        
        return subClass;
    },
    
    /**
     * インターフェースを実装する
     * 
     * @param {Function} implementClass インターフェースを実装するクラス
     * @param {String|Jeeel.Class.Interface|Array|Hash} implementInterface 実装インターフェース
     * @return {Function} 実装後の自動検証クラス(implementOf, isImplementedが実装される)
     */
    implement: function (implementClass, implementInterface) {
        return this.Interface.implement(implementClass, implementInterface);
    }
};

Jeeel.file.Jeeel.Class = ['Abstract', 'Interface', 'Mixin'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Class, Jeeel.file.Jeeel.Class);
/**
 * コンストラクタ
 * 
 * @abstractClass 継承時に使用する抽象クラス
 * @param {Function} superClass スーパークラス
 */
Jeeel.Class.Abstract = function (superClass) {
    this._super = superClass.prototype;
};

Jeeel.Class.Abstract.prototype = {
    
    /**
     * 親クラスのプロトタイプ
     * 
     * @type Object
     * @protected
     * @readOnly
     */
    _super: null
};

/**
 * コンストラクタ
 * 
 * @class インターフェースを擬似管理するクラス
 * @param {String} name インターフェース名
 * @param {Hash} interfaceClass インターフェース
 */
Jeeel.Class.Interface = function (name, interfaceClass) {
    this._name = name;
    
    var methods = [];
    var constants = [];
    var list = ['constructor', 'toString', 'valueOf'];
    
    if (Jeeel.Type.isArray(interfaceClass)) {
        for (var i = interfaceClass.length; i--;) {
            methods.push({
                name: interfaceClass[i],
                length: '*'
            });
        }
    } else {
        for (var key in interfaceClass) {
            if (typeof interfaceClass[key] === 'function') {
              
                if (Jeeel.Hash.inHash(key, list, true)) {
                    continue;
                }
                
                methods.push({
                    name: key,
                    length: interfaceClass[key].length
                });
            } else {
                constants.push({
                    name: key,
                    value: interfaceClass[key]
                });
            }
        }
    }
    
    this._interface = interfaceClass;
    this._methods = methods;
    this._constants = constants;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} name インターフェース名
 * @param {Hash} interfaceClass インターフェース
 * @return {Jeeel.Class.Interface} 作成したインスタンス
 */
Jeeel.Class.Interface.create = function (name, interfaceClass) {
    return new this(name, interfaceClass);
};

/**
 * インターフェースを登録する
 * 
 * @param {String} name インターフェース名
 * @param {Hash} interfaceClass 登録インターフェース
 * @return {Jeeel.Class.Interface} 登録したインターフェースインスタンス
 */
Jeeel.Class.Interface.register = function (name, interfaceClass) {
    if ( ! (interfaceClass instanceof this)) {
        interfaceClass = this.create(name, interfaceClass);
    }
    
    return this._caches[interfaceClass._name] = interfaceClass;
};

/**
 * インターフェース名からインスタンスの取得を行う
 * 
 * @param {String} name インターフェース名
 * @return {Jeeel.Class.Interface} 取得したインスタンス
 */
Jeeel.Class.Interface.getInstance = function (name) {
    return this._caches[name] || null;
};

Jeeel.Class.Interface.implement = function (implementClass, implementInterface) {
    
    if ( ! (implementInterface instanceof Jeeel.Class.Interface)) {
        if (Jeeel.Type.isString(implementInterface)) {
            implementInterface = Jeeel.Class.Interface.getInstance(implementInterface);
        } else if (Jeeel.Type.isArray(implementInterface) && Jeeel.Type.isString(implementInterface[0]) && Jeeel.Type.isHash(implementInterface[1])) {
            implementInterface = Jeeel.Class.Interface.register(implementInterface[0], implementInterface[1]);
        } else if (Jeeel.Type.isHash(implementInterface)) {
            implementInterface = Jeeel.Class.Interface.create((this._implementId++) + '-interface', implementInterface);
        }
    }

    if ( ! (implementInterface instanceof Jeeel.Class.Interface)) {
        throw new Error('implementInterface is not Jeeel.Class.Interface instance.');
    }
    
    if (implementClass.prototype._autoValidateImplements) {
        implementClass = implementClass.prototype._inherited;
    }

    if ( ! implementClass.prototype.implementOf) {
        implementClass.prototype.implementOf = this.implementOf;
    }

    if ( ! implementClass.prototype.isImplemented) {
        implementClass.prototype.isImplemented = this.isImplemented;
    }

    if ( ! implementClass.prototype._implements) {
        implementClass.prototype._implements = {};
    } else if ( ! implementClass.prototype.hasOwnProperty('_implements')) {
        implementClass.prototype._implements = Jeeel.Hash.merge({}, implementClass.prototype._implements);
    }

    if (implementClass.prototype.constructor !== implementClass) {
        implementClass.prototype.constructor = implementClass;
    }

    var constants = implementInterface.getConstants();

    for (var i = constants.length; i--;) {
        implementClass[constants[i].name] = constants[i].value;
    }

    implementClass.prototype._implements[implementInterface.getName()] = implementInterface;
    
    var newClass = new Function("this._autoValidateImplements.apply(this, arguments);");

    newClass.prototype = implementClass.prototype;
    newClass.prototype._inherited = implementClass;
    newClass.prototype._autoValidateImplements = this._autoValidateImplements;
    
    for (var key in implementClass) {
        if (implementClass.hasOwnProperty(key)) {
            newClass[key] = implementClass[key];
        }
    }

    return newClass;
};

/**
 * インターフェースを正確に実装しているかどうかを調べる
 * 
 * @param {String|Jeeel.Class.Interface} implementInterface 
 * @return {Boolean} 正確に実装しているかどうか
 */
Jeeel.Class.Interface.implementOf = function (implementInterface) {
    if (Jeeel.Type.isString(implementInterface)) {
        implementInterface = Jeeel.Class.Interface.getInstance(implementInterface);
    }

    if ( ! (implementInterface instanceof Jeeel.Class.Interface)) {
        throw new Error('implementInterface is not Jeeel.Class.Interface instance.');
    }

    var interfaceName = implementInterface.getName();

    var res = this._implements
           && this._implements[interfaceName]
           && this._implements[interfaceName].isImplemented(this);
    
    return !!res;
};

/**
 * 実装したインターフェースのメソッドが全て実装されているかどうかを調べる
 * 
 * @return {Boolean} 正確に実装しているかどうか
 */
Jeeel.Class.Interface.isImplemented = function () {
    if ( ! this._implements) {
        return false;
    }

    for (var key in this._implements) {
        if ( ! (this._implements[key] instanceof Jeeel.Class.Interface)) {
            continue;
        }
        
        if ( ! this._implements[key].isImplemented(this)) {
            return false;
        }
    }

    return true;
};

/**
 * コンストラクタ
 * 
 * @class インターフェースの状況を自動検証する擬似クラス
 * @private
 */
Jeeel.Class.Interface._autoValidateImplements = function () {
  
    this._inherited.apply(this, arguments);
    
    var err = true;
    
    if ( ! this._implements) {
        err = 'There is no evidence that implements the interface.';
    } else {
        for (var key in this._implements) {
            
            if ( ! (this._implements[key] instanceof Jeeel.Class.Interface)) {
                continue;
            }
            
            if ((err = this._implements[key]._validateImplement(this)) !== true) {
                break;
            }
        }
    }
    
    if (err !== true) {
        err = new Error(err);
        err.name = 'ImplementError';
        
        throw err;
    }
};

/**
 * キャッシュ
 * 
 * @type Hash
 * @private
 */
Jeeel.Class.Interface._caches = {};

Jeeel.Class.Interface._implementId = 0;

Jeeel.Class.Interface.prototype = {
    
    /**
     * インターフェース
     * 
     * @type Hash
     * @private
     */
    _interface: null,
    
    /**
     * インターフェース名
     * 
     * @type String
     * @private
     */
    _name: '',
    
    /**
     * 実装メソッド名のリスト
     * 
     * @type Array
     * @private
     */
    _methods: [],
    
    /**
     * 定数のリスト
     * 
     * @type Array
     * @private
     */
    _constants: [],
    
    /**
     * インターフェース名を取得する
     * 
     * @return {String} インターフェース名
     */
    getName: function () {
        return this._name;
    },
    
    /**
     * 定数リストを取得する
     * 
     * @return {Array} 定数リスト
     */
    getConstants: function () {
        return this._constants;
    },
    
    /**
     * このインターフェースを指定したインスタンスが実装しているかどうかを調べる
     * 
     * @param {Object} instance 比較インスタンス
     * @return {Boolean} 実装をしているかどうか
     */
    isImplemented: function (instance) {
        return this._validateImplement(instance) === true;
    },
    
    /**
     * このインターフェースを指定したインスタンスが実装しているかどうかを調べ状態を返す
     * 
     * @param {Object} instance 比較インスタンス
     * @return {Boolean|String} 実装状態
     */
    _validateImplement: function (instance) {
        var i;
        
        for (i = this._methods.length; i--;) {
            var method = instance[this._methods[i].name];
            
            if (typeof method !== 'function') {
                return 'You need to implement the "' + this._methods[i].name + '" method.';
            } else if (this._methods[i].length !== '*' && method.length !== this._methods[i].length) {
                return 'Number of arguments of the "' + this._methods[i].name + '" method is different.';
            }
        }
        
        for (i = this._constants.length; i--;) {
            var constant = this._constants[i];
            
            if (instance.constructor[constant.name] !== constant.value) {
                return 'Constant "' + constant.name + '" is not implemented properly.';
            }
        }
        
        return true;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {String} interfaceName インターフェース名
     * @param {String[]} methods 実装メソッドリスト
     * @constructor
     */
    constructor: Jeeel.Class.Interface
};

/**
 * コンストラクタ
 * 
 * @class インスタンス混合クラス
 * @param {Object|Object[]} [mixinInstances] 混合インスタンス、もしくは混合インスタンスリスト
 * @param {Boolean} [returnInstance] 戻り値に自インスタンス許可するかどうか
 */
Jeeel.Class.Mixin = function (mixinInstances, returnInstance) {
    if ( ! mixinInstances) {
        mixinInstances = [];
    } else if ( ! Jeeel.Type.isArray(mixinInstances)) {
        mixinInstances = [mixinInstances];
    }
    
    returnInstance = !!returnInstance;
    
    for (var i = mixinInstances.length; i--;) {
        mixinInstances[i] = {instance: mixinInstances[i], returnInstance: returnInstance};
    }
    
    this._mixinInstances = mixinInstances;
    
    this._mixinMethod();
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Object|Object[]} [mixinInstances] 混合インスタンス、もしくは混合インスタンスリスト
 * @param {Boolean} [returnInstance] 戻り値に自インスタンス許可するかどうか
 * @return {Jeeel.Class.Mixin} 作成したインスタンス
 */
Jeeel.Class.Mixin.create = function (mixinInstances, returnInstance) {
    return new this(mixinInstances, returnInstance);
};

Jeeel.Class.Mixin.prototype = {
  
    /**
     * 混ぜているインスタンスリスト
     * 
     * @type Hash[]
     * @private
     */
    _mixinInstances: [],
    
    /**
     * 新たにインスタンスを混合する<br />
     * 同じメソッドが存在した場合後から混合したインスタンスが優先される
     * 
     * @param {Object} mixinInstance 混合インスタンス
     * @param {Boolean} [returnInstance] 戻り値に自インスタンス許可するかどうか
     * @return {Jeeel.Class.Mixin} 自インスタンス
     */
    mixin: function (mixinInstance, returnInstance) {
        this._mixinInstances[this._mixinInstances.length] = {instance: mixinInstance, returnInstance: !!returnInstance};
        
        return this._mixinMethod();
    },
    
    /**
     * メソッドを呼び出す
     * 
     * @param {String} methodName メソッド名
     * @param {Mixied} var_args 引数を順に渡す
     * @return {Jeeel.Class.Mixin|Mixied} 自インスタンスもしくは戻り値
     */
    call: function (methodName, var_args) {
        var args = Array.prototype.slice.call(arguments, 1, arguments.length);
        
        return this.apply(methodName, args);
    },
    
    /**
     * メソッドを呼び出す
     * 
     * @param {String} methodName メソッド名
     * @param {Array} [args] 引数のリスト
     * @return {Jeeel.Class.Mixin|Mixied} 自インスタンスもしくは戻り値
     */
    apply: function (methodName, args) {
        var instance = this._getInstance(methodName);
        
        if ( ! instance) {
            throw new Error(methodName + ' メソッドは見つかりません。');
        }
        
        var returnInstance = instance.returnInstance;
        
        instance = instance.instance;
        
        var res = instance[methodName].apply(instance, args || []);
        
        if (returnInstance && res === instance) {
            return this;
        }
        
        return res;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Class.Mixin,
    
    /**
     * メソッド名からインスタンスを特定して返す
     * 
     * @param {String} methodName メソッド名
     * @return {Hash} インスタンス情報
     * @private
     */
    _getInstance: function (methodName) {
      
        // 後ろから検索してインスタンスを取得する
        for (var i = this._mixinInstances.length; i--;) {
            if (typeof this._mixinInstances[i].instance[methodName] === 'function') {
                return this._mixinInstances[i];
            }
        }
        
        return null;
    },
    
    /**
     * メソッドの混合を行う
     * 
     * @return {Jeeel.Class.Mixin} 自インスタンス
     * @private
     */
    _mixinMethod: function () {
      
        // インスタンスは後に混ぜた方を優先
        for (var i = 0, l = this._mixinInstances.length; i < l; i++) {
            
            // インスタンスのプロパティを全て列挙
            for (var methodName in this._mixinInstances[i].instance) {
                
                // メソッド以外と元からあるプロパティは除外
                if (typeof this._mixinInstances[i].instance[methodName] !== 'function') {
                    continue;
                } else if (this[methodName] && ! this.hasOwnProperty(methodName)) {
                    continue;
                }
                
                // クロージャによってインスタンスに直接アクセスするメソッドを作成
                this[methodName] = (function (self, instance, returnInstance, methodName) {
                    return function () {
                        var res = instance[methodName].apply(instance, arguments);

                        if (returnInstance && res === instance) {
                            return self;
                        }

                        return res;
                    };
                })(this, this._mixinInstances[i].instance, this._mixinInstances[i].returnInstance, methodName);
            }
        }
        
        return this;
    }
};
Jeeel.directory.Jeeel.Function = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Function/';
    }
};

/**
 * コンストラクタ
 *
 * @class 関数を拡張するクラス(name, length等の部分は初期化される)
 * @param {Function} target 基となる関数
 * @throws {Error} targetが関数でない場合に起こる
 * @example
 * このクラスは関数をラッパーし幾つかの機能を追加するクラスである
 * thisの固定や引数の固定、繰り返しや遅延実行などを使用する場合にこの機能を使う
 * 
 * 例：
 * var base = function (name, id) {
 *     return 'id: ' + id + ' name: ' + name + this;
 * }
 * var func = Jeeel.Function.create(base);
 * func.bind(' hello!!'); // thisの束縛
 *
 * var b = func('devid', 22);
 * // b = 'id: 22 name: devid hello!!'
 */
Jeeel.Function = function (target) {

    if ( ! Jeeel.Type.isFunction(target)) {
        throw new Error('targetが関数ではありません。');
    }

    /**
     * @ignore
     */
    var f = function () {
        return arguments.callee._cnvTarget.apply(this, arguments);
    };

    for (var key in Jeeel.Function.prototype) {
        f[key] = Jeeel.Function.prototype[key];
    }
    
    /**
     * 対象の関数
     *
     * @type Function
     * @private
     */
    f._target = target;

    /**
     * 変換後の関数
     *
     * @type Function
     * @private
     */
    f._cnvTarget = target;
    
    target = null;

    try {
        return f;
    } finally {
        f = null;
    }
};

/**
 * インスタンスの作成を行う
 *
 * @param {Function} target 基となる関数
 * @return {Jeeel.Function} 作成したインスタンス
 */
Jeeel.Function.create = function (target) {
    return new this(target);
};

/**
 * 関数ネイティブ化を行う<br />
 * コンストラクタやapplyのないIEのための関数
 * 
 * @param {Mixied} obj 親オブジェクト
 * @param {String} methodName ネイティブにしたい関数の名前
 * @param {Boolean} [useNew] インスタンス化するかどうか
 * @return {Function} ネイティブ化した関数
 */
Jeeel.Function.toNative = function (obj, methodName, useNew) {
    methodName = (useNew ? 'new' : '') + ' this["' + methodName + '"]';
    
    return function () {
        var params = [];
        
        for (var i = arguments.length; i--;) {
            params[i] = "_" + i;
        }
        
        params = params.join(',');
        
        return Function(
            params,
            'return ' + methodName + '(' + params + ')'
        ).apply(obj, arguments);
    };
};

/**
 * 単にthisをbindする関数<br />
 * メモリ消費等が少ないがエラー処理等は一切しない
 * 
 * @param {Function} target bind対象の関数
 * @param {Mixied} thisArg thisの部分にあたる値
 * @return {Function} bind後の関数
 */
Jeeel.Function.simpleBind = function (target, thisArg) {
    return function () {
        return target.apply(thisArg, arguments);
    };
};

Jeeel.Function.prototype = {
  
    /**
     * 対象の関数
     *
     * @type Function
     * @private
     */
    _target: null,
    
    /**
     * 変換後の関数
     *
     * @type Function
     * @private
     */
    _cnvTarget: null,
    
    /**
     * 関数内のthisの部分を定義する<br />
     * 一度しか意味がない
     *
     * @param {Mixied} thisArg thisの部分にあたる値
     * @return {Jeeel.Function} 自インスタンス
     */
    bind: function (thisArg) {
        var target = this._cnvTarget;

        this._cnvTarget = function () {
            return target.apply(thisArg, arguments);
        };

        return this;
    },

    /**
     * 関数の遅延実行を定義する<br />
     * 関数の戻り値はタイムアウトIDに変更される
     *
     * @param {Integer} delayTime 遅延時間(ミリ秒)
     * @return {Jeeel.Function} 自インスタンス
     */
    delay: function (delayTime) {

        var func = function () {
            Array.prototype.unshift.call(arguments, arguments.callee._target, arguments.callee._delayTime);

            return Jeeel.Timer.setTimeout.apply(null, arguments);
        };

        func._target = this._cnvTarget;
        func._delayTime = delayTime;

        this._cnvTarget = func;
        
        func = null;

        return this;
    },

    /**
     * 関数を複数回実行する<br />
     * 関数の戻り値はJeeel.Timerのインスタンスになる<br />
     * 関数内部のthisはこの関数前にbindしていない限りJeeel.Timerのインスタンスになる
     *
     * @param {Integer} interval 実行間隔(ミリ秒)
     * @param {Integer} count 実行回数
     * @return {Jeeel.Function} 自インスタンス
     */
    repeat: function (interval, count) {

        var func = function () {
            Array.prototype.unshift.call(arguments, arguments.callee._target, interval, count);

            return Jeeel.Timer.setLimitInterval.apply(null, arguments);
        };

        func._target = this._cnvTarget;

        this._cnvTarget = func;

        return this;
    },

    /**
     * 複数の関数を結合する<br />
     * 現在の関数が最初に実行される<br />
     * 関数の戻り値は複数の関数の戻り値のリストになる
     *
     * @param {Function} var_args 結合する関数を順に渡す
     * @return {Jeeel.Function} 自インスタンス
     * @throws {Error} 引数に関数以外を渡した場合に起こる
     * @example
     * var f1 = function (n) {
     *     return a + 1;
     * };
     * var f2 = function (n) {
     *     return a + 2;
     * };
     * var f3 = function (n) {
     *     return a + 3;
     * };
     * var sf = Jeeel.Function.create(f1);
     * sf.join(f2, f3);
     *
     * var res = sf(2);
     *
     * // res = [3, 4, 5]
     */
    join: function (var_args) {
        var funcs = Array.prototype.slice.call(arguments, 0, arguments.length);

        for (var i = 0, l = funcs.length; i < l; i++) {
            if ( ! Jeeel.Type.isFunction(funcs[i])) {
                throw new Error('引数に関数以外が含まれています。');
            }
        }

        var func = function () {
            var res = [];

            res[res.length] = arguments.callee._target.apply(this, arguments);

            for (var i = 0, l = funcs.length; i < l; i++) {
                res[res.length] = funcs[i].apply(this, arguments);
            }

            return res;
        };

        func._target = this._cnvTarget;

        this._cnvTarget = func;

        return this;
    },

    /**
     * 複数の関数を切り替えて実行する機能を付加する<br />
     * 現在の関数を起点として、引数に指定した関数を呼び出す毎に切り替えて実行する<br />
     * 最後まで実行したら自動的に最初に戻る
     *
     * @param {Function} var_args 順次実行する関数を順に渡す
     * @return {Jeeel.Function} 自インスタンス
     * @throws {Error} 引数に関数以外を渡した場合に起こる
     * @example
     * var f1 = function (n) {
     *     return n + 1;
     * };
     * var f2 = function (n) {
     *     return n + 2;
     * };
     * var f3 = function (n) {
     *     return n + 3;
     * };
     * var sf = Jeeel.Function.create(f1);
     * sf.iterate(f2, f3);
     *
     * var res = [];
     *
     * for (var i = 0; i &lt; 3; i++) {
     *     res[i] = sf(i);
     * }
     *
     * // res = [1, 3, 5]
     */
    iterate: function (var_args) {
        var funcs = Array.prototype.slice.call(arguments, 0, arguments.length);

        for (var i = 0, l = funcs.length; i < l; i++) {
            if ( ! Jeeel.Type.isFunction(funcs[i])) {
                throw new Error('引数に関数以外が含まれています。');
            }
        }

        var func = function () {

            var res = funcs[arguments.callee._cnt].apply(this, arguments);

            arguments.callee._cnt++;

            if (funcs.length <= arguments.callee._cnt) {
                arguments.callee._cnt = 0;
            }

            return res;
        };

        funcs.unshift(this._cnvTarget);
        func._cnt = 0;

        this._cnvTarget = func;

        return this;
    },

    /**
     * パラメータを定義づける
     *
     * @param {Mixied} var_args 定義づけるパラメータを左から順に渡す
     * @return {Jeeel.Function} 自インスタンス
     * @example
     * var f = function (a, b, c) {
     *     return a + b + c;
     * };
     * var sf = Jeeel.Function.create(f);
     * sf.curry('Hello! ', 'World ');
     *
     * var res = sf('Jhon!!');
     * // res = 'Hello! World Jhon!!'
     */
    curry: function (var_args) {
        var slice = Array.prototype.slice;
        var args = slice.call(arguments);

        var func = function () {
            var prms = slice.call(arguments);
            prms = args.concat(prms);

            return arguments.callee._target.apply(this, prms);
        };

        func._target = this._cnvTarget;

        this._cnvTarget = func;

        return this;
    },

    /**
     * 関数の変更を元に戻す
     * 
     * @return {Jeeel.Function} 自インスタンス
     */
    reset: function () {
        this._cnvTarget = this._target;

        return this;
    },

    /**
     * ベースとなった関数を取得する
     *
     * @return {Function} ベースになった関数
     */
    getBaseMethod: function () {
        return this._target;
    }
};

Jeeel.file.Jeeel.Function = ['Template', 'Callback'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Function, Jeeel.file.Jeeel.Function);

/**
 * @namespace 様々な箇所で汎用的に使用する関数を保有するネームスペース
 */
Jeeel.Function.Template = {
    
    /**
     * 何もしない関数
     * 
     * @type Function
     * @field
     * @constant
     */
    EMPTY: function () {
        
    },
    
    /**
     * nullを返すだけの関数
     * 
     * @type Function
     * @field
     * @constant
     */
    RETURN_NULL: function () {
        return null;
    },
    
    /**
     * trueを返すだけの関数
     * 
     * @type Function
     * @field
     * @constant
     */
    RETURN_TRUE: function () {
        return true;
    },
    
    /**
     * falseを返すだけの関数
     * 
     * @type Function
     * @field
     * @constant
     */
    RETURN_FALSE: function () {
        return false;
    },
    
    /**
     * 0を返すだけの関数
     * 
     * @type Function
     * @field
     * @constant
     */
    RETURN_ZERO: function () {
        return 0;
    },
    
    /**
     * 空文字列を返すだけの関数
     * 
     * @type Function
     * @field
     * @constant
     */
    RETURN_EMPTY_STRING: function () {
        return '';
    },
    
    /**
     * 空配列を返すだけの関数
     * 
     * @type Function
     * @field
     * @constant
     */
    RETURN_EMPTY_ARRAY: function () {
        return [];
    },
    
    /**
     * 空連想配列を返すだけの関数
     * 
     * @type Function
     * @field
     * @constant
     */
    RETURN_EMPTY_HASH: function () {
        return {};
    },
    
    /**
     * 引数返すだけの関数
     * 
     * @type Function
     * @field
     * @constant
     */
    RETURN_ARGUMENT: function (value) {
        return value;
    },
    
    /**
     * thisを返すだけの関数
     * 
     * @type Function
     * @field
     * @constant
     */
    RETURN_THIS: function () {
        return this;
    },
    
    /**
     * 引数を例外として投げる関数
     * 
     * @type Function
     * @field
     * @constant
     */
    THROW_ARGUMENT: function (value) {
        throw value;
    }
};

/**
 * コンストラクタ
 * 
 * @class コールバックを管理するクラス
 * @param {String} methodName メソッド名
 * @param {Object} [obj] オブジェクト(省略時はグローバルオブジェクト)
 */
Jeeel.Function.Callback = function (methodName, obj) {
    this._method = methodName;
    this._obj = (obj || obj === 0 ? obj : Jeeel._global);
    
    if ( ! Jeeel.Type.isFunction(this._obj[this._method])) {
        throw new Error('"' + this._method + '" is not a method of "' + this._obj.toString() + '".');
    }
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} methodName メソッド名
 * @param {Object} [obj] オブジェクト(省略時はグローバルオブジェクト)
 * @return {Jeeel.Function.Callback} 作成したインスタンス
 */
Jeeel.Function.Callback.create = function (methodName, obj) {
    return new this(methodName, obj);
};

Jeeel.Function.Callback.prototype = {
    
    /**
     * オブジェクト
     * 
     * @type Object
     * @private
     */
    _obj: null,
    
    /**
     * メソッド名
     * 
     * @type String
     * @private
     */
    _method: '',
    
    /**
     * オブジェクトを取得する
     * 
     * @return {Object} オブジェクト
     */
    getMethodOwner: function () {
        return this._obj;
    },
    
    /**
     * メソッド名を取得する
     * 
     * @return {String} メソッド名
     */
    getMethodName: function () {
        return this._method;
    },
    
    /**
     * メソッドを取得する
     * 
     * @return {Function} メソッド
     */
    getMethod: function () {
        return this._obj[this._method];
    },
    
    /**
     * メソッドをコールする
     * 
     * @param {Mixied} var_args 可変引数、メソッドに引き渡す引数を指定する
     * @return {Mixied} 戻り値
     */
    call: function (var_args) {
        return this.apply(arguments);
    },
    
    /**
     * メソッドを引数に配列を渡してコールする
     * 
     * @param {Array} [args] メソッドに引き渡す引数のリストを指定する
     * @return {Mixied} 戻り値
     */
    apply: function (args) {
        return this._obj[this._method].apply(this._obj, args || []);
    }
};

Jeeel.directory.Jeeel.Type = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Type/';
    }
};

/**
 * @staticClass 型に関する関数や定数を保持するスタティッククラス
 * @example
 * このクラスは型を判定する機能に特化したクラスである
 * JavaScriptでは型があるにも関わらず正確な判別方法がデフォで無いため
 * 正確な型判定をする必要がある際に利用する
 * 
 * 例：
 * Jeeel.Type.isInteger(12); // true、数値で且整数なのでtrueになる
 * Jeeel.Type.isInteger(12.5); // false、数値だか整数ではないのでfalseになる
 * Jeeel.Type.isInteger(new Number(11)); // true、typeofではobject判定だが整数なのでtrueになる
 * Jeeel.Type.isString('22'); // true、文字列なのでtrueになる
 * Jeeel.Type.isString(22); // false、数値なのでfalseになる
 * Jeeel.Type.isString(new String('22')); // true、typeofではobject判定だが文字列なのでtrueになる
 * 
 * 上記のように正確に判定する事が可能である
 * 他にも良く使用するメソッドとして以下が挙げられる
 * 
 * Jeeel.Type.isArray([]); // 配列かどうかを判定する
 * Jeeel.Type.isSet(null); // null, undefined以外かどうかを判定する(undefinedは a === undefined では判定出来ない)
 * Jeeel.Type.isPrimitive(5); // 基本型かどうかを判定する(真偽値、数値、文字列値、null、undefinedが対象となる)
 * Jeeel.Type.isHash({}); // 添え字を使用する事が出来るかどうかを判定する(基本型と関数以外全て)
 */
Jeeel.Type = {

    /**
     * 指定した値の型を返す
     *
     * @param {Mixied} val 判定値
     * @return {String} 判定結果
     */
    getType: function (val) {

        var types = Jeeel.Type.ObjectType;
        var type;

        switch (Object.prototype.toString.call(val)) {
            case '[object Function]':
                type = types.FUNCTION;
                break;

            case '[object Array]':
                type = types.ARRAY;
                break;

            case '[object Boolean]':
                type = types.BOOLEAN;
                break;

            case '[object String]':
                type = types.STRING;
                break;

            case '[object RegExp]':
                type = types.REGULAR_EXPRESSION;
                break;

            case '[object Date]':
                type = types.DATE;
                break;

            case '[object Number]':
                type = types.NUMBER;
                break;
                
            case '[object Math]':
                type = types.MATH;
                break;
                
            case '[object JSON]':
                type = types.JSON;
                break;

            default:

                if (this.isNull(val)) {
                    type = types.NULL;
                }
                else if (this.isUndefined(val)) {
                    type = types.UNDEFINED;
                }
                else if (this.isElement(val)) {
                    type = types.ELEMENT;
                }
                else if (this.isAttribute(val)) {
                    type = types.ATTRIBUTE;
                }
                else if (this.isText(val)) {
                    type = types.TEXT;
                }
                else if (this.isComment(val)) {
                    type = types.COMMENT;
                }
                else if (this.isDocumentFragment(val)) {
                    type = types.DOCUMENT_FRAGMENT;
                }
                else if (this.isDocument(val)) {
                    type = types.DOCUMENT;
                }
                else if (this.isWindow(val)) {
                    type = types.WINDOW;
                }
                else if (this.isArguments(val)) {
                    type = types.ARGUMENTS;
                }
                else if (this.isEvent(val)) {
                    type = types.EVENT;
                }
                else if (this.isError(val)) {
                    type = types.ERROR;
                }
                else if (this.isStorage(val)) {
                    type = types.STORAGE;
                }
                else if (this.isPrototype(val)) {
                    type = types.PROTOTYPE;
                }
                else {
                    type = types.OBJECT;
                }
                break;
        }

        return type;
    },

    /**
     * オブジェクトが元々保持しているキーのリストを返す
     *
     * @param {String} type 型を示す文字列値(Jeeel.Type.ObjectType 参照)
     * @return {String[]} キーのリスト
     */
    getKeys: function (type) {

        var types  = Jeeel.Type.ObjectType;
        var obKeys = Jeeel.Type.ObjectKeys;
        var keys = [];

        switch (type) {
            case types.NULL:
            case types.UNDEFINED:
                return [];
                break;

            case types.ARRAY:
                keys = keys.concat(obKeys.ARRAY);
                break;

            case types.BOOLEAN:
                keys = keys.concat(obKeys.BOOLEAN);
                break;

            case types.STRING:
                keys = keys.concat(obKeys.STRING);
                break;

            case types.NUMBER:
                keys = keys.concat(obKeys.NUMBER);
                break;

            case types.FUNCTION:
                keys = keys.concat(obKeys.FUNCTION);
                break;

            case types.REGULAR_EXPRESSION:
                keys = keys.concat(obKeys.REGULAR_EXPRESSION);
                break;

            case types.DATE:
                keys = keys.concat(obKeys.DATE);
                break;

            case types.ELEMENT:
                keys = keys.concat(obKeys.ELEMENT);
                break;
                
            case types.ATTRIBUTE:
                keys = keys.concat(obKeys.ATTRIBUTE);
                break;

            case types.TEXT:
                keys = keys.concat(obKeys.TEXT);
                break;

            case types.COMMENT:
                keys = keys.concat(obKeys.COMMENT);
                break;

            case types.DOCUMENT_FRAGMENT:
                keys = keys.concat(obKeys.DOCUMENT_FRAGMENT);
                break;

            case types.DOCUMENT:
                keys = keys.concat(obKeys.DOCUMENT);
                break;

            case types.WINDOW:
                keys = keys.concat(obKeys.WINDOW);
                break;

            case types.ARGUMENTS:
                keys = keys.concat(obKeys.ARGUMENTS);
                break;

            case types.EVENT:
                keys = keys.concat(obKeys.EVENT);
                break;

            case types.ERROR:
                keys = keys.concat(obKeys.ERROR);
                break;
                
            case types.MATH:
                keys = keys.concat(obKeys.MATH);
                break;
                
            case types.JSON:
                keys = keys.concat(obKeys.JSON);
                break;

            case types.STORAGE:
                keys = keys.concat(obKeys.STORAGE);
                break;

            case types.PROTOTYPE:
                keys = keys.concat(obKeys.PROTOTYPE);
                break;

            case types.OBJECT:
                break;

            default:
                break;
        }

        if (type != types.PROTOTYPE) {
            keys = keys.concat(obKeys.OBJECT);
        }

        return keys;
    },

    /**
     * オブジェクト型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isObject: function (val) {
        return !!(val && Object.prototype.toString.call(val) === "[object Object]");
    },

    /**
     * オブジェクトのprototype型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isPrototype: function (val) {
        return (Object.prototype === val);
    },

    /**
     * 関数型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isFunction: function (val) {
        return (Object.prototype.toString.call(val) === "[object Function]");
    },

    /**
     * 配列型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isArray: function (val) {
        return (Object.prototype.toString.call(val) === "[object Array]");
    },

    /**
     * ハッシュかどうか返す(name[key]の形が扱えるもの)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isHash: function (val) {
        var type = typeof val;
        
        // NodeList, HTMLCollection, RegExpのインスタンスはブラウザによってはfunctionになるので回避
        return !!(val && (type === 'object' || type === 'function' && ! (val instanceof Function)));
    },

    /**
     * 配列のように扱えると思われるlengthプロパティを保持しているかどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    hasLength: function (val) {
        return !!(val && this.isInteger(val.length));
    },

    /**
     * 真偽値型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isBoolean: function (val) {
        return (Object.prototype.toString.call(val) === "[object Boolean]");
    },

    /**
     * 文字列型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isString: function (val) {
        return (Object.prototype.toString.call(val) === "[object String]");
    },

    /**
     * 正規表現型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isRegularExpression: function (val) {
        return (Object.prototype.toString.call(val) === "[object RegExp]");
    },

    /**
     * 日付型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDate: function (val) {
        return (Object.prototype.toString.call(val) === "[object Date]");
    },

    /**
     * 数値型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNumber: function (val) {
        return (Object.prototype.toString.call(val) === "[object Number]");
    },
    
    /**
     * 実数かどうかを返す(数値型で無限大・非数値以外だったらtrue)
     * 
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isRealNumber: function (val) {
        if ( ! this.isNumber(val)) {
            return false;
        } else if (typeof val === 'object') {
            val = +val;
        }
        
        if (isNaN(val) || val === -Infinity || val === Infinity) {
            return false;
        }
        
        return true;
    },

    /**
     * 整数型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isInteger: function (val) {
        if ( ! this.isNumber(val)) {
            return false;
        } else if (typeof val === 'object') {
            val = +val;
        }
        
        if (isNaN(val) || val === -Infinity || val === Infinity) {
            return false;
        }

        val = '' + val;

        if (val.indexOf('.') < 0) {
            return true;
        }

        return false;
    },

    /**
     * 小数型かどうかを返す(小数値の部分が0になった場合整数になるのでfalseとなる)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isFloat: function (val) {
        if ( ! this.isNumber(val)) {
            return false;
        } else if (typeof val === 'object') {
            val = +val;
        }
        
        if (isNaN(val) || val === -Infinity || val === Infinity) {
            return false;
        }

        val = '' + val;

        if (val.indexOf('.') < 0) {
            return false;
        }

        return true;
    },

    /**
     * 数値型もしくは数値文字列型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNumeric: function (val) {
        if ( ! val && val !== 0) {
            return false;
        }
      
        val = +val;
        
        return ! (isNaN(val) || val === -Infinity || val === Infinity);
    },

    /**
     * 整数値型もしくは整数値文字列型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDigit: function (val) {
        if ( ! val && val !== 0) {
            return false;
        }
        
        return this.isInteger(+val);
    },
    
    /**
     * 16進数を表している文字列かどうかを返す<br />
     * 先頭に - があっても良く、0xはついて無くても良い(なお0xは代わりに#でも良い)
     * 
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isHexadecimalNumber: function (val) {
        if ( ! this.isString(val)) {
            return false;
        }
        
        if (val.match(/^-?(0x|#)?[0-9a-fA-F]+$/)) {
            return true;
        }

        return false;
    },

    /**
     * 基本型かどうかを返す(真偽値・数値・文字列値・null・undefined)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isPrimitive: function (val) {
        return (this.isBoolean(val) || this.isNumber(val) || this.isString(val) || this.isEmpty(val));
    },

    /**
     * HTML要素コレクション型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isHtmlCollection: function (val) {
        if ( ! this.isHash(val)) {
            return false;
        }
        
        var member = ['length', 'item', 'namedItem'];

        for (var i = member.length; i--;) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },

    /**
     * Nodeリスト型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNodeList: function (val) {
        if ( ! this.isHash(val)) {
            return false;
        }
        
        var member = ['length', 'item'];

        for (var i = member.length; i--;) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },
    
    /**
     * Node型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNode: function (val) {
        if ( ! this.isHash(val)) {
            return false;
        }
        
        var member = ['attributes', 'nodeType', 'nodeName', 'nodeValue'];

        for (var i = member.length; i--;) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },
    
    /**
     * Element型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isElement: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.ELEMENT_NODE);
    },
    
    /**
     * Attribute型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isAttribute: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.ATTRIBUTE_NODE);
    },

    /**
     * Text型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isText: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.TEXT_NODE);
    },
    
    /**
     * CDATASection型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isCDATASection: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.CDATA_SECTION_NODE);
    },
    
    /**
     * EntityReference型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEntityReference: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.ENTITY_REFERENCE_NODE);
    },
    
    /**
     * Entity型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEntity: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.ENTITY_NODE);
    },
    
    /**
     * ProcessingInstruction型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isProcessingInstruction: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.PROCESSING_INSTRUCTION_NODE);
    },

    /**
     * Comment型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isComment: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.COMMENT_NODE);
    },

    /**
     * Document型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDocument: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.DOCUMENT_NODE);
    },
    
    /**
     * DocumentType型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDocumentType: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.DOCUMENT_TYPE_NODE);
    },
    
    /**
     * DocumentFragment型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isDocumentFragment: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.DOCUMENT_FRAGMENT_NODE);
    },
    
    /**
     * Notation型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNotation: function (val) {
        return !!(val && val.nodeType === Jeeel.Dom.Node.NOTATION_NODE);
    },

    /**
     * Window型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isWindow: function (val) {
        if (typeof val !== 'object' || ! val) {
            return false;
        }
        
        var member = ['Object', 'Array', 'String', 'Number', 'Boolean', 'Function'];

        for (var i = member.length; i--;) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },

    /**
     * Event型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEvent: function (val) {
        if (typeof val !== 'object' || ! val) {
            return false;
        }
        
        var member;
        
        if ('reason' in val) {
            member = ['type', 'keyCode', 'shiftKey', 'ctrlKey', 'altKey', 'srcElement', 'reason'];
        } else {
            member = ['type', 'target', 'currentTarget'];
        }

        for (var i = member.length; i--;) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },

    /**
     * Error型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isError: function (val) {
        return (val instanceof Error) || (typeof DOMException !== "undefined" && val instanceof DOMException);
    },

    /**
     * Arguments型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isArguments: function (val) {
        if (typeof val !== 'object' || ! val) {
            return false;
        }
        
        var member = ['callee', 'length'];

        for (var i = member.length; i--;) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },
    
    /**
     * Math型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isMath: function (val) {
        return (Object.prototype.toString.call(val) === "[object Math]");
    },
    
    /**
     * JSON型かどうかを返す(Json文字列とは違う)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isJSON: function (val) {
        return (Object.prototype.toString.call(val) === "[object JSON]");
    },

    /**
     * Storage型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isStorage: function (val) {
        if (typeof val !== 'object' || ! val) {
            return false;
        }
        
        var member = ['key', 'getItem', 'setItem', 'removeItem', 'clear'];

        for (var i = member.length; i--;) {
            if ( ! (member[i] in val)) {
                return false;
            }
        }

        return true;
    },

    /**
     * nullかどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isNull: function (val) {
        return (val === null);
    },

    /**
     * 未定義かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isUndefined: function (val) {
        return (typeof val === 'undefined');
    },

    /**
     * 空変数かどうかを返す(nullまたはundefined)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEmpty: function (val) {
        return (this.isNull(val) || this.isUndefined(val));
    },

    /**
     * 変数がセットされているかかどうかを返す(undefinedでない)
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isSet: function (val) {
        return (typeof val !== 'undefined');
    },

    /**
     * 変数が配列式型で更に空であるかどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     */
    isEmptyHash: function (val) {
        if ( ! this.isHash(val)) {
            return false;
        }

        var check = true;

        Jeeel.Hash.forEach(val,
            function () {
                check = false;
                return Jeeel.Hash.FOR_EACH_EXIT;
            }
        );

        return check;
    }
};

if (Jeeel._global && Jeeel._global.Array && Jeeel._global.Array.isArray) {
  
    /**
     * 配列型かどうかを返す
     *
     * @param {Mixied} val 判定値
     * @return {Boolean} 判定結果
     * @ignore
     */
    Jeeel.Type.isArray = function (val) {
        return Array.isArray(val);
    };
}

Jeeel.file.Jeeel.Type = ['ObjectType', 'ObjectKeys'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Type, Jeeel.file.Jeeel.Type);

/**
 * @namespace オブジェクトの型の種類を示す列挙体
 */
Jeeel.Type.ObjectType = {
    /**
     * オブジェクト型を示す
     *
     * @type String
     * @constant
     */
    OBJECT: 'Object',

    /**
     * オブジェクトのprototype型を示す
     *
     * @type String
     * @constant
     */
    PROTOTYPE: 'Prototype',

    /**
     * Function型を示す
     *
     * @type String
     * @constant
     */
    FUNCTION: 'Function',

    /**
     * Array型を示す
     *
     * @type String
     * @constant
     */
    ARRAY: 'Array',

    /**
     * Arguments型を示す
     *
     * @type String
     * @constant
     */
    ARGUMENTS: 'Arguments',

    /**
     * Boolean型を示す
     *
     * @type String
     * @constant
     */
    BOOLEAN: 'Boolean',

    /**
     * String型を示す
     *
     * @type String
     * @constant
     */
    STRING: 'String',

    /**
     * RegExp型を示す
     *
     * @type String
     * @constant
     */
    REGULAR_EXPRESSION: 'RegularExpression',

    /**
     * Date型を示す
     *
     * @type String
     * @constant
     */
    DATE: 'Date',

    /**
     * Number型を示す
     *
     * @type String
     * @constant
     */
    NUMBER: 'Number',

    /**
     * Element型を示す
     *
     * @type String
     * @constant
     */
    ELEMENT: 'Element',
    
    /**
     * Attribute型を示す
     *
     * @type String
     * @constant
     */
    ATTRIBUTE: 'Attribute',

    /**
     * Text型を示す
     *
     * @type String
     * @constant
     */
    TEXT: 'Text',

    /**
     * Comment型を示す
     *
     * @type String
     * @constant
     */
    COMMENT: 'Comment',

    /**
     * DocumentFragment型を示す
     *
     * @type String
     * @constant
     */
    DOCUMENT_FRAGMENT: 'DocumentFragment',

    /**
     * Document型を示す
     *
     * @type String
     * @constant
     */
    DOCUMENT: 'Document',

    /**
     * Window型を示す
     *
     * @type String
     * @constant
     */
    WINDOW: 'Window',
    
    /**
     * Event型を示す
     *
     * @type String
     * @constant
     */
    EVENT: 'Event',

    /**
     * Error型を示す
     *
     * @type String
     * @constant
     */
    ERROR: 'Error',
    
    /**
     * Math型を示す
     *
     * @type String
     * @constant
     */
    MATH: 'Math',
    
    /**
     * JSON型を示す
     *
     * @type String
     * @constant
     */
    JSON: 'JSON',

    /**
     * Storage型を示す
     *
     * @type String
     * @constant
     */
    STORAGE: 'Storage',

    /**
     * nullを示す
     *
     * @type String
     * @constant
     */
    NULL: 'Null',

    /**
     * 未定義を示す
     *
     * @type String
     * @constant
     */
    UNDEFINED: 'Undefined'
};

/**
 * @namespace オブジェクトが元々保持しているキーのリストの列挙体
 */
Jeeel.Type.ObjectKeys = {

    /**
     * オブジェクト型のキーリスト
     *
     * @type String[]
     * @constant
     */
    OBJECT: (['toString', 'toLocaleString', 'valueOf', 'constructor', 'hasOwnProperty', 'propertyIsEnumerable', 'isPrototypeOf', '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__']).concat(({}).__proto__ ? ['__proto__'] : []),

    /**
     * オブジェクトのprototype型を示す
     *
     * @type String[]
     * @constant
     */
    PROTOTYPE: ['toString', 'toLocaleString', 'valueOf', 'constructor', 'hasOwnProperty', 'propertyIsEnumerable', 'isPrototypeOf', '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__'],

    /**
     * Function型のキーリスト
     *
     * @type String[]
     * @constant
     */
    FUNCTION: ['arguments', 'caller', 'length', 'name', 'prototype', 'call', 'apply', 'bind'],

    /**
     * Array型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ARRAY: ['length', 'concat', 'join', 'shift', 'unshift', 'push', 'pop', 'splice', 'slice', 'sort', 'reverse', 'indexOf', 'lastIndexOf', 'every', 'some', 'forEach', 'map', 'filter', 'reduce', 'reduceRight'],

    /**
     * Arguments型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ARGUMENTS: ['length', 'callee'],

    /**
     * Boolean型のキーリスト
     *
     * @type String[]
     * @constant
     */
    BOOLEAN: [],

    /**
     * String型のキーリスト
     *
     * @type String[]
     * @constant
     */
    STRING: ['length', 'charAt', 'substring', 'substr', 'slice', 'split', 'concat', 'replace', 'toUpperCase', 'toLowerCase', 'indexOf', 'lastIndexOf', 'match', 'search', 'charCodeAt', 'bold', 'italics', 'fixed', 'big', 'small', 'blink', 'strike', 'sup', 'sub', 'fontcolor', 'fontsize', 'anchor', 'link'],

    /**
     * RegExp型のキーリスト
     *
     * @type String[]
     * @constant
     */
    REGULAR_EXPRESSION: ['ignoreCase', 'global', 'source', 'exec', 'test', 'compile', 'lastIndex'],

    /**
     * Date型のキーリスト
     *
     * @type String[]
     * @constant
     */
    DATE: ['getFullYear', 'getYear', 'getMonth', 'getDate', 'getDay', 'getHours', 'getMinutes', 'getSeconds', 'getMilliseconds', 'setFullYear', 'setYear', 'setMonth', 'setDate', 'setHours', 'setMinutes', 'setSeconds', 'setMilliseconds', 'getUTCFullYear', 'getUTCYear', 'getUTCMonth', 'getUTCDate', 'getUTCDay', 'getUTCHours', 'getUTCMinutes', 'getUTCSeconds', 'getUTCMilliseconds', 'setUTCFullYear', 'setUTCYear', 'setUTCMonth', 'setUTCDate', 'setUTCHours', 'setUTCMinutes', 'setUTCSeconds', 'setUTCMilliseconds', 'getTime', 'setTime', 'toGMTString', 'toUTCString', 'toLocaleString', 'toString'],

    /**
     * Number型のキーリスト
     *
     * @type String[]
     * @constant
     */
    NUMBER: ['toString', 'toPrecision', 'toFixed', 'toExponential'],

    /**
     * Element型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ELEMENT: ['name', 'id', 'className', 'tagName', 'nodeName', 'nodeType', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'parentNode', 'children', 'childNodes', 'hasChildNodes', 'getElementsByClassName', 'getElementsByTagName', 'querySelectorAll', 'querySelector', 'style', 'appendChild', 'removeChild', 'replaceChild', 'insertBefore', 'setAttribute', 'getAttribute', 'removeAttribute', 'blur', 'focus', 'cloneNode', 'tabIndex', 'innerHTML', 'onabort', 'onbeforecopy', 'onbeforecut', 'onbeforepaste', 'onbeforeunload', 'onblur', 'onchange', 'onclick', 'oncontextmenu', 'oncopy', 'oncut', 'ondblclick', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'onerror', 'onfocus', 'onhashchange', 'oninput', 'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup', 'onload', 'onmessage', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onoffline', 'ononline', 'onpaste', 'onpopstate', 'onreset', 'onresize', 'onscroll', 'onsearch', 'onselect', 'onselectstart', 'onstorage', 'onsubmit', 'onunload'],

    /**
     * Attribute型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ATTRIBUTE: ['name', 'value', 'childNodes', 'firstChild', 'lastChild', 'nodeName', 'nodeType'],
    
    /**
     * Text型のキーリスト
     *
     * @type String[]
     * @constant
     */
    TEXT: ['nodeName', 'nodeType', 'data'],

    /**
     * Comment型のキーリスト
     *
     * @type String[]
     * @constant
     */
    COMMENT: ['nodeName', 'nodeType', 'data'],

    /**
     * DocumentFragment型のキーリスト
     *
     * @type String[]
     * @constant
     */
    DOCUMENT_FRAGMENT: ['nodeName', 'nodeType', 'childNodes', 'appendChild', 'removeChild', 'firstChild', 'lastChild'],

    /**
     * Document型のキーリスト
     *
     * @type String[]
     * @constant
     */
    DOCUMENT: ['nodeType', 'getElementById', 'getElementsByClassName', 'querySelectorAll', 'querySelector', 'getElementsByName', 'getElementsByTagName', 'documentElement', 'body', 'childNodes', 'write', 'writeln', 'open', 'close', 'cookie', 'createElement', 'createTextNode', 'createDocumentFragment', 'createComment', 'createAttribute'],

    /**
     * Window型のキーリスト
     *
     * @type String[]
     * @constant
     */
    WINDOW: ['Object', 'Number', 'String', 'Boolean', 'Array', 'RegExp', 'Date', 'JSON', 'document', 'location', 'navigator', 'name', 'parent', 'self', 'postMessage', 'setTimeout', 'setInterval', 'alert', 'prompt', 'confirm', 'open', 'close', 'closed', 'showModalDialog'],

    /**
     * Event型のキーリスト
     *
     * @type String[]
     * @constant
     */
    EVENT: ['type'],

    /**
     * Error型のキーリスト
     *
     * @type String[]
     * @constant
     */
    ERROR: ['name', 'message', 'stack', 'toString'],
    
    /**
     * Math型のキーリスト
     *
     * @type String[]
     * @constant
     */
    MATH: ['PI', 'SQRT2', 'SQRT1_2', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'abs', 'max', 'min', 'ceil', 'floor', 'random', 'pow', 'exp', 'log', 'sqrt', 'sin', 'cos', 'tan', 'acos', 'asin', 'atan', 'atan2'],

    /**
     * JSON型のキーリスト
     *
     * @type String[]
     * @constant
     */
    JSON: ['parse', 'stringify'],
    
    /**
     * Storage型のキーリスト
     *
     * @type String[]
     * @constant
     */
    STORAGE: ['length', 'key', 'getItem', 'setItem', 'removeItem', 'clear']
};
Jeeel.directory.Jeeel.String = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'String/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 文字列の複雑な処理をするクラス
 * @param {String} [string] 基となる文字列
 * @example
 * 文字列に対して複雑な処理を行うことが出来るクラス
 * sprintfを使用したりキャメルケース、スネークケース等の変換からHTMLとして文字列を埋め込んだ際の幅や高さの取得まで幅広い文字列操作を行うことが出来る
 * インスタンス化して使用する事も可能だがインスタンス化する必要があることは殆ど無い
 * 
 * 例：
 * var str = '  test-case-sort  ';
 * str = Jeeel.String.trim(str); // 前後の余分は空白等を取り除く
 * str = Jeeel.String.toCamelCase(str); // スネークケース、ハイフネーションをキャメルケースに変換する
 * str = Jeeel.String.padLeft(str, 15, '*'); // 左側を15文字になるまで*で埋める
 * 
 * // str => '***testCaseSort'
 * 
 * 他にも以下のような機能が良く使われる
 * 
 * Jeeel.String.escapeRegExp('$hoge'): // 正規表現で使用するメタ文字をエスケープする
 * Jeeel.String.escapeHtml('<p>tag</p>'); // HTMLで使用する特殊文字(<, >, "など)をエスケープする
 * Jeeel.String.stripTags('<p>test</p>'); // HTMLタグを全て取り除く
 * Jeeel.String.toSnakeCase('test-hyphen'); // キャメルケース、ハイフネーションをスネークケースに変換する
 * Jeeel.String.toHyphenation('test_snake'); // キャメルケース、スネークケースをハイフネーションに変換する
 * Jeeel.String.toTitleCase('test case'); // 単語の頭文字を全て大文字に変換する
 * Jeeel.String.sprintf('%02d:%02d', 1, 22); // C言語でお馴染みのsprintf関数を再現したものである
 * Jeeel.String.Hash.md5('678'); // 指定された文字列のMD5を取得する
 * Jeeel.String.Hash.Base64.encode('654'); // 指定された文字列に対してBASE64エンコードを行う
 * Jeeel.String.Hash.Base64.decode('NjU0'); // 指定されたBASE64に対してデコードを行い元の文字列に戻す
 */
Jeeel.String = function (string) {
    
    if ( ! Jeeel.Type.isSet(string)) {
        string = '';
    }
    
    this._str = ('' + string).replace(/\r\n/g, '\n');
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} [string] 基となる文字列
 * @return {Jeeel.String} 作成したインスタンス
 */
Jeeel.String.create = function (string) {
    return new this(string);
};

/**
 * バイナリコードよりインスタンスの作成を行う<br />
 * 多バイトには対応していない
 *
 * @param {String|String[]} binary 連結したバイナリコードまたはバイナリコード配列
 * @return {Jeeel.String} 作成したインスタンス
 * @throws {Error} binaryがバイナリコード・バイナリコード配列で無い場合に発生する
 */
Jeeel.String.fromBinary = function (binary) {
    var tmp = [];
    var i, l = binary.length;

    if (Jeeel.Type.isString(binary)) {
        for (i = 0; i < l; i += 2) {
            tmp[tmp.length] = '0x' + binary.slice(i, i + 2);
        }
    } else if (Jeeel.Type.isArray(binary)) {
        for (i = 0; i < l; i++) {
            tmp[i] = '0x' + binary[i];
        }
    } else {
        throw new Error('binaryはバイナリコードまたはバイナリコード配列でなければなりません。');
    }

    return new this(String.fromCharCode.apply(null, tmp));
};

/**
 * 正規表現のメタ文字をエスケープする
 * 
 * @param {String} string 対象文字列
 * @return {String} エスケープ後の文字列
 */
Jeeel.String.escapeRegExp = function (string) {
    var reg = /([\/()\[\]{}|*+-.,\^$?\\])/g;
    
    return ('' + string).replace(reg, '\\$1');
};

/**
 * HTML内で使用できない文字を特殊文字にエスケープする
 * 
 * @param {String} html 対象文字列
 * @param {Boolean} [replaceSpaceAndLineFeed] 改行とスペースを置き換えるかどうか(デフォルトは置き換えない)
 * @return {String} エスケープ後の文字列
 */
Jeeel.String.escapeHtml = function (html, replaceSpaceAndLineFeed) {
    html = '' + html;

    html = html.replace(/&/g, '&amp;')
               .replace(/"/g, '&quot;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;');

    if (replaceSpaceAndLineFeed) {

        // IEではスペースが入らない改行後に文字が入らないとその改行を無視するのでスペースを挿入
        if (Jeeel.UserAgent.isInternetExplorer()) {
            html = html.replace(/ /g, '&nbsp;')
                       .replace(/\r\n/g, '\n')
                       .replace(/\n\n/g, '<br />&nbsp;<br />')
                       .replace(/\n/g, '<br />');
        } else {
            html = html.replace(/ /g, '&nbsp;')
                       .replace(/\n/g, '<br />');
        }
    }

    return html;
};

/**
 * HTML内の特殊文字にを元に戻す(但し対象はHTML内でテキストとして存在出来ない文字列のみである)
 * 
 * @param {String} txt 対象文字列
 * @param {Boolean} [replaceNbspAndBr] brタグとスペース特殊文字を置き換えるかどうか(デフォルトは置き換えない)
 * @return {String} エスケープ後の文字列
 */
Jeeel.String.unescapeHtml = function (txt, replaceNbspAndBr) {
    txt = '' + txt;

    txt = txt.replace(/&amp;|&#38;|&#x26;/g, '&')
             .replace(/&quot;|&#34;|&#x22;/g, '"')
             .replace(/&lt;|&#60;|&#x3C;/g, '<')
             .replace(/&gt;|&#62;|&#x3E;/g, '>');

    if (replaceNbspAndBr) {
        txt = txt.replace(/&nbsp;|&#160;|&#xA0;/g, ' ')
                 .replace(/<br *(\/)?>/g, '\n');
    }

    return txt;
};

/**
 * HTML文字列からタグ文字を全て取り除く
 *
 * @param {String} html HTML文字列
 * @return {String} タグを取り除いた文字列
 */
Jeeel.String.stripTags = function (html) {

//    return html.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, '');

    var nodes = {childNodes: Jeeel.Document.createNodeList(html)};

    var res = [];
    var txt = Jeeel.Dom.Node.TEXT_NODE;

    function _search(target) {
        if (target.nodeType === txt) {
            res[res.length] = target.data;
        }

        for (var i = 0, l = target.childNodes.length; i < l; i++) {
            _search(target.childNodes[i]);
        }
    }

    _search(nodes);

    return res.join('');
};

/**
 * 文字列の前後から空白を取り除く
 *
 * @param {String} str 対象の文字列(文字列以外を入れた場合は文字列に変換された後に値を返す)
 * @return {String} 空白を取り除いた後の値
 */
Jeeel.String.trim = function (str) {
    if ( ! str) {
        return '';
    }
    
    str = str.toString();
    
    if (str.trim) {
        return str.trim();
    }

    var trimLeft  = /^\s+/;
    var trimRight = /\s\s*$/;

    return str.replace(trimLeft, '').replace(trimRight, '');
};

/**
 * 文字列を反転させる
 *
 * @param {String} str 対象の文字列
 * @return {String} 反転させた後の値
 */
Jeeel.String.reverse = function (str) {
    return ('' + str).split('').reverse().join('');
};

/**
 * 指定した文字列を指定した長さになるまで左側を空白もしくは指定文字列で埋める<br />
 * 但し、必要とされる埋める文字数がpadStrの長さで均等に分割出来ない場合割り切れる一番長い数まで行い終了する
 * 
 * @param {String} str 対象文字列
 * @param {Integer} length 処理後の文字列の長さ
 * @param {String} [padStr] 空白以外を使用したい時に指定
 * @return {String} 処理後の文字列
 */
Jeeel.String.padLeft = function (str, length, padStr) {
    str = '' + str;
    padStr = '' + (padStr || ' ');
    
    var padLength = padStr.length;

    while ((str.length + padLength) <= length) {
        str = padStr + str;
    }
    
    return str;
};

/**
 * 指定した文字列を指定した長さになるまで右側を空白もしくは指定文字列で埋める<br />
 * 但し、必要とされる埋める文字数がpadStrの長さで均等に分割出来ない場合割り切れる一番長い数まで行い終了する
 * 
 * @param {String} str 対象文字列
 * @param {Integer} length 処理後の文字列の長さ
 * @param {String} [padStr] 空白以外を使用したい時に指定
 * @return {String} 処理後の文字列
 */
Jeeel.String.padRight = function (str, length, padStr) {
    str = '' + str;
    padStr = '' + (padStr || ' ');
    
    var padLength = padStr.length;

    while ((str.length + padLength) <= length) {
        str += padStr;
    }
    
    return str;
};

/**
 * 対象文字列をキャメルケースに変更する(パスカルケースではない)<br />
 * 変換対象はパスカルケース、ハイフネーションまたはスネークケースが対象となる
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toCamelCase = function (str) {
    str = ('' + str).replace(/(?:-|_)([a-z])/g, function (str, p){return p.toUpperCase();});
    return str.replace(/^[A-Z]/, function (chr) {return chr.toLowerCase();});
};

/**
 * 対象文字列をパスカルケースに変更する<br />
 * 変換対象はハイフネーションまたはスネークケースが対象となる
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toPascalCase = function (str) {
    return ('' + str).replace(/(?:^|-|_)([a-z])/g, function (str, p){return p.toUpperCase();});
};

/**
 * 対象文字列をスネークケースに変更する<br />
 * 変換対象はハイフネーションまたはキャメルケースが対象となる
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toSnakeCase = function (str) {
    return ('' + str).replace(/([A-Z])/g, '_$1').replace(/-/g, '_').toLowerCase();
};

/**
 * 対象文字列をハイフネーションに変更する<br />
 * 変換対象はスネークケースまたはキャメルケースが対象となる
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toHyphenation = function (str) {
    return ('' + str).replace(/([A-Z])/g, '-$1').replace(/_/g, '-').toLowerCase();
};

/**
 * 対象文字列の単語の先頭をだけを大文字にする
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toTitleCase = function (str) {
    return ('' + str).toLowerCase().replace(/(^|\b)([a-z])/g, function (str, p1, p2){return p1 + p2.toUpperCase();});
};

/**
 * 全角文字を半角文字に変換する<br />
 * 対象となる文字は英数字、スペース、記号となる
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toHalfWidth = function (str) {
    return ('' + str).replace(/[！＃-＆（-／０-９：-＠Ａ-Ｚ［-｀ａ-ｚ｛-～　]+/g, function (chars) {

        var res = [];

        for (var i = chars.length; i--;) {
            var code = chars[i].charCodeAt(0);

            // 全角スペースは特殊なので個別に変換
            if (code === 12288) {
                code = 32;
            } else {
                code -= 65248;
            }

            res[i] = code;
        }

        return String.fromCharCode.apply(null, res);
    });
};

/**
 * 半角文字を全角文字に変換する<br />
 * 対象となる文字は英数字、スペース、記号となる
 * 
 * @param {String} str 対象文字列
 * @return {String} 変換後の文字列
 */
Jeeel.String.toFullWidth = function (str) {
    return ('' + str).replace(/[!#-&(-/0-9:-@A-Z\[-`a-z{-~ ]+/g, function (chars) {

        var res = [];

        for (var i = chars.length; i--;) {
            var code = chars[i].charCodeAt(0);

            // 半角スペースは特殊なので個別に変換
            if (code === 32) {
                code = 12288;
            } else {
                code += 65248;
            }

            res[i] = code;
        }

        return String.fromCharCode.apply(null, res);
    });
};

/**
 * 文字列の指定箇所に指定文字列を挿入する
 *
 * @param {String} str 対象の文字列(文字列以外を入れた場合は文字列に変換された後に値を返す)
 * @param {Integer} index 挿入箇所のインデックス(マイナスのインデックスの場合は先頭に、インデックスをオーバーしたら末尾に挿入文字列が付けられる)
 * @param {String} insertStr 挿入文字列
 * @return {String} 挿入後の文字列
 */
Jeeel.String.insert = function (str, index, insertStr) {
    if ( ! str) {
        return insertStr;
    }
    
    str = '' + str;
    
    var leftStr = str.substring(0, index);
    var rightStr = str.substring(index, str.length);

    return leftStr + insertStr + rightStr;
};

/**
 * Jeeel.String.insertの複数版
 *
 * @param {String} str 対象の文字列(文字列以外を入れた場合は文字列に変換された後に値を返す)
 * @param {Integer[]} indexArr 挿入箇所のインデックス配列(マイナスのインデックスの場合は先頭に、インデックスをオーバーしたら末尾に挿入文字列が付けられる)<br />
 *                              もしもこの配列内のインデックスの並びが昇順ではない場合、insertStrArrの配列のインデックスとずれるので注意
 * @param {String|String[]} insertStrArr 挿入文字列もしくは挿入文字列配列(配列にした場合はインデックスの配列と数が一致しなければならない)
 * @return {String} 挿入後の文字列
 * @throws {Error} insertStrArrが配列でindexArrとinsertStrArrの配列の要素数が一致しない場合に起こる
 */
Jeeel.String.multiInsert = function (str, indexArr, insertStrArr) {
    if ( ! Jeeel.Type.isArray(indexArr)) {
        indexArr = [indexArr];
    }
    
    str = '' + str;
    
    var res = [];
    var insertStrIsArray = Jeeel.Type.isArray(insertStrArr);
    var insertStr;
    
    if (insertStrIsArray && indexArr.length != insertStrArr.length) {
        throw new Error('インデックスの配列と挿入文字の配列の数が違います。');
    }
    
    indexArr.sort(function (a, b) {return a - b});

    indexArr.unshift(0);
    
    if (insertStrIsArray) {
        insertStrArr.unshift('');
    }
    
    for (var i = 1, l = indexArr.length; i < l; i++) {
        if (insertStrIsArray) {
            insertStr = insertStrArr[i];
        } else {
            insertStr = insertStrArr;
        }
        
        res[res.length] = str.substring(indexArr[i - 1], indexArr[i]);
        res[res.length] = insertStr;
    }
    
    res[res.length] = str.substring(indexArr[l - 1], str.length);
    
    return res.join('');
};

/**
 * テキストのサイズを取得する
 * 
 * @param {String} text サイズを知りたいテキスト
 * @param {Hash} [styleList] スタイルのキーと値のリスト
 * @return {Jeeel.Object.Size} ピクセル単位のテキストのサイズ
 */
Jeeel.String.getTextSize = function (text, styleList) {
    var span;
    
    if (this.getTextWidth._span) {
        span = this.getTextWidth._span;
    } else {
        span = Jeeel.Document.createElement('span');
        span.style.cssText = 'display: inline; position: absolute; top: 0px; margin: 0; white-space: nowrap; border: none; visibility: hidden;';
        
        Jeeel.Document.appendToBody(span);
        
        span = new Jeeel.Dom.Element(span);
        
        this.getTextWidth._span = span;
    }
    
    if ( ! styleList) {
        styleList = {};
    }
    
    delete styleList.visibility;
    delete styleList.position;
    
    span.setStyleList(styleList);
    
    if (text.charAt(text.length - 1) === '\n') {
        text += ' ';
    }
    
    span.setText(text);
    
    return span.getSize();
};

/**
 * テキストの幅を取得する
 * 
 * @param {String} text 幅を知りたいテキスト
 * @param {Hash} [styleList] スタイルのキーと値のリスト
 * @return {Integer} ピクセル単位のテキストの幅
 */
Jeeel.String.getTextWidth = function (text, styleList) {
    return this.getTextSize(text, styleList).width;
};

/**
 * テキストの高さを取得する
 * 
 * @param {String} text 高さを知りたいテキスト
 * @param {Hash} [styleList] スタイルのキーと値のリスト
 * @return {Integer} ピクセル単位のテキストの高さ
 */
Jeeel.String.getTextHeight = function (text, styleList) {
    return this.getTextSize(text, styleList).height;
};

Jeeel.String.prototype = {
  
    /**
     * 元の文字列
     * 
     * @type String
     * @private
     */
    _str: '',
    
    /**
     * 行数
     * 
     * @type Integer
     * @private
     */
    _lineCount: null,
    
    /**
     * 改行部分のインデックス配列
     * 
     * @type Integer[]
     * @private
     */
    _lineIndex: null,
    
    /**
     * 内部文字列を取得する
     * 
     * @return {String} 文字列
     */
    getString: function () {
        return this._str;
    },
    
    /**
     * 文字列の行数を取得する
     * 
     * @return {Integer} 行数
     */
    getLineCount: function () {
        if (this._lineCount) {
            return this._lineCount;
        }
        
        return this._lineCount = this._str.length - this._str.replace(/\n/g, '').length + 1;
    },
    
    /**
     * 指定した行の文字列を得る
     *
     * @param {Integer} [line] 行インデックス(範囲以外の数や文字を入れると全ての文字列が返ってくる)
     * @return {String} 指定行の文字列
     */
    getLine: function (line) {
      
        this._createLineIndex();

        var first = (line <= 0 ? 0 : this._lineIndex[line-1] + 1);
        var last  = this._lineIndex[line];
        
        return this._str.slice(first, last);
    },
    
    /**
     * 文字列のサイズを取得する
     * 
     * @param {Hash} [styleList] スタイルのキーと値のリスト
     * @return {Jeeel.Object.Size} ピクセル単位のテキストのサイズ
     */
    getTextSize: function (styleList) {
        return this.constructor.getTextSize(this._str, styleList);
    },
    
    /**
     * 文字列の幅を取得する
     * 
     * @param {Hash} [styleList] スタイルのキーと値のリスト
     * @return {Integer} ピクセル単位のテキストの幅
     */
    getTextWidth: function (styleList) {
        return this.constructor.getTextWidth(this._str, styleList);
    },
    
    /**
     * 文字列の高さを取得する
     * 
     * @param {Hash} [styleList] スタイルのキーと値のリスト
     * @return {Integer} ピクセル単位のテキストの高さ
     */
    getTextHeight: function (styleList) {
        return this.constructor.getTextHeight(this._str, styleList);
    },
    
    /**
     * 指定した文字列が最初に見つかった行インデックスとその行でのインデックスを取得する
     *
     * @param {String} search 検索文字列
     * @return {Jeeel.Object.Technical.LineIndex} 行数とその行でのインデックスを保持する構造体
     */
    lineIndexOf: function (search) {
        this._createLineIndex();
        
        var idx = this._str.indexOf(search);

        var line = 0;
        var tmp  = 0;

        for (var i = 0, l = this._lineIndex.length; i < l; i++) {
            if (tmp < idx && idx < this._lineIndex[i]) {
                line += i;
                idx  -= tmp + 1;
                break;
            }

            tmp = this._lineIndex[i];
        }

        return new Jeeel.Object.Technical.LineIndex({line: line, index: idx});
    },
    
    /**
     * Bsse64エンコードを行う
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    encodeBase64: function () {
        this._str = this.toBase64();
        
        return this._reset();
    },
    
    /**
     * Bsse64デコードを行う
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    decodeBase64: function () {
        this._str = this.constructor.Hash.Base64.decode(this._str);
        
        return this._reset();
    },
    
    /**
     * MD5エンコードを行う
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    encodeMd5: function () {
        this._str = this.toMd5();
        
        return this._reset();
    },
    
    /**
     * Jsonエンコードを行う
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    encodeJson: function () {
        this._str = Jeeel.Json.encode(this._str);
        
        return this._reset();
    },
    
    /**
     * Html文字列にあたる部分をエスケープする
     * 
     * @param {Boolean} [replaceSpaceAndLineFeed] 改行とスペースを置き換えるかどうか(デフォルトは置き換えない)
     * @return {Jeeel.String} 自インスタンス
     */
    escapeHtml: function (replaceSpaceAndLineFeed) {
        this._str = this.constructor.escapeHtml(this._str, replaceSpaceAndLineFeed);
        
        return this._reset();
    },
    
    /**
     * エスケープされたHtml文字列を元に戻す
     * 
     * @param {Boolean} [replaceNbspAndBr] brタグとスペース特殊文字を置き換えるかどうか(デフォルトは置き換えない)
     * @return {Jeeel.String} 自インスタンス
     */
    unescapeHtml: function (replaceNbspAndBr) {
        this._str = this.constructor.unescapeHtml(this._str, replaceNbspAndBr);
        
        return this._reset();
    },
    
    /**
     * RegExpに使用するメタ文字をエスケープする
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    escapeRegExp: function () {
        this._str = this.constructor.escapeRegExp(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列からHTMLタグ文字を全て取り除く
     *
     * @return {Jeeel.String} 自インスタンス
     */
    stripTags: function () {
        this._str = this.constructor.stripTags(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列の前後から空白を取り除く
     *
     * @return {Jeeel.String} 自インスタンス
     */
    trim: function () {
        this._str = this.constructor.trim(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列を反転させる
     *
     * @return {Jeeel.String} 自インスタンス
     */
    reverse: function () {
        this._str = this.constructor.reverse(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列を指定した長さになるまで左側を空白もしくは指定文字列で埋める<br />
     * 但し、必要とされる埋める文字数がpadStrの長さで均等に分割出来ない場合割り切れる一番長い数まで行い終了する
     * 
     * @param {Integer} length 処理後の文字列の長さ
     * @param {String} [padStr] 空白以外を使用したい時に指定
     * @return {Jeeel.String} 自インスタンス
     */
    padLeft: function (length, padStr) {
        this._str = this.constructor.padLeft(this._str, length, padStr);
        
        return this._reset();
    },
    
    /**
     * 文字列を指定した長さになるまで右側を空白もしくは指定文字列で埋める<br />
     * 但し、必要とされる埋める文字数がpadStrの長さで均等に分割出来ない場合割り切れる一番長い数まで行い終了する
     * 
     * @param {Integer} length 処理後の文字列の長さ
     * @param {String} [padStr] 空白以外を使用したい時に指定
     * @return {String} 処理後の文字列
     */
    padRight: function (length, padStr) {
        this._str = this.constructor.padRight(this._str, length, padStr);
        
        return this._reset();
    },
    
    /**
     * 文字列をキャメルケースに変更する
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    camelCase: function () {
        this._str = this.constructor.toCamelCase(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列をパスカルケースに変更する
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    pascalCase: function () {
        this._str = this.constructor.toPascalCase(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列をスネークケースに変更する
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    snakeCase: function () {
        this._str = this.constructor.toSnakeCase(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列をハイフネーションに変更する
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    hyphenation: function () {
        this._str = this.constructor.toHyphenation(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列をタイトルケースに変更する
     * 
     * @return {Jeeel.String} 自インスタンス
     */
    titleCase: function () {
        this._str = this.constructor.toTitleCase(this._str);
        
        return this._reset();
    },
    
    /**
     * 文字列に対して指定箇所に文字列を挿入する
     * 
     * @param {Integer} index 挿入箇所のインデックス(マイナスのインデックスの場合は先頭に、インデックスをオーバーしたら末尾に挿入文字列が付けられる)
     * @param {String} insertStr 挿入文字列
     * @return {Jeeel.String} 自インスタンス
     */
    insert: function (index, insertStr) {
        this._str = this.constructor.insert(this._str, index, insertStr);
        
        return this._reset();
    },
    
    /**
     * 文字列に対して指定箇所に文字列を挿入する
     * 
     * @param {Integer[]} indexArr 挿入箇所のインデックス配列(マイナスのインデックスの場合は先頭に、インデックスをオーバーしたら末尾に挿入文字列が付けられる)<br />
     *                              もしもこの配列内のインデックスの並びが昇順ではない場合、insertStrArrの配列のインデックスとずれるので注意
     * @param {String|String[]} insertStrArr 挿入文字列もしくは挿入文字列配列(配列にした場合はインデックスの配列と数が一致しなければならない)
     * @return {Jeeel.String} 自インスタンス
     */
    multiInsert: function (indexArr, insertStrArr) {
        this._str = this.constructor.multiInsert(this._str, indexArr, insertStrArr);
        
        return this._reset();
    },
    
    /**
     * Query形式の文字列を連想配列に変換する
     * 
     * @return {Hash} 変換後の連想配列
     */
    toQuery: function () {
        return Jeeel.Filter.Url.QueryParameter.create().filter(this._str);
    },
    
    /**
     * Json形式の文字列を変換する
     * 
     * @return {Mixied} 変換後の値
     */
    parseJson: function () {
        return Jeeel.Json.decode(this._str);
    },
    
    /**
     * Base64文字列に変換する
     * 
     * @return {String} Base64文字列
     */
    toBase64: function () {
        return this.constructor.Hash.Base64.encode(this._str);
    },
    
    /**
     * MD5文字列に変換する
     * 
     * @return {String} MD5文字列
     */
    toMd5: function () {
        return this.constructor.Hash.md5(this._str);
    },
    
    /**
     * 文字単位バイナリコードに変換して返す
     *
     * @param {String} [prefix] 16進数を示す接頭辞(デフォルトはなし)
     * @return {String} バイナリコード
     */
    toBinary: function (prefix) {
        return this.toBinaryArray(prefix).join('');
    },

    /**
     * 文字単位バイナリコード配列に変換して返す
     *
     * @param {String} [prefix] 16進数を示す接頭辞(デフォルトはなし)
     * @return {String[]} バイナリコード配列
     */
    toBinaryArray: function (prefix) {
        if ( ! Jeeel.Type.isString(prefix)) {
            prefix = '';
        }

        var res = [];

        for (var i = 0, l = this._str.length; i < l; i++) {
            var tmp = this._str.charCodeAt(i);
            tmp = tmp.toString(16);

            if (tmp.length & 1) {
                tmp = '0' + tmp;
            }

            res[i] = prefix + tmp;
        }

        return res;
    },
    
    /**
     * インスタンスを文字列に変換する
     * 
     * @return {String} 文字列
     */
    toString: function () {
        return this._str;
    },
    
    /**
     * インスタンスを文字列に変換する
     * 
     * @return {String} 文字列
     */
    valueOf: function () {
        return this._str;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {String} [str] 基となる文字列
     * @constructor
     */
    constructor: Jeeel.String,
    
    _createLineIndex: function () {
        if (this._lineIndex) {
            return;
        }
        
        this._lineIndex = [];
        
        var tmp = 0;

        while (1) {
            tmp = this._str.indexOf('\n', tmp);

            if (tmp < 0) {
                break;
            }

            this._lineIndex[this._lineIndex.length] = tmp;
            tmp++;
        }
    },
    
    _reset: function () {
        this._lineCount = null;
        this._lineIndex = null;
        
        return this;
    }
};

Jeeel._Object.JeeelString = {

};

Jeeel.file.Jeeel.String = ['Sprintf', 'Hash'];

Jeeel._autoImports(Jeeel.directory.Jeeel.String, Jeeel.file.Jeeel.String);
/**
 * sprintfのJS版<br />
 * 書式: %[フラグ][フィールド幅].[精度][型指定子]<br />
 * フラグ: -, +, 空白, 0, #<br />
 * 型指定子: b, c, d, e, E, u, f, g, G, o, s, x, X<br />
 * 正規表現を使用するのっでIEでの多用はお勧めしない
 *
 * @param {String} format フォーマット
 * @param {Mixied} var_args フォーマットに対して割り当てる値
 */
Jeeel.String.sprintf = function (format, var_args) {
    format = '' + format;
  
    var ch, res = [];
    var plCnt = 0;
    var len = format.length;
    var args = Array.prototype.slice.call(arguments, 1, arguments.length);
    var JeeelString = Jeeel._Object.JeeelString;
    var tmp = {
        length: 1
    };
    
    for (var i = 0; i < len; i++) {
        ch = format.charAt(i);
        
        // %が出るまで数値を進めて%が出たらプレースホルダ―毎変換する
        switch (ch) {
            case '%':
                if (format.charAt(i + 1) === '%') {
                    res[res.length] = '%';
                    i++;
                } else {
                    res[res.length] = JeeelString.convertPlaceholder(format.slice(i, len), args[plCnt++], tmp);
                    
                    i += tmp.length - 1;
                }
                break;
                
            default:
                res[res.length] = ch;
                break;
        }
    }
    
    return res.join('');
};

/**
 * @ignore
 */
Jeeel._Object.JeeelString.PLACEHOLDER_REGS = /%([+\-# 0]*)?([1-9][0-9]*)?(?:\.(|[0-9]*))?([^0-9]|$)/;

/**
 * @ignore
 */
Jeeel._Object.JeeelString.PLACEHOLDERS = {
    
    /**
     * 二進数に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    b: function (op, value) {
        return this.cnvRadix(op, value, 2);
    },
    
    /**
     * 文字に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    c: function (op, value) {
        return String.fromCharCode(+value);
    }, 
    
    /**
     * 整数に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    d: function (op, value) {
        return this.cnvInt(op, value);
    }, 
    
    /**
     * 指数表記に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    e: function (op, value) {
        return this.cnvExponential(op, value);
    }, 
    
    /**
     * 指数表記の大文字に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    E: function (op, value) {
        return this.cnvExponential(op, value, true);
    }, 
    
    /**
     * 符号なし整数に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    u: function (op, value) {
        return this.cnvInt(op, value, true);
    },
    
    /**
     * 数値に変換(double)<br />
     * 実際には
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    f: function (op, value) {
        return this.cnvFloat(op, value);
    },
    
    /**
     * 数値に変換(float)
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    F: function (op, value) {
        return this.cnvFloat(op, value);
    },
    
    /**
     * 有効桁数から指数表記もしくは数値に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    g: function (op, value) {
        
        var valid = false;
        
        if (op.accur === null || op.accur >= (+value).toString().length) {
            op.accur = null;
            valid = true;
        }

        return valid ? this.cnvFloat(op, value) : this.cnvExponential(op, value);
    },
    
    /**
     * 有効桁数から指数表記もしくは数値の大文字に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    G: function (op, value) {
      
        var valid = false;
        
        if (op.accur === null || op.accur >= (+value).toString().length) {
            op.accur = null;
            valid = true;
        }
        
        return valid ? this.cnvFloat(op, value) : this.cnvExponential(op, value, true);
    },
    
    /**
     * 八進数に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    o: function (op, value) {
        return this.cnvRadix(op, value, 8);
    },
    
    /**
     * 文字列に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    s: function (op, value) {
        value = '' + value;
        var width = (+op.width || 0) - value.length;
        
        if (width <= 0) {
            return value;
        }
        
        var pad = op.pad;
        
        if (op.right) {
            value += Array(width + 1).join(pad);
        } else {
            value = Array(width + 1).join(pad) + value;
        }
        
        return value;
    },
    
    /**
     * 十六進数に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    x: function (op, value) {
        return this.cnvRadix(op, value, 16);
    },
    
    /**
     * 十六進数大文字に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    X: function (op, value) {
        return this.cnvRadix(op, value, 16, true);
    },
    
    /**
     * N進数に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @param {Integer} radix 何進数に変換するか
     * @param {Boolean} [toUpper] 大文字にするかどうか
     * @return {String} 変換後の値
     */
    cnvRadix: function (op, value, radix, toUpper) {
        value = +value;
        
        var isPlus = value >= 0;
      
        value = Math.floor(isPlus && value || -value).toString(radix);
        
        var prf = ! isPlus && '-' || '';
        
        if (op.accur !== null) {
            value = prf = '';
        }
        
        if (toUpper) {
            value = value.toUpperCase();
        }
        
        if (value && op.sp) {
            switch (radix) {
                case 8:
                    prf = prf + '0';
                    break;
                    
                case 16:
                    prf = prf + '0x';
                    break;
            }
        }
        
        var width = (+op.width || 0) - value.length - prf.length;
        
        if (width <= 0) {
            return prf + value;
        }
        
        var pad = op.pad;
        
        if (op.right) {
            value += Array(width + 1).join(pad);
        } else {
            value = Array(width + 1).join(pad) + value;
        }

        return prf + value;
    },
    
    /**
     * 整数に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @param {Boolean} [unsigned] 符号を付けないかどうか
     * @return {String} 変換後の値
     */
    cnvInt: function (op, value, unsigned) {
        value = unsigned ? Math.abs(+value) : +value;
        
        var isPlus = value >= 0;
        
        value = Math.floor(isPlus && value || -value).toString(10);

        var prf = isPlus && op.plus && '+' || ! isPlus && '-' || '';
        
        var width = (+op.width || 0) - value.length - prf.length;
        
        if (width <= 0) {
            return prf + value;
        }
        
        var pad = op.pad;
        
        if (op.right) {
            value += Array(width + 1).join(pad);
        } else {
            value = Array(width + 1).join(pad) + value;
        }
        
        return prf + value;
    },
    
    /**
     * 数値に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @return {String} 変換後の値
     */
    cnvFloat: function (op, value) {
        value = +value;
        
        var isPlus = value >= 0;
        var accur = op.accur;
        
        if (accur !== null) {
            value = (isPlus && value || -value).toFixed(accur);
        } else {
            value = (isPlus && value || -value).toString(10);
        }

        var prf = isPlus && op.plus && '+' || ! isPlus && '-' || '';
        
        var width = (+op.width || 0) - value.length - prf.length;
        
        if (width <= 0) {
            return prf + value;
        }
        
        var pad = op.pad;
        
        if (op.right) {
            value += Array(width + 1).join(pad);
        } else {
            value = Array(width + 1).join(pad) + value;
        }
        
        return prf + value;
    },
    
    /**
     * 指数に変換
     * 
     * @param {Hash} op オプション
     * @param {Mixied} value 値
     * @param {Boolean} [toUpper] 大文字にするかどうか
     * @return {String} 変換後の値
     */
    cnvExponential: function (op, value, toUpper) {
        value = +value;
        
        var isPlus = value >= 0;
        var accur = op.accur;
        
        if (accur !== null) {
            value = (isPlus && value || -value).toExponential(accur);
        } else {
            value = (isPlus && value || -value).toExponential();
        }
        
        var prf = isPlus && op.plus && '+' || ! isPlus && '-' || '';
        
        var width = (+op.width || 0) - value.length - prf.length;
        
        if (width <= 0) {
            return prf + value;
        }
        
        var pad = op.pad;
        
        if (op.right) {
            value += Array(width + 1).join(pad);
        } else {
            value = Array(width + 1).join(pad) + value;
        }
        
        if (toUpper) {
            value = value.toUpperCase();
        }
        
        return prf + value;
    }
};

/**
 * @ignore
 */
Jeeel._Object.JeeelString.convertPlaceholder = function (placeholder, value, res) {
  
    placeholder = placeholder.match(this.PLACEHOLDER_REGS);
    
    res.length = placeholder[0].length;

    var plPrms = {};
    
    // プレースホルダ―の型指定子が一致しなかったら丸ごと消す
    if ( ! this.PLACEHOLDERS[placeholder[4]]) {
        return '';
    }
    
    var flg = placeholder[1] && placeholder[1].split('');
    
    plPrms.width = placeholder[2] || 0;
    plPrms.accur = (placeholder[3] || placeholder[3] === '') ? +placeholder[3] : null;
    
    if (flg) {
        
        for (var i = flg.length; i--;) {
            
            switch (flg[i]) {
                case '-':
                    plPrms.right = true;
                    break;
                    
                case '+':
                    plPrms.plus = true;
                    break;
                    
                case '#':
                    plPrms.sp = true;
                    break;
                    
                case ' ':
                case '0':
                    if ( ! plPrms.pad) {
                        plPrms.pad = flg[i];
                    }
                    break;
            }
        }
    }
    
    // パディング文字がなかった場合は空白をデフォ値にする
    if ( ! plPrms.pad) {
        plPrms.pad = ' ';
    }
    
    return this.PLACEHOLDERS[placeholder[4]](plPrms, value);
};
Jeeel.directory.Jeeel.String.Hash = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.String + 'Hash/';
    }
};

/**
 * @namespace Hash関数関連のネームスペース
 */
Jeeel.String.Hash = {

};

/**
 * @private
 */
Jeeel._Object.JeeelStringHash = {
    
};

Jeeel.file.Jeeel.String.Hash = ['Base64', 'Md5'];

Jeeel._autoImports(Jeeel.directory.Jeeel.String.Hash, Jeeel.file.Jeeel.String.Hash);
Jeeel.directory.Jeeel.String.Hash.Base64 = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.String.Hash + 'Base64/';
    }
};

/**
 * @namespace Base64関連のモジュール
 */
Jeeel.String.Hash.Base64 = {
    
    /**
     * エンコード文字列
     *
     * @type String
     * @constant
     */
    ENCODE_CHARS: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    
    /**
     * デコード配列
     * 
     * @type Integer[]
     * @constant
     */
    DECODE_CHARS: [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
        -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
    ]
};

Jeeel.file.Jeeel.String.Hash.Base64 = ['Encode', 'Decode'];

Jeeel._autoImports(Jeeel.directory.Jeeel.String.Hash.Base64, Jeeel.file.Jeeel.String.Hash.Base64);

/**
 * 指定した文字列に対してbsse64エンコードを行う
 * 
 * @param {String} str エンコード対象文字列
 * @return {String} bsse64文字列
 */
Jeeel.String.Hash.Base64.encode = function (str) {
    
    str = '' + str;
    
    var out, i, len;
    var c1, c2, c3;

    len = str.length;
    i = 0;
    out = [];
    
    while(i < len) {
        c1 = str.charCodeAt(i++) & 0xff;
        
        if (i == len) {
            out[out.length] = this.ENCODE_CHARS.charAt(c1 >> 2);
            out[out.length] = this.ENCODE_CHARS.charAt((c1 & 0x3) << 4);
            out[out.length] = "==";
            break;
        }
        
        c2 = str.charCodeAt(i++);
        
        if (i == len) {
            out[out.length] = this.ENCODE_CHARS.charAt(c1 >> 2);
            out[out.length] = this.ENCODE_CHARS.charAt(((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4));
            out[out.length] = this.ENCODE_CHARS.charAt((c2 & 0xF) << 2);
            out[out.length] = "=";
            break;
        }
        
        c3 = str.charCodeAt(i++);
        
        out[out.length] = this.ENCODE_CHARS.charAt(c1 >> 2);
        out[out.length] = this.ENCODE_CHARS.charAt(((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4));
        out[out.length] = this.ENCODE_CHARS.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6));
        out[out.length] = this.ENCODE_CHARS.charAt(c3 & 0x3F);
    }
    
    return out.join('');
};

/**
 * bsse64エンコードされた文字列を復元する
 * 
 * @param {String} str base64文字列
 * @return {String} 復元した文字列
 */
Jeeel.String.Hash.Base64.decode = function (str) {
    str = '' + str;
    
    var c1, c2, c3, c4;
    var i, len, out;

    len = str.length;
    i = 0;
    out = [];
    
    while(i < len) {
        // c1
        do {
            c1 = this.DECODE_CHARS[str.charCodeAt(i++) & 0XFF];
        } while(i < len && c1 == -1);
        
        if (c1 == -1) {
            break;
        }

        // c2
        do {
            c2 = this.DECODE_CHARS[str.charCodeAt(i++) & 0XFF];
        } while(i < len && c2 == -1);
        
        if (c2 == -1) {
            break;
        }

        out[out.length] = String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));

        // c3
        do {
            c3 = str.charCodeAt(i++) & 0XFF;
            
            if (c3 == 61) {
                return out.join('');
            }
            
            c3 = this.DECODE_CHARS[c3];
        } while(i < len && c3 == -1);
        
        if (c3 == -1) {
            break;
        }

        out[out.length] = String.fromCharCode(((c2 & 0XF) << 4) | ((c3 & 0x3C) >> 2));

        // c4
        do {
            c4 = str.charCodeAt(i++) & 0XFF;
            
            if (c4 == 61) {
                return out.join('');
            }
            
            c4 = this.DECODE_CHARS[c4];
        } while(i < len && c4 == -1);
        
        if (c4 == -1) {
            break;
        }
        
        out[out.length] = String.fromCharCode(((c3 & 0x03) << 6) | c4);
    }
    
    return out.join('');
};

/**
 * 文字列をMD5に変換する
 * 
 * @param {String} data 対象の文字列
 * @return {String} MD5文字列
 */
Jeeel.String.Hash.md5 = function (data) {
    return Jeeel._Object.JeeelStringHash.Md5.hexHash('' + data);
};

/**
 * @private
 */
Jeeel._Object.JeeelStringHash.Md5 = {
  
    /**
     * 16進数に使用する文字列
     * 
     * @type String
     * @constant
     */
    HEX_TEXT: "0123456789abcdef",
    
    /**
     * 16進数に使用する文字列
     * 
     * @type Integer[]
     * @constant
     */
    T: [],

    round: [],
    
    pack: function (n32) {
        return String.fromCharCode(n32 & 0xFF) 
             + String.fromCharCode((n32 >>> 8) & 0xFF) 
             + String.fromCharCode((n32 >>> 16) & 0xFF) 
             + String.fromCharCode((n32 >>> 24) & 0xFF);
    },

    unpack: function (s4) {
        return (s4.charCodeAt(0))
             | (s4.charCodeAt(1) <<  8) 
             | (s4.charCodeAt(2) << 16) 
             | (s4.charCodeAt(3) << 24);
    },

    number: function (n) {
        while (n < 0) {
            n += 4294967296;
        }
        
        while (n > 4294967295) {
            n -= 4294967296;
        }
        
        return n;
    },

    applyRound: function (x, s, f, abcd, r) {
        var a, b, c, d;
        var kk, ss, ii;
        var t, u;

        a = abcd[0];
        b = abcd[1];
        c = abcd[2];
        d = abcd[3];
        kk = r[0];
        ss = r[1];
        ii = r[2];

        u = f(s[b], s[c], s[d]);
        t = s[a] + u + x[kk] + this.T[ii];
        t = this.number(t);
        t = ((t<<ss) | (t>>>(32-ss)));
        t += s[b];
        s[a] = this.number(t);
    },
    
    hash: function (data) {
        this.init();
        
        var abcd, x, state, s;
        var len, index, padLen, f, r;
        var i, j, k;
        var tmp;

        state = [0X67452301, 0XEFCDAB89, 0X98BADCFE, 0X10325476];
        
        len = data.length;
        index = len & 0x3f;
        
        padLen = (index < 56) ? (56 - index) : (120 - index);
        
        if (padLen > 0) {
            data += "\x80";
            
            for (i = 0; i < padLen - 1; i++) {
                data += "\x00";
            }
        }
        
        data += this.pack(len * 8);
        data += this.pack(0);
        len  += padLen + 8;
        
        abcd = [0, 1, 2, 3];
        x    = [];
        s    = [];

        for (k = 0; k < len; k += 64) {
            for (i = 0, j = k; i < 16; i++, j += 4) {
                x[i] = (data.charCodeAt(j))
                     | (data.charCodeAt(j + 1) <<  8) 
                     | (data.charCodeAt(j + 2) << 16) 
                     | (data.charCodeAt(j + 3) << 24);
            }
            
            for (i = 0; i < 4; i++) {
                s[i] = state[i];
            }
            
            for (i = 0; i < 4; i++) {
                f = this.round[i][0];
                r = this.round[i][1];
                
                for (j = 0; j < 16; j++) {
                    this.applyRound(x, s, f, abcd, r[j]);
                    
                    tmp = abcd[0];
                    abcd[0] = abcd[3];
                    abcd[3] = abcd[2];
                    abcd[2] = abcd[1];
                    abcd[1] = tmp;
                }
            }

            for (i = 0; i < 4; i++) {
              state[i] += s[i];
              state[i] = this.number(state[i]);
            }
        }

        return this.pack(state[0]) 
             + this.pack(state[1]) 
             + this.pack(state[2]) 
             + this.pack(state[3]);
    },
    
    hexHash: function (data) {
        var i, out, c;
        var bit128;

        bit128 = this.hash(data);
        out = [];
        
        for (i = 0; i < 16; i++) {
            c = bit128.charCodeAt(i);
            
            out[out.length] = this.HEX_TEXT.charAt((c>>4) & 0xF);
            out[out.length] = this.HEX_TEXT.charAt(c & 0xF);
        }
        
        return out.join('');
    },
    
    init: function () {
        if (this.init.ignore) {
            return;
        }
        
        this.init.ignore = true;
        
        var merge = {
            T: [
                0X00000000, 0XD76AA478, 0XE8C7B756, 0X242070DB,
                0XC1BDCEEE, 0XF57C0FAF, 0X4787C62A, 0XA8304613,
                0XFD469501, 0X698098D8, 0X8B44F7AF, 0XFFFF5BB1,
                0X895CD7BE, 0X6B901122, 0XFD987193, 0XA679438E,
                0X49B40821, 0XF61E2562, 0XC040B340, 0X265E5A51,
                0XE9B6C7AA, 0XD62F105D, 0X02441453, 0XD8A1E681,
                0XE7D3FBC8, 0X21E1CDE6, 0XC33707D6, 0XF4D50D87,
                0X455A14ED, 0XA9E3E905, 0XFCEFA3F8, 0X676F02D9,
                0X8D2A4C8A, 0XFFFA3942, 0X8771F681, 0X6D9D6122,
                0XFDE5380C, 0XA4BEEA44, 0X4BDECFA9, 0XF6BB4B60,
                0XBEBFBC70, 0X289B7EC6, 0XEAA127FA, 0XD4EF3085,
                0X04881D05, 0XD9D4D039, 0XE6DB99E5, 0X1FA27CF8,
                0XC4AC5665, 0XF4292244, 0X432AFF97, 0XAB9423A7,
                0XFC93A039, 0X655B59C3, 0X8F0CCC92, 0XFFEFF47D,
                0X85845DD1, 0X6FA87E4F, 0XFE2CE6E0, 0XA3014314,
                0X4E0811A1, 0XF7537E82, 0XBD3AF235, 0X2AD7D2BB,
                0XEB86D391
            ],

            round1: [
                [ 0, 7, 1], [ 1,12, 2],
                [ 2,17, 3], [ 3,22, 4],
                [ 4, 7, 5], [ 5,12, 6],
                [ 6,17, 7], [ 7,22, 8],
                [ 8, 7, 9], [ 9,12,10],
                [10,17,11], [11,22,12],
                [12, 7,13], [13,12,14],
                [14,17,15], [15,22,16]
            ],

            round2: [
                [ 1, 5,17], [ 6, 9,18],
                [11,14,19], [ 0,20,20],
                [ 5, 5,21], [10, 9,22],
                [15,14,23], [ 4,20,24],
                [ 9, 5,25], [14, 9,26],
                [ 3,14,27], [ 8,20,28],
                [13, 5,29], [ 2, 9,30],
                [ 7,14,31], [12,20,32]
            ],

            round3: [
                [ 5, 4,33], [ 8,11,34],
                [11,16,35], [14,23,36],
                [ 1, 4,37], [ 4,11,38],
                [ 7,16,39], [10,23,40],
                [13, 4,41], [ 0,11,42],
                [ 3,16,43], [ 6,23,44],
                [ 9, 4,45], [12,11,46],
                [15,16,47], [ 2,23,48]
            ],

            round4: [
                [ 0, 6,49], [ 7,10,50],
                [14,15,51], [ 5,21,52],
                [12, 6,53], [ 3,10,54],
                [10,15,55], [ 1,21,56],
                [ 8, 6,57], [15,10,58],
                [ 6,15,59], [13,21,60],
                [ 4, 6,61], [11,10,62],
                [ 2,15,63], [ 9,21,64]
            ],

            /**
             * @ignore
             */
            F: function (x, y, z) {return (x & y) | (~x & z);},
            
            /**
             * @ignore
             */
            G: function (x, y, z) {return (x & z) | (y & ~z);},
            
            /**
             * @ignore
             */
            H: function (x, y, z) {return x ^ y ^ z;},
            
            /**
             * @ignore
             */
            I: function (x, y, z) {return y ^ (x | ~z);}
        };
    
        this.T = merge.T;
        this.round = [
            [merge.F, merge.round1],
            [merge.G, merge.round2],
            [merge.H, merge.round3],
            [merge.I, merge.round4]
        ];
    }
};
Jeeel.directory.Jeeel.Number = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Number/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 数値の複雑な処理をするクラス
 * @param {Number} [number] 基となる数値
 * @example
 * 数値に対して複雑な処理を行うクラス
 * 3桁区切りのフォーマット化や数値を指定範囲に収めたり、ランダムな整数を得たり平均や最小公倍数等を取得することが出来る
 * 
 * 例：
 * Jeeel.Number.format(12548752, ',', '\'); // "\12,548,752"を取得する、主に金額を表示する際に使用する
 * Jeeel.Number.limit(12, 0, 10); // 1つめの引数の数値が2つめと3つめの間に収まるように切り捨てる、この場合は10が返ってくる
 * Jeeel.Number.random(1, 10); // 1～10の間の整数を取得する
 * Jeeel.Number.getAvg(1, 5, 6); // 1, 5, 6を足し合わせて平均を取得する(戻り値4)
 */
Jeeel.Number = function (number) {
    
    if ( ! Jeeel.Type.isSet(number)) {
        number = 0;
    }
    
    this._num = +number;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Number} [number] 基となる数値
 * @return {Jeeel.Number} 作成したインスタンス
 */
Jeeel.Number.create = function (number) {
    return new this(number);
};

/**
 * 数字を千単位でグループ化してフォーマットする
 * 
 * @param {Number} number 対象の数値
 * @param {String} [separator] 千単位を区切る文字列(デフォルトは , )
 * @param {String} [prefix] 接頭辞
 * @param {String} [suffix] 接尾辞
 * @return {String} 変換後の値
 */
Jeeel.Number.format = function (number, separator, prefix, suffix) {
    var str = (+number || 0).toString();
    var dpi = str.indexOf('.');
    var moi = str.indexOf('-') + 1;
    
    if (dpi < 0) {
        dpi = str.length;
    }
    
    var indexArr = [];

    for (var i = dpi - 3; i > moi; i -= 3) {
        indexArr[indexArr.length] = i;
    }

    return (prefix || '') + Jeeel.String.multiInsert(str, indexArr, separator || ',') + (suffix || '');
};

/**
 * 数値を指定範囲内に収める
 * 
 * @param {Number} number 対象の数値
 * @param {Number} min 最小値
 * @param {Number} max 最大値
 * @return {Number} 収めた後の数値
 */
Jeeel.Number.limit = function (number, min, max) {
    if (number < min) {
        number = min;
    }
    
    if (number > max) {
        number = max;
    }
    
    return number;
};

/**
 * 指定した整数の範囲以内の値をランダムで返す
 * 
 * @param {Integer} min 最小値(負数も可)
 * @param {Integer} max 最大値(負数も可)
 * @return {Integer} ランダム整数値(min &lt;= random &lt;= max)
 */
Jeeel.Number.random = function (min, max) {
    var r = max - min + 1;
    
    return Math.floor(min + Math.random() * r);
};

/**
 * 数値を百分率にして返す
 * 
 * @param {Number} number 対象の数値
 * @return {String} 百分率表記の文字列(後ろに%が付く)
 */
Jeeel.Number.percentage = function (number) {
    return number * 100 + '%';
};

/**
 * 指定した角度をラジアンに変換する
 * 
 * @param {Number} deg 角度
 * @return {Number} ラジアン
 */
Jeeel.Number.degreeToRadian = function (deg) {
    return deg / 180 * Math.PI;
};

/**
 * 指定したラジアンを角度に変換する
 * 
 * @param {Number} rad ラジアン
 * @return {Number} 角度
 */
Jeeel.Number.radianToDegree = function (rad) {
    return rad / Math.PI * 180;
};

/**
 * 合計値を求める
 * 
 * @param {Number} var_args 合計値を求める際に数を可変で引き渡す
 */
Jeeel.Number.getSum = function (var_args) {
    var i, sum = 0;
    
    for (i = arguments.length; i--;) {
        sum += arguments[i];
    }
    
    return sum;
};

/**
 * 平均値を求める
 * 
 * @param {Number} var_args 平均値を求める際に数を可変で引き渡す
 */
Jeeel.Number.getAvg = function (var_args) {
    return this.getSum.apply(this, arguments) / arguments.length;
};

/**
 * 最大公約数を求める
 * 
 * @param {Integer} base 最大公約数を求める際の数
 * @param {Integer} var_args 可変引数、2つ以上の数を指定する場合に渡す
 * @return {Integer} 最大公約数(正)
 */
Jeeel.Number.getGcd = function (base, var_args) {
    var i, j, l, r;
    
    for (i = 0, l = arguments.length - 1; i < l; i++) {
        j = i + 1;
        r = arguments[i] % arguments[j];

        arguments[j] = r === 0 ? arguments[j] : arguments.callee(arguments[j], r < 0 ? -r : r);
    }
    
    return arguments[l];
};

/**
 * 最小公倍数を求める
 * 
 * @param {Integer} base 最小公倍数を求める際の数
 * @param {Integer} var_args 可変引数、2つ以上の数を指定する場合に渡す
 * @return {Integer} 最小公倍数(正)
 */
Jeeel.Number.getLcm = function (base, var_args) {
    var i, j, l;
    
    for (i = 0, l = arguments.length - 1; i < l; i++) {
        j = i + 1;
        
        arguments[j] = arguments[i] * arguments[j] / this.getGcd(arguments[i], arguments[j]);
    }

    return arguments[l] < 0 ? -arguments[l] : arguments[l];
};

Jeeel.Number.prototype = {
  
    /**
     * 元の数値
     * 
     * @type Number
     * @private
     */
    _num: 0,
    
    /**
     * 数値を絶対値にする
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    abs: function () {
        this._num =  (this._num > 0 ? this._num : -this._num);
        
        return this;
    },
    
    /**
     * 数値を切り上げる
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    ceil: function () {
        this._num = Math.ceil(this._num);
        
        return this;
    },
    
    /**
     * 数値を切り下げる
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    floor: function () {
        this._num = Math.floor(this._num);
        
        return this;
    },
    
    /**
     * 数値を四捨五入する
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    round: function () {
        this._num = Math.round(this._num);
        
        return this;
    },
    
    /**
     * 数値を指定範囲に収める
     * 
     * @return {Jeeel.Number} 自インスタンス
     */
    limit: function (min, max) {
        this._num = this.constructor.limit(this._num, min, max);
        
        return this;
    },
    
    /**
     * 数値を千単位でグループ化してフォーマットする
     * 
     * @param {String} [separator] 千単位を区切る文字列(デフォルトは , )
     * @param {String} [prefix] 接頭辞
     * @param {String} [suffix] 接尾辞
     * @return {String} フォーマット後の文字列
     */
    toFormatted: function (separator, prefix, suffix) {
        return this.constructor.format(this._num, separator, prefix, suffix);
    },
    
    /**
     * 数値を百分率表記に変換する
     * 
     * @return {String} 百分率表記の文字列
     */
    toPercentage: function () {
        return this.constructor.percentage(this._num);
    },
    
    /**
     * インスタンスを文字列に変換する
     * 
     * @param {Integer} [radix] 進数を指定する場合に指定
     * @return {String} 文字列
     */
    toString: function (radix) {
        return (radix ? this._num.toString(radix) : this._num.toString());
    },
    
    /**
     * インスタンスを数値に変換する
     * 
     * @return {Number} 数値
     */
    valueOf: function () {
        return this._num;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Number} [number] 基となる数値
     * @constructor
     */
    constructor: Jeeel.Number
};

Jeeel.file.Jeeel.Number = ['Fraction'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Number, Jeeel.file.Jeeel.Number);

/**
 * コンストラクタ
 * 
 * @class 分数を管理するクラス
 * @param {Number|String} numeric 分数化する数値もしくは数値文字列
 */
Jeeel.Number.Fraction = function (numeric) {};

/**
 * コンストラクタ
 * 
 * @class 分数を管理するクラス
 * @param {Integer} numerator 分子
 * @param {Integer} denominator 分母
 */
Jeeel.Number.Fraction = function (numerator, denominator) {
  
    switch (arguments.length) {
        case 1:
            var numeric = Jeeel.String.trim('' + arguments[0]);

            var pidx = numeric.lastIndexOf('.');
            denominator = 1;

            if (pidx + 1) {
                denominator = Math.pow(10, numeric.length - pidx - 1);
            }

            numerator = +(numeric.replace('.', ''));
            break;

        case 2:
            break;

        default:
            throw new Error('引数の数が違います。');
            break;
    }
    
    /**
     * 分子
     * 
     * @type Integer
     */
    this.numerator = +numerator;
    
    /**
     * 分母
     * 
     * @type Integer
     */
    this.denominator = +denominator;
};

Jeeel.Number.Fraction.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Number.Fraction} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Fraction(this.numerator, this.denominator);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Number.Fraction} fraction 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (fraction) {
        return this.numerator === fraction.numerator
            && this.denominator === fraction.denominator;
    },
    
    /**
     * 約分を行う
     * 
     * @return {Jeeel.Number.Fraction} 自インスタンス
     */
    reduce: function () {
        var gcd = Jeeel.Number.getGcd(this.numerator, this.denominator);
        
        this.numerator /= gcd;
        this.denominator /= gcd;
        
        return this;
    },
    
    /**
     * 通分を行う
     * 
     * @param {Jeeel.Number.Fraction} fraction 通分対象の分数インスタンス
     * @return {Jeeel.Number.Fraction} 自インスタンス
     */
    reduceCommonDenominator: function (fraction) {
        var commonNum = Jeeel.Number.getLcm(this.denominator, fraction.denominator) / this.denominator;
        
        this.numerator *= commonNum;
        this.denominator *= commonNum;
        
        return this;
    },
    
    /**
     * 分数を足し合わせる
     * 
     * @param {Jeeel.Number.Fraction} fraction 足し合わせる分数インスタンス
     * @return {Jeeel.Number.Fraction} 自インスタンス
     */
    add: function (fraction) {
        fraction = fraction.clone().reduceCommonDenominator(this);
        
        this.reduceCommonDenominator(fraction);
        
        this.numerator += fraction.numerator;
        
        return this;
    },
    
    /**
     * 分数を差し引く
     * 
     * @param {Jeeel.Number.Fraction} fraction 差し引く分数インスタンス
     * @return {Jeeel.Number.Fraction} 自インスタンス
     */
    sub: function (fraction) {
        fraction = fraction.clone().reduceCommonDenominator(this);
        
        this.reduceCommonDenominator(fraction);
        
        this.numerator -= fraction.numerator;
        
        return this;
    },
    
    /**
     * 分数を掛け合わせる
     * 
     * @param {Jeeel.Number.Fraction} fraction 掛け合わせる分数インスタンス
     * @return {Jeeel.Number.Fraction} 自インスタンス
     */
    mul: function (fraction) {
        this.numerator *= fraction.numerator;
        this.denominator *= fraction.denominator;
        
        return this;
    },
    
    /**
     * 分数を割る
     * 
     * @param {Jeeel.Number.Fraction} fraction 割る分数インスタンス
     * @return {Jeeel.Number.Fraction} 自インスタンス
     */
    div: function (fraction) {
        this.numerator *= fraction.denominator;
        this.denominator *= fraction.numerator;
        
        return this;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return this.numerator + ' / ' + this.denominator;
    },
    
    /**
     * 数値に変換する
     * 
     * @return {Number} 数値に変換した自インスタンス
     */
    valueOf: function () {
        return this.numerator / this.denominator;
    }
};
Jeeel.directory.Jeeel.Language = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Language/';
    }
};

/**
 * @staticClass 言語関連を管理するスタティッククラス
 */
Jeeel.Language = {
    
    /**
     * ユニークID
     * 
     * @type String
     * @private
     */
    _uid: Jeeel.UNIQUE_ID,
    
    /**
     * ロケール
     * 
     * @type String
     * @private
     */
    _locale: 'en',
    
    /**
     * 初期ロケール
     * 
     * @type String
     * @private
     */
    _defaultLocale: 'en',
    
    /**
     * サポートしているロケール
     * 
     * @type String[]
     * @private
     */
    _supportLocales: [
        'en',
        'ja'
    ],
    
    /**
     * ランゲージ格納ディレクトリ
     * 
     * @type String[]
     * @private
     */
    _languageDirectories: [
        Jeeel.BASE_URL + 'Jeeel/Language/'
    ],
    
    /**
     * 読み込み済みのランゲージ要素
     * 
     * @type Hash
     * @private
     */
    _languages: {},
    
    /**
     * 読み込み済みのパスリスト
     * 
     * @type String[]
     * @private
     */
    _loadedPaths: [],
    
    /**
     * このクラスがサポートするロケール一覧を取得する
     * 
     * @return {String[]} ロケール一覧
     */
    getSupportLocales: function () {
        return this._supportLocales;
    },
    
    /**
     * デフォルトのロケールを取得する
     * 
     * @return {String} ロケール
     */
    getDefaultLocale: function () {
        return this._defaultLocale;
    },
    
    /**
     * 現在のロケールを取得する
     * 
     * @return {String} ロケール
     */
    getLocale: function () {
        return this._locale;
    },
    
    /**
     * 現在のロケールを設定する(サポート外の値を指定すると初期ロケールに戻される)
     * 
     * @param {String} locale ロケール
     * @return {Jeeel.Language} 自クラス
     */
    setLocale: function (locale) {
        if ( ! Jeeel.Hash.inHash(locale, this._supportLocales, true)) {
            locale = this._defaultLocale;
        }
        
        this._locale = locale;
        
        return this._reloadLanguage();
    },
    
    /**
     * 言語設定を読み込む
     * 
     * @param {String} path 言語パス
     * @param {Function} [callback] 言語設定読み込み完了時のコールバック
     * @return {Jeeel.Language} 自クラス
     */
    loadLanguage: function (path, callback) {
        path = ('' + path);
        
        var urlPath = path.replace('.', '/');
        var idx = this._languageDirectories.length - 1;
        
        var url = this._languageDirectories[idx--] + urlPath + '/' + this._locale + '.xml';
        var ajax = Jeeel.Net.Ajax.create(url, 'GET');
        
        var retry = function () {
            if (Jeeel.UNIQUE_ID !== this._uid) {
                return;
            }
            
            if (idx >= 0) {
                url = this._languageDirectories[idx--] + urlPath + '/' + this._locale + '.xml';
                
                ajax.setUrl(url);
                ajax.execute();
            }
        };
        
        ajax.setSuccessMethod(function (response) {
            if (Jeeel.UNIQUE_ID !== this._uid) {
                return;
            }
            
            var xml = new Jeeel.Dom.Xml(response.responseXML || response.responseText);
            var names = path.split('.');
            var hash = this._languages;
            
            if ( ! hash[this._locale]) {
                hash[this._locale] = {};
            }

            hash = hash[this._locale];

            for (var i = 0, l = names.length - 1; i < l; i++) {
                if ( ! Jeeel.Type.isHash(hash[names[i]])) {
                    hash[names[i]] = {};
                }

                hash = hash[names[i]];
            }
            
            hash[names[l]] = xml.toHash().language;
            
            if ( ! Jeeel.Hash.inHash(path, this._loadedPaths, true)) {
                this._loadedPaths.push(path);
            }
            
            callback && callback();
            
        }, this).setFailureMethod(retry, this).setExceptionMethod(retry, this);

        ajax.execute();
        
        return this;
    },
    
    /**
     * 言語設定が存在するかどうかを返す
     * 
     * @param {String} path 言語パス
     * @return {Boolean} 存在するかどうか
     */
    hasLanguage: function (path) {
        var names = ('' + path).split('.');
        
        var hash = this._languages;
        
        if ( ! hash[this._locale]) {
            return false;
        }
        
        hash = hash[this._locale];
        
        for (var i = 0, l = names.length; i < l; i++) {
            if ( ! Jeeel.Type.isHash(hash[names[i]])) {
                return false;
            }
            
            hash = hash[names[i]];
        }
        
        return true;
    },
    
    /**
     * 言語設定を取得する
     * 
     * @param {String} path 言語パス
     * @return {Hash} 言語設定
     */
    getLanguage: function (path) {
        var names = ('' + path).split('.');
        
        var hash = this._languages;
        
        if ( ! hash[this._locale]) {
            return null;
        }
        
        hash = hash[this._locale];
        
        for (var i = 0, l = names.length; i < l; i++) {
            if ( ! Jeeel.Type.isHash(hash[names[i]])) {
                return null;
            }
            
            hash = hash[names[i]];
        }
        
        return hash;
    },
    
    /**
     * ロケールが変わった後に再読み込みを行う
     * 
     * @return {Jeeel.Language} 自クラス
     * @private
     */
    _reloadLanguage: function () {
        
        for (var i = this._loadedPaths.length; i--;) {
            var path = this._loadedPaths[i];
            
            if ( ! this.hasLanguage(path)) {
                this.loadLanguage(path);
            }
        }
        
        return this;
    }
};
/**
 * @namespace 汎用的なメソッドを保持するネームスペース
 */
Jeeel.Method = {
    
    /**
     * 指定した変数を複製して返す<br />
     * ただし比較の際型は違うものとしてとらえられる可能性がある<br />
     * なおコピー方法はシャローコピーであり内部変数までは複製しない
     *
     * @param {Mixied} value 複製する変数
     * @return {Mixied} 複製後の値
     */
    clone: function (value) {

        if (Jeeel.Type.isPrimitive(value)) {
            return value;
        } else if (Jeeel.Type.isArray(value)) {
            return (value.length === 1 ? [value[0]] : Array.apply(null, value));
        } else if (Jeeel.Type.isFunction(value)) {
            value = value.toString();

            if (value.match(/\{(\n|\s)+\[native code\](\n|\s)+\}/)) {
                return value;
            }

            eval('value = '+value);

            return value;
        }

        var newClass = function (){};

        newClass.prototype = value;

        return new newClass();
    }
};
/**
 * コンストラクタ
 * 
 * @class 配列もしくは連想配列について複雑な処理をするクラス<br />
 *         そのままの連想配列やJeeel.Parameterよりも高速に連想配列にアクセス出来るが、初期化にかなりのロスを伴う
 * @param {Hash} [hash] 基となるHash
 * @example
 * 配列・連想配列に対して様々な処理を行うクラス
 * インスタンス化すると連想配列を配列の様に扱い高速アクセスや配列に備わっているメソッドを使用できるようにする
 * 
 * 例：
 * var hash = Jeeel.Hash.create({a: 55, b: 777});
 * hash.getValues(); // 値のリストを取得する、[55, 777]
 * hash.getKeys(); // キーのリストを取得する、['a', 'b']
 * hash.search(777); // 内部の値を検索してヒットしたらキーを返しヒットしなかったらnullを返す
 * 
 * 他にも以下のようなメソッドが良く使用される
 * 
 * Jeeel.Hash.merge({a: 55, b: 888}, {b: 66, c: 45}); // 2つ配列、連想配列を混合して新しく連想配列を生成する
 * Jeeel.Hash.forEach(function (val, key) {  // 配列・連想配列に対してその要素に順次アクセスを行う
 *     console.log(key + ': ' + val);
 * }, {a: 1, b: 2, c: 3});
 */
Jeeel.Hash = function (hash) {
    this._init(hash);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Hash} [hash] 基となるHash
 * @return {Jeeel.Hash} 作成したインスタンス
 */
Jeeel.Hash.create = function (hash) {
    return new this(hash);
};

/**
 * Jeeel.Hash.forEachを途中で終了するための定数
 *
 * @type Object
 * @constant
 */
Jeeel.Hash.FOR_EACH_EXIT = {
    exit: true
};

/**
 * 指定したキーが配列式型に存在するかどうかを返す
 *
 * @param {String|Integer} key 判定値
 * @param {Hash} hash 配列式型
 * @return {Boolean} 判定結果
 * @throws {TypeError} arrayが配列式でない場合に起こる
 */
Jeeel.Hash.keyExists = function (key, hash) {
    return key in hash;
};

/**
 * 指定した値が配列式型の中に存在するかどうかを返す
 *
 * @param {Mixied} val 判定値
 * @param {Hash} hash 配列式型
 * @param {Boolean} [strict] 厳密に型のチェックをするかどうか
 * @return {Boolean} 判定結果
 * @throws {Error} arrayが配列式でない場合に起こる
 */
Jeeel.Hash.inHash = function (val, hash, strict) {
    var check = false;

    Jeeel.Hash.forEach(hash,
        function (elm) {
            if (( ! strict && val == elm) || (strict && val === elm)) {
                check = true;
                return Jeeel.Hash.FOR_EACH_EXIT;
            }
        }
    );

    return check;
};

/**
 * 指定したHashから配列の長さを返す
 *
 * @param {Hash} hash 配列・連想配列
 * @return {Integer} キーの数
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.getCount = function (hash) {
    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }

    if (Jeeel.Type.hasLength(hash)) {
        return hash.length;
    }

    var count = 0;

    for (var key in hash) {
        count++;
    }

    return count;
};

/**
 * 指定したHashからキーのリストを取得する
 *
 * @param {Hash} hash 配列・連想配列(キーを保持する全てを許可する)
 * @param {Mixied} [value] キーの取得条件値
 * @param {Boolean} [strict] 厳密な検索を行うかどうか
 * @return {String[]} キーのリスト
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.getKeys = function (hash, value, strict) {

    if (Jeeel.Type.isEmpty(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }
    
    var valSet = Jeeel.Type.isSet(value);
    var res = [];

    if (Jeeel.Type.isArray(hash) || Jeeel.Type.isArguments(hash) || Jeeel.Type.isHtmlCollection(hash) || Jeeel.Type.isNodeList(hash)) {
        for (var i = 0, l = hash.length; i < l; i++) {
            
            if (valSet) {
                if (strict && value !== hash[i]) {
                    continue;
                } else if ( ! strict && value != hash[i]) {
                    continue;
                }
            }

            res[res.length] = '' + i;
        }
    } else {
        for (var key in hash) {

            if (valSet) {
                if (strict && value !== hash[key]) {
                    continue;
                } else if ( ! strict && value != hash[key]) {
                    continue;
                }
            }

            res[res.length] = key;
        }
    }

    return res;
};

/**
 * 指定したHashの値を全て返す
 *
 * @param {Hash} hash 配列・連想配列
 * @return {Array} 値のリスト
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.getValues = function (hash) {

    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }
    
    var res;

    if (Jeeel.Type.isArray(hash) || Jeeel.Type.isArguments(hash)) {
        return Array.prototype.slice.call(hash, 0, hash.length);
    } else if (Jeeel.Type.isHtmlCollection(hash) || Jeeel.Type.isNodeList(hash)) {
        res = [];
        
        for (var i = hash.length; i--;) {
            res[i] = hash[i];
        }
        
        return res;
    }

    res = [];

    for (var key in hash) {
        res[res.length] = hash[key];
    }

    return res;
};

/**
 * 指定したHashのキーと値のペアを全て返す<br />
 * 配列等に関しても全て返す
 *
 * @param {Hash} hash 配列・連想配列
 * @param {Boolean} [sort] ソートするかどうか
 * @param {Boolean} [enableChainKey] プロトタイプチェーンのキーを全て参照するかどうか(__proto__が定義されていないブラウザには意味がない)
 * @return {Jeeel.Object.Item[]} キーと値のリスト(valueはセキュリティ系のエラーの場合、値ではなくエラーオブジェクトを代入する)
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.getPairs = function (hash, sort, enableChainKey) {
    
    if (Jeeel.Type.isEmpty(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }

    var type = Jeeel.Type.getType(hash);
    var list = Jeeel.Type.getKeys(type);
    var ownConstructor = hash.constructor && (Object.prototype.hasOwnProperty && ! Object.prototype.hasOwnProperty.call(hash, 'constructor') || hash.constructor !== Object);
    var retryWhere = !!( ! enableChainKey && (hash.__proto__ || Object.getPrototypeOf || ownConstructor) && Object.prototype.hasOwnProperty);
    var pair = [], key;

    for (key in hash) {

        if (retryWhere && ! Object.prototype.hasOwnProperty.call(hash, key)) {
            continue;
        }

        var val;

        try {
            val = hash[key];
        } catch (e) {
            val = e;
        }

        pair[pair.length] = new Jeeel.Object.Item(key, val);

        var searchKey = Jeeel.Hash.search(key, list, true);

        if ( ! Jeeel.Type.isEmpty(searchKey)) {
            list.splice(searchKey, 1);
        }
    }
    
    for (var i = 0, l = list.length; i < l; i++) {
        key = list[i];
        
        if (key !== '__proto__' && retryWhere && ! Object.prototype.hasOwnProperty.call(hash, key)) {
            continue;
        }
        
        if ( ! (key in hash)) {
            continue;
        }
        
        try {
            pair[pair.length] = new Jeeel.Object.Item(key, hash[key]);
        } catch (e) {
            pair[pair.length] = new Jeeel.Object.Item(key, e);
        }
    }
    
    if (retryWhere &&  ! ('__proto__' in hash)) {
        if (Object.getPrototypeOf) {
            pair[pair.length] = new Jeeel.Object.Item('__proto__', Object.getPrototypeOf(hash));
        } else if (ownConstructor && Object.prototype.hasOwnProperty && ! Object.prototype.hasOwnProperty.call(hash, 'constructor')) {
            pair[pair.length] = new Jeeel.Object.Item('__proto__', hash.constructor.prototype);
        } else if (ownConstructor && hash.constructor !== Object) {
            pair[pair.length] = new Jeeel.Object.Item('__proto__', hash._super || Object.prototype);
        }
    }
    
    if (sort) {
        pair.sort(function (a, b) {
            if (a.key > b.key) {
                return 1;
            } else if (a.key < b.key) {
                return -1;
            }
            
            return 0;
        });
    }

    return pair;
};

/**
 * 配列・連想配列をマージする
 *
 * @param {Hash} hash1 配列・連想配列
 * @param {Hash} hash2 配列・連想配列
 * @return {Hash} mergeした後の連想配列
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.merge = function (hash1, hash2) {
    if ( ! Jeeel.Type.isHash(hash1) || ! Jeeel.Type.isHash(hash2)) {
        throw new Error('hash1・hash2が配列・連想配列ではありません');
    }

    var res = {};

    var digit, count = 0;

    Jeeel.Hash.forEach(hash1,
        function (val, key) {

            digit = +key;

            if (Jeeel.Type.isInteger(digit) && digit > count) {
                count = digit;
            }

            res[key] = val;
        }
    );

    Jeeel.Hash.forEach(hash2,
        function (val, key) {

            if (Jeeel.Type.isInteger(+key)) {
                res[++count] = val;
            } else {
                res[key] = val;
            }
        }
    );
   
    return res;
};

/**
 * 指定した値をHash内で検索し、見つかった場合は対応するキーを返す
 *
 * @param {Mixied} value 検索する値
 * @param {Hash} hash 配列・連想配列
 * @param {Boolean} [strict] 厳密な検索を行うかどうか
 * @return {String} 見つかった値の対応するキー(見つからなかった場合はnull)
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.search = function (value, hash, strict) {
    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }
    
    var _key = null;

    Jeeel.Hash.forEach(hash,
        function (val, key) {
            if (strict && value === val) {
                _key = key;
                return Jeeel.Hash.FOR_EACH_EXIT;
            } else if ( ! strict && value == val) {
                _key = key;
                return Jeeel.Hash.FOR_EACH_EXIT;
            }
        }
    );

    return _key;
};

/**
 * Hash形式のオブジェクトを配列に修正して返す
 *
 * @param {Hash} hash 配列・連想配列
 * @return {Array} 配列に修正したHashの値リスト(hashのキーが数字の部分を優先し、その後ろからキーが文字列のものを入れていく)
 * @throws {Error} hashが配列式でない場合に起こる
 */
Jeeel.Hash.toArray = function (hash) {
    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }

    if (Jeeel.Type.isArray(hash)) {
        return Jeeel.Method.clone(hash);
    }
    else if (Jeeel.Type.isArguments(hash)) {
        return (hash.length === 1 ? [hash[0]] : Array.apply(null, hash));
    }
    else if (Jeeel.Type.isHtmlCollection(hash) || Jeeel.Type.isNodeList(hash)) {
        var arr = [];

        for (var i = hash.length; i--;) {
            arr[i] = hash[i];
        }

        return arr;
    }

    var key, num, nums = [];
    var res = [];
    var max = -1;
    
    for (key in hash) {
        num = +key;
        
        if (Jeeel.Type.isInteger(num)) {
            nums[nums.length] = num;
            
            res[num] = hash[num];
            
            if (max < num) {
                max = num;
            }
        }
    }

    for (key in hash) {
        if ( ! Jeeel.Type.isInteger(+key)) {
            res[++max] = hash[key];
        }
    }

    return res;
};

/**
 * 配列・連想配列に対して各要素にアクセスするメソッド<br />
 * 配列の場合は初期化していない要素にはアクセスしない
 * 
 * @param {Hash} hash 配列・連想配列
 * @param {Function} callback void callBack(Mixied value, String key, Hash hash)<br />
 *                             引数は左から要素,キー,配列となる(戻り値に指定定数を返すとbreakする)
 * @param {Mixied} [thisArg] コールバックメソッド中のthisに変わるオブジェクト(初期値はhashになる)
 * @throws {Error} hashが配列式でない場合に起こる
 * @see Jeeel.Hash.FOR_EACH_EXIT
 */
Jeeel.Hash.forEach = function (hash, callback, thisArg) {
    if ( ! Jeeel.Type.isHash(hash)) {
        throw new Error('hashが配列・連想配列ではありません');
    }
    
    if ( ! Jeeel.Type.isSet(thisArg)) {
        thisArg = hash;
    }

    var tmp, length;
    var exit = Jeeel.Hash.FOR_EACH_EXIT;

    if (Jeeel.Type.hasLength(hash)) {
        length = hash.length;

        for (var i = 0; i < length; i++) {

            if (i in hash) {

                tmp = callback.call(thisArg, hash[i], i, hash);

                if (tmp === exit) {
                    break;
                }
            }
        }
    } else {
        for (var key in hash) {
            
            tmp = callback.call(thisArg, hash[key], key, hash);

            if (tmp === exit) {
                break;
            }
        }
    }
};

Jeeel.Hash.prototype = {

    /**
     * 基のHash
     *
     * @type Hash
     */
    _hash: null,

    /**
     * Hashのキーリスト
     *
     * @type String[]
     */
    _keys: [],

    /**
     * Hashの値リスト
     *
     * @type Array
     */
    _vals: [],

    /**
     * Hashの値を全て数値に変更したリスト
     *
     * @type Number[]
     */
    _nums: null,

    /**
     * Hashの要素数
     *
     * @type Integer
     */
    _length: 0,
    
    /**
     * Hash内のキーの内最大の数値
     * 
     * @type Integer
     */
    _lastIndex: -1,
    
    /**
     * Hashの値を取得する
     * 
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 取得した値
     */
    get: function (key, defaultValue) {
        return (key in this._hash ? this._hash[key] : defaultValue);
    },
    
    /**
     * Hashに値を設定する
     * 
     * @param {String} key キー
     * @param {Mixed} val 保存する値
     * @return {Jeeel.Hash} 自インスタンス
     */
    set: function (key, val) {
        var c = ! (key in this._hash);
        
        this._hash[key] = val;
        
        if (c) {
            this._keys[this._length] = key;
            this._vals[this._length] = val;
            this._length++;
            
            this._nums = null;
            
            this._resetLastIndex(key, true);
        }

        return this;
    },
    
    /**
     * Hashの値を削除する
     * 
     * @param {String} key キー
     * @return {Jeeel.Hash} 自インスタンス
     */
    unset: function (key) {
        if (key in this._hash) {
            delete this._hash[key];
            var index, i;
            
            for (i = 0; i < this._length; i++) {
                if (this._keys[i] == key) {
                    index = i;
                    break;
                }
            }
            
            this._keys.splice(index, 1);
            this._vals.splice(index, 1);
            
            this._length--;
            
            this._nums = null;
            
            this._resetLastIndex(key);
        }

        return this;
    },
    
    /**
     * 指定したキーに対応するインデックスを取得する
     * 
     * @param {String} key キー
     * @return {Integer} インデックス
     */
    getIndex: function (key) {
        var index = -1;
        
        for (var i = 0; i < this._length; i++) {
            if (this._keys[i] == key) {
                index = i;
                break;
            }
        }
        
        return index;
    },
    
    /**
     * 指定したインデックスに対応するキーを取得する
     * 
     * @param {Integer} index インデックス
     * @return {String} キー
     */
    getKey: function (index) {
        return this._keys[index];
    },
    
    /**
     * 指定したインデックスに対応する値を取得する
     * 
     * @param {Integer} index インデックス
     * @return {Mixied} 取得した値
     */
    getValue: function (index) {
        return this._vals[index];
    },

    /**
     * Hashの要素数を返す
     *
     * @return {Integer} 要素数
     */
    getLength: function () {
        return this._length;
    },

    /**
     * 最初の値を取得する
     *
     * @return {Mixied} 取得した値
     */
    getFirst: function () {
        return this._vals[0];
    },

    /**
     * 最後の値を取得する
     *
     * @return {Mixied} 取得した値
     */
    getLast: function () {
        return this._vals[this._length - 1];
    },

    /**
     * 基のHashを返す
     *
     * @return {Hash} 基のHash
     */
    getHash: function () {
        return this._hash;
    },

    /**
     * Hashのキーのリストを作成して取得する
     *
     * @return {String[]} キーのリスト
     */
    getKeys: function () {
        return this._keys;
    },

    /**
     * Hashの値のリストを作成して取得する
     *
     * @return {Array} 値のリスト
     */
    getValues: function () {
        return this._vals;
    },
    
    /**
     * Hash内の値を全て数値と見立てて最大値を得る
     *
     * @return {Number} 最大値
     */
    getMax: function () {
        return Math.max.apply(null, this._getNums());
    },

    /**
     * Hash内の値を全て数値と見立てて最小値を得る
     *
     * @return {Number} 最小値
     */
    getMin: function () {
        return Math.min.apply(null, this._getNums());
    },

    /**
     * Hash内の値を全て数値と見立てて合計値を得る
     *
     * @return {Number} 合計値
     */
    getSum: function () {
        var nums = this._getNums();
        var sum  = 0;

        for (var i = nums.length; i--;) {
            sum += nums[i];
        }

        return sum;
    },

    /**
     * Hash内の値を全て数値と見立てて平均値を得る
     *
     * @return {Number} 平均値
     */
    getAvg: function () {
        return this.getSum() / this._length;
    },

    /**
     * 指定された関数を実行し、それらに合格した要素からなる新しいインスタンスを作成する
     *
     * @param {Function} callback Boolean callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    filter: function (callback, thisArg) {
        var res = {};
        
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        for (var i = 0; i < this._length; i++) {
            if (callback.call(thisArg, this._vals[i], this._keys[i], this._hash)) {
                res[this._keys[i]] = this._vals[i];
            }
        }

        return this.constructor.create(res);
    },

    /**
     * 指定された関数を実行し、それらの戻り値から新しいインスタンスを作成する
     *
     * @param {Function} callback Mixied callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    map: function (callback, thisArg) {
        var res = {};
        
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        for (var i = 0; i < this._length; i++) {
            res[this._keys[i]] = callback.call(thisArg, this._vals[i], this._keys[i], this._hash);
        }

        return this.constructor.create(res);
    },

    /**
     * 前の戻り値とHashの値を先頭から1つ引数に取り、<br />
     * 最終的にひとつの値を結果として得る<br />
     * 始めの時の戻り値には初期値もしくは先頭の値が来る(先頭の値の場合は引数に二番目の値が来る)
     * 
     * @param {Function} callback Mixied callback(Mixied tmp, Mixied val, String key, Hash hash)
     * @param {Mixied} [initVal] 初期値(指定しない場合は最初の値を使う)
     * @return {Mixied} 戻り値
     */
    reduce: function (callback, initVal) {
        if ( ! Jeeel.Type.isSet(initVal) && this._length <= 0) {
            throw new Error('空のHashに対して初期値未指定でReduceメソッドは使えません。');
        }

        var val;
        var min = 0;

        if (Jeeel.Type.isSet(initVal)) {
            val = initVal;
        } else {
            val = this._vals[0];
            min++;
        }

        for (var i = min; i < this._length; i++) {
            val = callback(val, this._vals[i], this._keys[i], this._hash);
        }

        return val;
    },

    /**
     * 前の戻り値とHashの値を後尾から1つ引数に取り、<br />
     * 最終的にひとつの値を結果として得る<br />
     * 始めの時の戻り値には初期値もしくは先頭の値が来る(先頭の値の場合は引数に二番目の値が来る)
     *
     * @param {Function} callback Mixied reduce(Mixied tmp, Mixied val, String key, Hash hash)
     * @param {Mixied} [initVal] 初期値(指定しない場合は最初の値を使う)
     * @return {Mixied} 戻り値
     */
    reduceRight: function (callback, initVal) {
        if ( ! Jeeel.Type.isSet(initVal) && this._length <= 0) {
            throw new Error('空のHashに対して初期値未指定でReduceRightメソッドは使えません。');
        }

        var val;
        var max = this._length - 1;

        if (Jeeel.Type.isSet(initVal)) {
            val = initVal;
        } else {
            val = this._vals[max];
            max--;
        }

        for (var i = max; i >= 0; i--) {
            val = callback(val, this._vals[i], this._keys[i], this._hash);
        }

        return val;
    },

    /**
     * 指定された関数を実行し、全ての要素がそれを合格するかどうかを返す
     *
     * @param {Function} callback Boolean callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Boolean} 全ての要素が合格したかどうか
     */
    every: function (callback, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        for (var i = 0; i < this._length; i++) {
            if ( ! callback.call(thisArg, this._vals[i], this._keys[i], this._hash)) {
                return false;
            }
        }

        return true;
    },

    /**
     * 指定された関数を実行し、それに合格する要素があるかどうかを返す
     *
     * @param {Function} callback Boolean callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Boolean} 合格する要素があるかどうか
     */
    some: function (callback, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        for (var i = 0; i < this._length; i++) {
            if (callback.call(thisArg, this._vals[i], this._keys[i], this._hash)) {
                return true;
            }
        }

        return false;
    },

    /**
     * 指定された関数を各要素に一度ずつ実行する
     *
     * @param {Function} callback void callback(Mixied val, String key, Hash hash)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Jeeel.Hash} 自インスタンス
     */
    forEach: function (callback, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        for (var i = 0; i < this._length; i++) {
            callback.call(thisArg, this._vals[i], this._keys[i], this._hash);
        }

        return this;
    },
    
    /**
     * Hash内の要素が配列もしくはJeeel.Hashインスタンスだった場合は押しつぶして、1次元に変換して新しいインスタンスとして作成する<br />
     * その際キーは失われる
     *
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    flatten: function () {
        var res = [];
        
        var _flatten = function (arr) {
            for (var i = 0, l = arr.length; i < l; i++) {
                
                if (Jeeel.Type.isArray(arr[i])) {
                    _flatten(arr[i]);
                    continue;
                } else if (arr[i] instanceof this.constructor) {
                    _flatten(arr[i].getValues());
                    continue;
                }
                
                res[res.length] = arr[i];
            }
        };
        
        _flatten(this._vals);
        
        return new this.constructor(res);
    },
    
    /**
     * 指定したキー同士の値を交換する
     * 
     * @param {String} keyLeft キー1
     * @param {String} keyRight キー2
     * @return {Jeeel.Hash} 自インスタンス
     */
    swap: function (keyLeft, keyRight) {
        var left, right, both = 0;
        
        for (var i = 0; i < this._length; i++) {
            if (this._keys[i] == keyLeft) {
                left  = i;
                both++;
            } else if (this._keys[i] == keyRight) {
                right = i;
                both++;
            }
            
            if (both === 2) {
                break;
            }
        }
        
        return this.swapValue(left, right);
    },

    /**
     * 指定したインデックス同士の値を交換する
     * 
     * @param {Integer} left インデックス1
     * @param {Integer} right インデックス2
     * @return {Jeeel.Hash} 自インスタンス
     */
    swapValue: function (left, right) {
        if ( ! (0 <= left && left < this._length)) {
            return this;
        }
        else if ( ! (0 <= right && right < this._length)) {
            return this;
        }
        else if (left === right) {
            return this;
        }
        
        var key = this._keys[left];
        var val = this._vals[left];

        this._keys[left] = this._keys[right];
        this._vals[left] = this._vals[right];

        this._keys[right] = key;
        this._vals[right] = val;

        return this;
    },
    
    /**
     * Hash内から最後の要素を取り除き、<br />
     * その値を返す
     *
     * @return {Mixied} 取りだした値
     */
    pop: function () {
        if ( ! this._length) {
            return undefined;
        }
        
        this._length--;

        var key = this._keys.pop();
        var val = this._vals.pop();

        delete this._hash[key];

        this._nums = null;
        
        this._resetLastIndex(key);

        return val;
    },

    /**
     * 引数で受け取った値をHashの最後に挿入する
     *
     * @param {Mixied} var_args 挿入値の可変引数
     * @return {Integer} 挿入後の要素数
     */
    push: function (var_args) {
        var len = arguments.length;
        
        if ( ! len) {
            return this._length;
        }
        
        var max = this._lastIndex + 1;

        for (var i = 0; i < len; i++) {
            this._hash[max] = arguments[i];
            this._vals[this._length] = arguments[i];
            this._keys[this._length] = '' + max;

            max++;
            this._length++;
        }

        this._nums = null;
        this._lastIndex = max - 1;

        return this._length;
    },

    /**
     * Hash内の先頭の要素を取り除き、<br />
     * その値を返す
     *
     * @return {Mixied} 取りだした値
     */
    shift: function () {
        if ( ! this._length) {
            return undefined;
        }
        
        this._length--;

        var key = this._keys.shift();
        var val = this._vals.shift();

        delete this._hash[key];

        this._nums = null;
        
        this._resetLastIndex(key);

        return val;
    },

    /**
     * 引数で受け取った値をHashの先頭に挿入する
     *
     * @param {Mixied} var_args 挿入値の可変引数
     * @return {Integer} 挿入後の要素数
     */
    unshift: function (var_args) {
        var len = arguments.length;
        
        if ( ! len) {
            return this._length;
        }
        
        var li, i, keys = [], vals = [], repKeys = {};
        
        if (this._lastIndex >= 0) {
            for (i = this._lastIndex; i >= 0; i--) {
                if (i in this._hash) {
                    this._hash[i + len] = this._hash[i];
                    
                    repKeys[i] = '' + (i + len);
                    
                    if ( ! li) {
                        li = i + len;
                    }
                }
            }
        } else {
            li = len - 1;
        }
        
        for (i = 0; i < len; i++) {
            this._hash[i] = arguments[i];
            vals[i] = arguments[i];
            keys[i] = '' + i;
        }

        for (i = 0; i < this._length; i++) {
            vals[len + i] = this._vals[i];
            keys[len + i] = repKeys[this._keys[i]] || this._keys[i];
        }
        
        this._keys = keys;
        this._vals = vals;

        this._nums = null;
        
        if (li) {
            this._lastIndex = li;
        }

        return this._length += len;
    },
    
    /**
     * Hashの一部を取り出して新たにインスタンスを作成する
     * 
     * @param {Integer} [start] どこから取り出すかを示すインデックス<br />
     *                           負の数を指定した場合Hashの終わりからのオフセットを示す<br />
     *                           省略時は0
     * @param {Integer} [end] どこまで取りだすかを示すインデックス(この数値は含まない)<br />
     *                         負の数を指定した場合Hashの終わりからのオフセットを示す<br />
     *                         省略時はHashの最後まで
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    slice: function (start, end) {
        if ( ! Jeeel.Type.isInteger(start)) {
            start = 0;
        } else if (start < 0) {
            start = start + this._length;
            
            if (start < 0) {
                start = 0;
            }
        }
        
        if ( ! Jeeel.Type.isSet(end) || end > this._length) {
            end = this._length;
        } else if (end < 0) {
            end = end + this._length + 1;
        }
        
        return this._copy(start, end - 1);
    },

    /**
     * Hash内の古い要素を取り除き、代わりに新しい要素を挿入する
     * 
     * @param {Integer} index 配列を変化させ始めるインデックス
     * @param {Integer} [count] 配列から取り除く要素の数(省略はindex以降全ての要素)
     * @param {Mixied} var_args 追加要素の可変引数
     * @return {Array} 古い要素の配列
     */
    splice: function (index, count, var_args) {
        if ( ! Jeeel.Type.isInteger(index)) {
            return [];
        }
        
        if ( ! Jeeel.Type.isInteger(count)) {
            count = this._length;
        }
        
        var i, idx, ai = 2, li = -1;
        var len = index + count;
        var res = [], keys = [], vals = [];
        
        for (i = 0; i < index; i++) {
            keys[i] = this._keys[i];
            vals[i] = this._vals[i];
            
            idx = +keys[i];
            
            if (Jeeel.Type.isInteger(idx) && li < idx) {
                li = idx;
            }
        }
        
        for (i = index; i < len; i++) {
            res[res.length] = this._vals[i];
            
            if (ai in arguments) {
                keys[i] = this._keys[i];
                vals[i] = arguments[ai];
                
                idx = +keys[i];

                if (Jeeel.Type.isInteger(idx) && li < idx) {
                    li = idx;
                }
                
                this._hash[keys[i]] = vals[i];
                
                ai++;
            } else {
                delete this._hash[this._keys[i]];
            }
        }
        
        for (i = len; i < this._length; i++) {
            keys[keys.length] = this._keys[i];
            vals[vals.length] = this._vals[i];
            
            idx = +keys[i];
            
            if (Jeeel.Type.isInteger(idx) && li < idx) {
                li = idx;
            }
        }
        
        this._keys = keys;
        this._vals = vals;
        
        this._length = this._vals.length;
        
        this._nums = null;
        
        this._lastIndex = li;
        
        return res;
    },

    /**
     * 配列をソートする<br />
     * ソートアルゴリズムはクイックソート
     * 
     * @param {Function} [compareFunction] 比較関数(大きい数値の場合はaを優先、小さい数値の場合はbを優先、0は同値とする)<br />
     *                                      Integer compareFunction(Mixied a, Mixied b)
     * @return {Jeeel.Hash} 自インスタンス
     */
    sort: function (compareFunction) {
        if ( ! compareFunction ) {
          
            /**
             * @ignore
             */
            compareFunction = function (a, b) {
                a = '' + a;
                b = '' + b;
                
                return a > b ? 1 : (a < b ? -1 : 0);
            };
        }
        
        /**
         * @ignore
         */
        var middle = function (h, t) {
            return h + ((t - h) >>> 1);
        };

        var stack = [0, this._length - 1];
        
        while(stack.length) {
            var tail = stack.pop();
            var head = stack.pop();
            var pivot = this._vals[middle(head, tail)];
            var i = head - 1;
            var j = tail + 1;
            
            while (1) {
                while (i < tail && compareFunction(this._vals[++i], pivot) < 0);
                while (j > head && compareFunction(this._vals[--j], pivot) > 0);
                
                if (i >= j) break;
                
                this.swapValue(i, j);
            }
            
            if (head < i - 1) {stack.push(head);stack.push(i - 1);}
            if (j + 1 < tail) {stack.push(j + 1);stack.push(tail);}
        }
        
        return this;
    },

    /**
     * Hash内の要素をシャッフルする
     *
     * @return {Jeeel.Hash} 自インスタンス
     */
    shuffle: function () {
        var i = this._length;

        while(i) {
            var j = Math.floor(Math.random() * i);

            i--;

            if (i == j) {
                continue;
            }

            this.swapValue(i, j);
        }
        
        this._nums = null;

        return this;
    },

    /**
     * Hash内の並びを逆転させる
     *
     * @return {Jeeel.Hash} 自インスタンス
     */
    reverse: function () {

        this._keys.reverse();
        this._vals.reverse();
        this._nums = null;

        return this;
    },

    /**
     * Hashに他のインスタンス・配列や値を結合し新しいインスタンスとして返す<br />
     * その際キーは失われる
     * 
     * @param {Mixied} var_args 接続値の可変引数
     * @return {Jeeel.Hash} 作成したインスタンス
     */
    concat: function (var_args) {
        var i, j, res = [];

        for (i = 0; i < this._length; i++) {
            res[i] = this._vals[i];
        }

        var len = arguments.length;
        var idx = this._length;
        var arg;
        
        for (i = 0; i < len; i++) {
            arg = arguments[i];
            
            if (arg instanceof this.constructor) {
                for (j = 0; j < arg._length; j++) {
                    res[idx++] = arg._vals[j];
                }
            }
            else if (Jeeel.Type.isArray(arg)) {
                for (j = 0; j < arg.length; j++) {
                    res[idx++] = arg[j];
                }
            } 
            else {
                res[idx++] = arg;
            }
        }

        return new this.constructor(res);
    },

    /**
     * Hash内の要素を全て繋げて文字列にする
     *
     * @param {String} [separator] 連結時の区切り文字列
     * @return {String} 連結文字列
     */
    join: function (separator) {
        if ( ! Jeeel.Type.isSet(separator)) {
            separator = ',';
        }

        return this._vals.join(separator);
    },
    
    /**
     * 指定した値をHash内で検索し、見つかった場合は対応するキーを返す
     *
     * @param {Mixied} searchValue 検索する値
     * @param {Boolean} [strict] 厳密な検索を行うかどうか
     * @return {String} 見つかった値に対応するキー(見つからなかった場合はnull)
     */
    search: function (searchValue, strict) {
        var len = this._length;
        
        for (var from = 0; from < len; from++) {
            if (strict && this._vals[from] === searchValue) {
                return this._keys[from];
            } else if ( ! strict && this._vals[from] == searchValue) {
                return this._keys[from];
            }
        }

        return null;
    },

    /**
     * 指定した値をHash内で検索し、見つかった場合は対応するインデックスを返す
     *
     * @param {Mixied} searchValue 検索する値
     * @param {Integer} [fromIndex] 検索を始める初期インデックス
     * @return {Integer} 見つかった値に対応するインデックス(見つからなかった場合は-1)
     */
    indexOf: function (searchValue, fromIndex) {
        var len = this._length;

        var from = Number(fromIndex) || 0;

        from = (from < 0 ? Math.ceil(from) : Math.floor(from));

        if (from < 0) {
            from += len;
        }

        for (; from < len; from++) {
            if (from in this._vals && this._vals[from] === searchValue) {
                return from;
            }
        }

        return -1;
    },
    
    /**
     * 指定した値をHash内で後ろから検索し、見つかった場合は対応するインデックスを返す
     *
     * @param {Mixied} searchValue 検索する値
     * @param {Integer} [fromIndex] 検索を始める初期インデックス
     * @return {Integer} 見つかった値に対応するインデックス(見つからなかった場合は-1)
     */
    lastIndexOf: function (searchValue, fromIndex) {
        var len = this.length;

        var from = Number(fromIndex);
        
        if (isNaN(from)) {
            from = len - 1;
        }
        else {
            from = (from < 0 ? Math.ceil(from) : Math.floor(from));

            if (from < 0) {
                from += len;
            }
            else if (from >= len) {
                from = len - 1;
            }
        }

        for (; from > -1; from--) {
            if (from in this._vals && this._vals[from] === searchValue) {
                return from;
            }
        }
        
        return -1;
    },

    /**
     * HashをGetパラメータ文字列に変換する(先頭に?はつかない)
     *
     * @return {String} Getパラメータ文字列
     */
    toQueryString: function () {
        return Jeeel.Filter.Url.QueryString.create().filter(this._hash);
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Hash} [hash] 基となるHash
     * @constructor
     */
    constructor: Jeeel.Hash,
    
    /**
     * 初期化を行う
     * 
     * @param {Hash} [hash] 基となるHash
     */
    _init: function (hash) {
        if ( ! Jeeel.Type.isHash(hash)) {
            hash = {};
        } else if (hash instanceof this.constructor) {
            hash = hash.getHash();
        } else if (hash instanceof Jeeel.Parameter) {
            hash = hash.getAll();
        }
        
        var keys = [], vals = [];
        
        if ('length' in hash && (Jeeel.Type.isArray(hash) || Jeeel.Type.isArguments(hash) || Jeeel.Type.isHtmlCollection(hash) || Jeeel.Type.isNodeList(hash))) {
            for (var i = 0, l = hash.length; i < l; i++) {
                keys[i] = '' + i;
                vals[i] = hash[i];
            }
            
            this._lastIndex = l - 1;
        } else {
            var max = -1;
            
            for (var key in hash) {
                keys[keys.length] = key;
                vals[vals.length] = hash[key];
                
                key = +key;
                
                if (Jeeel.Type.isInteger(key) && max < key) {
                    max = key;
                }
            }
            
            this._lastIndex = max;
        }

        this._hash = hash;
        this._keys = keys;
        this._vals = vals;
        this._length = vals.length;
    },
    
    _copy: function (from, to) {
        var res = new this.constructor();
        var max = -1;
        
        for (var i = from; i <= to; i++) {
            var key = this._keys[i];
            
            res._keys[res._keys.length] = key;
            res._vals[res._vals.length] = this._vals[i];
            res._hash[key] = this._vals[i];
            
            key = +key;

            if (Jeeel.Type.isInteger(key) && max < key) {
                max = key;
            }
        }
        
        res._lastIndex = max;
        res._length = res._keys.length;
        
        return res;
    },
    
    /**
     * 
     */
    _resetLastIndex: function (key, set) {
        
        if ( ! Jeeel.Type.isSet(key)) {
            key = -1;
            
            for (var i = 0; i < this._length; i++) {
                var tmp = +this._keys[i];
                
                if (Jeeel.Type.isInteger(tmp) && key < tmp) {
                    key = tmp;
                }
            }
            
            this._lastIndex = key;
            
            return;
        }
        
        key = +key;

        if (set && this._lastIndex < key) {
            this._lastIndex = key;
        } else if (this._lastIndex == key) {
            for (var i = key; i >= 0; i--) {
                if (i in this._hash) {
                    this._lastIndex = i;
                    return;
                }
            }

            this._lastIndex = -1;
        }
    },

    /**
     * Hash内の物を全て数値だと仮定してキャストして取得する
     * 
     * @return {Number[]} 数値配列
     */
    _getNums: function () {
        if (this._nums) {
            return this._nums;
        }

        var nums = [];

        for (var i = 0; i < this._length; i++) {
            nums[i] = +this._vals[i];
        }
        
        this._nums = nums;

        return nums;
    }
};
Jeeel.directory.Jeeel.Filter = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Filter/';
    }
};

/**
 * @namespace フィルターに関するネームスペース
 */
Jeeel.Filter = {

    /**
     * コンストラクタ
     * 
     * @abstractClass フィルタークラスを作る際の抽象クラス
     */
    Abstract: function () {}
};

Jeeel.Filter.Abstract.prototype = {

    /**
     * 指定した値に対してフィルターを掛ける
     *
     * @param {Mixied} val フィルターを掛ける値
     * @return {Mixied} フィルターを掛けた後の値
     */
    filter: function (val) {
        if (Jeeel.Type.isHash(val)) {
            val = this._filterEach(val);
        } else {
            val = this._filter(val);
        }

        return val;
    },

    /**
     * 通常値の場合のメソッド<br />
     * 必ずオーバーライドしなければならない
     *
     * @param {Mixied} val フィルターを掛ける値
     * @return {Mixied} フィルターを掛けた後の値
     * @protected
     * @abstract
     */
    _filter: function (val) {
        throw new Error('_filterメソッドが実装されていません。');
    },

    /**
     * 配列式の場合のメソッド
     *
     * @param {Hash} arr フィルターを掛ける値のリスト
     * @return {Mixied} フィルターを掛けた後の値
     * @protected
     */
    _filterEach: function (arr) {
        var result = {};

        Jeeel.Hash.forEach(arr,
            function (val, key) {
                result[key] = this.filter(val);
            }, this
        );

        return result;
    }
};

Jeeel._Object.JeeelFilter = {
    
    getInputs: function (elm) {
        var selector = "input, select, keygen, textarea, button";
        var res = [], i, l;
        
        if (elm.querySelectorAll) {
            var sres = elm.querySelectorAll(selector);
            
            for (i = 0, l = sres.length; i < l; i++) {
                res[i] = sres[i];
            }
        } else {
            
            var tags = ['INPUT', 'SELECT', 'KEYGEN', 'TEXTAREA', 'BUTTON'];

            res = Jeeel.Dom.Core.Searcher.create(elm).getElementsByTagName(tags);
        }
        
        return res;
    },
    
    getInputName: Jeeel._Object.Jeeel.getInputName,
    
    repairInputName: function (names) {
        var name = [names[0]];
        
        for (var i = 1, l = names.length; i < l; i++) {
            name[name.length] = '[';

            name[name.length] = names[i];
            
            name[name.length] = ']';
        }
        
        return name.join('');
    }
};

Jeeel.file.Jeeel.Filter = ['Each', 'Chain', 'Join', 'Subset', 'Map', 'Cast', 'Hash', 'String', 'Url', 'Html'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter, Jeeel.file.Jeeel.Filter);

/**
 * コンストラクタ
 * 
 * @class フィルターを配列の各要素にそれぞれ掛けるためのフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {Jeeel.Filter.Abstract} innerFilter 内部フィルター
 * @param {String[]} [keys] 操作許可キーリスト(初期値は全て)
 */
Jeeel.Filter.Each = function (innerFilter, keys) {
  
    Jeeel.Filter.Abstract.call(this);
    
    if (keys && ! Jeeel.Type.isArray(keys)) {
        keys = [keys];
    }
    
    this._innerFilter = innerFilter;
    this._keys = keys || null;
};

/**
 * インスタンスを作成して返す
 *
 * @param {Jeeel.Filter.Abstract} innerFilter 内部フィルター
 * @param {String[]} [keys] 操作許可キーリスト(初期値は全て)
 * @return {Jeeel.Filter.Each} 作成したインスタンス
 */
Jeeel.Filter.Each.create = function (innerFilter, keys) {
    return new this(innerFilter, keys);
};

Jeeel.Filter.Each.prototype = {
  
    /**
     * 操作対象キーリスト
     * 
     * @type String[]
     * @private
     */
    _keys: null,
    
    /**
     * 内部フィルター
     * 
     * @type Jeeel.Filter.Abstract
     * @private
     */
    _innerFilter: null,
    
    /**
     * 内部フィルターを取得する
     * 
     * @return {Jeeel.Filter.Abstract} innerFilter 内部フィルター
     */
    getInnerFilter: function () {
        return this._innerFilter;
    },

    /**
     * 内部フィルターをセットする
     *
     * @param {Jeeel.Filter.Abstract} innerFilter 内部フィルター
     * @return {Jeeel.Filter.Each} 自身のインスタンス
     */
    setInnerFilter: function (innerFilter) {
        this._innerFilter = innerFilter;

        return this;
    },

    /**
     * @private
     */
    _filter: function (params) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (params) {
        var result = {};
        var filter = this.getInnerFilter();

        Jeeel.Hash.forEach(params,
            function (val, key) {

                if ( ! this._keys || Jeeel.Hash.inHash(key, this._keys)) {
                    result[key] = filter.filter(val);
                }
                else {
                    result[key] = val;
                }
            }
        );

        return result;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Each, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class フィルターを複数連結するフィルター
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Chain = function () {
  
    Jeeel.Filter.Abstract.call(this);

    this._filters = [];
    this._log = {};
};

/**
 * インスタンスを作成して返す
 *
 * @return {Jeeel.Filter.Chain} 作成したインスタンス
 */
Jeeel.Filter.Chain.create = function () {
    return new this();
};

Jeeel.Filter.Chain.prototype = {
    
    /**
     * 連結フィルター
     * 
     * @type Jeeel.Filter.Abstract[]
     * @private
     */
    _filters: [],
    
    /**
     * フィルターログ
     * 
     * @type Hash
     * @private
     */
    _log: {},
    
    /**
     * フィルターログ使用の可否
     * 
     * @type Boolean
     * @private
     */
    _useLog: false,
    
    /**
     * 連結するフィルタを追加する
     *
     * @param {Jeeel.Filter.Abstract} filter 連結するフィルタ
     * @param {String} [name] 連結するフィルタの名前を指定する(デフォルトは無名)<br />
     *                         名前をしてした場合途中結果を保持する対象に入る
     * @return {Jeeel.Filter.Chain} 自インスタンス
     */
    add: function (filter, name) {
        this._filters[this._filters.length] = {name: name, filter: filter};

        return this;
    },

    /**
     * 途中結果を取得する
     *
     * @return {Hash} 名前のついたフィルターの結果をキーと結果のペア
     */
    getLog: function () {
        return this._log;
    },

    /**
     * 途中結果を保持するかどうかを設定する
     *
     * @param {Boolean} useLog 途中結果を保持するかどうか
     * @return {Jeeel.Filter.Chain} 自インスタンス
     */
    setUseLog: function (useLog) {
        this._useLog = Boolean(useLog);

        return this;
    },
    
    /**
     * @private
     */
    _filter: function (params) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (params) {
        var log = {};

        for (var i = 0, l = this._filters.length; i < l; i++) {
            var filter = this. _filters[i];

            params = filter.filter.filter(params);

            if (this._useLog && filter.name) {
                log[filter.name] = params;
            }
        }

        this._log = log;

        return params;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Chain, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 対象のHashの各要素を連結して文字列にするフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} [separator] 連結時の区切り文字列
 * @param {String[]} [keys] 連結するキーのリスト
 */
Jeeel.Filter.Join = function (separator, keys) {
    Jeeel.Filter.Abstract.call(this);

    this._separator = (separator ? '' + separator : '');
    this._keys = keys || null;
};

/**
 * インスタンスの作成
 *
 * @param {String} [separator] 連結時の区切り文字列
 * @param {String[]} [keys] 連結するキーのリスト
 * @return {Jeeel.Filter.Join} 作成したインスタンス
 */
Jeeel.Filter.Join.create = function (separator, keys) {
    return new this(separator, keys);
};

Jeeel.Filter.Join.prototype = {
    
    /**
     * 連結時の区切り文字列
     * 
     * @type String
     * @private
     */
    _separator: '',
    
    /**
     * 連結するキーリスト
     * 
     * @type String[]
     * @private
     */
    _keys: null,
    
    /**
     * @private
     */
    _filter: function (array) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (array) {
        var keys = this._keys || Jeeel.Hash.getKeys(array);

        var params = Jeeel.Parameter.create(array)
                                  .getSubset(keys)
                                  .getAll();

        var res = [];

        Jeeel.Hash.forEach(params,
            function (val) {
                res[res.length] = '' + val;
            }
        );

        return res.join(this._separator);
    }
};

Jeeel.Class.extend(Jeeel.Filter.Join, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class キーを複数指定し、部分集合を作成するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {Hash|String} keys 部分集合を表す複数のキー
 * @param {Mixed} [defaultValue] キーが存在しなかった場合のデフォルト値
 */
Jeeel.Filter.Subset = function (keys, defaultValue) {
    Jeeel.Filter.Abstract.call(this);

    if ( ! Jeeel.Type.isHash(keys)) {
        keys = [keys];
    }

    this._keys = keys;
    this._defaultValue = defaultValue;
};

/**
 * インスタンスの作成
 *
 * @param {Hash|String} keys 部分集合を表す複数のキー
 * @param {Mixed} [defaultValue] キーが存在しなかった場合のデフォルト値
 * @return {Jeeel.Filter.Subset} 作成したインスタンス
 */
Jeeel.Filter.Subset.create = function (keys, defaultValue) {
    return new this(keys, defaultValue);
};

Jeeel.Filter.Subset.prototype = {
    
    /**
     * 部分集合を表す複数のキー
     * 
     * @type Hash|String
     * @private
     */
    _keys: [],
    
    /**
     * キーが存在しなかった場合のデフォルト値
     * 
     * @type Mixed
     * @private
     */
    _defaultValue: undefined,
    
    /**
     * @private
     */
    _filter: function (val) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (array) {

        var globalDefault = null;
        var defaults;

        if (Jeeel.Type.isUndefined(this._defaultValue)) {
            defaults = {};
        }
        else if ( ! Jeeel.Type.isHash(this._defaultValue)) {
            defaults = {'*': this._defaultValue};
        }
        else {
            defaults = this._defaultValue;
        }

        if ('*' in defaults) {
            globalDefault = defaults['*'];
            
            delete defaults['*'];
        }

        var result = {};

        for (var arrayKey in this._keys) {
            var key = this._keys[arrayKey];

            if (key in array) {
                result[key] = array[key];
                
                continue;
            }
            
            if (key in defaults) {
                result[key] = defaults[key];
                
                continue;
            }
            
            if (globalDefault !== null) {
                result[key] = globalDefault;
            }
        }

        return result;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Subset, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 指定した値を他の値に変換して新たな値を返す
 * @augments Jeeel.Filter.Abstract
 * @param {Function} callback 値を変換するコールバックメソッド(1番目の引数に値、二番目の引数はHash形式の値を対象にした場合のキー)<br />
 *                             Mixied callback(Mixied value, String Key)
 */
Jeeel.Filter.Map = function (callback) {
    Jeeel.Filter.Abstract.call(this);
  
    this._callback = callback;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Function} callback 値を変換するコールバックメソッド(1番目の引数に値、二番目の引数はHash形式の値を対象にした場合のキー)<br />
 *                             Mixied callback(Mixied value, String Key)
 * @return {Jeeel.Filter.Html.Hidden} 作成したインスタンス
 */
Jeeel.Filter.Map.create = function (callback) {
    return new this(callback);
};

Jeeel.Filter.Map.prototype = {
    
    /**
     * 値を変換するコールバックメソッド(1番目の引数に値、二番目の引数はHash形式の値を対象にした場合のキー)
     * 
     * @type Function Mixied callback(Mixied value, String Key)
     */
    _callback: null,
    
    /**
     * @private
     */
    _filter: function (val, key) {
        return this._callback(val, key);
    },
    
    /**
     * @private
     */
    _filterEach: function (vals) {
        var res = {};
        
        Jeeel.Hash.forEach(vals,
            function (val, key) {
                res[key] = this._filter(val, key);
            }, this
        );
          
        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Map, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Filter.Cast = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Filter + 'Cast/';
    }
};

/**
 * @namespace キャスト系のネームスペース
 */
Jeeel.Filter.Cast = {
    
};

Jeeel.file.Jeeel.Filter.Cast = ['Number', 'String'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter.Cast, Jeeel.file.Jeeel.Filter.Cast);

/**
 * コンストラクタ
 * 
 * @class Numberにキャストするフィルター
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Cast.Number = function () {
    Jeeel.Filter.Abstract.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Filter.Cast.Number} 作成したインスタンス
 */
Jeeel.Filter.Cast.Number.create = function () {
    return new this();
};

Jeeel.Filter.Cast.Number.prototype = {
  
    /**
     * @private
     */
    _filter: function (val) {
        return +val;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Cast.Number, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class Stringにキャストするフィルター
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Cast.String = function () {
    Jeeel.Filter.Abstract.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Filter.Cast.String} 作成したインスタンス
 */
Jeeel.Filter.Cast.String.create = function () {
    return new this();
};

Jeeel.Filter.Cast.String.prototype = {
  
    /**
     * @private
     */
    _filter: function (val) {
        return '' + val;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Cast.String, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Filter.Hash = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Filter + 'Hash/';
    }
};

/**
 * @namespace 配列・連想配列関連のフィルター管理ネームスペース
 */
Jeeel.Filter.Hash = {

};

Jeeel.file.Jeeel.Filter.Hash = ['Reduce', 'Bundle', 'Key', 'Flat', 'KeySpecify', 'Fill', 'Unique', 'Difference', 'CopyKey', 'DeleteKey'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter.Hash, Jeeel.file.Jeeel.Filter.Hash);

/**
 * コンストラクタ
 * 
 * @class 指定したキーのリストを作成する
 * @augments Jeeel.Filter.Abstract
 * @param {String} key リスト化したい値を保持するキー
 * @param {String} [hashKey] リスト化した際のキーに持たせたい値を保持するキー
 */
Jeeel.Filter.Hash.Reduce = function (key, hashKey) {
    Jeeel.Filter.Abstract.call(this);
   
   this._key = key;
   this._hashKey = hashKey;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} key リスト化したい値を保持するキー
 * @param {String} [hashKey] リスト化した際のキーに持たせたい値を保持するキー
 * @return {Jeeel.Filter.Hash.Reduce} 作成したインスタンス
 */
Jeeel.Filter.Hash.Reduce.create = function (key, hashKey) {
    return new this(key, hashKey);
};

Jeeel.Filter.Hash.Reduce.prototype = {
    
    /**
     * リスト化したい値を保持するキー
     * 
     * @type String
     * @private
     */
    _key: null,
    
    /**
     * リスト化した際のキーに持たせたい値を保持するキー
     * 
     * @type String
     * @private
     */
    _hashKey: null,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('valは配列・連想配列でなければなりません。');
    },

    /**
     * @private
     */
    _filterEach: function (val) {
        var res = {};

        Jeeel.Hash.forEach(val,
            function (row, rowKey) {

                if ( ! (this._key in row)) {
                    throw new Error('valには' + this._key + '要素がありません。');
                }

                if (this._hashKey) {
                    if ( ! (this._hashKey in row)) {
                        throw new Error('valには' + this._hashKey + 'がありません。');
                    }

                    res[row[this._hashKey]] = row[this._key];
                    return;
                }

                res[rowKey] = row[this._key];
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.Reduce, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class 多次元配列をあるキーで纏めるフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} key バンドルするキー
 */
Jeeel.Filter.Hash.Bundle = function (key) {
    Jeeel.Filter.Abstract.call(this);
    
    this._key = key;
};

/**
 * インスタンスの作成
 *
 * @param {String} key バンドルするキー
 * @return {Jeeel.Filter.Hash.Bundle} 作成したインスタンス
 */
Jeeel.Filter.Hash.Bundle.create = function (key) {
    return new this(key);
};

Jeeel.Filter.Hash.Bundle.prototype = {
    
    /**
     * バンドルキー
     * 
     * @type String
     * @private
     */
    _key: null,
    
    /**
     * @private
     */
    _filter: function (array) {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (array) {
        var res = {};
        
        Jeeel.Hash.forEach(array,
            function (val, arrayKey) {
                if ( ! (this._key in val)) {
                    throw new Error('valには' + this._key + '要素がありません');
                }

                if ( ! (res[val[this._key]])) {
                    res[val[this._key]] = {};
                }
                
                res[val[this._key]][arrayKey] = val;
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.Bundle, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class あるキーについて調べ、そのキーの値が指定値以外だった場合排除するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} key キー
 * @param {Hash} allowList 許可値リスト
 * @throws {Error} allowListが配列式でない場合に起こる
 */
Jeeel.Filter.Hash.Key = function (key, allowList) {

    Jeeel.Filter.Abstract.call(this);
    
    if ( ! Jeeel.Type.isHash(allowList)) {
        throw new Error('allowListは配列式でなければなりません。');
    }

    this._key = key;
    this._allowList = allowList;
};

/**
 * インスタンスの作成
 *
 * @param {String} key キー
 * @param {Hash} allowList 許可値リスト
 * @return {Jeeel.Filter.Hash.Key} 作成したインスタンス
 */
Jeeel.Filter.Hash.Key.create = function (key, allowList) {
    return new this(key, allowList);
};

Jeeel.Filter.Hash.Key.prototype = {
    
    /**
     * キー
     * 
     * @type String
     * @private
     */
    _key: null,
    
    /**
     * 許可値リスト
     * 
     * @type Hash
     * @private
     */
    _allowList: [],
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (array) {

        var res = {};

        Jeeel.Hash.forEach(array,
            function (row, rowKey) {

                var allow = false;

                if ( ! (this._key in row)) {
                    throw new Error("この配列には " + this._key + " が含まれていません。");
                }

                Jeeel.Hash.forEach(row,
                    function (val, key) {
                        if (key === this._key) {
                            allow = Jeeel.Hash.inHash(val, this._allowList);
                           return Jeeel.Hash.FOR_EACH_EXIT;
                        }
                    }, this
                );

                if (allow) {
                    res[rowKey] = row;
                }
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.Key, Jeeel.Filter.Abstract);
/**
 * コンストラクタ
 *
 * @class 配列の階層を減らすフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {Integer} from 階層を減らす階層の深さの始め
 * @param {Integer} length 階層を減らす回数
 * @throws {Error} fromが整数でない場合に起こる
 * @throws {Error} lengthが整数でない場合に起こる
 */
Jeeel.Filter.Hash.Flat = function (from, length) {

    Jeeel.Filter.Abstract.call(this);
    
    if ( ! Jeeel.Type.isInteger(from)) {
        throw new Error('fromは整数でなければなりません。');
    }

    if ( ! Jeeel.Type.isInteger(length)) {
        throw new Error('lengthは整数でなければなりません。');
    }

    this._from = from;
    this._length = length;
};

/**
 * インスタンスの作成
 *
 * @param {Integer} from 階層を減らす階層の深さの始め
 * @param {Integer} length 階層を減らす回数
 * @return {Jeeel.Filter.Hash.Flat} 作成したインスタンス
 */
Jeeel.Filter.Hash.Flat.create = function (from, length) {
    return new this(from, length);
};

Jeeel.Filter.Hash.Flat.prototype = {
    
    /**
     * 階層を減らす階層の深さの始め
     * 
     * @type Integer
     * @private
     */
    _from: 0,
    
    /**
     * 階層を減らす回数
     * 
     * @type Integer
     * @private
     */
    _length: 0,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (rows) {
        var result = this._arrayWhile(0, rows);

        return result;
    },
    
    /**
     * @private
     */
    _push: function (hash, value) {
        var cnt = 0;

        while (true) {
            if ( ! (cnt in hash)) {
                hash[cnt] = value;
                break;
            }

            cnt++;
        }
    },

    /**
     * @private
     */
    _arrayWhile: function (count, array) {

        if ( ! Jeeel.Type.isHash(array) || this._length === (count - this._from)) {
            return array;
        }

        if (count >= this._from) {
            var res = {};

            Jeeel.Hash.forEach(array,
                function (val) {
                    if (Jeeel.Type.isHash(val)) {
                        res = Jeeel.Hash.merge(res, this._arrayWhile(count + 1, val));
                    } else {
                        this._push(res, val);
                    }
                }, this
            );

            array = res;
        } else {
            Jeeel.Hash.forEach(array,
                function (val, key) {
                    if (Jeeel.Type.isHash(val)) {
                        array[key] = this._arrayWhile(count + 1, val);
                    }
                }, this
            );
        }

        return array;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.Flat, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 指定した内部キーの値をリストの固有キーにする
 * @augments Jeeel.Filter.Abstract
 * @param {String} key キー
 */
Jeeel.Filter.Hash.KeySpecify = function (key) {
  
    Jeeel.Filter.Abstract.call(this);

    this._key = key;
};

/**
 * インスタンスの作成
 *
 * @param {String} key キー
 * @return {Jeeel.Filter.Hash.KeySpecify} 作成したインスタンス
 */
Jeeel.Filter.Hash.KeySpecify.create = function (key) {
    return new this(key);
};

Jeeel.Filter.Hash.KeySpecify.prototype = {
    
    /**
     * キー
     * 
     * @type String
     * @private
     */
    _key: null,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (array) {

        var res = {};

        Jeeel.Hash.forEach(array,
            function (row) {
                res[row[this._key]] = row;
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.KeySpecify, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 指定したインデックスから指定要素数を指定値で埋めるフィルター(戻り値は配列なら配列、連想配列なら連想配列になる)
 * @augments Jeeel.Filter.Abstract
 * @param {Integer} index 開始インデックス
 * @param {Integer} length 挿入要素数
 * @param {Mixied} [value] 挿入値(デフォルトはnull)
 * @throws {Error} indexが整数でない場合に起こる
 * @throws {Error} lengthが整数でない場合に起こる
 */
Jeeel.Filter.Hash.Fill = function (index, length, value) {
    Jeeel.Filter.Abstract.call(this);
    
    if ( ! Jeeel.Type.isInteger(index)) {
        throw new Error('indexが整数ではありません。');
    } else if ( ! Jeeel.Type.isInteger(length)) {
        throw new Error('lengthが整数ではありません。');
    }

    this._index = index;
    this._length = length + index;
    this._value = value || null;
};

/**
 * インスタンスの作成
 *
 * @param {Integer} index 開始インデックス
 * @param {Integer} length 挿入要素数
 * @param {Mixied} [value] 挿入値(デフォルトはnull)
 * @return {Jeeel.Filter.Hash.Fill} 作成したインスタンス
 */
Jeeel.Filter.Hash.Fill.create = function (index, length, value) {
    return new this(index, length, value);
};

Jeeel.Filter.Hash.Fill.prototype = {
    
    /**
     * 開始インデックス
     * 
     * @type Integer
     * @private
     */
    _index: 0,
    
    /**
     * 挿入要素数
     * 
     * @type Integer
     * @private
     */
    _length: 0,
    
    /**
     * 挿入値
     * 
     * @type Mixied
     * @private
     */
    _value: null,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (array) {
        var result = Jeeel.Method.clone(array);

        for (var i = this._index; i < this._length; i++) {
            result[i] = this._value;
        }

        return result;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.Fill, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 配列の重複する内部値を削除する
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [strict] 厳密な型チェックを行うかどうか
 * @param {Boolean} [toValues] キーを無視して値だけのリストにするかどうか(trueの場合は必ず配列が帰ってくるようになる)
 */
Jeeel.Filter.Hash.Unique = function (strict, toValues) {

    Jeeel.Filter.Abstract.call(this);
    
    this._strict = !!strict;
    this._toValues = !!toValues;
};

/**
 * インスタンスの作成
 *
 * @param {Boolean} [strict] 厳密な型チェックを行うかどうか
 * @param {Boolean} [toValues] キーを無視して値だけのリストにするかどうか(trueの場合は必ず配列が帰ってくるようになる)
 * @return {Jeeel.Filter.Hash.Unique} 作成したインスタンス
 */
Jeeel.Filter.Hash.Unique.create = function (strict, toValues) {
    return new this(strict, toValues);
};

Jeeel.Filter.Hash.Unique.prototype = {
    
    /**
     * 厳密な型チェックを行うかどうか
     * 
     * @type Boolean
     * @private
     */
    _strict: false,
    
    /**
     * キーを無視して値だけのリストにするかどうか
     * 
     * @type Boolean
     * @private
     */
    _toValues: false,
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (array) {
      
        array = Jeeel.Hash.create(array);

        var res = Jeeel.Hash.create();

        array.forEach(
            function (val, key) {
                if (res.search(val, this._strict) === null) {
                    res.set(key, val);
                }
            }, this
        );

        return (this._toValues ? res.getValues() : res.getHash());
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.Unique, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class 配列の差分を取得するフィルター
 * @param {Hash} baseHash 比較元のHash
 * @param {Boolean} [toValues] キーを無視して値だけのリストにするかどうか(trueの場合は配列が帰ってくるようになる)
 */
Jeeel.Filter.Hash.Difference = function (baseHash, toValues) {
    Jeeel.Filter.Abstract.call(this);
    
    this._baseHash = new Jeeel.Hash(baseHash);
    this._toValues = !!toValues;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Hash} baseHash 比較元のHash
 * @param {Boolean} [toValues] キーを無視して値だけのリストにするかどうか(trueの場合は配列が帰ってくるようになる)
 * @return {Jeeel.Filter.Hash.Difference} 作成したインスタンス
 */
Jeeel.Filter.Hash.Difference.create = function (baseHash, toValues) {
    return new this(baseHash, toValues);
};

Jeeel.Filter.Hash.Difference.prototype = {
  
    /**
     * @type Jeeel.Hash
     * @private
     */
    _baseHash: null,
    
    _toValues: false,
    
    /**
     * 対象のHashと比較を行い結果を返す
     * 
     * @param {Hash} targetHash 比較先のHash
     * @return {Object} 差分結果(baseに比較元にしか存在しない値、targetに比較先にしか存在しない値)
     */
    filter: function (targetHash) {
        return this._super.filter.call(this, targetHash);
    },
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('このフィルターは配列式が使えないオブジェクトには対応していません。');
    },

    /**
     * @private
     */
    _filterEach: function (array) {
      
        array = new Jeeel.Hash(array);

        var res = this._toValues ? {base: [], target: []} : {base: {}, target: {}};
        
        this._baseHash.forEach(
            this._toValues ? function (val) {
                if (array.search(val, true) === null) {
                    res.base.push(val);
                }
            } : function (val, key) {
                if (array.search(val, true) === null) {
                    res.base[key] = val;
                }
            }
        );

        array.forEach(
            this._toValues ? function (val) {
                if (this._baseHash.search(val, true) === null) {
                    res.target.push(val);
                }
            } : function (val, key) {
                if (this._baseHash.search(val, true) === null) {
                    res.target[key] = val;
                }
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.Difference, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class フィルタ対象の配列の指定キーの値を他のキーにコピーする
 * @augments Jeeel.Filter.Abstract
 * @param {Hash} [copyMap] コピーマップ
 */
Jeeel.Filter.Hash.CopyKey = function (copyMap) {
    Jeeel.Filter.Abstract.call(this);
  
    this._copyMap = copyMap || {};
};

/**
 * インスタンスを作成して返す
 *
 * @param {Hash} [copyMap] コピーマップ
 * @return {Jeeel.Filter.Hash.CopyKey} 作成したインスタンス
 */
Jeeel.Filter.Hash.CopyKey.create = function (copyMap) {
    return new this(copyMap);
};

Jeeel.Filter.Hash.CopyKey.prototype = {
  
    /**
     * コピーマップ
     * 
     * @type Hash
     * @private
     */
    _copyMap: {},
    
    /**
     * コピーマップを取得する
     * 
     * @return {Hash} コピーマップ
     */
    getCopyMap: function () {
        return this._copyMap;
    },

    /**
     * コピーマップを設定する
     * 
     * @param {Hash} copyMap コピーマップ
     * @return {Jeeel.Filter.Hash.CopyKey} 自インスタンス
     */
    setCopyMap: function (copyMap) {
        this._copyMap = copyMap;

        return this;
    },

    /**
     * @private
     */
    _filter: function () {
        throw new Error('valは配列・連想配列でなければなりません。');
    },

    /**
     * @private
     */
    _filterEach: function (vals) {
        
        var res = {};
        var map = this.getCopyMap();

        Jeeel.Hash.forEach(vals,
            function (val, key) {

                if ( ! (key in res)) {
                    res[key] = val;
                }

                if (key in map) {
                    if ( ! Jeeel.Type.isHash(map[key])) {
                        map[key] = [map[key]];
                    }

                    Jeeel.Hash.forEach(map[key],
                        function (copyKey) {
                            res[copyKey] = val;
                        }
                    );
                }
            }
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.CopyKey, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 * 
 * @class フィルタ対象の配列内の指定したキーを削除する
 * @augments Jeeel.Filter.Abstract
 * @param {String[]} [deleteKeys] 削除キーのリスト
 */
Jeeel.Filter.Hash.DeleteKey = function (deleteKeys) {
    Jeeel.Filter.Abstract.call(this);
  
    this._deleteKeys = deleteKeys || [];
};

/**
 * インスタンスを作成して返す
 *
 * @param {String[]} [deleteKeys] 削除キーのリスト
 * @return {Jeeel.Filter.Hash.DeleteKey} 作成したインスタンス
 */
Jeeel.Filter.Hash.DeleteKey.create = function (deleteKeys) {
    return new this(deleteKeys);
};

Jeeel.Filter.Hash.DeleteKey.prototype = {
  
    /**
     * 削除キーリスト
     * 
     * @type String[]
     * @private
     */
    _deleteKeys: [],
    
    /**
     * @private
     */
    _filter: function () {
        throw new Error('valは配列・連想配列でなければなりません。');
    },

    /**
     * @private
     */
    _filterEach: function (vals) {
        var res = {};

        Jeeel.Hash.forEach(vals,
            function (val, key) {

                if ( ! Jeeel.Hash.inHash(key, this._deleteKeys)) {
                    res[key] = val;
                }
            }, this
        );

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Hash.DeleteKey, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Filter.String = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Filter + 'String/';
    }
};

/**
 * @namespace 文字列関連のフィルター管理ネームスペース
 */
Jeeel.Filter.String = {

};

Jeeel.file.Jeeel.Filter.String = ['Split', 'Replace'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter.String, Jeeel.file.Jeeel.Filter.String);

/**
 * コンストラクタ
 *
 * @class 対象の要素に対して文字列として扱い文字列置換を行うフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} separator 区切り文字
 * @param {Integer} [limit] 配列の要素数の制限をする場合に指定
 * @throws {Error} separatorが文字列ではない場合に投げられる
 */
Jeeel.Filter.String.Split = function (separator, limit) {
    Jeeel.Filter.Abstract.call(this);

    if ( ! Jeeel.Type.isString(separator)) {
        throw new Error('separatorが文字列ではありません。');
    }

    this._separator = separator;
    this._limit = limit;
};

/**
 * インスタンスの作成
 *
 * @param {String} separator 区切り文字
 * @param {Integer} [limit] 配列の要素数の制限をする場合に指定
 * @return {Jeeel.Filter.String.Split} 作成したインスタンス
 */
Jeeel.Filter.String.Split.create = function (separator, limit) {
    return new this(separator, limit);
};

Jeeel.Filter.String.Split.prototype = {
  
    /**
     * 区切り文字
     * 
     * @type String
     * @private
     */
    _separator: '',
    
    /**
     * 配列の要素数の制限
     * 
     * @type Integer
     * @private
     */
    _limit: -1,
    
    /**
     * @private
     */
    _filter: function (val) {
        val = '' + val;

        return val.split(this._separator, this._limit);
    }
};

Jeeel.Class.extend(Jeeel.Filter.String.Split, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 対象の要素に対して文字列として扱い文字列置換を行うフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String|RegExp} reg 検索パターン及び検索文字列
 * @param {String} replace 置換後の文字列
 * @throws {Error} regが文字列・正規表現どちらでもない場合に投げられる
 * @throws {Error} replaceが文字列ではない場合に投げられる
 */
Jeeel.Filter.String.Replace = function (reg, replace) {
    Jeeel.Filter.Abstract.call(this);

    if ( ! Jeeel.Type.isString(reg) && ! (reg instanceof RegExp)) {
        throw new Error('regが文字列でも正規表現でもありません。');
    }

    if ( ! Jeeel.Type.isString(replace)) {
        throw new Error('replaceが文字列ではありません。');
    }

    this._reg = reg;
    this._replace = replace;
};

/**
 * インスタンスの作成
 *
 * @param {String|RegExp} reg 検索パターン及び検索文字列
 * @param {String} replace 置換後の文字列
 * @return {Jeeel.Filter.String.Replace} 作成したインスタンス
 */
Jeeel.Filter.String.Replace.create = function (reg, replace) {
    return new this(reg, replace);
};

Jeeel.Filter.String.Replace.prototype = {
    
    /**
     * 検索パターン及び検索文字列
     * 
     * @type String|RegExp
     * @private
     */
    _reg: '',
    
    /**
     * 置換文字列
     * 
     * @type String
     * @private
     */
    _replace: '',
    
    /**
     * @private
     */
    _filter: function (val) {
        val = '' + val;

        return val.replace(this._reg, this._replace);
    }
};

Jeeel.Class.extend(Jeeel.Filter.String.Replace, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Filter.Url = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Filter + 'Url/';
    }
};

/**
 * @namespace Url関連のフィルター管理ネームスペース
 */
Jeeel.Filter.Url = {

};

Jeeel.file.Jeeel.Filter.Url = ['Escape', 'QueryString', 'QueryParameter', 'Parser'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter.Url, Jeeel.file.Jeeel.Filter.Url);
/**
 * コンストラクタ
 *
 * @class 値をGetやPostで送信できる形に変換する(非可逆変換)
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [useEncodeURIComponent] encodeURIComponentを使用するかどうか(デフォルトは使用しない)
 */
Jeeel.Filter.Url.Escape = function (useEncodeURIComponent) {

    Jeeel.Filter.Abstract.call(this);
    
    this._useEncodeURIComponent = !!useEncodeURIComponent;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [useEncodeURIComponent] encodeURIComponentを使用するかどうか(デフォルトは使用しない)
 * @return {Jeeel.Filter.Url.Escape} 作成したインスタンス
 */
Jeeel.Filter.Url.Escape.create = function (useEncodeURIComponent) {
    return new this(useEncodeURIComponent);
};

Jeeel.Filter.Url.Escape.prototype = {
  
    /**
     * encodeURIComponentを使用するかどうか
     * 
     * @type Boolean
     * @private
     */
    _useEncodeURIComponent: false,
  
    /**
     * @private
     */
    _filter: function (val) {
        var res;

        if (Jeeel.Type.isEmpty(val)) {
            res = '';
        } else if (Jeeel.Type.isBoolean(val)) {
            res = (val ? '1' : '');
        } else if (Jeeel.Type.isNumber(val)) {
            res = val.toString();
        } else {
            res = '' + val;
        }

        if (this._useEncodeURIComponent) {
            res = encodeURIComponent(res);
        }

        return res;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Url.Escape, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 連想配列をGetパラメータ用の形式にするフィルター(先頭の?はつかない)
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Url.QueryString = function () {
    Jeeel.Filter.Abstract.call(this);
};

/**
 * インスタンスの作成を行う
 *
 * @return {Jeeel.Filter.Url.QueryString} 作成したインスタンス
 */
Jeeel.Filter.Url.QueryString.create = function () {
    return new this();
};

Jeeel.Filter.Url.QueryString.prototype = {
    _sFilter: Jeeel.Filter.Url.Escape.create(true),
    
    _filter: function () {
        throw new Error('valは配列式でなければなりません。');
    },

    _filterEach: function (params) {
        var tmp, res = [];

        for (var key in params) {
            tmp = this._getParams(key, params[key], res.length === 0);
            
            if (tmp) {
                res[res.length] = tmp;
            }
        }

        return res.join('');
    },
    
    _getParams: function (parent, vals, first) {
        if ( ! Jeeel.Type.isHash(vals)) {
            return (first ? '' : '&') + parent + '=' + this._sFilter.filter(vals);
        }

        var tmp, res = [];

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                var nextParent;

                if (parent) {
                    nextParent = parent + '[' + key + ']';
                } else {
                    nextParent = key;
                }
                
                tmp = this._getParams(nextParent, val, first);

                if (tmp) {
                    res[res.length] = tmp;

                    first = false;
                }
            }, this
        );

        return res.join('');
    }
};

Jeeel.Class.extend(Jeeel.Filter.Url.QueryString, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class Getパラメータの形式の文字列を連想配列に変換するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} [overwriteName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
 */
Jeeel.Filter.Url.QueryParameter = function (overwriteName) {
    Jeeel.Filter.Abstract.call(this);
    
    this._overwriteName = overwriteName || null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} [overwriteName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
 * @return {Jeeel.Filter.Url.QueryParameter} 作成したインスタンス
 */
Jeeel.Filter.Url.QueryParameter.create = function (overwriteName) {
    return new this(overwriteName);
};

Jeeel.Filter.Url.QueryParameter.prototype = {
    
    _overwriteName: null,
    
    _avoidValues: [],
    
    /**
     * @private
     */
    _filter: function (params) {

        if ( ! Jeeel.Type.isString(params) || params.length === 0) {
            return {};
        }

        if (params.charAt(0) === '?') {
            params = params.substring(1, params.length);
        }

        params = params.split('&');
        
        this._avoidValues = [];
        
        var i, l, pair, res = {};
        
        for (i = 0, l = params.length; i < l; i++) {
            pair = params[i].split('=');

            if (pair.length === 2) {
                this._setParams(res, pair[0], pair[1]);
            }
        }
        
        if (this._overwriteName) {
            res[this._overwriteName] = this._avoidValues;
        }

        return res;
    },
    
    _getName: Jeeel._Object.JeeelFilter.getInputName,
    
    _repairName: Jeeel._Object.JeeelFilter.repairInputName,
    
    _repairValue: function (name, hash) {
        if ( ! Jeeel.Type.isHash(hash)) {
            return new Jeeel.Object.Item(name, hash);
        }

        var tmp, res = [];

        for (var key in hash) {
            var nextParent, 
                val = hash[key];

            if (name) {
                nextParent = name + '[' + key + ']';
            } else {
                nextParent = key;
            }

            tmp = this._repairValue(nextParent, val);

            if (tmp) {
                res = res.concat(tmp);
            }
        }

        return res;
    },
    
    _setParams: function (res, name, value) {
        var key, names = this._getName(name);

        for (var i = 0, l = names.length; i < l; i++) {

            if (key) {
                res = res[key];
            }

            key = names[i] || this._getMaxCount(res);

            if (i < l -1) {
                if (typeof res[key] === 'string') {
                    this._avoidValues[this._avoidValues.length] = new Jeeel.Object.Item(this._repairName(names.slice(0, i + 1)), res[key]);
                      
                    res[key] = {};
                } else if ( ! (key in res)) {
                    res[key] = {};
                }
            }
        }
        
        if (key in res) {
            this._avoidValues = this._avoidValues.concat(this._repairValue(name, res[key]));
        }

        res[key] = decodeURIComponent(value);
    },
    
    _getMaxCount: function (res) {
        var cnt = null;

        for (var key in res) {

            var digit = +key;

            if (Jeeel.Type.isInteger(digit) && (cnt === null || digit > cnt)) {
                cnt = digit;
            }
        }

        return (cnt === null ? 0 : cnt + 1);
    }
};

Jeeel.Class.extend(Jeeel.Filter.Url.QueryParameter, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class URL解析クラス
 * @augments Jeeel.Filter.Abstract
 */
Jeeel.Filter.Url.Parser = function () {
    Jeeel.Filter.Abstract.call(this);
};

/**
 * インスタンスの作成を行う
 *
 * @return {Jeeel.Filter.Url.Parser} 作成したインスタンス
 */
Jeeel.Filter.Url.Parser.create = function () {
    return new this();
};

Jeeel.Filter.Url.Parser.prototype = {
    
    /**
     * URLをパースするための正規表現
     * 
     * @type RegExp
     * @private
     */
    _parseReg: /^(https?|ftp):\/\/(?:([^@:]+)(?::([^@]+))?@)?([^:\/]+)(?::([0-9]+))?(\/[^?]*)?(?:\?([^#]*))?(?:#(.*))?$/,
    
    /**
     * URLを解析して返す
     * 
     * @param {String} url URL
     * @return {Hash} 連想配列(URL以外を指定された場合はnullを返す)
     */
    parse: function (url) {
        return this.filter(url);
    },
  
    /**
     * @private
     */
    _filter: function (val) {
        var match = ('' + val).match(this._parseReg);
        
        if ( ! match) {
            return null;
        }
        
        return {
            scheme: match[1],
            user: match[2] || '',
            pass: match[3] || '',
            host: match[4],
            port: +match[5] || null,
            path: match[6] || '',
            query: match[7] || '',
            fragment: match[8] || ''
        };
    }
};

Jeeel.Class.extend(Jeeel.Filter.Url.Parser, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Filter.Html = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Filter + 'Html/';
    }
};

/**
 * @namespace Html関連のフィルター管理ネームスペース
 */
Jeeel.Filter.Html = {

};

Jeeel.file.Jeeel.Filter.Html = ['Form', 'FormValue', 'Hidden', 'HiddenString'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Filter.Html, Jeeel.file.Jeeel.Filter.Html);

/**
 * コンストラクタ
 *
 * @class Html要素毎に内部のinputをまとめあげる(送信時のパラメータのようにnameで区分け)<br />
 *         その際radioボタンは強制的にリストになる
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [useDefaultValue] trueにすると現在値でなくデフォルト値を参照して纏め上げる
 * @param {String} [unknownName] 名前のついていないinputに使用する名前(デフォルトは無視する)
 * @param {String} [overwrittenName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はElement[]になる)
 */
Jeeel.Filter.Html.Form = function (useDefaultValue, unknownName, overwrittenName) {

    Jeeel.Filter.Abstract.call(this);
    
    this._useDefaultValue = !!useDefaultValue;
    
    if (unknownName) {
        this._unknownName = unknownName + '[]';
    }
    
    this._overwrittenName = overwrittenName || null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [useDefaultValue] trueにすると現在値でなくデフォルト値を参照して纏め上げる
 * @param {String} [unknownName] 名前のついていないinputに使用する名前(デフォルトは無視する)
 * @param {String} [overwrittenName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はElement[]になる)
 * @return {Jeeel.Filter.Html.Form} 作成したインスタンス
 */
Jeeel.Filter.Html.Form.create = function (useDefaultValue, unknownName, overwrittenName) {
    return new this(useDefaultValue, unknownName, overwrittenName);
};

Jeeel.Filter.Html.Form.prototype = {
    
    _radioToArray: false,
    
    _useDefaultValue: false,
    
    _unknownName: '',
    
    _overwrittenName: null,
    
    _avoidValues: [],
    
    /**
     * 正確なリストを有効にするかどうかを設定する
     * 
     * @param {Boolean} [enable] 有効かどうか
     * @return {Jeeel.Filter.Html.Form} 自インスタンス
     */
    enableAccurateList: function (enable) {
        this._radioToArray = !!enable;
        
        return this;
    },
    
    /**
     * @private
     */
    _filter: function (val) {
        if ( ! Jeeel.Type.isElement(val)) {
            throw new Error('Elementではない要素を含んでいます。');
        }

        var inputs = this._getInputs(val);

        var res = {}, name;
        
        this._avoidValues = [];
        
        for (var i = 0, l = inputs.length; i < l; i++) {

            name = this._getProp(inputs[i], 'name') || this._unknownName;

            if ( ! name) {
                continue;
            }

            this._setParams(res, name, inputs[i]);
        }
        
        if (this._overwrittenName) {
            res[this._overwrittenName] = this._avoidValues;
        }

        return res;
    },

    /**
     * @private
     */
    _filterEach: function (vals) {

        if (Jeeel.Type.isElement(vals)) {
            return this._filter(vals);
        }

        var res = {};

        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                res[key] = self._filter(val);
            }
        );

        return res;
    },
    
    _getInputs: Jeeel._Object.JeeelFilter.getInputs,

    _getName: Jeeel._Object.JeeelFilter.getInputName,
    
    _repairName: Jeeel._Object.JeeelFilter.repairInputName,
    
    _repairValue: function (hash) {
        if (Jeeel.Type.isElement(hash)) {
            return hash;
        }

        var tmp, res = [];

        for (var key in hash) {
            var val = hash[key];

            tmp = this._repairValue(val);

            if (tmp) {
                res = res.concat(tmp);
            }
        }

        return res;
    },
    
    _getProp: function (elm, propName) {
        if (this._useDefaultValue) {
            return elm.getAttribute(propName);
        }
        
        return elm[propName];
    },
    
    _setParams: function (res, name, element) {
        
        var tagName = element.tagName.toUpperCase();
        
        if ( ! this._radioToArray && tagName === 'INPUT') {
            if (element.type.toLowerCase() === 'radio' && ! this._getProp(element, 'checked')) {
                return;
            }
        }

        var key, names = this._getName(name);

        for (var i = 0, l = names.length; i < l; i++) {
          
            if (key) {
                res = res[key];
            }

            key = names[i] || this._getMaxCount(res);

            if (i < l - 1) {
                if (Jeeel.Type.isElement(res[key])) {
                    this._avoidValues[this._avoidValues.length] = new Jeeel.Object.Item(this._repairName(names.slice(0, i + 1)), res[key]);
                    
                    res[key] = {};
                } else if ( ! (key in res)) {
                    res[key] = {};
                }
            }
        }
        
        if (key in res && ! Jeeel.Type.isArray(res[key])) {
            this._avoidValues = this._avoidValues.concat(this._repairValue(res[key]));
        }
        
        if (this._radioToArray && tagName === 'INPUT' && element.type.toLowerCase() === 'radio') {
            if ( ! res[key]) {
                res[key] = [];
                res[key]._checkRadio = null;
                res[key].valueOf = this._getRadio;
            }
            
            if (this._getProp(element, 'checked')) {
                res[key]._checkRadio = element;
            }
            
            res[key].push(element);
        } else {
            res[key] = element;
        }
    },
    
    _getMaxCount: function (res) {
        var cnt = null;

        for (var key in res) {

            var digit = +key;

            if (Jeeel.Type.isInteger(digit) && (cnt === null || digit > cnt)) {
                cnt = digit;
            }
        }

        return (cnt === null ? 0 : cnt + 1);
    },
    
    _getRadio: function () {
        return this._checkRadio;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.Form, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class Html要素毎に内部のinputの値をまとめあげる(送信時のパラメータのようにnameで区分け)<br />
 *         その際無効なinputは無視する(checkedが付いていないradioボタンやcheckbox、選択されていないselectbox)
 * @augments Jeeel.Filter.Abstract
 * @param {Boolean} [useDefaultValue] trueにすると現在値でなくデフォルト値を参照して纏め上げる(値もデフォルト値になる)
 * @param {String} [unknownName] 名前のついていないinputに使用する名前(デフォルトは無視する)
 * @param {String} [overwrittenName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
 */
Jeeel.Filter.Html.FormValue = function (useDefaultValue, unknownName, overwrittenName) {

    Jeeel.Filter.Abstract.call(this);
    
    this._useDefaultValue = !!useDefaultValue;
    
    if (unknownName) {
        this._unknownName = unknownName + '[]';
    }
    
    this._overwrittenName = overwrittenName || null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [useDefaultValue] trueにすると現在値でなくデフォルト値を参照して纏め上げる
 * @param {String} [unknownName] 名前のついていないinputに使用する名前(デフォルトは無視する)
 * @param {String} [overwrittenName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
 * @return {Jeeel.Filter.Html.FormValue} 作成したインスタンス
 */
Jeeel.Filter.Html.FormValue.create = function (useDefaultValue, unknownName, overwrittenName) {
    return new this(useDefaultValue, unknownName, overwrittenName);
};

Jeeel.Filter.Html.FormValue.prototype = {
    
    _useDefaultValue: false,
    
    _unknownName: '',
    
    _overwrittenName: null,
    
    _avoidValues: [],
    
    /**
     * @private
     */
    _filter: function (val) {
        if ( ! Jeeel.Type.isElement(val)) {
            throw new Error('Elementではない要素を含んでいます。');
        }

        var inputs = this._getInputs(val);
        
        var res = {}, name;
        
        this._avoidValues = [];
        
        for (var i = 0, l = inputs.length; i < l; i++) {
            name = this._getProp(inputs[i], 'name') || this._unknownName;

            if ( ! name) {
                continue;
            }

            this._setParams(res, name, inputs[i]);
        }
        
        if (this._overwrittenName) {
            res[this._overwrittenName] = this._avoidValues;
        }

        return res;
    },

    /**
     * @private
     */
    _filterEach: function (vals) {

        if (Jeeel.Type.isElement(vals)) {
            return this._filter(vals);
        }

        var res = {};

        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                res[key] = self._filter(val);
            }
        );

        return res;
    },
    
    _getInputs: Jeeel._Object.JeeelFilter.getInputs,
    
    _getName: Jeeel._Object.JeeelFilter.getInputName,
    
    _repairName: Jeeel._Object.JeeelFilter.repairInputName,
    
    _repairValue: function (name, hash) {
        if ( ! Jeeel.Type.isHash(hash)) {
            return new Jeeel.Object.Item(name, hash);
        }

        var tmp, res = [];

        for (var key in hash) {
            var nextParent, 
                val = hash[key];

            if (name) {
                nextParent = name + '[' + key + ']';
            } else {
                nextParent = key;
            }

            tmp = this._repairValue(nextParent, val);

            if (tmp) {
                res = res.concat(tmp);
            }
        }

        return res;
    },
    
    _getProp: function (elm, propName) {
        var tag, res, ops, i, l;
        
        if (this._useDefaultValue) {
            if (propName === 'value') {
                tag = elm.tagName.toUpperCase();
                
                if (tag === 'SELECT') {
                    ops = elm.options;

                    if (elm.getAttribute('multiple')) {
                        res = [];

                        for (i = 0, l = ops.length; i < l; i++) {
                            if (ops[i].getAttribute('selected') !== null) {
                                res[res.length] = ops[i].getAttribute(propName);
                            }
                        }
                        
                        return res;
                    }
                    
                    for (i = ops.length; i--;) {
                        if (ops[i].getAttribute('selected') !== null) {
                            return ops[i].getAttribute(propName);
                        }
                    }

                    return l && ops[0].getAttribute(propName) || null;
                } else if (tag === 'INPUT') {
                    return elm.defaultValue;
                }
            }
            
            return elm.getAttribute(propName);
        }
        
        if (propName === 'value') {
            if (Jeeel.Dom.Behavior.Placeholder.isHolded(elm)) {
                return '';
            }
            
            tag = elm.tagName.toUpperCase();
            
            if (tag === 'SELECT' && elm.multiple) {
                ops = elm.options;
                
                res = [];
                
                for (i = 0, l = ops.length; i < l; i++) {
                    if (ops[i].selected) {
                        res[res.length] = ops[i].value;
                    }
                }
                
                return res;
            }
        }
        
        return elm[propName];
    },
    
    _setParams: function (res, name, element) {

        if (element.tagName.toUpperCase() === 'INPUT') {
            if (element.type.toLowerCase() === 'checkbox' && ! this._getProp(element, 'checked')) {
                return;
            } else if (element.type.toLowerCase() === 'radio' && ! this._getProp(element, 'checked')) {
                return;
            }
        } else if (element.tagName.toLowerCase() === 'select') {
            
            var multiple = (this._useDefaultValue && element.getAttribute('multiple'))
                        || ( ! this._useDefaultValue && element.multiple);
            
            if (element.selectedIndex < 0 && ! multiple) {
                return;
            }
        }

        var key, names = this._getName(name);

        for (var i = 0, l = names.length; i < l; i++) {
          
            if (key) {
                res = res[key];
            }

            key = names[i] || this._getMaxCount(res);

            if (i < l -1) {
                if (typeof res[key] === 'string') {
                    this._avoidValues[this._avoidValues.length] = new Jeeel.Object.Item(this._repairName(names.slice(0, i + 1)), res[key]);
                    
                    res[key] = {};
                } else if ( ! (key in res)) {
                    res[key] = {};
                }
            }
        }
        
        if (key in res) {
            this._avoidValues = this._avoidValues.concat(this._repairValue(name, res[key]));
        }
        
        res[key] = this._getProp(element, 'value');
    },
    
    _getMaxCount: function (res) {
        var cnt = null;

        for (var key in res) {

            var digit = +key;

            if (Jeeel.Type.isInteger(digit) && (cnt === null || digit > cnt)) {
                cnt = digit;
            }
        }

        return (cnt === null ? 0 : cnt + 1);
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.FormValue, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 配列値をhiddenタグに加工するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} [key] 特定のキーとしてまとめ上げたい場合に指定する
 */
Jeeel.Filter.Html.Hidden = function (key) {

    Jeeel.Filter.Abstract.call(this);
    
    if (key || key === 0) {
        this._key = key;
    }
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} [key] 特定のキーとしてまとめ上げたい場合に指定する
 * @return {Jeeel.Filter.Html.Hidden} 作成したインスタンス
 */
Jeeel.Filter.Html.Hidden.create = function (key) {
    return new this(key);
};

Jeeel.Filter.Html.Hidden.prototype = {
    _key: null,
    
    _sFilter: new Jeeel.Filter.Url.Escape(),
    
    _filter: function (vals) {

        if (this._key || this._key === 0) {
            return this._makeHiddenString(this._key, vals);
        }

        throw new Error('keyを作成時に指定せずに配列式が使えない値に対しては対応していません。');
    },

    _filterEach: function (vals) {

        if (this._key || this._key === 0) {
            return this._scanArray(this._key, vals);
        }
        
        var res = [];

        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                val = this._scanArray(key, val);

                Jeeel.Hash.forEach(val,
                    function (v) {
                        res[res.length] = v;
                    }, self
                );
            }, self
        );

        return res;
    },

    _scanArray: function (origKey, a) {
        if ( ! Jeeel.Type.isHash(a)) {
            return [this._makeHiddenString(origKey, a)];
        }

        var self = this;

        var result = [];

        Jeeel.Hash.forEach(a,
            function (v0, k0) {

                var key = origKey + '[' + k0 + ']';

                if ( ! Jeeel.Type.isHash(v0)) {
                    result[result.length] = this._makeHiddenString(key, v0);
                    return;
                }

                var val = this._scanArray(key, v0);

                Jeeel.Hash.forEach(val,
                    function (v1) {
                        result[result.length] = v1;
                    }, self
                );
            }, self
        );

        return result;
    },

    _makeHiddenString: function (key, val) {
        var hidden = Jeeel.Document.createElement('input');

        hidden.type  = 'hidden';
        hidden.name  = key;
        hidden.value = this._sFilter.filter(val);

        return hidden;
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.Hidden, Jeeel.Filter.Abstract);

/**
 * コンストラクタ
 *
 * @class 配列値をhiddenタグのHTML文字列に加工するフィルター
 * @augments Jeeel.Filter.Abstract
 * @param {String} [key] 特定のキーとしてまとめ上げたい場合に指定する
 */
Jeeel.Filter.Html.HiddenString = function (key) {
    Jeeel.Filter.Abstract.call(this);
    
    if (key || key === 0) {
        this._key = key;
    }
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} [key] 特定のキーとしてまとめ上げたい場合に指定する
 * @return {Jeeel.Filter.Html.HiddenString} 作成したインスタンス
 */
Jeeel.Filter.Html.HiddenString.create = function (key) {
    return new this(key);
};

Jeeel.Filter.Html.HiddenString.prototype = {
    _key: null,
    
    _mFilter: new Jeeel.Filter.Url.Escape(),
  
    _filter: function (vals) {

        if (this._key || this._key === 0) {
            return this._makeHiddenString(this._key, vals);
        }
        
        throw new Error('keyを作成時に指定せずに配列式が使えない値に対しては対応していません。');
    },

    _filterEach: function (vals) {

        if (this._key || this._key === 0) {
            return this._scanArray(this._key, vals);
        }

        var res = [];
        var self = this;

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                val = this._scanArray(key, val);

                Jeeel.Hash.forEach(val,
                    function (v) {
                        res[res.length] = v;
                    }, self
                );
            }, self
        );

        return res;
    },

    _scanArray: function (origKey, a) {
        if ( ! Jeeel.Type.isHash(a)) {
            return [this._makeHiddenString(origKey, a)];
        }

        var self = this;

        var res = [];

        Jeeel.Hash.forEach(a,
            function (v0, k0) {

                var key = origKey + '[' + k0 + ']';

                if ( ! Jeeel.Type.isHash(v0)) {
                    res[res.length] = this._makeHiddenString(key, v0);
                    return;
                }

                var val = this._scanArray(key, v0);

                Jeeel.Hash.forEach(val,
                    function (v1) {
                        res[res.length] = v1;
                    }, self
                );
            }, self
        );

        return res;
    },

    _makeHiddenString: function (key, val) {
        val = this._mFilter.filter(val);
        val = Jeeel.String.escapeHtml(val);
        return '<input type="hidden" name="' + key + '" value="' + val + '" />';
    }
};

Jeeel.Class.extend(Jeeel.Filter.Html.HiddenString, Jeeel.Filter.Abstract);
Jeeel.directory.Jeeel.Parameter = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Parameter/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 配列・連想配列に対して操作を行うクラス
 * @implements Jeeel.Parameter.Filter.Interface, Jeeel.Parameter.Validator.Interface
 * @param {Hash} [params] 入力パラメータ
 * @throws {Error} paramsを指定してかつが配列式でない場合に起こる
 */
Jeeel.Parameter = function (params) {

    if ( ! params) {
        params = {};
    } else if ( ! Jeeel.Type.isHash(params)) {
        throw new Error('paramsには配列式が使えなければなりません。');
    }

    this._params = params;
    this._errors = {};
    this._fieldList = new this.constructor.FieldList();
    this._validators = this.constructor._validators.concat();
    this._filters = this.constructor._filters.concat();
    
    if ( ! Jeeel.Parameter._lock && ! Jeeel.Language.hasLanguage('Parameter.Validator')) {
        Jeeel.Parameter._lock = true;
        
        Jeeel.Language.loadLanguage('Parameter.Validator', function () {
            Jeeel.Parameter._lock = false;
        });
    }
};

/**
 * インスタンスの作成
 *
 * @param {Hash} [params] 入力パラメータ
 * @return {Jeeel.Parameter} 作成したインスタンス
 * @throws {Error} paramsを指定してかつが配列式でない場合に起こる
 */
Jeeel.Parameter.create = function (params) {
    return new this(params);
};

Jeeel.Parameter._validators = [];
Jeeel.Parameter._filters = [];
Jeeel.Parameter._activeParameter = null;
Jeeel.Parameter._activeField = null;

/**
 * 初期で使用するバリデータを追加する
 * 
 * @param {Jeeel.Parameter.Validator.Interface} validator
 */
Jeeel.Parameter.addDefaultValidator = function (validator) {
    this._validators.push(validator);
};

/**
 * 初期で使用するフィルタを追加する
 * 
 * @param {Jeeel.Parameter.Filter.Interface} filter
 */
Jeeel.Parameter.addDefaultFilter = function (filter) {
    this._filters.push(filter);
};

/**
 * 現在処理中のパラメータを取得する
 * 
 * @return {Jeeel.Parameter} パラメータ
 */
Jeeel.Parameter.getActiveParameter = function () {
    return this._activeParameter;
};

/**
 * 現在処理中のフィールドを取得する
 * 
 * @return {Jeeel.Parameter.Field} フィールド
 */
Jeeel.Parameter.getActiveField = function () {
    return this._activeField;
};

/**
 * 現在処理中のパラメータを設定する
 * 
 * @param {Jeeel.Parameter} parameter パラメータ
 */
Jeeel.Parameter._setActiveParameter = function (parameter) {
    this._activeParameter = parameter || null;
};

/**
 * 現在処理中のフィールドを設定する
 * 
 * @param {Jeeel.Parameter.Field} field フィールド
 */
Jeeel.Parameter._setActiveField = function (field) {
    this._activeField = field || null;
};

Jeeel.Parameter.prototype = {

    /**
     * パラメータ
     *
     * @type Hash
     * @private
     */
    _params: {},
    
    /**
     * フィールドリスト
     * 
     * @type Jeeel.Parameter.FieldList
     * @private
     */
    _fieldList: null,
    
    /**
     * バリデータリスト
     * 
     * @type Jeeel.Parameter.Validator.Abstract[]
     * @private
     */
    _validators: [],
    
    /**
     * フィルタリスト
     * 
     * @type Jeeel.Parameter.Filter.Abstract[]
     * @private
     */
    _filters: [],

    /**
     * エラー
     *
     * @type Hash
     * @private
     */
    _errors: {},
    
    /**
     * バリデート済みかどうか
     * 
     * @type Boolean
     * @private
     */
    _validated: true,

    /**
     * ストレージ
     *
     * @type Jeeel.Storage.Abstract
     * @private
     */
    _storage: null,
    
    /**
     * バリデータを追加する
     * 
     * @param {Jeeel.Parameter.Validator.Abstract} validator バリデータ
     * @return {Jeeel.Parameter} 自インスタンス
     */
    addValidator: function (validator) {
        this._validators.push(validator);
        
        return this;
    },
    
    /**
     * フィルタを追加する
     * 
     * @param {Jeeel.Parameter.Filter.Abstract} filter フィルタ
     * @return {Jeeel.Parameter} 自インスタンス
     */
    addFilter: function (filter) {
        this._filters.push(filter);
        
        return this;
    },
    
    /**
     * フィルタメソッドが呼べるかどうかを返す
     * 
     * @param {String} name フィルタ名
     * @return {Boolean} フィルタメソッドが呼べるかどうか
     */
    hasFiltration: function (name) {
        var fname = '_filter' + Jeeel.String.toPascalCase(name);
        
        if (this[fname] && typeof this[fname] === 'function') {
            return true;
        }
        
        for (var i = this._filters.length; i--;) {
            if (this._filters[i].hasFiltration(name)) {
                return true;
            }
        }
        
        return false;
    },
    
    /**
     * フィルタメソッドが取得する
     * 
     * @param {String} name フィルタ名
     * @return {Jeeel.Function.Callback} コールバック
     */
    getFiltration: function (name) {
        var fname = '_filter' + Jeeel.String.toPascalCase(name);
        
        if (this[fname] && typeof this[fname] === 'function') {
            return new Jeeel.Function.Callback(fname, this);
        }
        
        for (var i = this._filters.length; i--;) {
            if (this._filters[i].hasFiltration(name)) {
                return this._filters[i].getFiltration(name);
            }
        }
        
        return null;
    },
    
    /**
     * バリデートメソッドが呼べるかどうかを返す
     * 
     * @param {String} name バリデート名
     * @return {Boolean} バリデートメソッドが呼べるかどうか
     */
    hasValidation: function (name) {
        var vname = '_validate' + Jeeel.String.toPascalCase(name);
        
        if (this[vname] && typeof this[vname] === 'function') {
            return true;
        }
        
        for (var i = this._validators.length; i--;) {
            if (this._validators[i].hasValidation(name)) {
                return true;
            }
        }
        
        return false;
    },
    
    /**
     * バリデートメソッドを取得する
     * 
     * @param {String} name バリデート名
     * @return {Jeeel.Function.Callback} コールバック
     */
    getValidation: function (name) {
        var vname = '_validate' + Jeeel.String.toPascalCase(name);
        
        if (this[vname] && typeof this[vname] === 'function') {
            return new Jeeel.Function.Callback(vname, this);
        }
        
        for (var i = this._validators.length; i--;) {
            if (this._validators[i].hasValidation(name)) {
                return this._validators[i].getValidation(name);
            }
        }
        
        return null;
    },
    
    /**
     * 指定したキーの値を取得する
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 取得値
     */
    get: function (key, defaultValue) {
        return (key in this._params) ? this._params[key] : defaultValue;
    },

    /**
     * Hashの最初の値を取得する
     *
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 取得値
     * @deprecated 今後削除される予定
     */
    getOne: function (defaultValue) {
        var result;

        Jeeel.Hash.forEach(this._params,
            function (val) {

                result = val;

                return Jeeel.Hash.FOR_EACH_EXIT;
            }
        );

        if (Jeeel.Type.isEmpty(result)) {
            return defaultValue;
        }

        return result;
    },

    /**
     * 全ての値を返す
     *
     * @return {Hash} 取得値
     */
    getAll: function () {
        return this._params;
    },

    /**
     * 現インスタンスの配列に値を保存する
     *
     * @param {String} key 保存する値を示すキー
     * @param {Mixed} val 保存する値
     * @return {Jeeel.Parameter} 自インスタンス
     */
    set: function (key, val) {
        this._params[key] = val;

        return this;
    },

    /**
     * 全ての値を上書きする
     *
     * @param {Hash} params 上書きする値リスト
     * @return {Jeeel.Parameter} 自インスタンス
     * @throws {Error} paramsが配列式でない場合に起こる
     */
    setAll: function (params) {
        if ( ! Jeeel.Type.isHash(params)) {
           throw new Error('paramsには配列式が使えなければなりません。');
        }
        
        var self = this;

        Jeeel.Hash.forEach(params,
            function (val, key) {
                self._params[key] = val;
            }
        );

        return this;
    },

    /**
     * 現在保持している内部値のキーのリストを作成して取得する
     * 
     * @return {String[]} キーのリスト
     */
    getKeys: function () {
        return Jeeel.Hash.getKeys(this._params);
    },

    /**
     * 現在保持している内部値のリストを作成して取得する
     *
     * @return {Array} キーのリスト
     */
    getValues: function () {
        return Jeeel.Hash.getValues(this._params);
    },
    
    /**
     * 指定したキーの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Parameter} 自インスタンス
     */
    unset: function (key) {
        delete this._params[key];

        return this;
    },
    
    /**
     * 現在の内部の値を全て破棄する
     * 
     * @return {Jeeel.Parameter} 自インスタンス
     */
    clear: function () {
        this._params = {};
        
        return this;
    },

    /**
     * 指定したキーの値を保持しているかどうかを返す
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    has: function (key) {
        return key in this._params;
    },
    
    /**
     * フィールドを全て取得する
     * 
     * @return {Jeeel.Parameter.Field[]} フィールドのリスト
     */
    getFields: function () {
        var fields = this._fieldList.getFieldAll();
        
        var res = [];
        
        for (var name in fields) {
            res.push(fields[name]);
        }
        
        return res;
    },
    
    /**
     * フィールドを追加する
     * 
     * @param {String} name フィールド名
     * @param {String} label ラベル
     * @param {Array|String} [validationRules] バリデートルール
     * @param {Array|String} [filtrationRules] フィルタールール
     * @return {Jeeel.Parameter} 自インスタンス
     */
    addField: function (name, label, validationRules, filtrationRules) {
        
        if ( ! (name && label)) {
            throw new Error('name and label is required.');
        }
        
        var vRules = [];
        var fRules = [];
        var i, l, pos, key, rule, args,
            validateRule, filterRule;
        
        // バリデートルールの解析
        if (validationRules && Jeeel.Type.isHash(validationRules)) {
            
            for (key in validationRules) {
                
                validateRule = validationRules[key];
                
                if ( ! Jeeel.Type.isDigit(key)) {
                    rule = key;
                    args = Jeeel.Type.isArray(validateRule) && validateRule || [validateRule];
                } else if (Jeeel.Type.isArray(validateRule)) {
                    rule = validateRule[0];
                    args = Jeeel.Type.isArray(validateRule[1]) && validateRule[1] || [validateRule[1]];
                } else {
                    rule = Jeeel.String.trim(validateRule);
                    args = [];
                }
                
                vRules.push([rule, args]);
            }
        } else if (validationRules) {
            validationRules = validationRules.split('|');
            
            for (i = 0, l = validationRules.length; i < l; i++) {
                
                validateRule = Jeeel.String.trim(validationRules[i]);
                
                pos = validateRule.indexOf('[');
                
                if (pos >= 0) {
                    rule = validateRule.substr(0, pos);
                    args = validateRule.substr(pos + 1, validateRule.lastIndexOf(']') - pos - 1).split(',');
                } else {
                    rule = validateRule;
                    args = [];
                }
                
                vRules.push([rule, args]);
            }
        }
        
        // フィルタルールの解析
        if (filtrationRules && Jeeel.Type.isHash(filtrationRules)) {
            
            for (key in filtrationRules) {
                
                filterRule = filtrationRules[key];

                if ( ! Jeeel.Type.isDigit(key)) {
                    rule = key;
                    args = Jeeel.Type.isArray(filterRule) && filterRule || [filterRule];
                } else if (Jeeel.Type.isArray(filterRule)) {
                    rule = filterRule[0];
                    args = Jeeel.Type.isArray(filterRule[1]) && filterRule[1] || [filterRule[1]];
                } else {
                    rule = Jeeel.String.trim(filterRule);
                    args = [];
                }
                
                fRules.push([rule, args]);
            }
        } else if (filtrationRules) {
            filtrationRules = filtrationRules.split('|');
            
            for (i = 0, l = filtrationRules.length; i < l; i++) {
                filterRule = Jeeel.String.trim(filtrationRules[i]);

                pos = filterRule.indexOf('[');
                
                if (pos >= 0) {
                    rule = filterRule.substr(0, pos);
                    args = filterRule.substr(pos + 1, filterRule.lastIndexOf(']') - pos - 1).split(',');
                } else {
                    rule = filterRule;
                    args = [];
                }
                
                fRules.push([rule, args]);
            }
        }
        
        var field = new this.constructor.Field(this, name, label, vRules, fRules);
        
        this._validated = false;
        this._fieldList.addField(field);
        
        return this;
    },
    
    /**
     * フィールドを削除する
     * 
     * @param {String} name フィールド名
     * @return {Jeeel.Parameter} 自インスタンス
     */
    removeField: function (name) {
        this._fieldList.removeField(name);
        
        return this;
    },
    
    /**
     * 指定した名前のフィールドを保持しているかどうかを返す
     * 
     * @param {String} name フィールド名
     * @return {Boolean} フィールドを保持しているかどうか
     */
    hasField: function (name) {
        return this._fieldList.hasField(name);
    },
    
    /**
     * 設定した全てのフィルタ・検証を行う
     * 
     * @return {Jeeel.Net.Abstract} 自インスタンス
     */
    validate: function () {
        this.constructor._setActiveParameter(this);
        
        var values = this._params;
        var fields = this._fieldList.toHash();
        
        this._validated = true;
        this._errors = {};
        
        for (var key in fields) {
            
            var field = fields[key];

            this.constructor._setActiveField(field);
            
            var value = Jeeel.Type.isSet(values[key]) ? values[key] : null;
            var fRules = field.getFilterRules();
            var vRules = field.getValidateRules();
            
            value = this._filter(field, value, fRules);
            
            if (value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
                field.setValue(value);
                
                continue;
            }
            
            var isValid = this._validate(field, value, vRules);
            
            if (isValid) {
                field.setValue(value);
            } else {
                field.setValue(null);
            }
        }
        
        this.constructor._setActiveParameter();
        this.constructor._setActiveField();
        
        return this;
    },
    
    /**
     * バリーデータを全て通過したかどうかを返す
     *
     * @return {Boolean} 通過ならばtrueそれ以外はfalseを返す
     */
    isValid: function () {
        return this._validated && Jeeel.Type.isEmptyHash(this._errors);
    },
    
    /**
     * フィルタ・検証後の値を全て取得する
     * 
     * @return {Hash} 取得値
     */
    getValidatedValues: function () {
        var res = {};
        var fields = this._fieldList.toHash();
        
        for (var key in fields) {
            var field = fields[key];
            
            var value = field.getValue();
            
            if (value !== Jeeel.Parameter.Filter.IGNORED_VALUE) {
                res[key] = value;
            }
        }
        
        return res;
    },

    /**
     * パラメータにフィルターを掛けた値を新しくインスタンスとして返す
     *
     * @param {Jeeel.Filter.Abstract} filter Jeeel.Filter.Abstractを継承したクラスのフィルター
     * @param {String|String[]} keys 指定キーの要素のみを対象とする
     * @return {Jeeel.Parameter} フィルターを掛けた新しいインスタンス
     */
    filter: function (filter, keys) {
        var value;

        if (keys) {
            value = this.filterEach(filter, keys).getAll();
        }
        else {
            value = filter.filter(this.getAll());
        }

        if ( ! Jeeel.Type.isHash(value)) {
            value = [value];
        }

        return Jeeel.Parameter.create(value);
    },

    /**
     * フィルターを配列の各要素にそれぞれ掛けていく
     *
     * @param {Jeeel.Filter.Abstract} innerFilter 内部フィルター
     * @param {String[]} [keys] 操作許可キーリスト(初期値は全て)
     * @return {Jeeel.Parameter} フィルターを掛けた新しいインスタンス
     */
    filterEach: function (innerFilter, keys) {
        var filter = Jeeel.Filter.Each.create(innerFilter, keys);

        return this.filter(filter);
    },

    /**
     * 現インスタンスの内部値を文字列として結合し返す
     *
     * @param {String} [separator] 連結時の区切り文字列
     * @param {String[]} [keys] 連結するキーのリスト
     * @return {String} 結合後の値
     */
    join: function (separator, keys) {
        return this.filter(Jeeel.Filter.Join.create(separator, keys)).getOne('');
    },

    /**
     * エラーを全て返す
     *
     * @return {Hash} エラーのリスト
     */
    getErrors: function () {
        return this._errors;
    },
    
    /**
     * 指定したフィールドのエラーを取得する
     * 
     * @param {String} name フィールド名
     * @return {Jeeel.Parameter.Validator.Error|Mixed} エラー
     */
    getError: function(name) {
        return Jeeel.Type.isSet(this._errors[name]) ? this._errors[name] : null;
    },
    
    /**
     * 全てのエラーを文字列として取得する
     * 
     * @return {String[]|Array} エラーリスト
     */
    getErrorMessages: function () {
        var err, res = {};
        
        for (var name in this._errors) {
            err = this._errors[name];
            
            if (err instanceof this.constructor.Validator.Error) {
                res[name] = err.getMessage();
            } else {
                res[name] = err;
            }
        }
        
        return res;
    },
    
    /**
     * 指定したフィールドのエラーを文字列として取得する
     * 
     * @return {String|Mixed} エラー
     */
    getErrorMessage: function (name) {
        var err = this._errors[name] || '';

        if (err instanceof this.constructor.Validator.Error) {
            err = err.getMessage();
        }
        
        return err;
    },

    /**
     * エラーをセットする
     *
     * @param {String} key エラーのキー
     * @param {Jeeel.Parameter.Validator.Error|Mixed} val エラーの内容
     * @return {Jeeel.Parameter} 自インスタンス
     */
    setError: function (key, val) {
        this._errors[key] = val;

        return this;
    },
    
    /**
     * エラーを削除する
     * 
     * @param {String} key エラーのキー
     * @return {Jeeel.Parameter} 自インスタンス
     */
    removeError: function (key) {
        delete this._errors[key];
        
        return this;
    },

    /**
     * keyで指定された値をとりだし、Jeeel.Parameterのインスタンスとして返す<br />
     * 取り出した値が配列ではなかった場合、かわりにdefaultが使われる<br />
     * defaultが配列ではなかった場合、[default]が使われる<br />
     * defaultが指定されなかった（またはnullだった)場合、[]が使われる
     *
     * @param {String} key 取りだす要素のキー
     * @param {Mixed} [defaultValue] デフォルト値
     * @return {Jeeel.Parameter} 取りだした要素を含んだインスタンス
     */
    getElement: function (key, defaultValue) {
        var val = this.get(key, null);

        if (val === null) {
            val = [];
        }

        if ( ! Jeeel.Type.isHash(val) && Jeeel.Type.isSet(defaultValue)) {

            if ( ! Jeeel.Type.isHash(defaultValue)) {
                defaultValue = [defaultValue];
            }

            val = defaultValue;
        }

        return Jeeel.Parameter.create(val);
    },

    /**
     * keysで指定された部分集合をJeeel.Parameterのインスタンスとして返す。<br />
     * defaultは、キーが存在しなかった場合のデフォルト値として使われる。<br />
     * defaultが配列array(x => y, ...) だった場合、キーxのデフォルトにyが適用される。<br />
     * defaultが配列で、キー '*' => z を持つ場合、すべてのキーのデフォルトにzが適用される。<br />
     * defaultが配列で、キー a => v を持ち、aが配列だった場合、<br />
     *     aで指定された全てのキーのデフォルトに、vが適用される<br />
     * '*' => z と 'x' => y が指定された場合、yが優先される<br />
     * defaultが配列ではなかった場合、すべてのキーに対して、defaultが適用される。<br />
     * defaultが指定されない場合、部分集合に含まれない。
     *
     * @param {String|String[]} keys 部分集合を表す複数のキー
     * @param {Mixed} [defaultValue] キーが存在しなかった場合のデフォルト値
     * @return {Jeeel.Parameter} 部分集合を持ったインスタンス
     */
    getSubset: function (keys, defaultValue) {
        return this.filter(Jeeel.Filter.Subset.create(keys, defaultValue));
    },

    /**
     * 現インスタンス内部の値をシリアライズして返す<br />
     * その際指定したキーの値のみをシリアライズ出来、<br />
     * かつその内部の部分配列をシリアライズ出来る
     *
     * @param {String} [key] 指定キー
     * @param {String|String[]} [subset] 部分配列を指定するキーリスト
     * @return {String} Json化した内部値
     */
    serialize: function (key, subset) {
        var params = (key ? this.getElement(key) : this);
        params = (subset ? params.getSubset(subset) : params);

        return Jeeel.Json.encode(params.getAll());
    },

    /**
     * Jeeel.Storage.Abstractを継承したストレージをセットする
     *
     * @param {Jeeel.Storage.Abstract} storage ストレージ
     * @return {Jeeel.Parameter} 自インスタンス
     */
    setStorage: function (storage) {
        this._storage = storage;

        return this;
    },

    /**
     * ストレージを取得する
     *
     * @return {Jeeel.Storage.Abstract} 取得したストレージ
     * @throws {Error} ストレージがセットされていない場合に投げられる
     */
    getStorage: function () {
        if ( ! this._storage) {
            throw new Error('ストレージがセットされていません。');
        }

        return this._storage;
    },


    /**
     * ストレージにパラメータを保存する
     *
     * @param {Jeeel.Storage.Abstract} [storage] 任意のストレージを使う場合に指定
     * @return {Jeeel.Parameter} 自インスタンス
     * @throws {Error} ストレージを指定せず、ストレージがセットされていない場合に投げられる
     */
    save: function (storage) {
        if ( ! storage) {
            storage = this.getStorage();
        }

        storage.save(this.getAll());

        return this;
    },

    /**
     * ストレージからパラメータを読み込む
     *
     * @param {Jeeel.Storage.Abstract} [storage] 任意のストレージを使う場合に指定
     * @return {Jeeel.Parameter} 自インスタンス
     * @throws {Error} ストレージを指定せず、ストレージがセットされていない場合に投げられる
     */
    load: function (storage) {
        if ( ! storage) {
            storage = this.getStorage();
        }

        this.setAll(storage.load());

        return this;
    },

    /**
     * 内部の保持値をGetパラメータ用の値に変更して返す<br />
     * Getパラメータの先頭に?はつかない
     *
     * @return {String} Getパラメータを示す文字列
     */
    toQueryString: function () {
        return Jeeel.Filter.Url.QueryString.create().filter(this._params);
    },

    /**
     * 内部要素にforeachをかける<br />
     * 詳しくはJeeel.Hash.forEach参照
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Jeeel.Parameter} 自インスタンス
     * @see Jeeel.Hash.forEach
     */
    each: function (eachMethod, thisArg) {
        Jeeel.Hash.forEach(this._params, eachMethod, thisArg);
        
        return this;
    },
    
    /**
     * インスタンスの複製を行う
     * 
     * @return {Jeeel.Parameter} 複製したインスタンス
     */
    clone: function () {
        var prms;
        
        if (Jeeel.Type.isArray(this._params)) {
            prms = this._params.concat();
        } else {
            prms = {};
            
            for (var key in this._params) {
                prms[key] = this._params[key];
            }
        }
        
        var instance = new this.constructor(prms);
        
        return instance;
    },
    
    _filter: function (field, value, rules) {
        
        for (var key in rules) {
            var rule = rules[key];
            var callback = this.getFiltration(rule[0]);
            
            if (callback) {
                var args = rule[1];
                args.unshift(value);
                value = callback.apply(args);
                
                if (value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
                    return value;
                }
            }
        }
        
        return value;
    },
    
    _validate: function(field, value, rules) {
        
        var isValid = true;
        
        for (var key in rules) {
            var rule = rules[key];
            var callback = this.getValidation(rule[0]);
            
            if (callback) {
                var args = rule[1].concat();
                args.unshift(value);
                
                var isFieldValid = callback.apply(args);
                
                if (isFieldValid !== true) {
                    
                    var fieldName = field.getName();
                    
                    if ( ! this._errors[fieldName]) {
                        this._errors[fieldName] = new this.constructor.Validator.Error(field, value, callback.getMethodName(), rule[1]);
                        
                        if (isFieldValid !== false) {
                            this._errors[fieldName].setMessage(isFieldValid);
                        }
                    }
                    
                    isValid = false;
                }
            }
        }
        
        return isValid;
    },

    /**
     * コンストラクタ
     * 
     * @param {Hash} [params] 入力パラメータ
     * @constructor
     */
    constructor: Jeeel.Parameter
};

Jeeel.file.Jeeel.Parameter = ['Field', 'FieldList', 'Filter', 'Validator'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Parameter, Jeeel.file.Jeeel.Parameter);

/**
 * コンストラクタ
 * 
 * @class フィールドを扱うクラス
 * @param {Jeeel.Parameter} parameter パラメータ
 * @param {String} name フィールド名
 * @param {String} [label] ラベル
 * @param {Array} [validateRules] バリデートルール
 * @param {Array} [filterRules] フィルタルール
 */
Jeeel.Parameter.Field = function (parameter, name, label, validateRules, filterRules) {
    this._parameter = parameter;
    this._name = name;
    this._label = label || '';
    this._validateRules = validateRules || [];
    this._filterRules = filterRules || [];
};

Jeeel.Parameter.Field.prototype = {
    
    _parameter: null,
    _name: '',
    _label: '',
    _value: null,
    _validateRules: [],
    _filterRules: [],
    
    /**
     * パラメータを取得する
     * 
     * @return {Jeeel.Parameter} パラメータ
     */
    getParameter: function () {
        return this._parameter;
    },

    /**
     * フィールド名を取得する
     * 
     * @return {String} フィールド名
     */
    getName: function () {
        return this._name;
    },
    
    /**
     * フィールドのラベルを取得する
     * 
     * @return {String} ラベル値
     */
    getLabel: function () {
        return this._label;
    },
    
    /**
     * フィールドの値を取得する
     * 
     * @return {Mixed} フィールド値
     */
    getValue: function () {
        return this._value;
    },
    
    /**
     * フィールドの値を設定する
     * 
     * @param {Mixed} value フィールド値
     * @return {Jeeel.Parameter.Field} 自インスタンス
     */
    setValue: function (value) {
        this._value = value;
        
        return this;
    },
    
    /**
     * バリデートルールのリストを取得する
     * 
     * @return {Array} バリデートルールリスト
     */
    getValidateRules: function () {
        return this._validateRules;
    },
    
    /**
     * フィルタのルールのリストを取得する
     * 
     * @return {Array} フィルタルールリスト
     */
    getFilterRules: function () {
        return this._filterRules;
    }
};

/**
 * コンストラクタ
 * 
 * @class フィールドを管理するクラス
 */
Jeeel.Parameter.FieldList = function () {
    this._fields = {};
};

Jeeel.Parameter.FieldList.prototype = {
    
    /**
     * フィールドリスト
     * 
     * @type Hash
     * @private
     */
    _fields: {},
    
    /**
     * フィールドを追加する
     * 
     * @param {Jeeel.Parameter.Field} field 追加フィールド
     * @return {Jeeel.Parameter.FieldList} 自インスタンス
     */
    addField: function (field) {
        this._fields[field.getName()] = field;
        
        return this;
    },
    
    /**
     * フィールドを取得する
     * 
     * @param {String} name フィールド名
     * @return {Jeeel.Parameter.Field} フィールド
     */
    getField: function (name) {
        return this.hasField(name) ? this._fields[name] : null;
    },
    
    /**
     * フィールドを削除する
     * 
     * @param {String} name フィールド名
     * @return {Jeeel.Parameter.FieldList} 自インスタンス
     */
    removeField: function (name) {
        delete this._fields[name];
        
        return this;
    },

    /**
     * フィールドを全て取得する
     * 
     * @return {Hash} フィールドリスト
     */
    getFieldAll: function () {
        return this._fields;
    },

    /**
     * フィールドを保持しているかどうかを取得する
     * 
     * @param {String} name フィールド名
     * @return {Boolean} 保持しているかどうか
     */
    hasField: function (name) {
        if (name === '*') {
            for (var key in this._fields) {
                return true;
            }
            
            return false;
        }
        
        return !!this._fields[name];
    },
    
    /**
     * ハッシュに変換する
     * 
     * @return {Hash} 変換後のハッシュ
     */
    toHash: function () {
        var res = {};
        
        for (var key in this._fields) {
            res[key] = this._fields[key];
        }
        
        return res;
    }
};
Jeeel.directory.Jeeel.Parameter.Filter = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Parameter + 'Filter/';
    }
};

/**
 * @namespace フィルタクラスのためのネームスペース
 */
Jeeel.Parameter.Filter = {
    
    /**
     * DBに対して入れるべきでない事を示す定数<br />
     * この定数をフィルタが返したら検証済みの値のリストにそのフィールドは含んではならない
     * 
     * @type String
     * @constant
     */
    IGNORED_VALUE: '@pbs-form-filter-ignored-value@',
    
    /**
     * インターフェース
     * 
     * @interface フィルタークラスを作る際のインターフェース
     */
    Interface: {
        /**
         * フィルタメソッドが呼べるかどうかを返す
         * 
         * @param {String} name フィルタ名
         * @return {Boolean} フィルタメソッドが呼べるかどうか
         */
        hasFiltration: function (name) {},
        
        /**
         * フィルタメソッドが取得する
         * 
         * @param {String} name フィルタ名
         * @return {Jeeel.Function.Callback} コールバック
         */
        getFiltration: function (name) {}
    },
    
    /**
     * コンストラクタ
     * 
     * @abstractClass フィルタークラスを作る際の抽象クラス
     * @implements Jeeel.Parameter.Filter.Interface
     */
    Abstract: function () {}
};

Jeeel.Parameter.Filter.Interface = Jeeel.Class.Interface.register('Jeeel.Parameter.Filter.Interface', Jeeel.Parameter.Filter.Interface);

Jeeel.Parameter.Filter.Abstract.prototype = {
    
    /**
     * フィルタを行う
     * 
     * @param {String} name フィルタ名
     * @param {Mixed} value フィルタ対象
     * @param {Array} [args] 引数リスト
     * @return {Boolean} フィルタ結果
     */
    filter: function(name, value, args) {
        
        args = args || [];
        
        args.unshift(value);
        
        name = "filter" + Jeeel.String.toPascalCase(name);
        
        return this[name].apply(this, args);
    },
    
    /**
     * フィルタメソッドが呼べるかどうかを返す
     * 
     * @param {String} name フィルタ名
     * @return {Boolean} フィルタメソッドが呼べるかどうか
     */
    hasFiltration: function (name) {
        name = "filter" + Jeeel.String.toPascalCase(name);
        
        return !!(this[name] && typeof this[name] === 'function');
    },
    
    /**
     * フィルタメソッドが取得する
     * 
     * @param {String} name フィルタ名
     * @return {Jeeel.Function.Callback} コールバック
     */
    getFiltration: function (name) {
        name = "filter" + Jeeel.String.toPascalCase(name);
        
        return this[name] && typeof this[name] === 'function' && new Jeeel.Function.Callback(name, this) || null;
    }
};

Jeeel.Parameter.Filter.Abstract = Jeeel.Class.implement(Jeeel.Parameter.Filter.Abstract, Jeeel.Parameter.Filter.Interface);

Jeeel.file.Jeeel.Parameter.Filter = ['Base'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Parameter.Filter, Jeeel.file.Jeeel.Parameter.Filter);

/**
 * コンストラクタ
 * 
 * @class 基本となるフィルタクラス
 * @augments Jeeel.Parameter.Filter.Abstract
 */
Jeeel.Parameter.Filter.Base = function () {
    Jeeel.Parameter.Filter.Abstract.call(this);
};

Jeeel.Parameter.Filter.Base.prototype = {
    
    /**
     * 値が無かったら無視する
     * 
     * @param {Mixed} value フィルタ値
     * @return int フィルタ後の値
     */
    filterOption: function (value) {
        return ! Jeeel.Type.isEmpty(value) ? value : Jeeel.Parameter.Filter.IGNORED_VALUE;
    },
    
    /**
     * 値が指定されていなかった場合に代わりに代替値を返す
     * 
     * @param {Mixed} value 対象値
     * @param {Mixed} defaultValue デフォルト値
     * @return {Mixed} 処理後の値
     */
    filterDefault: function (value, defaultValue) {
        return ! Jeeel.Type.isEmpty(value) ? value : defaultValue;
    },
    
    /**
     * floatにキャストする
     * 
     * @param {Mixed} value キャスト値
     * @return {Number} キャスト後の値
     */
    filterFloat: function (value) {
        if (value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
            return value;
        }
        
        return +value;
    },
    
    /**
     * intにキャストする
     * 
     * @param {Mixed} value キャスト値
     * @return {Integer} キャスト後の値
     */
    filterInt: function (value) {
        if (value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
            return value;
        }
        
        return Math.floor(+value);
    },
    
    /**
     * Stringにキャストする
     * 
     * @param {Mixed} value キャスト値
     * @return {String} キャスト後の値
     */
    filterString: function (value) {
        if (value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
            return value;
        } else if ( ! value && value !== 0) {
            return '';
        }
        
        return (value.toString ? value.toString() : '' + value);
    },
    
    /**
     * Arrayにキャストする
     * 
     * @param {Mixed} value キャスト値
     * @return {Array} キャスト後の値
     */
    filterArray: function (value) {
        if (value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
            return value;
        }
        
        return Jeeel.Type.isArray(value) ? value : [value];
    },
    
    /**
     * Booleanにキャストする
     * 
     * @param {Mixed} value キャスト値
     * @return {Boolean} キャスト後の値
     */
    filterBool: function (value) {
        if (value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
            return value;
        }
        
        return !!value;
    },
    
    /**
     * 前後の空白等を取り除く
     * 
     * @param {String} value 対象値
     * @return {String} 処理後の値
     */
    filterTrim: function (value) {
        if (Jeeel.Type.isEmpty(value) || value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
            return value;
        }
        
        return Jeeel.String.trim(value);
    },
    
    /**
     * 全角英数字とスペース・記号を半角にする
     * 
     * @param {String} value 対象値
     * @return {String} 処理後の値
     */
    filterHalfWidth: function (value) {
        if (Jeeel.Type.isEmpty(value) || value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
            return value;
        }
        
        return Jeeel.String.toHalfWidth(value);
    },
    
    /**
     * 半角英数字とスペース・記号を全角にする
     * 
     * @param {String} value 対象値
     * @return {String} 処理後の値
     */
    filterFullWidth: function (value) {
        if (Jeeel.Type.isEmpty(value) || value === Jeeel.Parameter.Filter.IGNORED_VALUE) {
            return value;
        }
        
        return Jeeel.String.toFullWidth(value);
    }
};

Jeeel.Class.extend(Jeeel.Parameter.Filter.Base, Jeeel.Parameter.Filter.Abstract);

Jeeel.Parameter.addDefaultFilter(new Jeeel.Parameter.Filter.Base());

Jeeel.directory.Jeeel.Parameter.Validator = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Parameter + 'Validator/';
    }
};

/**
 * @namespace バリデータクラスのためのネームスペース
 */
Jeeel.Parameter.Validator = {
    
    /**
     * インターフェース
     * 
     * @interface バリデートクラスを作る際のインターフェース
     */
    Interface: {
        /**
         * バリデートメソッドが呼べるかどうかを返す
         * 
         * @param {String} name バリデート名
         * @return {Boolean} バリデートメソッドが呼べるかどうか
         */
        hasValidation: function (name) {},
        
        /**
         * バリデートメソッドを取得する
         * 
         * @param {String} name バリデート名
         * @return {Jeeel.Function.Callback} コールバック
         */
        getValidation: function (name) {}
    },
    
    /**
     * コンストラクタ
     * 
     * @abstractClass バリデータクラスを作る際の抽象クラス
     * @implements Jeeel.Parameter.Validator.Interface
     */
    Abstract: function () {}
};

Jeeel.Parameter.Validator.Interface = Jeeel.Class.Interface.register('Jeeel.Parameter.Validator.Interface', Jeeel.Parameter.Validator.Interface);

Jeeel.Parameter.Validator.Abstract.prototype = {
    
    /**
     * バリデートを行う
     * 
     * @param {String} name バリデート名
     * @param {Mixed} value バリデート対象
     * @param {Array} [args] 引数リスト
     * @return {Boolean} バリデート結果
     */
    validate: function(name, value, args) {
        
        args = args || [];
        
        args.unshift(value);
        
        name = "validate" + Jeeel.String.toPascalCase(name);
        
        return this[name].apply(this, args);
    },
    
    /**
     * バリデートメソッドが呼べるかどうかを返す
     * 
     * @param {String} name バリデート名
     * @return {Boolean} バリデートメソッドが呼べるかどうか
     */
    hasValidation: function (name) {
        name = "validate" + Jeeel.String.toPascalCase(name);
        
        return !!(this[name] && typeof this[name] === 'function');
    },
    
    /**
     * バリデートメソッドを取得する
     * 
     * @param {String} name バリデート名
     * @return {Jeeel.Function.Callback} コールバック
     */
    getValidation: function (name) {
        name = "validate" + Jeeel.String.toPascalCase(name);
        
        return this[name] && typeof this[name] === 'function' && new Jeeel.Function.Callback(name, this) || null;
    }
};

Jeeel.Parameter.Validator.Abstract = Jeeel.Class.implement(Jeeel.Parameter.Validator.Abstract, Jeeel.Parameter.Validator.Interface);

Jeeel.file.Jeeel.Parameter.Validator = ['Base', 'Error'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Parameter.Validator, Jeeel.file.Jeeel.Parameter.Validator);

/**
 * コンストラクタ
 * 
 * @class 基本となるバリデータクラス
 * @augments Jeeel.Parameter.Validator.Abstract
 */
Jeeel.Parameter.Validator.Base = function () {
    Jeeel.Parameter.Validator.Abstract.call(this);
};

Jeeel.Parameter.Validator.Base.prototype = {
    
    /**
     * 必須項目のバリデートを行う
     * 
     * @param {Mixed} value バリデート値
     * @return {Boolean} 空じゃなかったかどうか(null, undefined以外が通過)
     */
    validateRequired: function (value) {
        return ! Jeeel.Type.isEmpty(value);
    },
    
    /**
     * 列挙体のバリデートを行う
     * 
     * @param {Mixed} value バリデート値
     * @param {Array} enums 列挙体
     * @param {Boolean} strict 値比較の際に型まで比較するかどうか
     * @return {Boolean} 指定した列挙体中の値だったかどうか
     */
    validateEnum: function (value, enums, strict) {
        return ! this.validateRequired(value) || Jeeel.Hash.inHash(value, enums || [], strict);
    },
    
    /**
     * 数値が下限以上かのバリデートを行う
     * 
     * @param {String|Number} value 数値
     * @param {Number} min 下限
     * @return {Boolean} 数値が下限以上かどうか
     */
    validateNumericMin: function (value, min) {
        return ! this.validateRequired(value) || (+min <= +value);
    },
    
    /**
     * 数値が上限以下かのバリデートを行う
     * 
     * @param {String|Number} value 数値
     * @param {Number} max 上限
     * @return {Boolean} 数値が上限以下かどうか
     */
    validateNumericMax: function (value, max) {
        return ! this.validateRequired(value) || (+value <= +max);
    },
    
    /**
     * 数値が範囲内かのバリデートを行う
     * 
     * @param {String|Number} value 数値
     * @param {Number} min 下限
     * @param {Number} max 上限
     * @return {Boolean} 数値が範囲内かどうか
     */
    validateBetween: function (value, min, max) {
        if ( ! this.validateRequired(value)) {
            return true;
        }
        
        value = +value;
        
        return (+min <= value && value <= +max);
    },
    
    /**
     * 文字列の長さの下限のバリデートを行う
     * 
     * @param {String} str 文字列
     * @param {Integer} min 長さの下限
     * @return {Boolean} 長さが下限以上かどうか
     */
    validateMinLength: function (str, min) {
        if ( ! this.validateRequired(str)) {
            return true;
        }
        
        str = '' + str;
        min = Math.floor(+min);
        
        return min <= str.length;
    },
    
    /**
     * 文字列の長さの上限のバリデートを行う
     * 
     * @param {String} str 文字列
     * @param {Integer} max 長さの上限
     * @return {Boolean} 長さが上限以下かどうか
     */
    validateMaxLength: function (str, max) {
        if ( ! this.validateRequired(str)) {
            return true;
        }
        
        str = '' + str;
        max = Math.floor(+max);
        
        return str.length <= max;
    },

    /**
     * 文字列の長さのバリデートを行う
     * 
     * @param {String} str 文字列
     * @param {Integer} min 長さの下限
     * @param {Integer} max 長さの上限
     * @return {Boolean} 長さが範囲以内かどうか
     */
    validateLength: function (str, min, max) {
        if ( ! this.validateRequired(str)) {
            return true;
        }
        
        str = '' + str;
        min = Math.floor(+min);
        max = Math.floor(+max);
        
        return min <= str.length && str.length <= max;
    },
    
    /**
     * 半角英数字のバリデートを行う
     * 
     * @param {String} alnum 半角英数字
     * @return {Boolean} 半角英数字かどうか
     */
    validateAlnum: function (alnum) {
        return ! this.validateRequired(alnum) || /^[a-z0-9]*$/ig.test(alnum);
    },
    
    /**
     * 半角英字のバリデートを行う
     * 
     * @param {String} alpha 半角英字
     * @return {Boolean} 半角英字かどうか
     */
    validateAlpha: function (alpha) {
        return ! this.validateRequired(alpha) || /^[a-z]*$/ig.test(alpha);
    },
    
    /**
     * 数値のバリデートを行う
     * 
     * @param {String|Number} digits 数値
     * @return {Boolean} 数値かどうか
     */
    validateDigits: function (digits) {
        return ! this.validateRequired(digits) || /^[0-9]+$/ig.test(digits);
    },
    
    /**
     * 半角のバリデートを行う
     * 
     * @param {String} str 文字列
     * @return {Boolean} 半角かどうか
     */
    validateHalfWidth: function (str) {
        return  ! this.validateRequired(str) || /^[\u0000-\u007E]*$/ig.test(str);
    },
    
    /**
     * 全角のバリデートを行う
     * 
     * @param {String} str 文字列
     * @return {Boolean} 半角かどうか
     */
    validateFullWidth: function (str) {
        return  ! this.validateRequired(str) || /^[^\u0020-\u007E]*$/ig.test(str);
    },
    
    /**
     * ひらがなのバリデートを行う
     * 
     * @param {String} str 文字列
     * @return {Boolean} ひらがなかどうか
     */
    validateHiragana: function (str) {
        return ! this.validateRequired(str) || /^[\u3001\u3002\u3041-\u3096　]*$/ig.test(str);
    },
    
    /**
     * カタカナのバリデートを行う
     * 
     * @param {String} str 文字列
     * @return {Boolean} カタカナかどうか
     */
    validateKatakana: function (str) {
        return ! this.validateRequired(str) || /^[\u30A0-\u30FC\u31F0-\u31FF　]*$/ig.test(str);
    },
    
    /**
     * 半角カタカナのバリデートを行う
     * 
     * @param {String} str 文字列
     * @return {Boolean} 半角カタカナかどうか
     */
    validateHalfWidthKana: function (str) {
        return  ! this.validateRequired(str) || /^[\uFF65-\uFF9F ]*$/ig.test(str);
    },
    
    /**
     * 真偽値のバリデートを行う
     * 
     * @param {Boolean|Integer|String} bool 真偽値
     * @return {Boolean} 真偽値かどうか
     */
    validateBool: function (bool) {
        if ( ! this.validateRequired(bool)) {
            return true;
        }
        
        return bool === true || bool === false
            || bool === 1    || bool === 0
            || bool === '1'  || bool === '0';
    },

    /**
     * Emailのバリデートを行う
     * 
     * @param {String} email Email
     * @return {Boolean} Emailかどうか
     */
    validateEmail: function (email) {
        if ( ! this.validateRequired(email)) {
            return true;
        }
        
        var reg = /^(?:(?:(?:(?:[a-zA-Z0-9_!#\$\%&'*+\/=?\^`{}~|\-]+)(?:\.(?:[a-zA-Z0-9_!#\$\%&'*+\/=?\^`{}~|\-]+))*)|(?:"(?:\\[^\r\n]|[^\\"])*")))\@(?:(?:(?:(?:[a-zA-Z0-9_!#\$\%&'*+\/=?\^`{}~|\-]+)(?:\.(?:[a-zA-Z0-9_!#\$\%&'*+\/=?\^`{}~|\-]+))*)|(?:\[(?:\\\S|[\x21-\x5a\x5e-\x7e])*\])))$/;
        
        return reg.test(email);
    },

    /**
     * URLのバリデートを行う
     * 
     * @param {String} url URL
     * @return {Boolean} URLかどうか
     */
    validateUrl: function (url) {
        var reg = /^(https?|ftp):\/\/(?:([^@:]+)(?::([^@]+))?@)?([^:\/]+)(?::([0-9]+))?(\/[^?]*)?(?:\?([^#]*))?(?:#(.*))?$/;
        
        return ! this.validateRequired(url) || reg.test(url);
    },
    
    /**
     * IPのバリデートを行う
     * 
     * @param {String} ip IP
     * @return {Boolean} IPかどうか
     */
    validateIp: function (ip) {
        if ( ! this.validateRequired(ip)) {
            return true;
        }
        
        ip = '' + ip;
        
        var ips, reg;
        
        // IPv4の場合(IPv6未対応)
        if (ip.indexOf('.') >= 0) {
            ips = ip.split('.');
            
            if (ips.length !== 4) {
                return false;
            }
            
            reg = /^0|[1-9][0-9]*$/g;
            
            for (var i = ips.length; i--;) {
                if ( ! ips[i].match(reg)) {
                    return false;
                }
                
                ips[i] = +ips[i];
                
                if ( ! (0 <= ips[i] && ips[i] <= 255)) {
                    return false;
                }
            }
            
            return true;
        }
        
        return false;
    },

    /**
     * 文字列の正規表現でのバリデートを行う
     * 
     * @param {String} value 検証文字列
     * @param {String} pattern 正規表現
     * @return bool 正規表現にマッチするかどうか
     */
    validateRegex: function (value, pattern) {
        return ! this.validateRequired(value) 
            || !!('' + value).match(new RegExp(Jeeel.String.escapeRegExp(pattern)));
    }
};

Jeeel.Class.extend(Jeeel.Parameter.Validator.Base, Jeeel.Parameter.Validator.Abstract);

Jeeel.Parameter.addDefaultValidator(new Jeeel.Parameter.Validator.Base());

/**
 * コンストラクタ
 * 
 * @class 検証エラーを管理するクラス
 * @param {Jeeel.Parameter.Field} field 対象フィールド
 * @param {Mixed} value フィールド値
 * @param {String} validationName バリデートメソッド名
 * @param {Array} [args] バリデートメソッドの引数リストリスト
 */
Jeeel.Parameter.Validator.Error = function (field, value, validationName, args) {
    this._field = field;
    this._value = value;
    this._validationName = ('' + validationName).replace(/^_?validate/, '');
    this._args = args || [];
};

Jeeel.Parameter.Validator.Error.prototype = {
    _field: null,
    _value: null,
    _validationName: '',
    _args: [],
    _msg: '',
    
    /**
     * フィールドを取得する
     * 
     * @return {Jeeel.Parameter.Field} フィールド
     */
    getValidationField: function() {
        return this._field;
    },

    /**
     * バリデートで引っ掛かったバリデーション名を取得する
     * 
     * @return {String} バリデーション名
     */
    getValidationName: function () {
        return this._validationName;
    },
    
    /**
     * バリデートで引っ掛かったバリデート対象の値を取得する
     * 
     * @return {Mixed} バリデート対象値
     */
    getValidationValue: function () {
        return this._value;
    },
    
    /**
     * バリデーションを通した際に渡した引数を取得する
     * 
     * @return {Array} 引数リスト
     */
    getValidationArgs: function () {
        return this._args;
    },
    
    /**
     * 現在の内部情報からエラーメッセージを取得する
     * 
     * @return {String} エラーメッセージ
     */
    getMessage: function () {
        var path = 'Parameter.Validator';
        var res;
        
        if (Jeeel.Language.hasLanguage(path)) {
            var language = Jeeel.Language.getLanguage(path);

            var vName = Jeeel.String.toHyphenation(this._validationName).replace(/^-/, '');
            
            if (language[vName]) {
                res = language[vName];
            } else {
                res = this._msg;
            }
        } else {
            res = this._msg;
        }

        res = res.replace(':label', this._field.getLabel());
        res = res.replace(':param:0', this._value);
        
        for (var i = this._args.length; i--;) {
            res = res.replace(':param:' + (i + 1), this._args[i]);
        }
        
        return res;
    },
    
    /**
     * エラーメッセージを設定する
     * 
     * @param {String} msg エラーメッセージ
     * @return {Jeeel.Parameter.Validator.Error} 自インスタンス
     */
    setMessage: function (msg) {
        this._msg = msg;
        
        return this;
    },
    
    /**
     * 文字列に変換する
     * 
     * @return string エラーメッセージ
     */
    toString: function () {
        return this.getMessage();
    }
};

if (Jeeel._auto) {
    Jeeel._tmp();
}
Jeeel.directory.Jeeel.UserAgent = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'UserAgent/';
    }
};

/**
 * @staticClass ブラウザの情報を判別するためのクラス
 * @example
 * このクラスはブラウザ情報からURL情報まで一括で管理するクラスである
 * ブラウザ毎に正確に挙動を分けたい場合やURLのクエリなどを取得したい際に使用する
 * 
 * 例：
 * Jeeel.UserAgent.isInternetExplorer(); // ブラウザがIEの場合にtrue
 * Jeeel.UserAgent.isInternetExplorer(6); // 引数にバージョンを指定して、ブラウザがIE6の場合にtrueになる
 * Jeeel.UserAgent.getVersion(); // ブラウザの正確なバージョン情報を返す、Chromeなら"19.0.1084.56"など
 * Jeeel.UserAgent.getBrowserName(); // ブラウザの正確な名前を返す、Firefoxなら"Mozilla Firefox"など
 * Jeeel.UserAgent.getQuery(); // URLのクエリ文字列を解析した連想配列を取得する
 * 
 * 他にも以下のメソッド等が良く使われる
 * 
 * Jeeel.UserAgent.isFirefox(4); // Firefoxかどうかを判定する、引数でバージョンを指定
 * Jeeel.UserAgent.isChrome(); // Chromeかどうかを判定する、引数でバージョンを指定
 * Jeeel.UserAgent.isOpera();  // Opearaかどうかを判定する、引数でバージョンを指定
 * Jeeel.UserAgent.isSafari(); // Safariかどうかを判定する、引数でバージョンを指定
 * Jeeel.UserAgent.isIPhone(); // iPhoneかどうかを判定する
 * Jeeel.UserAgent.isAndroid(); // Androidかどうかを判定する
 */
Jeeel.UserAgent = {

    /**
     * ユーザーエージェントの文字列情報
     *
     * @type String
     * @private
     */
    _ua: Jeeel._global.navigator && Jeeel._global.navigator.userAgent || '',
    
    /**
     * ブラウザのバージョン文字列
     * 
     * @type String
     * @private
     */
    _browserVersion: '0',
    
    /**
     * スキーム文字列
     * 
     * @type String
     * @private
     */
    _scheme: Jeeel._global.location && Jeeel._global.location.protocol && Jeeel._global.location.protocol.replace(':', '') || '',
    
    /**
     * クエリ文字列
     * 
     * @type String
     * @private
     */
    _query: Jeeel._global.location && Jeeel._global.location.search && Jeeel._global.location.search.replace(/^\?/, '') || '',
    
    /**
     * クエリフィルター
     * 
     * @type Jeeel.Filter.Url.QueryParameter
     * @private
     */
    _queryFilter: new Jeeel.Filter.Url.QueryParameter(),
        
    /**
     * ブラウザがInternetExplorerかどうかを返す
     *
     * @param {Integer|String} [version] バージョンを指定したい場合に指定する(例: 6)
     * @return {Boolean} InternetExplorerかどうか
     */
    isInternetExplorer: function (version) {},

    /**
     * ブラウザがFirefoxかどうかを返す
     *
     * @param {Integer|String} [version] バージョンを指定したい場合に指定する(例: 3)
     * @return {Boolean} FireFoxかどうか
     */
    isFirefox: function (version) {},
    
    /**
     * ブラウザがChromeかどうかを返す
     *
     * @param {Integer|String} [version] バージョンを指定したい場合に指定する(例: 13)
     * @return {Boolean} Chromeかどうか
     */
    isChrome: function (version) {},
    
    /**
     * ブラウザがSafariかどうかを返す
     *
     * @param {Integer|String} [version] バージョンを指定したい場合に指定する(例: 5)
     * @return {Boolean} Safariかどうか
     */
    isSafari: function (version) {},

    /**
     * ブラウザがOperaかどうかを返す
     *
     * @param {Integer|String} [version] バージョンを指定したい場合に指定する(例: 10)
     * @return {Boolean} Operaかどうか
     */
    isOpera: function (version) {},

    /**
     * iPhoneかどうかを返す
     * 
     * @return {Boolean} iPhoneかどうか
     */
    isIPhone: function () {},
    
    /**
     * iPadかどうかを返す
     * 
     * @return {Boolean} iPadかどうか
     */
    isIPad: function () {},
    
    /**
     * iPod touchかどうかを返す
     * 
     * @return {Boolean} iPhoneかどうか
     */
    isIPod: function () {},
    
    /**
     * Androidかどうかを返す
     * 
     * @return {Boolean} Androidかどうか
     */
    isAndroid: function () {},
    
    /**
     * Mobileかどうかを返す(現在スマートフォンのみ考慮)
     * 
     * @return {Boolean} Mobileかどうか
     */
    isMobile: function () {},
    
    /**
     * Workerとして動作しているかどうかを返す
     * 
     * @return {Boolean} Workerかどうか
     */
    isWorker: function () {},

    /**
     * ブラウザのレンダリングエンジンがTridentかどうかを返す
     *
     * @return {Boolean} Tridentかどうか
     */
    isTridentEngine: function () {},

    /**
     * ブラウザのレンダリングエンジンがGeckoかどうかを返す
     *
     * @return {Boolean} Geckoかどうか
     */
    isGeckoEngine: function () {},

    /**
     * ブラウザのレンダリングエンジンがWebkitかどうかを返す
     *
     * @return {Boolean} Webkitかどうか
     */
    isWebkitEngine: function () {},

    /**
     * ブラウザのレンダリングエンジンがPrestoかどうかを返す
     *
     * @return {Boolean} Prestoかどうか
     */
    isPrestoEngine: function () {},
    
    /**
     * ブラウザ名を取得する
     *
     * @return {String} ブラウザ名
     */
    getBrowserName: function () {
        return navigator.appName;
    },

    /**
     * ブラウザのバージョンを取得する
     *
     * @return {String} ブラウザのバージョン
     */
    getVersion: function () {
        return this._browserVersion || navigator.appVersion;
    },

    /**
     * ブラウザのユーザエージェントを取得する
     *
     * @return {String} ブラウザのユーザエージェント
     */
    getUserAgent: function () {
        return this._ua;
    },

    /**
     * ユーザーのOSプラットフォームを取得する
     *
     * @return {String} ユーザーのOSプラットフォーム
     */
    getPlatform: function () {
        return navigator.platform;
    },

    /**
     * ブラウザの使用言語を取得する
     *
     * @return {String} ブラウザの使用言語
     */
    getLanguage: function () {
        var lang = navigator.userLanguage || navigator.browserLanguage || navigator.language;
        
        return lang && lang.substr(0, 2) || Jeeel.Language.getDefaultLocale();
    },

    /**
     * 現在のパスを取得する
     *
     * @return {String} パス
     */
    getPath: function () {
        return location.pathname;
    },
    
    /**
     * 現在のベースURLを取得する
     * 
     * @return {String} ベースURL
     */
    getBaseUrl: function () {
        var port = this.getPort();
        
        return this.getScheme()
             + '://'
             + this.getHostname()
             + (port && ':' + port);
    },

    /**
     * 現在のURLを取得する
     *
     * @return {String} URL
     */
    getUrl: function () {
        return location.href;
    },

    /**
     * 現在のURLを設定する(ページ遷移する)
     *
     * @param {String} url 遷移対象URL
     */
    setUrl: function (url) {
        if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
        
        location.href = url;
    },
    
    /**
     * 現在のURLをパラメータやフラグメントの付いていない状態で返す。
     * 
     * @return {String} URL
     */
    getUrlPath: function () {
        return location.href.replace(/\?.+$/, '');
    },
    
    /**
     * 現在のフラグメントを取得する
     * 
     * @return {String} フラグメント
     */
    getFragment: function () {
        return location.hash.replace('#', '');
    },

    /**
     * 現在のポートを取得する
     *
     * @return {String} ポート
     */
    getPort: function () {
        return location.port;
    },

    /**
     * 現在のスキームを取得する
     * 
     * @return {String} スキーム
     */
    getScheme: function () {
        return this._scheme;
    },

    /**
     * 現在のホストを取得する(host = hostname + port)
     *
     * @return {String} ホスト
     */
    getHost: function () {
        return location.host;
    },

    /**
     * 現在のホスト名を取得する
     *
     * @return {String} ホスト名
     */
    getHostname: function () {
        return location.hostname;
    },

    /**
     * 現在のURLパラメータを示す文字列を取得する<br />
     * 先頭に?は付かない
     *
     * @return {String} Urlパラメータを示す文字列
     */
    getQueryString: function () {
        return this._query;
    },

    /**
     * 現在のURLパラメータを取得する<br />
     * URLパラメータは連想配列でもよいが、<br />
     * 正しく記述されている必要がある<br />
     * 以下は正しく取得できない可能性のある例である
     *
     * <pre>
     * ?a[&]=2&a[2]=3   //配列の添え字に&が入っている
     * ?a[=]=2&a[2]=3   //配列の添え字に=が入っている
     * ?a[[1]]=2&a[2]=3 //配列の添え字に[]のいずれかが入っている
     * ?a[1][=2&a[2]=3  //配列の形式が途中で途切れている
     * ?a[]=2&a[]=3     //配列の添え字がない
     * </pre>
     *
     * @param {String} [overwriteName] 本来上書きされてしまう要素を取得したい時に使用する名前(内部はJeeel.Object.Item[]になる)
     * @return {Hash} URLパラメータの連想配列
     */
    getQuery: function (overwriteName) {
        return (overwriteName ? new Jeeel.Filter.Url.QueryParameter(overwriteName) : this._queryFilter).filter(this._query);
    },
    
    /**
     * リファラを取得する
     * 
     * @return {String} リファラ
     */
    getReferrer: function () {
        return Jeeel._doc.referrer;
    },
    
    /**
     * 現在のURLを解析して結果を返す
     * 
     * @return {Hash} URL解析結果の連想配列
     */
    parseUrl: function () {
        var parser = Jeeel.Filter.Url.Parser.create();
        
        return parser.parse(this.getUrl());
    },
    
    /**
     * 現在のURLの履歴を残さずに次のURLに移行する
     * 
     * @param {String} url 移行先URL
     */
    redirect: function (url) {
        if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
        
        location.replace(url);
    },

    /**
     * クッキーが有効かどうかを返す
     *
     * @return {Boolean} クッキーが有効かどうか
     */
    isCookieEnabled: function () {
        return navigator.cookieEnabled;
    },

    /**
     * 現在のページが暗号化されているかどうかを返す
     *
     * @return {Boolean} 暗号化されているかどうか
     */
    isSecure: function () {},
    
    /**
     * ブラウザの対応MIMEタイプの一覧を取得する
     * 
     * @return {Hash} MimeTypeリスト(キーがタイプになる)
     */
    getMimeTypes: function () {
        var res = {};
        
        for (var i = 0, l = navigator.mimeTypes.length; i < l; i++) {
            res[navigator.mimeTypes[i].type] = navigator.mimeTypes[i];
        }
        
        return res;
    },
    
    /**
     * VMLの有効・無効化を行う(IE限定: それ以外のブラウザでは何も起こらない)
     * 
     * @param {Boolean} enable 有効にするかどうか
     */
    enableVml: function (enable) {
        if ( ! Jeeel._doc.uniqueID) {
            return;
        }
        
        var root = Jeeel.Document.getDocumentElement();

        root = Jeeel.Dom.Element.create(root);

        if (enable) {
            if ( ! root.hasAttribute('xmlns:v')) {
                root.setAttribute('xmlns:v', 'urn:schemas-microsoft-com:vml');
            }
            
            if ( ! arguments.callee._tag) {
                var self = arguments.callee;
                
                Jeeel.Timer.setTimeout(function () {
                    var style = 'v\\:* { behavior: url(#default#VML); }';

                    self._tag = Jeeel.Loader.addStyle(style);
                }, 1);
            }
        } else {
            if (root.hasAttribute('xmlns:v')) {
                root.removeAttribute('xmlns:v');
            }
            
            if (arguments.callee._tag) {
                Jeeel.Dom.Element.create(arguments.callee._tag).remove();
                
                delete arguments.callee._tag;
            }
        }
    },
    
    /**
     * @ignore
     */
    _init: function () {
        
        var uao = this._ua;

        if ( ! uao) {
            delete this._init;
            return;
        }
        
        var trueF  = Jeeel.Function.Template.RETURN_TRUE;
        var falseF = Jeeel.Function.Template.RETURN_FALSE;
        
        this.isSecure = (this._scheme === 'https' ? trueF : falseF);
        
        if ( ! this._query) {
            this.getQuery = Jeeel.Function.Template.RETURN_EMPTY_HASH;
        }

        var idx;
        
        this.isIPhone = (uao.indexOf("(iPhone;") !== -1 ? trueF : falseF);
        this.isIPad = (uao.indexOf("(iPad;") !== -1 ? trueF : falseF);
        this.isIPod = (uao.indexOf("(iPod;") !== -1 ? trueF : falseF);
        this.isMobile = (uao.indexOf("Mobile") !== -1 ? trueF : falseF);
        this.isAndroid = (uao.indexOf("Android") !== -1 ? trueF : falseF);
        
        this.isWorker = (Jeeel._global && Jeeel._global.importScripts ? trueF : falseF);

        idx = uao.indexOf("Firefox");
        
        if (idx !== -1) {
            
            this._browserVersion = uao.substring(idx + 8, uao.length);
            
            /**
             * @ignore
             */
            this.isFirefox = function (version) {
                if (version) {
                    return this._ua.indexOf("Firefox/" + version + '.') !== -1;
                }
                
                return true;
            };
            
            /**
             * @ignore
             */
            this.getBrowserName = function () {
                return 'Mozilla Firefox';
            };
        } else {
            this.isFirefox = falseF;
        }
        
        idx = uao.indexOf("MSIE");
        
        if (idx !== -1) {
            
            this._browserVersion = uao.substring(idx + 5, uao.indexOf(';', idx));
            
            /**
             * @ignore
             */
            this.isInternetExplorer = function (version) {
                if (version) {
                    return this._ua.indexOf("MSIE " + version + '.') !== -1;
                }
                
                return true;
            };
            
            /**
             * @ignore
             */
            this.getBrowserName = function () {
                return 'Microsoft Internet Explorer';
            };
        } else {
            this.isInternetExplorer = falseF;
        }
        
        idx = uao.indexOf("Chrome");
        
        if (idx !== -1) {
            this._browserVersion = uao.substring(idx + 7, uao.indexOf(' ', idx));
            
            /**
             * @ignore
             */
            this.isChrome = function (version) {
                if (version) {
                    return this._ua.indexOf("Chrome/" + version + '.') !== -1;
                }
                
                return true;
            };
            
            /**
             * @ignore
             */
            this.getBrowserName = function () {
                return 'Google Chrome';
            };
        } else {
            this.isChrome = falseF;
        }
        
        if (uao.indexOf("Safari") !== -1 && idx === -1) {
            idx = uao.indexOf("Version");
            
            this._browserVersion = uao.substring(idx + 8, uao.indexOf(' ', idx));
            
            /**
             * @ignore
             */
            this.isSafari = function (version) {
                if (version) {
                    return this._ua.indexOf("Version/" + version + '.') !== -1;
                }
                
                return true;
            };
            
            /**
             * @ignore
             */
            this.getBrowserName = function () {
                return 'Apple Safari';
            };
        } else {
            this.isSafari = falseF;
        }
        
        if (uao.indexOf("Opera") !== -1) {
            idx = uao.indexOf("Version");
            
            this._browserVersion = uao.substring(idx + 8, uao.length);
            
            /**
             * @ignore
             */
            this.isOpera = function (version) {
                if (version) {
                    return this._ua.indexOf("Version/" + version + '.') !== -1;
                }
                
                return true;
            };
            
            /**
             * @ignore
             */
            this.getBrowserName = function () {
                return 'ASA Opera';
            };
        } else {
            this.isOpera = falseF;
        }
        
        this.isTridentEngine = (this.isInternetExplorer() || uao.indexOf("Trident/") !== -1 ? trueF : falseF);
        this.isGeckoEngine = (uao.indexOf("Gecko/") !== -1 ? trueF : falseF);
        this.isWebkitEngine = (uao.indexOf("AppleWebKit/") !== -1 ? trueF : falseF);
        this.isPrestoEngine = (uao.indexOf("Presto/") !== -1 ? trueF : falseF);
        
        delete this._init;
    }
};

Jeeel.UserAgent._init();

// 初期のロケールを設定
if (Jeeel.UserAgent.isWorker()) {
    Jeeel.Language.setLocale(Jeeel.UserAgent.getQuery().lang || Jeeel.Language.getDefaultLocale());
} else {
    Jeeel.Language.setLocale(Jeeel.UserAgent.getLanguage());
}

Jeeel.file.Jeeel.UserAgent = [];

if (Jeeel._extendMode.Geolocation && Jeeel._global.navigator && Jeeel._global.navigator.geolocation) {
    Jeeel.file.Jeeel.UserAgent[Jeeel.file.Jeeel.UserAgent.length] = 'Geolocation';
}

Jeeel._autoImports(Jeeel.directory.Jeeel.UserAgent, Jeeel.file.Jeeel.UserAgent);
Jeeel.directory.Jeeel.UserAgent.Geolocation = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.UserAgent + 'Geolocation/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 位置情報について操作するクラス
 */
Jeeel.UserAgent.Geolocation = function () {
    
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.UserAgent.Geolocation} 作成したインスタンス
 */
Jeeel.UserAgent.Geolocation.create = function () {
    return new this();
};
    
Jeeel.UserAgent.Geolocation.prototype = {
  
    /**
     * 成功コールバック
     * 
     * @type Hash
     * @private
     */
    _successMethod: null,
    
    /**
     * エラーコールバック
     * 
     * @type Hash
     * @private
     */
    _errorMethod: null,
    
    /**
     * 取得する情報の正確性
     * 
     * @type Boolean
     * @private
     */
    _enableHighAccuracy: false,
    
    /**
     * 接続タイムアウト
     * 
     * @type Integer
     * @private
     */
    _timeout: null,
    
    /**
     * キャッシュの有効期限
     * 
     * @type Integer
     * @private
     */
    _maximumAge: null,
    
    /**
     * 位置情報監視ID
     * 
     * @type Integer
     * @private
     */
    _watchId: null,
    
    /**
     * 最後に取得した位置情報
     * 
     * @type Jeeel.UserAgent.Geolocation.Position
     * @private
     */
    _lastPosition: null,
    
    /**
     * 成功メソッドの登録
     *
     * @param {Function} callBack 成功メソッド<br />
     *                             コールバックメソッドに渡される引数は位置情報となる<br />
     *                             void callBack(Jeeel.UserAgent.Geolocation.Position position)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    setSuccessMethod: function (callBack, thisArg) {
        this._successMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 例外メソッドの登録
     *
     * @param {Function} callBack 例外メソッド<br />
     *                             コールバックメソッドに渡される引数はエラーとなる<br />
     *                             void callBack(Error error)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    setErrorMethod: function (callBack, thisArg) {
        this._errorMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
       
    /**
     * 取得に掛かる時間の制限を設けタイムアウトの設定をする
     * 
     * @param {Integer} timeout タイムアウトの時間(ミリ秒)
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    setTimeout: function (timeout) {
        this._timeout = timeout;
        
        return this;
    },
    
    /**
     * キャッシュの有効期限
     * 
     * @param {Integer} maximumAge キャッシュが破棄されるまでの時間(ミリ秒)
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    setMaximumAge: function (maximumAge) {
        this._maximumAge = maximumAge;
        
        return this;
    },
    
    /**
     * 正確性の高い位置情報を要求するかどうかを設定する
     * 
     * @param {Booleans} enable 正確な情報を要求するかどうか
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    enableHighAccuracy: function (enable) {
        this._enableHighAccuracy = !!enable;
        
        return this;
    },
    
    /**
     * 最後の取得した位置情報を取得する<br />
     * なお成功メソッドが呼び出された後に更新が行われる
     * 
     * @return {Jeeel.UserAgent.Geolocation.Position} 位置情報を示すインスタンス
     */
    getLastPosition: function () {
        return this._lastPosition;
    },
    
    /**
     * 現在の位置情報を取得する
     * 
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    getCurrentPosition: function () {
        if (this._watchId) {
            throw new Error('このインスタンスは位置情報の監視を行っています。\n監視中はこのメソッドを使用できません。');
        }
        
        var self = this;

        navigator.geolocation.getCurrentPosition(
            function (pos) {
                pos = new Jeeel.UserAgent.Geolocation.Position(pos);
                
                if (self._successMethod) {
                    self._callMethod('_successMethod', pos);
                }
                
                self._lastPosition = pos;
            },
            function (error) {
                if (self._errorMethod) {
                    self._callMethod('_errorMethod', error);
                } else {
                    Jeeel.errorHtmlDump('Error', error.name, error.fileName + '(' + error.lineNumber + ')', error.message);
                }
            },
            this._getOption()
        );
          
        return this;
    },
    
    /**
     * 位置情報の監視を行う
     * 
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    watchPosition: function () {
        if (this._watchId) {
            throw new Error('既に位置情報の監視を行っています。位置情報の監視は1つまでです。');
        }
        
        var self = this;
        
        this._watchId = navigator.geolocation.watchPosition(
            function (pos) {
                pos = new Jeeel.UserAgent.Geolocation.Position(pos);
                
                if (self._successMethod) {
                    self._callMethod('_successMethod', pos);
                }
                
                self._lastPosition = pos;
            },
            function (error) {
                if (self._errorMethod) {
                    self._callMethod('_errorMethod', error);
                } else {
                    Jeeel.errorHtmlDump('Error', error.name, error.fileName + '(' + error.lineNumber + ')', error.message);
                }
            },
            this._getOption()
        );
          
        return this;
    },
    
    /**
     * 位置情報の監視を破棄する
     * 
     * @return {Jeeel.UserAgent.Geolocation} 自身のインスタンス
     */
    clearWatch: function () {
        if ( ! this._watchId) {
            throw new Error('このインスタンスで位置情報の監視は行っていません。');
        }
        
        navigator.geolocation.clearWatch(this._watchId);
        
        this._watchId = null;
        
        return this;
    },
    
    /**
     * オプションを作成して返す
     * 
     * @return {Hash} オプション
     * @private
     */
    _getOption: function () {
        var option = {
            enableHighAccuracy: this._enableHighAccuracy
        };
        
        if (Jeeel.Type.isInteger(this._timeout)) {
            option.timeout = this._timeout;
        }
        
        if (Jeeel.Type.isInteger(this._maximumAge)) {
            option.timeout = this._maximumAge;
        }
        
        return option;
    },
    
    _callMethod: function (name, arg) {
        this[name].func.call(this[name].thisArg || this, arg);
    }
};

Jeeel.file.Jeeel.UserAgent.Geolocation = ['Position'];

Jeeel._autoImports(Jeeel.directory.Jeeel.UserAgent.Geolocation, Jeeel.file.Jeeel.UserAgent.Geolocation);
/**
 * コンストラクタ
 * 
 * @class 位置情報を保持するクラス
 * @param {Geoposition} position 基となる位置情報
 */
Jeeel.UserAgent.Geolocation.Position = function (position) {
    this._position = position;
    this._timestamp = Jeeel.Object.Date.create(position.timestamp);
};

Jeeel.UserAgent.Geolocation.Position.prototype = {
  
    /**
     * 基となる位置情報
     * 
     * @type Geoposition
     * @private
     */
    _position: null,
    
    /**
     * 位置情報を取得した時刻
     * 
     * @type Jeeel.Object.Date
     * @private
     */
    _timestamp: null,
    
    /**
     * 経度を取得する
     * 
     * @return {Number} 経度
     */
    getLatitude: function () {
        return this._position.latitude;
    },
    
    /**
     * 緯度を取得する
     * 
     * @return {Number} 緯度
     */
    getLongitude: function () {
        return this._position.longitude;
    },
    
    /**
     * 標高を取得する
     * 
     * @return {Number} 標高
     */
    getAltitude: function () {
        return this._position.altitude;
    },
    
    /**
     * 経度・緯度の正確さを取得する
     * 
     * @return {Number} 正確さ
     */
    getAccuracy: function () {
        return this._position.accuracy;
    },
    
    /**
     * 標高の正確さを取得する
     * 
     * @return {Number} 正確さ
     */
    getAltitudeAccuracy: function () {
        return this._position.altitudeAccuracy;
    },
    
    /**
     * デバイスの進行方向を取得する
     * 
     * @return {Number} 進行方向
     */
    getHeading: function () {
        return this._position.heading;
    },
    
    /**
     * デバイスの進行速度を取得する
     * 
     * @return {Number} 進行速度
     */
    getSpeed: function () {
        return this._position.speed;
    },
    
    /**
     * 位置情報が取得された時刻を示すインスタンスを返す
     * 
     * @return {Jeeel.Object.Date} 位置情報の取得時刻を示すインスタンス
     */
    getTimestamp: function () {
        return this._timestamp;
    }
};

Jeeel.directory.Jeeel.Dom = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Dom/';
    }
};

/**
 * @namespace Domに関するネームスペース
 * @see Jeeel.Dom.Event
 * @see Jeeel.Dom.Event.Type
 * @see Jeeel.Dom.Element
 * @see Jeeel.Dom.ElementOperator
 * @see Jeeel.Dom.Document
 * @see Jeeel.Dom.Window
 * @example
 * Domネームスペース以下はDOM関連の要素の操作やイベントのハンドリングなど多岐に渡るメイン機能の一つ
 * その中でも特に使用される頻度が高いのは以下のクラスである
 * Jeeel.Dom.Event
 * Jeeel.Dom.Element
 * Jeeel.Dom.ElementOperator
 * Jeeel.Dom.Document
 * Jeeel.Dom.Window
 * 
 * Jeeel.Dom.Event
 * このクラスはイベント関連の制御を一括で行うクラスである
 * このクラスはインスタンスを作成してから何かをする訳ではなく、静的メソッドからイベントを登録し呼び出されたタイミングで処理を行う
 * 
 * 例：
 * var Test = {
 *     
 *     // evがJeeel.Dom.Eventインスタンスになる
 *     onClick: function (ev) {
 *         console.log(ev.mousePoint.x, ev.mousePoint.y);
 *     }
 * };
 * 
 * Jeeel.Dom.Event.addEventListener($ID('test'), Jeeel.Dom.Event.Type.CLICK, Test.onClick, Test);
 * 
 * addEventListenerでイベントを登録する際に引数は順に要素, イベント名, 関数, 関数内でのthisとなる
 * 
 * 
 * Jeeel.Dom.Element
 * このクラスは良く使われる可能性の高いクラスのひとつである
 * このクラスはHTMLElementには無い幾つかの拡張機能を提供するクラスである
 * このクラスはHTMLElementを引数に取ってインスタンス化してから使用する
 * 
 * 例：
 * var elm = new Jeeel.Dom.Element($ID('test')); //他にもJeeel.Dom.Element.create($ID('test'))や$ELM($ID('test'))でも同じ意味である
 * elm.setText('<p>Pタグ</p>'); // 文字列としてinnnerHTMLを書き換える
 * elm.setHtml('<p>Pタグ</p>'); // HTMLとしてinnnerHTMLを書き換える
 * elm.hasClassName('test'); // testという名前のクラスを保持しているかどうか調べる
 * elm.toggle(1000); // jQueryでお馴染みのtoggleとほぼ同等でアニメーションを行う
 * elm.insertTop(document.createElement('div')); // Prototype.jsでお馴染みのInsertion.Topとほぼ同等でラッパーしている要素無いのトップに指定要素を追加する
 * elm.up(); // ラッパーしている要素自体をひとつ上に動かす(兄要素と交換する)
 * 
 * 他にも様々な機能があるがそれらはJeeel.Dom.Elementを参照
 * 
 * 
 * Jeeel.Dom.ElementOperator
 * 場合によってはもっとも多く使用される可能性の高いクラスである
 * 先のJeeel.Dom.Elementを更にラッパーし複数の要素に対して操作を行うクラスである
 * jQueryを参考にして作成してあるので近い機能が多く含まれている
 * このクラスはインスタンス化の際にセレクタ、HTML要素、HTML要素の配列、NodeList数多くの種類の引数を取ることが出来る
 * 
 * 例：
 * var elms = new Jeeel.Dom.ElementOperator('#test .child'); // Jeeel.Dom.ElementOperator.create('#test .child')や$ELMOP('#test .child')でも同じ意味である
 * elms.addClass('hoge'); // 現在保持する全ての要素にクラス hoge を追加する
 * elms.addClick(function (ev) { console.log('click'); }); // 現在保持する全ての要素にクリックイベントを追加する
 * elms.$TAG('p'); // 現在保持する全ての要素内のpタグを検索して新たにJeeel.Dom.ElementOperatorインスタンスを作成して返す
 * elms.filterOdd(); // 現在保持する全ての要素の内奇数の要素のみを収集し新たにインスタンス化して返す
 * elms.setText('chain'); // 現在保持する全ての要素のinnnerHTMLを文字列 "chain" に書き換える
 * 
 * 
 * Jeeel.Dom.Document
 * このクラスは直接インスタンス化する機会が殆ど無い
 * documentのラッパークラスである
 * このクラスの機能を使うときは基本的にJeeel.Documentに代入されているインスタンスを使用する
 * 検索系のショートカットがあるので直接検索メソッドが呼ばれることは殆ど無い
 * 
 * 例：
 * Jeeel.Document.getElementsByClassName('child'); // $CLASS('child')と同じ、ドキュメント上からchildクラスの要素を検索して返す
 * Jeeel.Document.getElementsBySelector('#test > .child'); // $QUERY('#test > .child')と同じ、ドキュメント上からIDがtestの直下のchildクラス要素を検索して返す
 * Jeeel.Document.createElementList('<p>Pタグ</p>'); //指定したHTML文字列から要素の配列を作成して返す
 * Jeeel.Document.getDocumentSize(); // 現在のドキュメントのサイズを取得する(スクロールの増減を含めた値)
 * 
 * 
 * Jeeel.Dom.Window
 * Jeeel.Dom.Documentと同じく直接インスタンス化する機会が殆ど無いクラスである
 * windowのラッパークラスである
 * このクラスの機能を使うときは基本的にJeeel.Windowに代入されているインスタンスを使用する
 * 
 * 例：
 * Jeeel.Window.getWindowSize(); // 現在のウィンドウのサイズを取得する(スクロールの増減を含めない値)
 * Jeeel.Window.createWindowOpener(); // window.openをラッピングし、新しく開くウィンドウに対してPOSTデータを送る機能などを追加したインスタンスを返す
 */
Jeeel.Dom = {

};

Jeeel.file.Jeeel.Dom = ['Core', 'Node', 'Window', 'Document', 'Xml', 'Event', 'Style', 'Element', 'ElementOperator', 'Selector', 'Behavior', 'SearchOption'];

if (Jeeel._auto) {
    Jeeel.Dom._tmp = function () {
        for (var i = 1, l = Jeeel.file.Jeeel.Dom.length; i < l; i++) {
            Jeeel._import(Jeeel.directory.Jeeel.Dom, Jeeel.file.Jeeel.Dom[i]);
        }

        delete Jeeel.Dom._tmp;
    };

    Jeeel._import(Jeeel.directory.Jeeel.Dom, Jeeel.file.Jeeel.Dom[0]);
}
Jeeel.directory.Jeeel.Dom.Core = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Core/';
    }
};

/**
 * @namespace DOMの関連のクラスの核になる機能を保有
 */
Jeeel.Dom.Core = {
    
};

Jeeel.file.Jeeel.Dom.Core = ['Searcher'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Core, Jeeel.file.Jeeel.Dom.Core);

if (Jeeel.Dom._tmp) {
    Jeeel.Dom._tmp();
}
/**
 * コンストラクタ
 * 
 * @class 指定した要素内の検索を行うメソッドを自動選択して提供するクラス
 * @param {Node} target 検索対象ノード
 */
Jeeel.Dom.Core.Searcher = function (target) {
    if ( ! target || ! target.nodeType) {
        return null;
    }
    
    this._target = target;
    this._init();
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Node} target 検索対象ノード
 * @return {Jeeel.Dom.Core.Searcher} 作成したインスタンス
 */
Jeeel.Dom.Core.Searcher.create = function (target) {
    return new this(target);
};

/**
 * キャッシュ
 * 
 * @type Hash
 */
Jeeel.Dom.Core.Searcher.caches = {};

Jeeel.Dom.Core.Searcher.prototype = {
  
    /**
     * 検索対象要素
     * 
     * @type Node
     * @private
     */
    _target: null,
    
    /**
     * このElement内から指定IDのHTML要素を取得する
     *
     * @param {String} id 検索ID
     * @return {Element} 取得したElement
     */
    getElementById: function (id) {
        return this._target.getElementById(id) || null;
    },
    
    /**
     * このElement内から指定ClassのHTML要素を取得する
     *
     * @param {String|String[]} className 検索Class
     * @return {Element[]} 取得したElement配列
     */
    getElementsByClassName: function (className) {

        if (Jeeel.Type.isArray(className)) {
            return this.searchElementsByClassName(className);
        }
      
        var res = this._target.getElementsByClassName(className);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定NameのHTML要素を取得する
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする
     *
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch=false] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか
     * @return {Element[]} 取得したElement配列
     */
    getElementsByName: function (name, submitSearch) {
        
        if (Jeeel.Type.isArray(name) || submitSearch) {
            return this.searchElementsByName(name, submitSearch);
        }
        
        var res = this._target.getElementsByName(name);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定TagのHTML要素を取得する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Element[]} 取得したElement配列
     */
    getElementsByTagName: function (tagName) {
      
        if (Jeeel.Type.isArray(tagName)) {
            return this.searchElementsByTagName(tagName);
        }
      
        var res = this._target.getElementsByTagName(tagName);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定属性が指定値のHTML要素を取得する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByAttribute: function (attribute, value) {
        var res = this._target.getElementsByAttribute(attribute, value);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定プロパティが指定値のHTML要素を取得する<br />
     * Elementのプロパティである事に注意
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value プロパティ値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByProperty: function (property, value) {
        var res = this._target.getElementsByProperty(property, value);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内部に絞り込みを掛ける<br />
     * 現在のHTML内に存在しない要素は取れない
     *
     * @param {String} selector CSSと同じ絞り込みセレクタ
     * @return {Element[]} 絞り込んだElement配列
     */
    getElementsBySelector: function (selector) {
        var res = this._target.querySelectorAll(selector);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定IDのHTML要素を取得する
     *
     * @param {String} id 検索ID
     * @return {Element} 取得したElement
     */
    selectElementById: function (id) {
        return this._target.querySelector('#' + id) || null;
    },
    
    /**
     * このElement内から指定ClassのHTML要素を取得する
     *
     * @param {String|String[]} className 検索Class
     * @return {Element[]} 取得したElement配列
     */
    selectElementsByClassName: function (className) {

        if (Jeeel.Type.isArray(className)) {
            className = className.join(', .');
        }
      
        var res = this._target.querySelectorAll('.' + className);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定NameのHTML要素を取得する
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする
     *
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch=false] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか
     * @return {Element[]} 取得したElement配列
     */
    selectElementsByName: function (name, submitSearch) {
      
        var eq = '=';
        
        if (submitSearch) {
            eq = '^=';
        }
        
        if ( ! Jeeel.Type.isArray(name)) {
            name = [name];
        }
        
        for (var i = name.length; i--;) {
            name[i] = '[name' + eq + '"' + name[i] + '"]';
        }
        
        var res = this._target.querySelectorAll(name.join(', '));
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定TagのHTML要素を取得する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Element[]} 取得したElement配列
     */
    selectElementsByTagName: function (tagName) {
      
        if (Jeeel.Type.isArray(tagName)) {
            tagName = tagName.join(', ');
        }
      
        var res = this._target.querySelectorAll(tagName);
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定属性が指定値のHTML要素を取得する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    selectElementsByAttribute: function (attribute, value) {
        var res = this._target.querySelectorAll('[' + attribute + (value === '*' ? '' : '="' + value + '"') + ']');
        
        return Jeeel.Hash.toArray(res);
    },
    
    /**
     * このElement内から指定IDのHTML要素を取得する<br />
     * この際既存のAPIに頼らずに検索を実行する
     *
     * @param {String} id 検索ID
     * @return {Element} 取得したElement
     */
    searchElementById: function (id) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        
        /**
         * @ignore
         */
        var search = function (elm, id, f) {
            if ( ! f && elm.id === id) {
                return elm;
            }
            
            var tmp, child = elm.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    tmp = search(child, id);

                    if (tmp) {
                        return tmp;
                    }
                }

                child = child.nextSibling;
            }

            return null;
        };
        
        /**
         * @ignore
         */
        this.searchElementById = function (id) {
            return id && search(this._target, id, true) || null;
        };
        
        if (arguments.callee === this.getElementById) {
            this.constructor.caches[this._target.nodeType].getElementById = this.getElementById = this.searchElementById;
        }
        
        return this.searchElementById(id);
    },
    
    /**
     * このElement内から指定ClassのHTML要素を取得する<br />
     * この際既存のAPIに頼らずに検索を実行する
     *
     * @param {String|String[]} className 検索Class
     * @return {Element[]} 取得したElement配列
     */
    searchElementsByClassName: function (className) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        
        /**
         * @ignore
         */
        var search = function (res, target, reg, f) {

            var className = target.className;
            
            if ( ! f && className.match && className.match(reg)) {
                res[res.length] = target;
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, reg);
                }

                child = child.nextSibling;
            }
        };
        
        /**
         * @ignore
         */
        this.searchElementsByClassName = function (className) {
            var res = [];
            
            if ( ! className) {
                return res;
            }
            
            var isArr = Jeeel.Type.isArray(className),
                reg;
            
            if (isArr) {
                
                if (className.length === 0) {
                    return res;
                }
                
                reg = new RegExp('(?:^| )' + className.join('|') + '(?: |$)', 'i');
            } else {
                
                reg = new RegExp('(?:^| )' + className + '(?: |$)', 'i');
            }

            search(res, this._target, reg, true);
            
            return res;
        };
        
        if (arguments.callee === this.getElementsByClassName) {
            this.constructor.caches[this._target.nodeType].getElementsByClassName = this.getElementsByClassName = this.searchElementsByClassName;
        }
        
        return this.searchElementsByClassName(className);
    },

    /**
     * このElement内から指定NameのHTML要素を取得する<br />
     * この際既存のAPIに頼らずに検索を実行する
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする
     *
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch=false] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか
     * @return {Element[]} 取得したElement配列
     */
    searchElementsByName: function (name, submitSearch) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        
        /**
         * @ignore
         */
        var search = function (res, target, reg, s, f) {

            var name = target.name;
              
            if ( ! f && name) {
                if (s) {
                    if (name.match(reg)) {
                        res[res.length] = target;
                    }
                } else {
                    if (name === reg) {
                        res[res.length] = target;
                    }
                }
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, reg, s);
                }

                child = child.nextSibling;
            }
        };
        
        /**
         * @ignore
         */
        var multiSearch = function (res, target, regs, s, f) {

            var name = target.name;
              
            if ( ! f && name) {
                if (s) {
                    for (var i = regs.length; i--;) {
                        if (name.match(regs[i])) {
                            res[res.length] = target;
                            break;
                        }
                    }
                } else {
                    if (Jeeel.Hash.inHash(name, regs, true)) {
                        res[res.length] = target;
                    }
                }
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    multiSearch(res, child, regs, s);
                }

                child = child.nextSibling;
            }
        };
        
        /**
         * @ignore
         */
        this.searchElementsByName = function (name, submitSearch) {
            var res = [];
            
            if ( ! name) {
                return res;
            }

            var isArr = Jeeel.Type.isArray(name),
                l = isArr && name.length;
            
            // 配列かどうかで検索手法を切り替える
            if (isArr && l === 0) {
                return res;
            } else if (isArr && name.length > 1) {
  
                if (submitSearch) {
                    while (l--) {
                        name[l] = new RegExp('^' + Jeeel.String.escapeRegExp(name[l]) + '(?:$|\\[)');
                    }
                }

                multiSearch(res, this._target, name, submitSearch, true);
            } else {
                if (isArr) {
                    name = name[0];
                }
                
                if (submitSearch) {
                    name = new RegExp('^' + Jeeel.String.escapeRegExp(name) + '(?:$|\\[)');
                }
                
                search(res, this._target, name, submitSearch, true);
            }
            
            return res;
        };
        
        if (arguments.callee === this.getElementsByName) {
            this.constructor.caches[this._target.nodeType].getElementsByName = this.getElementsByName = this.searchElementsByName;
        }
        
        return this.searchElementsByName(name, submitSearch);
    },

    /**
     * このElement内から指定TagのHTML要素を取得する<br />
     * この際既存のAPIに頼らずに検索を実行する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Element[]} 取得したElement配列
     */
    searchElementsByTagName: function (tagName) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        
        /**
         * @ignore
         */
        var search = function (res, target, tag, f) {

            if ( ! f && (tag === '*' || target.nodeName.toUpperCase() === tag)) {
                res[res.length] = target;
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, tag);
                }

                child = child.nextSibling;
            }
        };
        
        /**
         * @ignore
         */
        var multiSearch = function (res, target, tags, f) {

            if ( ! f && Jeeel.Hash.inHash(target.nodeName.toUpperCase(), tags, true)) {
                res[res.length] = target;
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    multiSearch(res, child, tags);
                }

                child = child.nextSibling;
            }
        };
        
        /**
         * @ignore
         */
        this.searchElementsByTagName = function (tagName) {
            var res = [];
            
            if ( ! tagName) {
                return res;
            }
            
            var isArr = Jeeel.Type.isArray(tagName),
                l = isArr && tagName.length;
            
            if (isArr && l === 0) {
                return res;
            } else if (isArr && l > 1) {
                if (Jeeel.Hash.inHash('*', tagName, true)) {
                    search(res, this._target, '*', true);
                } else {
                    while (l--) {
                        tagName[l] = tagName[l].toUpperCase();
                    }
                    
                    multiSearch(res, this._target, tagName, true);
                }
            } else {
                if (isArr) {
                    tagName = tagName[0];
                }
                
                search(res, this._target, tagName.toUpperCase(), true);
            }

            return res;
        };
        
        if (arguments.callee === this.getElementsByTagName) {
            this.constructor.caches[this._target.nodeType].getElementsByTagName = this.getElementsByTagName = this.searchElementsByTagName;
        }
        
        return this.searchElementsByTagName(tagName);
    },

    /**
     * このElement内から指定属性が指定値のHTML要素を取得する<br />
     * この際既存のAPIに頼らずに検索を実行する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    searchElementsByAttribute: function (attribute, value) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        
        /**
         * @ignore
         */
        var search = function (res, target, attr, value, f) {

            if ( ! f && target.getAttribute) {
                var val = target.getAttribute(attr);

                if ((val && value === '*') || val === value) {
                    res[res.length] = target;
                }
            }
 
            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, attr, value);
                }

                child = child.nextSibling;
            }
        };
        
        /**
         * @ignore
         */
        this.searchElementsByAttribute = function (attribute, value) {
            var res = [];
            
            if ( ! attribute) {
                return res;
            }
            
            search(res, this._target, attribute, value, true);
            
            return res;
        };
        
        if (arguments.callee === this.getElementsByAttribute) {
            this.constructor.caches[this._target.nodeType].getElementsByAttribute = this.getElementsByAttribute = this.searchElementsByAttribute;
        }
        
        return this.searchElementsByAttribute(attribute, value);
    },
    
    /**
     * このElement内から指定プロパティが指定値のHTML要素を取得する<br />
     * この際既存のAPIに頼らずに検索を実行する<br />
     * Elementのプロパティである事に注意
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value プロパティ値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    searchElementsByProperty: function (property, value) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        
        /**
         * @ignore
         */
        var search = function (res, target, prop, value, f) {

            if ( ! f && prop in target) {
                var val = target[prop];

                if (value === '*' || val == value) {
                    res[res.length] = target;
                }
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    search(res, child, prop, value);
                }

                child = child.nextSibling;
            }
        };
        
        /**
         * @ignore
         */
        this.searchElementsByProperty = function (property, value) {
            var res = [];
            
            if ( ! property) {
                return res;
            }
            
            search(res, this._target, property, value, true);
            
            return res;
        };
        
        if (arguments.callee === this.getElementsByProperty) {
            this.constructor.caches[this._target.nodeType].getElementsByProperty = this.getElementsByProperty = this.searchElementsByProperty;
        }
        
        return this.searchElementsByProperty(property, value);
    },
    
    /**
     * このElement内部に絞り込みを掛ける<br />
     * この際既存のAPIに頼らずに検索を実行する<br />
     * 現在のHTML内に存在しない要素は取れない
     *
     * @param {String} selector CSSと同じ絞り込みセレクタ
     * @return {Element[]} 絞り込んだElement配列
     */
    searchElementsBySelector: function (selector) {
        /**
         * @ignore
         */
        this.searchElementsBySelector = function (selector) {
            if ( ! selector) {
                return [];
            }
            
            return Jeeel.Dom.Selector.create(selector).search(this._target);
        };
        
        if (arguments.callee === this.getElementsBySelector) {
            this.constructor.caches[this._target.nodeType].getElementsBySelector = this.getElementsBySelector = this.searchElementsBySelector;
        }
        
        return this.searchElementsBySelector(selector);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Core.Searcher,
    
    /**
     * @ignore
     */
    _init: function () {
        
        var key, cache = this.constructor.caches[this._target.nodeType];
        
        if (cache) {
            
            for (key in cache) {
                this[key] = cache[key];
            }
            
            return;
        }
        
        if ( ! this._target.getElementById) {
            this.getElementById = this._target.querySelectorAll && this.selectElementById || this.searchElementById;
        }
        
        if ( ! this._target.getElementsByClassName) {
            this.getElementsByClassName = this._target.querySelectorAll && this.selectElementsByClassName || this.searchElementsByClassName;
        }
        
        if ( ! this._target.getElementsByName) {
            this.getElementsByName = this._target.querySelectorAll && this.selectElementsByName || this.searchElementsByName;
        }
        
        if ( ! this._target.getElementsByTagName) {
            this.getElementsByTagName = this._target.querySelectorAll && this.selectElementsByTagName || this.searchElementsByTagName;
        }

        if ( ! this._target.getElementsByAttribute) {
            this.getElementsByAttribute = this._target.querySelectorAll && this.selectElementsByAttribute || this.searchElementsByAttribute;
        }
        
        if ( ! this._target.getElementsByProperty) {
            this.getElementsByProperty = this.searchElementsByProperty;
        }
        
//        if ( ! this._target.querySelectorAll || ! Jeeel.Type.isDocument(this._target)) {
            this.getElementsBySelector = this.searchElementsBySelector;
//        }
        
        cache = {};
        
        for (key in this) {
            if (key !== 'constructor' && key.indexOf('_') < 0) {
                cache[key] = this[key];
            }
        }
        
        this.constructor.caches[this._target.nodeType] = cache;
    }
};

/**
 * @namespace Nodeに関する事を保持するネームスペース
 */
Jeeel.Dom.Node = {
    
    /**
     * NodeがElement型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    ELEMENT_NODE: 1,

    /**
     * NodeがAttribute型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    ATTRIBUTE_NODE: 2,

    /**
     * NodeがText型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    TEXT_NODE: 3,
    
    /**
     * NodeがCDATASection型である事を示す定数
     * 
     * @type Integer
     * @constant
     */
    CDATA_SECTION_NODE: 4,
    
    /**
     * NodeがEntityReference型である事を示す定数
     * 
     * @type Integer
     * @constant
     */
    ENTITY_REFERENCE_NODE: 5,
    
    /**
     * NodeがEntity型である事を示す定数
     * 
     * @type Integer
     * @constant
     */
    ENTITY_NODE: 6,
    
    /**
     * NodeがProcessingInstruction型である事を示す定数
     * 
     * @type Integer
     * @constant
     */
    PROCESSING_INSTRUCTION_NODE: 7,

    /**
     * NodeがComment型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    COMMENT_NODE: 8,

    /**
     * NodeがDocument型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    DOCUMENT_NODE: 9,
    
    /**
     * NodeがDocumentType型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    DOCUMENT_TYPE_NODE: 10,

    /**
     * NodeがDocumentFragment型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    DOCUMENT_FRAGMENT_NODE: 11,
    
    /**
     * NodeがNotation型である事を示す定数
     *
     * @type Integer
     * @constant
     */
    NOTATION_NODE: 12
};
Jeeel.directory.Jeeel.Dom.Window = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Window/';
    }
};

/**
 * コンストラクタ
 * 
 * @class windowをラップして拡張するクラス
 * @param {Window|IFrameElement} [window] 対象のウィンドウ(iframe等で階層が違う場合に指定)
 * @throws {Error} windowが指定されてかつiframeやWindow型でない場合に発生
 */
Jeeel.Dom.Window = function (window) {
  
    if (Jeeel.Window && ( ! window || window === Jeeel._global)) {
        return Jeeel.Window;
    }
    
    if ( ! window) {
        window = Jeeel._global;
    } else if (window.nodeName && window.nodeName.toUpperCase() === 'IFRAME') {
        window = window.contentWindow;
    } else if (window instanceof Jeeel.Dom.Document) {
        this._document = window;
        window = window.getDocument();
        window = window.defaultView || window.parentWindow;
    }
    
    if ( ! Jeeel.Type.isWindow(window)) {
        throw new Error('引数はWindowまたはIFrameElementを渡してください。');
    }
    
    this._window = window;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Window|IFrameElement} [window] 対象のウィンドウ(iframe等で階層が違う場合に指定)
 * @return {Jeeel.Dom.Window} 作成したインスタンス
 */
Jeeel.Dom.Window.create = function (window) {
    return new this(window);
};

Jeeel.Dom.Window.prototype = {
    /**
     * 操作対象のWindow
     * 
     * @type Window
     * @protected
     */
    _window: null,
    
    /**
     * Windowに属するDocumentのラッパーインスタンス
     * 
     * @type Jeeel.Dom.Document
     * @private
     */
    _document: null,
    
    /**
     * setIntervalを高速化するためのインスタンス
     * 
     * @type Jeeel.Dom.Window.Interval
     * @private
     */
    _interval: null,
    
    /**
     * 操作しているWindowを取得する
     * 
     * @return {Window} 操作しているWindow
     */
    getWindow: function () {
        return this._window;
    },
    
    /**
     * このWindowに属するDocumentのラッパーインスタンスを取得する
     * 
     * @return {Jeeel.Dom.Document} Documentラッパーインスタンス
     */
    getDocument: function () {
        return this._document || (this._document = Jeeel.Dom.Document.create(this));
    },
    
    /**
     * 現在のウィンドウのサイズを取得する(ブラウザサイズの切り替えで値も変わる)
     * 
     * @return {Jeeel.Object.Size} サイズ
     */
    getWindowSize: function () {},
    
    /**
     * 現在のウィンドウのスクロール位置を取得する
     * 
     * @return {Jeeel.Object.Point} スクロール位置
     */
    getScrollPosition: function () {},
    
    /**
     * モードレスなサブウィンドウを開くためのインスタンスを作成する
     * 
     * @param {String} url サブウィンドウを開く際のURL
     * @return {Jeeel.Dom.Window.Opener.Window} 作成したインスタンス
     */
    createWindowOpener: function (url) {
        return new this.constructor.Opener.Window(this._window, url);
    },
    
    /**
     * モーダルなサブウィンドウを開くためのインスタンスを作成する
     * 
     * @param {String} url サブウィンドウを開く際のURL
     * @return {Jeeel.Dom.Window.Opener.Dialog} 作成したインスタンス
     * @ignore 未完成
     */
    createDialogOpener: function (url) {
        return new this.constructor.Opener.Dialog(this._window, url);
    },
    
    /**
     * 定期的に実行するタイマーをセットする(複数のタイマーをセットする場合はこの関数を使う事で高速化が図れる)
     * 
     * @param {Function|String} func 一定時間毎に呼び出されるコールバック
     * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数
     * @return {Integer} タイマーID
     */
    setInterval: function (func, interval, var_args) {
        if ( ! this._interval) {
            this._interval = new this.constructor.Interval(this._window);
        }
        
        return this._interval.addTask.apply(this._interval, arguments);
    },
    
    /**
     * 定期実行タイマーを破棄する(このインスタンスのsetIntervalで無ければ無効)
     * 
     * @param {Integer} intervalID 破棄対象のタイマーID
     * @return {Jeeel.Dom.Window} 自インスタンス
     */
    clearInterval: function (intervalID) {
        if ( ! this._interval) {
            return this;
        }
        
        this._interval.removeTask(intervalID);
        
        return this;
    },
    
    /**
     * このWindowにイベントを追加する<br />
     * 引数はJeeel.Dom.Event, このWindowになる
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Window} 自インスタンス
     */
    addEventListener: function (type, listener, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        Jeeel.Dom.Event.addEventListener(this._window, type, listener, thisArg);
        
        return this;
    },

    /**
     * イベントの削除を行う<br />
     * このインスタンスのaddEventListenerに対して行わなければ削除はできない
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @return {Jeeel.Dom.Window} 自インスタンス
     */
    removeEventListener: function (type, listener) {
        Jeeel.Dom.Event.removeEventListener(this._window, type, listener);

        return this;
    },
    
    /**
     * このWindowに設定されているイベントを任意のタイミングで実行する
     *
     * @param {String} type イベントタイプ
     * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
     * @return {Jeeel.Dom.Window} 自インスタンス
     * @ignore 未完成
     */
    dispatchEvent: function (type, option) {
        Jeeel.Dom.Event.dispatchEvent(this._window, type, option);
        
        return this;
    },
    
    /**
     * このWindowにオーバーレイを設定する
     * 
     * @param {Boolean} enable オーバーレイを有効にするかどうか
     * @param {Hash} [styles] zIndex, backgroundColor, opacityを独自に設定する場合に指定<br />
     *                         デフォルトは以下である<br />
     *                         zIndex: 1000, backgroundColor: '#000000', opacity: 0.75
     * @return {Jeeel.Dom.Window} 自インスタンス
     */
    setOverlay: function (enable, styles) {
        if ( ! styles) {
            styles = {};
        }
        
        var doc = this._document;
        var size, overlay = doc.getElementById('jeeel-window-overlay');
        
        if ( ! enable) {
            if (overlay) {
                Jeeel.Dom.Element.create(overlay).hide();
            }
            
            return this;
        }
        
        size = this._document.getDocumentSize();
        
        if (overlay) {
            overlay = new Jeeel.Dom.Element(overlay);
            overlay.setStyleList({
                zIndex: styles.zIndex || 1000,
                backgroundColor: styles.backgroundColor || '#000000',
                width: size.width + 'px',
                height: size.height + 'px',
                opacity: styles.opacity ||0.75
            }).show();

            return this;
        }
        
        overlay = new Jeeel.Dom.Element(doc.createElement('div'));

        overlay.setId('jeeel-window-overlay').setStyleList({
            position: 'absolute',
            top: '0px',
            left: '0px',
            zIndex: styles.zIndex || 1000,
            backgroundColor: styles.backgroundColor || '#000000',
            width: size.width + 'px',
            height: size.height + 'px',
            opacity: styles.opacity ||0.75
        }).setShim();
        
        doc.appendToBody(overlay.getElement());
        
        return this;
    },

    /**
     * コンストラクタ
     * 
     * @param {Window|IFrameElement} [window] 対象のウィンドウ(iframe等で階層が違う場合に指定)
     * @constructor
     */
    constructor: Jeeel.Dom.Window,
    
    /**
     * @ignore
     */
    _init: function () {
      
        var doc = Jeeel._doc,
            win = Jeeel._global;
        
        if ( ! doc) {
            delete this._init;
            return;
        }
        
        var body;
        
        if (win.innerWidth) {
          
            /**
             * @ignore
             */
            this.getWindowSize = function () {
                var win = this._window;

                return new Jeeel.Object.Size(win.innerWidth, win.innerHeight);
            };
            
            /**
             * @ignore
             */
            this.getScrollPosition = function () {
                var win = this._window;
                
                return new Jeeel.Object.Point(win.pageXOffset, win.pageYOffset);
            };
        } else if (doc.documentElement && doc.documentElement.clientWidth) {
          
            /**
             * @ignore
             */
            this.getWindowSize = function () {
                var root = this._document.getDocumentElement();

                return new Jeeel.Object.Size(root.clientWidth, root.clientHeight);
            };
            
            /**
             * @ignore
             */
            this.getScrollPosition = function () {
                var root = this._document.getDocumentElement();
                
                return new Jeeel.Object.Point(root.scrollLeft, root.scrollTop);
            };
        } else if ((body = doc.body || doc.createElement('body')) && 'clientWidth' in body) {
          
            /**
             * @ignore
             */
            this.getWindowSize = function () {
                var root = this._document.getBody();

                return new Jeeel.Object.Size(root.clientWidth, root.clientHeight);
            };
            
            /**
             * @ignore
             */
            this.getScrollPosition = function () {
                var root = this._document.getBody();
                
                return new Jeeel.Object.Point(root.scrollLeft, root.scrollTop);
            };
        } else {
          
            /**
             * @ignore
             */
            this.getWindowSize = function () {
                return new Jeeel.Object.Size(0, 0);
            };
            
            /**
             * @ignore
             */
            this.getScrollPosition = function () {
                return new Jeeel.Object.Point(0, 0);
            };
        }

        delete this._init;
    }
};

Jeeel.Dom.Window.prototype._init();

Jeeel.file.Jeeel.Dom.Window = ['Opener', 'Interval'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Window, Jeeel.file.Jeeel.Dom.Window);
Jeeel.directory.Jeeel.Dom.Window.Opener = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Window + 'Opener/';
    }
};

/**
 * @namespace ウィンドウやダイアログを開くためのクラスがあるネームスペース
 */
Jeeel.Dom.Window.Opener = {

};

Jeeel.file.Jeeel.Dom.Window.Opener = ['Abstract', 'Window', 'Dialog'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Window.Opener, Jeeel.file.Jeeel.Dom.Window.Opener);
/**
 * コンストラクタ
 * 
 * @abstractClass Opener系の抽象クラス
 */
Jeeel.Dom.Window.Opener.Abstract = function () {
    
};

Jeeel.Dom.Window.Opener.Abstract.prototype = {
    /**
     * 操作対象のWindow
     * 
     * @type Window
     * @private
     */
    _window: null,
    
    /**
     * 新しく開くウィンドウのURL
     * 
     * @type String
     * @private
     */
    _url: '',
    
    /**
     * HTTPメソッド
     * 
     * @type String
     * @private
     */
    _method: 'POST',

    /**
     * window.openの際にサーバー側に渡すパラメータ
     *
     * @type Jeeel.Parameter
     * @private
     */
    _params: null,
    
    /**
     * window.openの際のwindowオプション
     *
     * @type Jeeel.Parameter
     * @private
     */
    _options: null,
    
    /**
     * HTTPメソッドを取得する
     *
     * @return {String} HTTPメソッド(getまたはpost、大文字小文字は問わない)
     */
    getMethod: function () {
        return this._method;
    },
    
    /**
     * HTTPメソッドを設定する
     *
     * @param {String} method HTTPメソッド(getまたはpost、大文字小文字は問わない)
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setMethod: function (method) {
        if ( ! Jeeel.Type.isString(method)) {
            method = 'POST';
        }
        
        method = method.toUpperCase();

        if (method !== 'GET' && method !== 'POST') {
            method = 'POST';
        }

        this._method = method;

        return this;
    },
    
    /**
     * 新しく開くウィンドウのURLを取得する
     * 
     * @return {String} ウィンドウのURL
     */
    getUrl: function () {
        return this._url;
    },
    
    /**
     * 新しく開くウィンドウのURLを設定する
     * 
     * @param {String} url ウィンドウのURL
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setUrl: function (url) {
        this._url = url;
        
        return this;
    },
    
    /**
     * ウィンドウに渡すパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    get: function (key, defaultValue) {
        return this._params.get(key, defaultValue);
    },
    
    /**
     * ウィンドウに渡すパラメータ全取得
     *
     * @return {Hash} 値リスト
     */
    getAll: function () {
        return this._params.getAll();
    },
    
    /**
     * ウィンドウに渡すパラメータをセットする
     * 
     * @param {String} key キー
     * @param {Mixied} val 値
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    set: function (key, val) {
        this._params.set(key, val);
        
        return this;
    },
    
    /**
     * ウィンドウに渡すパラメータを総入れ替えする
     * 
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setAll: function (vals) {
        this._params.setAll(vals);
        
        return this;
    },
    
    /**
     * ウィンドウに渡すパラメータの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    unset: function (key) {
        this._params.unset(key);

        return this;
    },
    
    /**
     * ウィンドウのオプションの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getOption: function (key, defaultValue) {
        return this._options.get(key, defaultValue);
    },
    
    /**
     * ウィンドウのオプション全取得
     *
     * @return {Hash} 値リスト
     */
    getOptionAll: function () {
        return this._options.getAll();
    },
    
    /**
     * ウィンドウのオプションをセットする
     * 
     * @param {String} key キー
     * @param {String|Integer} val 値
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setOption: function (key, val) {
        this._options.set(key, val);
        
        return this;
    },
    
    /**
     * ウィンドウのオプションを総入れ替えする
     * 
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    setOptionAll: function (vals) {
        this._options.setAll(vals);
        
        return this;
    },
    
    /**
     * ウィンドウのオプションの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Dom.Window.Opener.Abstract} 自インスタンス
     */
    unsetOption: function (key) {
        this._options.unset(key);
        
        return this;
    },
    
    /**
     * ウィンドウを開く
     * 
     * @return {Mixied} 戻り値(子クラスの実装による)
     * @abstract
     */
    open: function () {
        throw new Error('実装されていません');
    }
};
/**
 * コンストラクタ
 * 
 * @class サブウィンドウの生成を管理するクラス
 * @param {Window} window サブウィンドウのオープン元となるWindow
 * @param {String} url サブウィンドウを開く際のURL
 * @throws {Error} windowが指定されていない場合に起こる
 * @throws {Error} urlが指定されていない場合に起こる
 */
Jeeel.Dom.Window.Opener.Window = function (window, url) {
    Jeeel.Dom.Window.Opener.Abstract.call(this);
    
    if ( ! Jeeel.Type.isWindow(window)) {
        throw new Error('Windowを指定してください。');
    } 
    else if ( ! Jeeel.Type.isString(url)) {
        throw new Error('URLを指定してください。');
    }
    
    this._window = window;
    this._url = url;
    
    this._params  = new Jeeel.Parameter();
    this._options = new Jeeel.Parameter();
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Window} window サブウィンドウのオープン元となるWindow
 * @param {String} url サブウィンドウを開く際のURL
 * @return {Jeeel.Dom.Window.Opener.Window} 作成したインスタンス
 */
Jeeel.Dom.Window.Opener.Window.create = function (window, url) {
    return new this(window, url);
};

Jeeel.Dom.Window.Opener.Window.prototype = {
  
    /**
     * 新しく開くウィンドウの名前
     * 
     * @type String
     * @private
     */
    _name: '',
  
    /**
     * 新しく開くウィンドウの名前を取得する
     * 
     * @return {String} ウィンドウの名前
     */
    getName: function () {
        return this._name;
    },
    
    /**
     * 新しく開くウィンドウの名前を設定する
     * 
     * @param {String} name ウィンドウの名前
     * @return {Jeeel.Dom.Window.Opener.Window} 自インスタンス
     */
    setName: function (name) {
        this._name = name;
        
        return this;
    },
  
    /**
     * 実際にウィンドウを開く
     * 
     * @return {Window} 開いたウィンドウ(ウィンドウを開けなかった場合はnull)
     */
    open: function () {
        var options = [];
        var ops = this._options.getAll();
        var markerName = this._name || '__MARK_WINDOW_NAME__';
        
        for (var key in ops) {
            options[options.length] = key + '=' + ops[key];
        }
        
        var window = this._window.open('', markerName, options.join(','));
        
        if ( ! window) {
            throw new Error('ウィンドウを作成出来ませんでした。');
        }
        
        var submitter = Jeeel.Net.Form.newForm(this._url, this._method);
        
        submitter.setAll(this._params.getAll())
                 .setTarget(markerName)
                 .submit();
                
        window.name = this._name;
        
        return window;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Window} window サブウィンドウのオープン元となるWindow
     * @param {String} url サブウィンドウを開く際のURL
     */
    constructor: Jeeel.Dom.Window.Opener.Window
};

Jeeel.Class.extend(Jeeel.Dom.Window.Opener.Window, Jeeel.Dom.Window.Opener.Abstract);
Jeeel.directory.Jeeel.Dom.Window.Opener.Dialog = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Window.Opener + 'Dialog/';
    }
};

/**
 * コンストラクタ
 * 
 * @class サブウィンドウの生成を管理するクラス
 * @param {Window} window サブウィンドウのオープン元となるWindow
 * @param {String} url サブウィンドウを開く際のURL
 * @throws {Error} windowが指定されていない場合に起こる
 * @throws {Error} urlが指定されていない場合に起こる
 * @ignore 未完成
 */
Jeeel.Dom.Window.Opener.Dialog = function (window, url) {
    Jeeel.Dom.Window.Opener.Abstract.call(this);
    
    if ( ! Jeeel.Type.isWindow(window)) {
        throw new Error('Windowを指定してください。');
    } 
    else if ( ! Jeeel.Type.isString(url)) {
        throw new Error('URLを指定してください。');
    }
    
    this._window = window;
    this._url = url;
    
    this._params  = new Jeeel.Parameter();
    this._options = new Jeeel.Parameter();
    this._args = new Jeeel.Parameter();
    this._method = 'GET';
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Window} window サブウィンドウのオープン元となるWindow
 * @param {String} url サブウィンドウを開く際のURL
 * @return {Jeeel.Dom.Window.Opener.Dialog} 作成したインスタンス
 */
Jeeel.Dom.Window.Opener.Dialog.create = function (window, url) {
    return new this(window, url);
};

Jeeel.Dom.Window.Opener.Dialog.prototype = {
  
    _args: null,
    
    /**
     * HTTPメソッドはGETのみ
     * 
     * @return {Jeeel.Dom.Window.Opener.Dialog} 自インスタンス
     */
    setMethod: function () {
        return this;
    },

    /**
     * ダイアログのパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getArgument: function (key, defaultValue) {
        return this._args.get(key, defaultValue);
    },
    
    /**
     * ダイアログのパラメータ全取得
     *
     * @return {Hash} 値リスト
     */
    getArgumentAll: function () {
        return this._args.getAll();
    },
    
    /**
     * ダイアログのパラメータをセットする
     * 
     * @param {String} key キー
     * @param {String|Integer} val 値
     * @return {Jeeel.Dom.Window.Opener.Dialog} 自インスタンス
     */
    setArgument: function (key, val) {
        this._args.set(key, val);
        
        return this;
    },
    
    /**
     * ダイアログのパラメータを総入れ替えする
     * 
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Dom.Window.Opener.Dialog} 自インスタンス
     */
    setArgumentAll: function (vals) {
        this._args.setAll(vals);
        
        return this;
    },
    
    /**
     * ダイアログのパラメータの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Dom.Window.Opener.Dialog} 自インスタンス
     */
    unsetArgument: function (key) {
        this._args.unset(key);
        
        return this;
    },

    /**
     * 実際にダイアログウィンドウを開く
     * 
     * @return {Mixied} ダイアログからの戻り値
     */
    open: function () {
        var options = [];
        var ops = this._options.getAll();
        
        for (var key in ops) {
            options[options.length] = key + '=' + ops[key];
        }
        
        var url;
        var prms = {};
        
        if (this._method == 'GET') {
            url = this._url + '?' + this._params.toQueryString();
            prms = this._args.getAll();
        } else {
            url = Jeeel.directory.Jeeel.Dom.Window.Opener.Dialog + 'Post.html';
            prms.Jeeel = Jeeel;
            prms.url = this._url;
            prms.method = this._method;
            prms.args = this._args.getAll();
            prms.params = this._params.getAll();
        }
        
        return this._window.showModalDialog(url, prms, options.join(';'));
    },
    
    /**
     * テンプレートを介してダイアログを開く
     * 
     * @param {Function} [callback] ページロード時のコールバック
     * @return {Mixied} ダイアログからの戻り値
     * @ignore
     */
    openTemplate: function (callback) {
        var options = [];
        var ops = this._options.getAll();
        
        for (var key in ops) {
            options[options.length] = key + '=' + ops[key];
        }
        
        var url = Jeeel.directory.Jeeel.Dom.Window.Opener.Dialog + 'Template.html?' + this._params.toQueryString();
        var prms = {
            Jeeel: Jeeel,
            parent: Jeeel._global,
            params: this._args.getAll(),
            callback: callback || Jeeel.Function.Template.EMPTY
        };

        return this._window.showModalDialog(url, prms, options.join(';'));
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Window} window サブウィンドウのオープン元となるWindow
     * @param {String} url サブウィンドウを開く際のURL
     */
    constructor: Jeeel.Dom.Window.Opener.Dialog
};

Jeeel.Class.extend(Jeeel.Dom.Window.Opener.Dialog, Jeeel.Dom.Window.Opener.Abstract);
Jeeel.directory.Jeeel.Dom.Window.Interval = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Window + 'Interval/';
    }
};

/**
 * コンストラクタ
 * 
 * @class タイマーの負荷を軽減し、クロスブラウザの違いを吸収するクラス
 * @param {Window} window setInterval,clearIntervalを保持するWindow
 */
Jeeel.Dom.Window.Interval = function (window) {
    this._window = window;
    this._timestamp = Jeeel.Object.Date.create();
    this._tasks = [];
    this._tasksHash = {};
    
    var self = this, interval = this.interval;
    
    /**
     * @ignore
     */
    this.interval = function () {
        interval.call(self);
    };
    
    this.start();
};

Jeeel.Dom.Window.Interval.prototype = {
    /**
     * タイマー関数保持オブジェクト
     * 
     * @type Window
     * @private
     */
    _window: null,
    
    /**
     * インスタンス作成時間
     * 
     * @type Jeeel.Object.Date
     * @private
     */
    _timestamp: null,
    
    /**
     * 有効タスク一覧
     * 
     * @type Jeeel.Dom.Window.Interval[]
     * @private
     */
    _tasks: [],
    
    /**
     * タスク参照Hashテーブル
     * 
     * @type Hash
     * @private
     */
    _tasksHash: {},
    
    /**
     * タスクの実行数に応じて変化するタスクIDの元
     * 
     * @type Integer
     * @private
     */
    _taskIndex: 0,
    
    /**
     * 実際のタイマーID
     * 
     * @type Integer
     * @private
     */
    _id: 0,
    
    /**
     * ロックをしているかどうか
     * 
     * @type Boolean
     * @private
     */
    _lock: false,
    
    /**
     * 現在のタイマーにタスクを追加する
     * 
     * @param {Function|String} task タスク
     * @param {Integer} delay どれくらい置きに実行するか(ミリ秒)
     * @param {Mixied} var_args 可変引数、タスクに渡す引数
     * @return {Integer} タスクID
     * @throws {Error} taskの型が正しくなかった際に発生
     */
    addTask: function (task, delay, var_args) {
        var id = ++this._taskIndex;
        var args = Array.prototype.slice.call(arguments, 2, arguments.length);
        
        if (Jeeel.Type.isString(task)) {
            task = new Function(task);
        } else if ( ! Jeeel.Type.isFunction(task)) {
            throw new Error('taskが文字列もしくは関数ではありません。');
        }
        
        this._tasks[this._tasks.length] = this._tasksHash[id] = new this.constructor.Task(task, delay, args);
        
        this.start();
        
        args = null;
        
        return id;
    },
    
    /**
     * タイマーのタスクを破棄する
     * 
     * @param {Integer} id タスクID
     * @return {Jeeel.Dom.Window.Interval} 自インスタンス
     */
    removeTask: function (id) {
        var task = this._tasksHash[id];
        
        if ( ! task) {
            task = null;
            return this;
        }
        
        this._lock = true;
        
        for (var i = 0, l = this._tasks.length; i < l; i++) {
            if (this._tasks[i] === task) {
                this._tasks.splice(i, 1);
                break;
            }
        }
        
        task = null;
        
        delete this._tasksHash[id];
        
        if ( ! this._tasks.length) {
            this.stop();
        }
        
        this._lock = false;
        
        return this;
    },
    
    /**
     * タイマーの実行を開始する(実行中は意味が無い)
     * 
     * @return {Jeeel.Dom.Window.Interval} 自インスタンス
     */
    start: function () {
        if (this._id) {
            return this;
        }
        
        this._id = this._window.setInterval(this.interval, 10);
        
        return this;
    },
    
    /**
     * タイマーの実行を停止する(停止中は意味が無い)
     * 
     * @return {Jeeel.Dom.Window.Interval} 自インスタンス
     */
    stop: function () {
        if ( ! this._id) {
            return this;
        }
        
        this._window.clearInterval(this._id);
        
        this._id = null;
        
        return this;
    },
    
    /**
     * タイマーに呼び出されるメソッド
     */
    interval: function () {
        if (this._lock) {
            return;
        }
        
        var time = this._timestamp.getElapsedTime();
        
        this._timestamp.setElapsedTime(0);
        
        var cloneTasks = this._tasks.concat();
      
        for (var i = 0, l = cloneTasks.length; i < l; i++) {
            cloneTasks[i].execute(time);
        }
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Window} window setInterval,clearIntervalを保持するWindow
     * @constructor
     */
    constructor: Jeeel.Dom.Window.Interval
};

Jeeel.file.Jeeel.Dom.Window.Interval = ['Task'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Window.Interval, Jeeel.file.Jeeel.Dom.Window.Interval);
/**
 * コンストラクタ
 * 
 * @class タイマー内で実行されるタスクを管理するクラス
 * @param {Function} func タスク
 * @param {Integer} delay どれくらい置きに実行するか(ミリ秒)
 * @param {Array} args タスクに渡す引数のリスト
 */
Jeeel.Dom.Window.Interval.Task = function (func, delay, args) {
    this._process = func;
    this._delay = delay;
    this._args = args || [];
};

Jeeel.Dom.Window.Interval.Task.prototype = {
    
    /**
     * 実行タスク
     * 
     * @type Function
     * @private
     */
    _process: null,
    
    /**
     * 実行遅延時間
     * 
     * @type Integer
     * @private
     */
    _delay: 0,
    
    /**
     * タスク引数
     * 
     * @type Array
     * @private
     */
    _args: [],
    
    /**
     * 前回実際にタスクを実行してからの経過時間
     * 
     * @type Integer
     * @private
     */
    _time: 0,
    
    /**
     * タスクの実行を行う
     * 
     * @param {Integer} time 前回の実行からの経過時間
     */
    execute: function (time) {
        this._time += time;
        
        while(this._time >= this._delay) {
            this._process.apply(null, this._args);
            this._time -= this._delay;
        }
    }
};Jeeel.directory.Jeeel.Dom.Document = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Document/';
    }
};

/**
 * コンストラクタ
 * 
 * @class documentをラップして拡張するクラス
 * @param {Document|IFrameElement} [document] 対象のドキュメント(iframe等で階層が違う場合に指定)
 * @throws {Error} documentが指定されてかつiframeやDocument型でない場合に発生
 */
Jeeel.Dom.Document = function (document) {

    if (Jeeel.Document && ( ! document || document === Jeeel._doc)) {
        return Jeeel.Document;
    }
    
    if ( ! document) {
        document = Jeeel._doc;
    } else if (document.nodeName && document.nodeName.toUpperCase() == 'IFRAME') {
        document = document.contentWindow.document;
    } else if (document instanceof Jeeel.Dom.Window) {
        this._window = document;
        document = document.getWindow().document;
    }
    
    if ( ! Jeeel.Type.isDocument(document)) {
        throw new Error('引数はDocumentまたはIFrameElementを渡してください。');
    }

    this._document = document;
    this._searcher = new Jeeel.Dom.Core.Searcher(document);
    this._elementCash = {};
};

/**
 * インスタンスの作成を行う
 *
 * @param {Document|IFrameElement} [document] 対象のドキュメント(iframe等で階層が違う場合に指定)
 * @return {Jeeel.Dom.Document} 作成したインスタンス
 */
Jeeel.Dom.Document.create = function (document) {
    return new this(document);
};

Jeeel.Dom.Document.prototype = {

    /**
     * 操作対象のDocument
     * 
     * @type Document
     * @protected
     */
    _document: null,
    
    /**
     * Documentに属するWindowのラッパーインスタンス
     * 
     * @type Jeeel.Dom.Window
     * @private
     */
    _window: null,
    
    /**
     * 検索インスタンス
     * 
     * @type Jeeel.Dom.Core.Searcher
     * @private
     */
    _searcher: null,
    
    /**
     * Elementの作成で使用するキャッシュ
     * 
     * @type Hash
     */
    _elementCash: {},
    
    /**
     * ネームスペース使用時のElementの作成で使用するキャッシュ
     * 
     * @type Hash
     */
    _elementNsCash: {},
    
    /**
     * 操作しているDocumentを取得する
     * 
     * @return {Document} 操作しているDocument
     */
    getDocument: function () {
        return this._document;
    },
    
    /**
     * このDocumentに属するWindowのラッパーインスタンスを取得する
     * 
     * @return {Jeeel.Dom.Window} Windowラッパーインスタンス
     */
    getWindow: function () {
        return this._window || (this._window = Jeeel.Dom.Window.create(this));
    },
    
    /**
     * 現在のドキュメントのサイズを取得する
     * 
     * @return {Jeeel.Object.Size} サイズ
     */
    getDocumentSize: function () {},
    
    /**
     * Elementの作成を行う
     * 
     * @param {String} tagName 作成タグの名前(タグ名は大文字小文字を統一した方が早くなる)
     * @return {Element} 作成したタグ
     */
    createElement: function (tagName) {
        if (this._elementCash[tagName]) {
            return this._elementCash[tagName].cloneNode(false);
        }
        
        var elm = this._document.createElement(tagName);
        
        return elm && (this._elementCash[tagName] = elm).cloneNode(false) || null;
    },
    
    /**
     * ネームスペースを指定してElementの作成を行う
     * 
     * @param {String} namespaceUri ネームスペースURI(例： http://www.w3.org/1999/xhtml)
     * @param {String} tagName 作成タグの名前(タグ名は大文字小文字を統一した方が早くなる)
     * @return {Element} 作成したタグ
     */
    createElementNS: function (namespaceUri, tagName) {
        if ( ! this._elementNsCash[namespaceUri]) {
            this._elementNsCash[namespaceUri] = {};
        }
        
        if (this._elementNsCash[namespaceUri][tagName]) {
            return this._elementNsCash[namespaceUri][tagName].cloneNode(false);
        }
        
        var elm = this._document.createElementNS(namespaceUri, tagName);
        
        return elm && (this._elementNsCash[namespaceUri][tagName] = elm).cloneNode(false) || null;
    },
    
    /**
     * Textノードの作成を行う
     * 
     * @param {String} text 作成するテキスト
     * @return {Text} 作成したTextノード
     */
    createTextNode: function (text) {
        return this._document.createTextNode(text);
    },
    
    /**
     * DocumentFragmentの作成を行う
     * 
     * @return {DocumentFragment} 作成したDocumentFragment
     */
    createDocumentFragment: function () {
        return this._document.createDocumentFragment();
    },
    
    /**
     * HTML文字列からNodeリストを作成して返す
     *
     * @param {String} html HTML文字列
     * @return {Node[]} 作成されたNodeリスト
     * @example
     * var doc = new Jeeel.Dom.Document();
     * var html = '<div></div>ほげ<span>ぽんちょ</span>';
     * var nodes = doc.createNodeList(html);
     * // nodes => [HTMLDivElement, Text, HTMLSpanElement]
     */
    createNodeList: function (html) {

        var div;
        
        var supports = this.constructor.Supports;

        if ( ! supports.rhtml.test(html)) {
            div = {childNodes: [this.createTextNode(html)]};
        } else {
            // Fix "XHTML"-style tags in all browsers
            html = html.replace(supports.rxhtmlTag, "<$1></$2>");

            // Trim whitespace, otherwise indexOf won't work as expected
            var tag = (supports.rtagName.exec(html) || ["", ""])[1].toLowerCase(),
            wrap = supports.wrapMap[tag] || supports.wrapMap._default,
            depth = wrap[0];

            div = this.createElement('div');
            div.style.display = 'none';
            
            this.appendToBody(div);

            // Go to html and back, then peel off extra wrappers
            div.innerHTML = wrap[1] + html + wrap[2];

            // Move to the right depth
            while (depth--) {
                div = div.lastChild;
            }

            // Remove IE's autoinserted <tbody> from table fragments
            if ( ! supports.tbody) {

                // String was a <table>, *may* have spurious <tbody>
                var hasBody = supports.rtbody.test(html),
                  tbody = tag === "table" && !hasBody ?
                    div.firstChild && div.firstChild.childNodes :

                    // String was a bare <thead> or <tfoot>
                    wrap[1] === "<table>" && !hasBody ?
                      div.childNodes : [];

                for (var j = tbody.length - 1; j >= 0 ; --j) {
                    if (tbody[j].nodeName.toLowerCase() == "tbody" && ! tbody[j].childNodes.length ) {
                        tbody[j].parentNode.removeChild(tbody[j]);
                    }
                }
            }

            // IE completely kills leading whitespace when innerHTML is used
            if ( ! supports.leadingWhitespace && supports.rleadingWhitespace.test(html)) {
                div.insertBefore(this.createTextNode(supports.rleadingWhitespace.exec(html)[0]), div.firstChild);
            }
        }

        var res = [];

        var children = div.childNodes;

        for (var i = children.length; i--;) {
            res[i] = children[i];
        }
        
        var child;
        
        while (child = div.firstChild) {
            div.removeChild(child);
        }
        
        if (div.parentNode) {
            var parent = div.parentNode;
            
            parent.removeChild(div);
        }

        return res;
    },
    
    /**
     * HTML文字列からElementリストを作成して返す
     *
     * @param {String} html HTML文字列
     * @return {Element[]} 作成されたElementリスト
     * @example
     * var doc = new Jeeel.Dom.Document();
     * var html = '<div></div>ほげ<span>ぽんちょ</span>';
     * var nodes = doc.createElementList(html);
     * // nodes => [HTMLDivElement, HTMLSpanElement]
     */
    createElementList: function (html) {
        var res = [];
        var tmp = this.createNodeList(html);
        var elmType = Jeeel.Dom.Node.ELEMENT_NODE;
        
        for (var i = 0, l = tmp.length; i < l; i++) {
            if (tmp[i].nodeType === elmType) {
                res[res.length] = tmp[i];
            }
        }
        
        return res;
    },
    
    /**
     * ヘッダの取得
     *
     * @return {Element} ヘッダElement
     */
    getHead: function () {
        return this._document.head || this.getElementsByTagName('head')[0];
    },

    /**
     * ボディの取得
     *
     * @return {Element} ボディElement
     */
    getBody: function () {
        return this._document.body;
    },
    
    /**
     * ルートElementの取得
     * 
     * @return {Element} ルートElement
     */
    getDocumentElement: function () {
        return this._document.documentElement;
    },

    /**
     * 指定IDのHTML要素を取得する
     *
     * @param {String} id 検索ID
     * @return {Element} 取得したElement
     */
    getElementById: function (id) {
        return this._searcher.getElementById(id);
    },

    /**
     * 指定ClassのHTML要素を取得する
     *
     * @param {String|String[]} className 検索Class
     * @return {Element[]} 取得したElement配列
     */
    getElementsByClassName: function (className) {
        return this._searcher.getElementsByClassName(className);
    },
    
    /**
     * 指定NameのHTML要素を取得する<br />
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする<br />
     * submitSearchなしのIEではName属性の解釈が違うので注意
     * 
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch=false] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか
     * @return {Element[]} 取得したElement配列
     */
    getElementsByName: function (name, submitSearch) {
        return this._searcher.getElementsByName(name, submitSearch);
    },
    
    /**
     * 指定TagのHTML要素を取得する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Element[]} 取得したElement配列
     */
    getElementsByTagName: function (tagName) {
        
        if ( ! tagName) {
            return [];
        }
        
        var isArr = Jeeel.Type.isArray(tagName);
        
        if ( ! isArr) {
            tagName = tagName.toUpperCase();

            if (tagName === 'BODY') {
                return [this._document.body];
            } else if (tagName === 'HEAD' && this._document.head) {
                return [this._document.head];
            } else if (tagName === 'HTML') {
                return [this._document.documentElement];
            }
        }
      
        return this._searcher.getElementsByTagName(tagName);
    },

    /**
     * 指定属性が指定値のHTML要素を取得する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByAttribute: function (attribute, value) {
        return this._searcher.getElementsByAttribute(attribute, value);
    },

    /**
     * 指定プロパティが指定値のHTML要素を取得する<br />
     * Elementのプロパティである事に注意
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value 指定値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByProperty: function (property, value) {
        return this._searcher.getElementsByProperty(property, value);
    },

    /**
     * 指定セレクタで絞り込んだHTML要素を取得する
     *
     * @param {String} selector CSSセレクタ
     * @return {Element[]} 取得したElement配列
     * @see Jeeel.Dom.Selector
     */
    getElementsBySelector: function (selector) {
        return this._searcher.getElementsBySelector(selector);
    },
    
    /**
     * HTML要素を指定範囲検索する
     * 
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {Function} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Element[]} 範囲検索に引っかかったElement配列
     * @see Jeeel.Dom.SearchOption
     */
    searchElementsByRange: function (rect, option) {},
    
    /**
     * 計算済みのスタイルを取得する
     * 
     * @param {Element} element 取得対象のElement
     * @return {CSSCurrentStyleDeclaration|CSSStyleDeclaration} 取得した計算済みスタイル
     */
    getComputedStyle: function (element) {
        return element.currentStyle || this._document.defaultView.getComputedStyle(element, '');
    },
    
    /**
     * ヘッダに対して要素を追加する
     * 
     * @param {Element} element 追加Element
     * @return {Jeeel.Dom.Document} 自インスタンス
     */
    appendToHead: function (element) {
        this.getHead().appendChild(element);
        return this;
    },
    
    /**
     * ボディに対して要素を追加する
     * 
     * @param {Element} element 追加Element
     * @return {Jeeel.Dom.Document} 自インスタンス
     */
    appendToBody: function (element) {
        this.getBody().appendChild(element);
        return this;
    },
    
    /**
     * このDocumentにイベントを追加する<br />
     * 引数はJeeel.Dom.Event, このDocumentになる
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Document} 自インスタンス
     */
    addEventListener: function (type, listener, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        Jeeel.Dom.Event.addEventListener(this._document, type, listener, thisArg);
        
        return this;
    },

    /**
     * イベントの削除を行う<br />
     * このインスタンスのaddEventListenerに対して行わなければ削除はできない
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @return {Jeeel.Dom.Document} 自インスタンス
     */
    removeEventListener: function (type, listener) {
        Jeeel.Dom.Event.removeEventListener(this._document, type, listener);

        return this;
    },
    
    /**
     * このDocumentに設定されているイベントを任意のタイミングで実行する
     *
     * @param {String} type イベントタイプ
     * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
     * @return {Jeeel.Dom.Document} 自インスタンス
     * @ignore 未完成
     */
    dispatchEvent: function (type, option) {
        Jeeel.Dom.Event.dispatchEvent(this._document, type, option);
        
        return this;
    },

    /**
     * コンストラクタ
     * 
     * @param {Document} [document] 対象のドキュメント(iframe等で階層が違う場合に指定)
     * @constructor
     */
    constructor: Jeeel.Dom.Document,
    
    /**
     * @ignore
     */
    _init: function () {
      
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var doc  = Jeeel._doc;

        if ( ! doc) {
            delete this._init;
            return;
        }
        
        var _option, _rect;

        /**
         * @ignore
         */
        function _searchRange(res, target) {
            var trect = Jeeel.Dom.Element.create(target).getRect();

            if (_option(_rect, trect)) {
                res[res.length] = target;
            }

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    _searchRange(res, child);
                }

                child = child.nextSibling;
            }
        }
        
        /**
         * @ignore
         */
        this.searchElementsByRange = function (rect, option) {
            if ( ! rect) {
                return [];
            }

            if ( ! option) {
                option = Jeeel.Dom.SearchOption.RANGE_OVERLAY;
            }
            
            _rect = rect;
            _option = option;

            var res = [];
            
            _searchRange(res, this._document.documentElement);

            return res;
        };
        
        if ('scrollWidth' in doc.documentElement) {
            
            /**
             * @ignore
             */
            this.getDocumentSize = function () {
                var root = this.getDocumentElement();
                
                return new Jeeel.Object.Size(root.scrollWidth, root.scrollHeight);
            };
        } else {
            /**
             * @ignore
             */
            this.getDocumentSize = function () {
                var root = this.getBody();
                
                return new Jeeel.Object.Size(root.scrollWidth, root.scrollHeight);
            };
        }
        
        // createElementNSが存在しないブラウザはネームスペースを無視
        if ( ! doc.createElementNS) {
          
            /**
             * @ignore
             */
            this.createElementNS = function (namespaceUri, tagName) {
                return this.createElement(tagName);
            };
        }
        
        delete this._init;
    }
};

Jeeel.Dom.Document.prototype._init();

Jeeel.file.Jeeel.Dom.Document = ['ReadyStatus'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Document, Jeeel.file.Jeeel.Dom.Document);

if (Jeeel._doc) {
    Jeeel.Document = new Jeeel.Dom.Document();
    Jeeel.Window = Jeeel.Document.getWindow();
} else if (Jeeel._global) {
    Jeeel.Window = new Jeeel.Dom.Window();
}

(function () {
    if ( ! Jeeel._doc) {
        return;
    }
    
    var div = Jeeel.Document.createElement('div');
    
    div.setAttribute("className", "t");
    div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

    /**
     * @namespace サポート用ネームスペース
     */
    Jeeel.Dom.Document.Supports = ({
        leadingWhitespace: ( div.firstChild.nodeType === 3 ),

        // Make sure that tbody elements aren't automatically inserted
        // IE will insert them into empty tables
        tbody: !div.getElementsByTagName( "tbody" ).length,

        // Make sure that link elements get serialized correctly by innerHTML
        // This requires a wrapper element in IE
        htmlSerialize: !!div.getElementsByTagName( "link" ).length,
        
        wrapMap: {
            option: [1, "<select multiple='multiple'>", "</select>"],
            legend: [1, "<fieldset>", "</fieldset>"],
            thead: [1, "<table>", "</table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            area: [1, "<map>", "</map>"],
            _default: [0, "", ""]
        },
        
        rtbody: /<tbody/i,
        rhtml: /<|&#?\w+;/,
        rleadingWhitespace: /^\s+/,
        rxhtmlTag: /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
        rtagName: /<([\w:]+)/,
        
        /**
         * @ignore
         */
        _init: function () {
            this.wrapMap.optgroup = this.wrapMap.option;
            this.wrapMap.tbody = this.wrapMap.tfoot = this.wrapMap.colgroup = this.wrapMap.caption = this.wrapMap.thead;
            this.wrapMap.th = this.wrapMap.td;
            
            if ( ! this.htmlSerialize ) {
                this.wrapMap._default = [1, "div<div>", "</div>"];
            }
            
            delete this._init;
            
            return this;
        }
    })._init();
})();

/**
 * Documentの読み込み状態を示す
 */
Jeeel.Dom.Document.ReadyStatus = {

    /**
     * 未初期化
     *
     * @type String
     * @constant
     */
    UNINITIALIZED: 'uninitialized',

    /**
     * ロード中
     *
     * @type String
     * @constant
     */
    LOADING: 'loading',

    /**
     * Document作成中
     *
     * @type String
     * @constant
     */
    INTERACTIVE: 'interactive',

    /**
     * 読み込み完了
     *
     * @type String
     * @constant
     */
    COMPLETE: 'complete'
};
Jeeel.directory.Jeeel.Dom.Xml = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Xml/';
    }
};

/**
 * コンストラクタ
 * 
 * @class XMLを簡単にアクセス可能にするクラス
 * @param {Document|String} xmlDocument XMLドキュメント
 * @throws {Error} xmlDocumentがXMLのドキュメントオブジェクトでない場合に発生
 */
Jeeel.Dom.Xml = function (xmlDocument) {
    
    // 文字列はXML文字列として処理する
    if (Jeeel.Type.isString(xmlDocument)) {
        xmlDocument = this.constructor.Parser.parse(xmlDocument);
    }
    
    this._init(xmlDocument);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Document} xmlDocument XMLドキュメント
 * @return {Jeeel.Dom.Xml} 作成したインスタンス
 * @throws {Error} xmlDocumentがXMLのドキュメントオブジェクトでない場合に発生
 */
Jeeel.Dom.Xml.create = function (xmlDocument) {
    return new this(xmlDocument);
};

/**
 * XMLを読み込んでインスタンスの作成を同期的行う
 * 
 * @param {String} url XMLのURL
 * @param {Hash} [params] XML取得の際にサーバーに渡すパラメータ
 * @return {Jeeel.Dom.Xml} 作成したインスタンス
 */
Jeeel.Dom.Xml.load = function (url, params) {
    var ajax = Jeeel.Net.Ajax.create(url)
                    .setAsynchronous(false)
                    .setAll(params || {})
                    .execute();
    
    var response = ajax.getResponse();
    
    return new this(response.responseXML || response.responseText);
};

/**
 * XMLを読み込んでインスタンスの作成を非同期で行う
 * 
 * @param {String} url XMLのURL
 * @param {Function} callback 指定すると非同期読み込みになり引数にXMLが渡される<br />
 *                             void callback(Jeeel.Dom.Xml xml)
 * @param {Hash} [params] XML取得の際にサーバーに渡すパラメータ
 */
Jeeel.Dom.Xml.loadAsync = function (url, callback, params) {
  
    if ( ! callback) {
        return;
    }
  
    var ajax = Jeeel.Net.Ajax.create(url);
    
    ajax.setAll(params || {})
        .setSuccessMethod(function (response) {
            callback(new this(response.responseXML || response.responseText));
        }, this).execute();
};

Jeeel.Dom.Xml.prototype = {
    
    /**
     * XMLエンコーディング
     * 
     * @type String
     * @private
     */
    _encoding: '',
    
    /**
     * XMLバージョン
     * 
     * @type String
     * @private
     */
    _version: '',
    
    /**
     * XMLドキュメント
     * 
     * @type Document
     * @private
     */
    _doc: null,
    
    /**
     * ルートノード
     * 
     * @type Jeeel.Dom.Xml.Node
     * @private
     */
    _root: null,
    
    /**
     * この要素が持つ子要素リスト
     * 
     * @type Jeeel.Dom.Xml.Node[]
     * @private
     */
    _childNodes: [],
    
    /**
     * XMLのバージョンを取得する
     * 
     * @return {String} バージョン
     */
    getVersion: function () {
        return this._version;
    },
    
    /**
     * XMLのエンコーディングを取得する
     * 
     * @return {String} エンコーディング
     */
    getEncoding: function () {
        return this._encoding;
    },
    
    /**
     * ルートノードを取得する
     * 
     * @return {Jeeel.Dom.Xml.Node} ルートノード
     */
    getDocumentElement: function () {
        return this._root;
    },
    
    /**
     * この要素の子要素を全て取得する
     * 
     * @return {Jeeel.Dom.Xml.Node[]} 子要素リスト
     */
    getChildNodes: function () {
        return this._childNodes;
    },
    
    /**
     * 簡単なHashに変換して返す<br />
     * 変換対象はタグ・テキストのみである
     * 
     * @return {Hash} 変換後のHash
     */
    toHash: function() {
        var res = {};
        
        if (this._root) {
            res[this._root._name] = this._root.toHash();
        }
        
        return res;
    },
    
    /**
     * このXMLを文字列に変換して返す
     * 
     * @return {String} XML文字列
     */
    toString: function () {
        var header = '<?xml version="'
                   + this._version + '"'
                   + (this._encoding ? ' encoding="' + this._encoding + '"' : '')
                   + '?>\n';
        
        var children = [];
        
        for (var i = this._childNodes.length; i--;) {
            children[i] = this._childNodes[i].toXmlString();
        }
        
        return header
             + children.join('\n');
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Document} xmlDocument XMLドキュメント
     * @constructor
     */
    constructor: Jeeel.Dom.Xml,
    
    /**
     * 初期化
     * 
     * @param {Document} xmlDocument XMLドキュメント
     * @private
     */
    _init: function (xmlDocument) {
        delete this._init;
        
        if (xmlDocument.nodeType !== Jeeel.Dom.Node.DOCUMENT_NODE || Jeeel.Type.isEmpty(this._version)) {
            throw new Error('XMLドキュメントを指定して下さい。');
        }
        
        this._doc = xmlDocument;
        this._version  = xmlDocument.xmlVersion;
        this._encoding = xmlDocument.xmlEncoding;
        
        var root = xmlDocument.documentElement;
        var nodeName = root.nodeName;

        var nodes = xmlDocument.childNodes;
        
        this._childNodes = [];
        
        for (var i = 0, l = nodes.length; i < l; i++) {
            this._childNodes[i] = new Jeeel.Dom.Xml.Node(nodes[i]);
            
            if (root === nodes[i]) {
                this._root = this[nodeName] = this._childNodes[i];
            }
        }
    }
};

Jeeel.file.Jeeel.Dom.Xml = ['Node', 'Parser'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Xml, Jeeel.file.Jeeel.Dom.Xml);

/**
 * コンストラクタ
 * 
 * @class XMLの内部ノードを示すクラス
 * @param {Element} xmlNode XMLノード
 */
Jeeel.Dom.Xml.Node = function (xmlNode) {
    this._init(xmlNode);
};

Jeeel.Dom.Xml.Node.prototype = {
    
    /**
     * この要素の名前
     * 
     * @type String
     * @private
     */
    _name: '',
    
    /**
     * この要素の名前空間
     * 
     * @type String
     * @private
     */
    _namespace: '',
    
    /**
     * この要素の名前空間URI
     * 
     * @type String
     * @private
     */
    _namespaceUri: '',
    
    /**
     * この要素を示す定数
     * 
     * @type Integer
     * @private
     */
    _type: 0,
    
    /**
     * この要素の持つ値
     * 
     * @type String
     * @private
     */
    _value: '',
    
    /**
     * この要素の持つ属性
     * 
     * @type Hash[]
     * @private
     */
    _attr: [],
    
    /**
     * この要素が持つ子要素リスト
     * 
     * @type Jeeel.Dom.Xml.Node[]
     * @private
     */
    _childNodes: [],
    
    /**
     * この要素の名前を取得する
     * 
     * @return {String} 要素名
     */
    getName: function () {
        return this._name;
    },
    
    /**
     * この要素の名前空間を取得する
     * 
     * @return {String} 名前空間
     */
    getNamespace: function () {
        return this._namespace;
    },
    
    /**
     * この要素の名前空間URIを取得する
     * 
     * @return {String} 名前空間URI
     */
    getNamespaceUri: function () {
        return this._namespaceUri;
    },
    
    /**
     * この要素の種類を取得する
     * 
     * @return {Integer} 要素の種類定数
     * @see Jeeel.Dom.Node
     */
    getType: function () {
        return this._type;
    },
    
    /**
     * この要素の値を取得する
     * 
     * @return {Mixied} 要素値
     */
    getValue: function () {
        return this._value;
    },
    
    /**
     * この要素に定義付けられている属性値を取得する
     * 
     * @param {String} attribute 属性名
     * @return {String} 属性値
     */
    getAttribute: function (attribute) {
        if (Jeeel.Type.isSet(this._attr[attribute])) {
            return this._attr[attribute];
        }
        
        return null;
    },
    
    /**
     * 属性の名前と値を連想配列にして返す
     * 
     * @return {Hash} 属性のリスト
     */
    getAttributes: function () {
        return this._attr;
    },
    
    /**
     * この要素の子要素を全て取得する
     * 
     * @return {Jeeel.Dom.Xml.Node[]} 子要素リスト
     */
    getChildNodes: function () {
        return this._childNodes;
    },
    
    /**
     * 簡単なHashに変換して返す<br />
     * 変換対象はタグ・テキストのみである
     * 
     * @return {Hash} 変換後のHash
     */
    toHash: function () {
        var res = {},
            len = this._childNodes.length;
        
        if (len === 0) {
            return '';
        }
        else if (len === 1 && this._childNodes[0]._type === Jeeel.Dom.Node.TEXT_NODE) {
            return this._childNodes[0] && this._childNodes[0]._value || '';
        }
        
        for (var i = 0; i < len; i++) {
            var child = this._childNodes[i];
            
            if (child._type !== Jeeel.Dom.Node.ELEMENT_NODE) {
                continue;
            }
            
            if (res[child._name]) {
                res[child._name].push(child.toHash());
            } else {
                var hash = child.toHash();
                
                if ( ! Jeeel.Type.isHash(hash)) {
                    res[child._name] = hash;
                } else {
                    res[child._name] = [hash];
                    
                    for (var key in hash) {
                        res[child._name][key] = hash[key];
                    }
                }
            }
        }
        
        return res;
    },
    
    /**
     * この要素の内部XMLを文字列にして返す
     * 
     * @return {String} XML文字列
     */
    toXmlString: function () {
        switch (this._type) {
            case Jeeel.Dom.Node.TEXT_NODE:
                return this._value;
                break;
                
            case Jeeel.Dom.Node.COMMENT_NODE:
                return '<!--' + this._value + '-->';
                break;
                
            case Jeeel.Dom.Node.CDATA_SECTION_NODE:
                return '<![CDATA[' + this._value + ']]>';
                break;
                
            case Jeeel.Dom.Node.PROCESSING_INSTRUCTION_NODE:
                return '<?' + this._name + ' ' + this._value + '?>';
                break;
                
            case Jeeel.Dom.Node.DOCUMENT_TYPE_NODE:
                return '<!DOCTYPE ' + this._name + '>';
                break;
            
            default:
                break;
        }
        
        var attrs = [],
            children = [],
            i;
        
        for (i = this._attr.length; i--;) {
            var attr = this._attr[i];
            attrs[i] = attr.name + '="' + attr.value + '"';
        }
        
        for (i = this._childNodes.length; i--;) {
            children[i] = this._childNodes[i].toXmlString();
        }
        
        return '<' + this._name
             + (attrs.length ? ' ' + attrs.join(' ') : '')
             + '>'
             + children.join('')
             + '</' + this._name + '>';
    },
    
    /**
     * この要素の要素値もしくはXML文字列を返す
     * 
     * @return {String} 要素値もしくはXML文字列
     */
    toString: function () {
        return this._value || this.toXmlString();
    },
    
    /**
     * この要素の値を取得する
     * 
     * @return {Mixied} 要素値
     */
    valueOf: function () {
        return this._value;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Element} xmlNode XMLノード
     * @constructor
     */
    constructor: Jeeel.Dom.Xml.Node,
    
    /**
     * 初期化
     * 
     * @param {Element} xmlNode XMLノード
     */
    _init: function (xmlNode) {
        delete this._init;
        
        this._value        = xmlNode.nodeValue;
        this._name         = xmlNode.nodeName;
        this._namespace    = xmlNode.prefix;
        this._namespaceUri = xmlNode.namespaceURI;
        this._type         = xmlNode.nodeType;
        this._attr         = [];
        this._childNodes   = [];
        
        var i, l, attrs = xmlNode.attributes;
        
        if (attrs) {
            for (i = attrs.length; i--;) {
                var attr = attrs[i];
                
                this._attr[i] = {
                    name: attr.nodeName,
                    value: attr.nodeValue
                };
            }
        }
        
        var elmType = Jeeel.Dom.Node.ELEMENT_NODE;
        var nodes = xmlNode.childNodes;
        
        for (i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            var nodeName = node.nodeName;
            var xml = new Jeeel.Dom.Xml.Node(node);
            
            this._childNodes[i] = xml;

            if (node.nodeType !== elmType) {
                if (l === 1) {
                    this._value = node.nodeValue;
                }

                continue;
            }
            
            if ( ! this[nodeName]) {
                this[nodeName] = [];
            }
            
            var accessNodes = this[nodeName];
            
            accessNodes[accessNodes.length] = xml;
            
            if (accessNodes.length === 1) {
                for (var property in xml) {
                    if (property !== '_init') {
                        accessNodes[property] = xml[property];
                    }
                }
            }
        }
    }
};

/**
 * @staticClass XMLをパースするための静的クラス(対応しているのは完全XML形式でヘッダ、通常要素、テキスト、属性、名前空間)
 */
Jeeel.Dom.Xml.Parser = {
    
    /**
     * 元から存在するネームスペース
     * 
     * @type Hash
     * @constant
     */
    NAMESPACES: {
        xmlns: 'http://www.w3.org/2000/xmlns/'
    },
    
    /**
     * 現在パース中のXMLドキュメント
     * 
     * @type Hash
     * @private
     */
    _xml: null,

    /**
     * XML文字列をパースする
     * 
     * @param {String} xml パース対象のXML文字列
     * @return {Hash} パース後の簡易オブジェクト
     */
    parse: function (xml) {
        xml = Jeeel.String.trim(xml);
        
        this._xml = {
            nodeName: '#document',
            nodeValue: null,
            nodeType: Jeeel.Dom.Node.DOCUMENT_NODE,
            innerXML: xml
        };
        
        xml = this._parseXmlHeader(xml);
        
        this._parseXmlDocument(xml);
        
        this._xml.firstChild = this._xml.childNodes[0] || null;
        this._xml.lastChild = this._xml.childNodes[this._xml.childNodes.length - 1] || null;
        
        return this._xml;
    },
    
    /**
     * XMLのヘッダを解析する
     * 
     * @param {String} xml 解析XML
     * @return {String} ヘッダを取り除いた値
     * @private
     */
    _parseXmlHeader: function (xml) {
        var self = this;
        
        return xml.replace(/<\?xml(.*)?\?>/, function (match, header) {
            
            var v = header.match(/version=(?:([0-9.]+)|((["'])?[0-9.]+[^\\]\3))/);
            var e = header.match(/encoding=(?:([^"']+)|((["'])?[^"']+[^\\]\3))/);
            
            self._xml.xmlVersion = v[1] || v[2] && v[2].replace(/^["']|["']$/g, '') || '';
            self._xml.xmlEncoding = e[1] || e[2] && e[2].replace(/^["']|["']$/g, '') || '';
            
            return '';
        });
    },
    
    /**
     * XMLのドキュメント本体を解析する
     * 
     * @param {String} xml 解析XML
     * @private
     */
    _parseXmlDocument: function (xml) {
        var inTag = false, isTagName = false, isAttrName = false, isAttrValue = false, isEndTag = false;
        var attrName, prefix, tagName, tag, bchar, quot = null, txt = '', bi = null;
        var i, j, l, tmp, tmpName, tmpTags = [], attrs, namespaceVal = this.NAMESPACES;
        var parent;
        
        this._xml.childNodes = [];
        this._xml.documentElement = null;
        
        parent = this._xml;
        
        for (i = 0, l = xml.length; i < l; i++) {
            var chr = xml.charAt(i);
            
            switch (chr) {
                case '<':
                    inTag = true;
                    isTagName = true;
                    isAttrName = false;
                    isAttrValue = false;
                    isEndTag = false;
                    tagName = '';
                    prefix = null;
                    attrs = [];
                    bi = i;
                    
                    // 今までテキストを保持指定居た場合テキストノードを生成して親に入れる
                    if (txt && ! ('documentElement' in parent)) {
                        tag = {
                            attributes: null,
                            childNodes: [],
                            parentNode: parent,
                            nodeValue: txt,
                            nodeName: '#text',
                            prefix: null,
                            namespaceURI: null,
                            nodeType: Jeeel.Dom.Node.TEXT_NODE,
                            innerXML: ''
                        };
                        
                        parent.childNodes.push(tag);
                    }
                    break;
                    
                case '>':
                    if ( ! inTag) {
                        break;
                    }
                    
                    inTag = false;
                    
                    // テキストが存在しておりそれが属性値の場合は属性を作成
                    if (txt && isAttrValue) {
                        attrs.push({
                            nodeName: attrName,
                            nodeValue: txt,
                            prefix: prefix,
                            namespaceURI: namespaceVal[prefix] || null
                        });
                    }
                    
                    // タグが閉じられているかどうかで分岐する
                    if (isEndTag) {
                        
                        // 前後にタグが存在するタイプと1つのタグで開始と終了を併せ持つ場合で分岐する
                        if (bchar !== '/') {
                            tag = tmpTags.pop();
                            
                            // 開始タグと終了タグの名前が異なっていた場合はパースエラー
                            if (tag.nodeName !== tagName) {
                                throw new Error('Parse error.');
                            }
                            
                            parent = parent.parentNode;
                            
                            tag.innerXML = xml.substring(tag.innerXML, bi);
                            
                            if ( ! tag.childNodes.length) {
                                tag.nodeValue = tag.innerXML;
                            }
                            
                            if (namespaceVal.__back) {
                                namespaceVal = namespaceVal.__back;
                            }
                            
                            tag.firstChild = tag.childNodes[0] || null;
                            tag.lastChild = tag.childNodes[tag.childNodes.length - 1] || null;
                        } else {
                            tmpName = {};

                            for (j = attrs.length; j--;) {
                                if (tmp = attrs[j].nodeName.match(/^xmlns:(.+)$/)) {
                                    tmpName[tmp[1]] = attrs[j].nodeValue;
                                }
                            }

                            this._namespace.prototype = namespaceVal;
                            tmp = namespaceVal;

                            namespaceVal = new this._namespace(tmpName);
                            namespaceVal.__back = tmp;
                        
                            tag = {
                                attributes: attrs,
                                childNodes: [],
                                parentNode: parent,
                                nodeName: tagName,
                                nodeValue: null,
                                prefix: prefix,
                                namespaceURI: namespaceVal[prefix] || null,
                                nodeType: Jeeel.Dom.Node.ELEMENT_NODE,
                                innerXML: '',
                                firstChild: null,
                                lastChild: null
                            };
                            
                            if (namespaceVal.__back) {
                                namespaceVal = namespaceVal.__back;
                            }
                        }
                        
                        parent.childNodes.push(tag);
                        
                        // ルートノードが未定義で親がドキュメントだった場合はルートノードを定義する
                        if (parent.nodeType === Jeeel.Dom.Node.DOCUMENT_NODE && ! parent.documentElement) {
                            parent.documentElement = tag;
                        }
                    } else {
                        tmpName = {};
                        
                        for (j = attrs.length; j--;) {
                            if (tmp = attrs[j].nodeName.match(/^xmlns:(.+)$/)) {
                                tmpName[tmp[1]] = attrs[j].nodeValue;
                            }
                        }
                        
                        this._namespace.prototype = namespaceVal;
                        tmp = namespaceVal;
                        
                        namespaceVal = new this._namespace(tmpName);
                        namespaceVal.__back = tmp;
                      
                        tag = {
                            attributes: attrs,
                            childNodes: [],
                            parentNode: parent,
                            nodeName: tagName,
                            nodeValue: null,
                            prefix: prefix,
                            namespaceURI: namespaceVal[prefix] || null,
                            nodeType: Jeeel.Dom.Node.ELEMENT_NODE,
                            innerXML: i + 1,
                            firstChild: null,
                            lastChild: null
                        };
                        
                        parent = tag;
                        
                        tmpTags.push(tag);
                    }
                    
                    txt = '';

                    break;
                    
                case '/':
                    if (quot) {
                        txt += chr;
                        break;
                    }
                    
                    if (inTag) {
                        isEndTag = true;
                    } else {
                        txt += chr;
                    }
                    break;
                    
                case ':':
                    if (quot) {
                        txt += chr;
                        break;
                    }
                    
                    if (inTag) {
                        if (isTagName) {
                            prefix = tagName;
                            tagName += chr;
                        } else if (isAttrName) {
                            prefix = attrName;
                            attrName += chr;
                        } else if (isAttrValue) {
                            txt += chr;
                        }
                    } else {
                        txt += chr;
                    }
                    break;
                    
                case ' ':
                    if (quot) {
                        txt += chr;
                        break;
                    }
                    
                    if (inTag && isTagName) {
                        isTagName = false;
                        isAttrName = true;
                        isAttrValue = false;
                        attrName = '';
                        prefix = null;
                    } else if (inTag && isAttrValue) {
                        isAttrName = true;
                        isAttrValue = false;

                        attrs.push({
                            nodeName: attrName,
                            nodeValue: txt,
                            prefix: prefix,
                            namespaceURI: namespaceVal[prefix] || null
                        });
                        
                        attrName = '';
                        
                    } else if ( ! inTag) {
                        txt += chr;
                    }
                    break;
                    
                case '=':
                    if (quot) {
                        txt += chr;
                        break;
                    }
                    
                    if (inTag && isAttrName) {
                        isAttrName = false;
                        isAttrValue = true;
                        txt = '';
                    } else if ( ! inTag) {
                        txt += chr;
                    }
                    break;
                
                case "'":
                case '"':
                    if ( ! inTag) {
                        txt += chr;
                        break;
                    }
                    
                    if (quot === chr) {
                        quot = null;
                    } else if ( ! quot) {
                        quot = chr;
                    }
                    break;
                    
                default:
                    if (inTag) {
                        if (isTagName) {
                            tagName += chr;
                        } else if (isAttrName) {
                            attrName += chr;
                        } else if (isAttrValue) {
                            txt += chr;
                        }
                    } else {
                        txt += chr;
                    }
                    break;
            }
            
            bchar = chr;
        }
    },
    
    /**
     * コンストラクタ
     * 
     * @class 名前空間に使用するための内部クラス
     * @param {Hash} values 継承プロパティ
     * @private
     */
    _namespace: function (values) {
        if (values) {
            for (var key in values) {
                this[key] = values[key];
            }
        }
    }
};
Jeeel.directory.Jeeel.Dom.Event = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Event/';
    }
};

/**
 * コンストラクタ
 *
 * @class Eventを拡張するラッパークラス
 * @param {Event} event 基となるEventインスタンス
 */
Jeeel.Dom.Event = function (event) {
    var self = this;

    self._event = event;

    var docElement = Jeeel._doc.documentElement;
    var body = Jeeel._doc.body || {scrollLeft: 0, scrollTop: 0};

    var x = event.changedTouches && event.changedTouches[0].pageX || event.pageX || (event.clientX +
      (docElement.scrollLeft || body.scrollLeft) -
      (docElement.clientLeft || 0));

    var y = event.changedTouches && event.changedTouches[0].pageY || event.pageY || (event.clientY +
       (docElement.scrollTop || body.scrollTop) -
       (docElement.clientTop || 0));

    var right, left, middle;
    var button = event.button;
    
    if (Jeeel.UserAgent.isInternetExplorer()) {
        right  = !!(button & 2);
        left   = !!(button & 1);
        middle = !!(button & 4);
    } else {
        right  = button === 2;
        left   = button === 0;
        middle = button === 1;
    }

    var code = this._getCode();

    self.type = event.type.toLowerCase();
    self.data = event.data || null;
    self.target = event.target || event.srcElement;
    self.currentTarget = event.currentTarget || arguments[1] || null;
    self.relatedTarget = event.relatedTarget || event.fromElement || event.toElement || null;
    self.mouseX = x;
    self.mouseY = y;
    self.mouseWheel = (event.wheelDelta / 120) || -event.detail / 3;
    
    self.mousePoint = new Jeeel.Object.Point(x, y);

    self.keyCode  = code[0];
    self.charCode = code[1];

    self.ctrlKey  = event.ctrlKey;
    self.shiftKey = event.shiftKey;
    self.altKey   = event.altKey;

    self.isRightDown  = right;
    self.isLeftDown   = left;
    self.isMiddleDown = middle;
};

Jeeel.Dom.Event.prototype = {

    /**
     * イベントオブジェクト
     *
     * @type Event
     */
    _event: null,
    
    /**
     * イベントの種類
     *
     * @type String
     */
    type: '',
    
    /**
     * イベント発生Element
     * 
     * @type Element
     */
    target: null,
    
    /**
     * イベント補足Element
     * 
     * @type Element
     */
    currentTarget: null,
    
    /**
     * マウスの移動元・移動先の要素
     * 
     * @type Element
     */
    relatedTarget: null,
    
    /**
     * イベントのデータ
     * 
     * @type Mixied
     */
    data: null,

    /**
     * マウスのX座標
     *
     * @type Integer
     */
    mouseX: 0,
  
    /**
     * マウスのY座標
     *
     * @type Integer
     */
    mouseY: 0,

    /**
     * マウスの座標
     *
     * @type Jeeel.Object.Point
     */
    mousePoint: null,
    
    /**
     * マウスのホイール量
     * 
     * @type Integer
     */
    mouseWheel: 0,

    /**
     * キーコード
     *
     * @type Integer
     */
    keyCode: 0,

    /**
     * 文字コード
     *
     * @type Integer
     */
    charCode: 0,
  
    /**
     * Ctrlキーが押されているかどうか
     *
     * @type Boolean
     */
    ctrlKey: false,

    /**
     * Shiftキーが押されているかどうか
     *
     * @type Boolean
     */
    shiftKey: false,
  
    /**
     * Altキーが押されているかどうか
     *
     * @type Boolean
     */
    altKey: false,

    /**
     * マウスの右ボタンが押されたかどうか
     *
     * @type Boolean
     */
    isRightDown: false,
  
    /**
     * マウスの左ボタンが押されたかどうか
     *
     * @type Boolean
     */
    isLeftDown: false,

    /**
     * マウスの中ボタンが押されたかどうか
     *
     * @type Boolean
     */
    isMiddleDown: false,
    
    /**
     * イベントが伝播してきたElementリスト(伝播順配列)
     * 
     * @type Element[]
     * @private
     */
    _bubblingTargets: null,

    /**
     * 内部のEventインスタンスを返す
     *
     * @return {Event} Eventインスタンス
     */
    getEvent: function () {
        return this._event;
    },
    
    /**
     * イベント対象のElementからの相対マウス座標を取得する
     * 
     * @param {Element} [element] イベント対象のElementの代わりに使用するElement
     * @return {Jeeel.Object.Point} 相対マウス座標
     */
    getRelativeMousePoint: function (element) {
        var bp = Jeeel.Dom.Element.prototype.getPosition.call({_element: element || this.target, _doc: Jeeel.Document});
        var mp = this.mousePoint;
        
        bp.x = mp.x - bp.x;
        bp.y = mp.y - bp.y;
        
        return bp;
    },
    
    /**
     * イベントが伝播してきたElementリストを取得する(伝播順配列)
     * 
     * @return {Element[]} 伝搬リスト
     */
    getBubblingTargets: function () {
        if (this._bubblingTargets) {
            return this._bubblingTargets;
        }
        
        var c = this.currentTarget,
            p = this.target;

        if (p === c) {
            this._bubblingTargets = [p];
        }
        else if (c) {
            var elms = [];

            while (p && p !== c) {
                elms[elms.length] = p;
                p = p.parentNode;
            }

            elms[elms.length] = p;

            if (p) {
                this._bubblingTargets = elms;
            } else {
                this._bubblingTargets = [];
            }
        }
        
        return this._bubblingTargets;
    },

    /**
     * 全てのキーボードイベントで共通のキーコードを取得する<br />
     * 以下は例外入力(正しく取得できない)<br />
     * 1～8のキーをShiftと一緒に押したとき
     *
     * @return {Integer} キーコード
     */
    getKeyCode: function () {

        var keyCode  = this._event.keyCode;
        var charCode = this._event.charCode;
        var which    = this._event.which;

        if (this.type != 'keypress') {
            keyCode = this.keyCode;

            if (Jeeel.Dom.Event.KeyCode.T0 <= keyCode && keyCode <= Jeeel.Dom.Event.KeyCode.T9) {
                keyCode += Jeeel.Dom.Event.KeyCode[0] - Jeeel.Dom.Event.KeyCode.T0;
            } else if (Jeeel.Dom.Event.KeyCode.TMultiplicationSign <= keyCode && keyCode <= Jeeel.Dom.Event.KeyCode.TDivisionSign) {
                keyCode += Jeeel.Dom.Event.KeyCode.MultiplicationSign - Jeeel.Dom.Event.KeyCode.TMultiplicationSign;
            }

            return keyCode;
        }

        if (Jeeel.Code.CharCode.a <= keyCode && keyCode <= Jeeel.Code.CharCode.z) {
            keyCode += Jeeel.Code.CharCode.A - Jeeel.Code.CharCode.a;
        } else {

            switch (keyCode) {

                case Jeeel.Code.CharCode.RightParenthesis:
                    keyCode = Jeeel.Dom.Event.KeyCode[9];
                    break;

                case Jeeel.Code.CharCode.SubtractionSign:
                case Jeeel.Code.CharCode.EqualsSign:
                    keyCode = Jeeel.Dom.Event.KeyCode.SubtractionSign;
                    break;

                case Jeeel.Code.CharCode.Caret:
                case Jeeel.Code.CharCode.Tilde:
                    keyCode = Jeeel.Dom.Event.KeyCode.Caret;
                    break;

                case Jeeel.Code.CharCode.YenMark:
                case Jeeel.Code.CharCode.VerticalBar:
                    keyCode = Jeeel.Dom.Event.KeyCode.YenMark;
                    break;

                case Jeeel.Code.CharCode.Atmark:
                case Jeeel.Code.CharCode.BackQuote:
                    keyCode = Jeeel.Dom.Event.KeyCode.Atmark;
                    break;

                case Jeeel.Code.CharCode.LeftBracket:
                case Jeeel.Code.CharCode.LeftBrace:
                    keyCode = Jeeel.Dom.Event.KeyCode.LeftBracket;
                    break;

                case Jeeel.Code.CharCode.Semicolon:
                case Jeeel.Code.CharCode.AdditionSign:
                    keyCode = Jeeel.Dom.Event.KeyCode.AdditionSign;
                    break;

                case Jeeel.Code.CharCode.Colon:
                case Jeeel.Code.CharCode.MultiplicationSign:
                    keyCode = Jeeel.Dom.Event.KeyCode.MultiplicationSign;
                    break;

                case Jeeel.Code.CharCode.RightBracket:
                case Jeeel.Code.CharCode.RightBrace:
                    keyCode = Jeeel.Dom.Event.KeyCode.RightBracket;
                    break;

                case Jeeel.Code.CharCode.Comma:
                case Jeeel.Code.CharCode.LessThan:
                    keyCode = Jeeel.Dom.Event.KeyCode.Comma;
                    break;

                case Jeeel.Code.CharCode.Period:
                case Jeeel.Code.CharCode.GreaterThan:
                    keyCode = Jeeel.Dom.Event.KeyCode.Period;
                    break;

                case Jeeel.Code.CharCode.DivisionSign:
                case Jeeel.Code.CharCode.QuestionMark:
                    keyCode = Jeeel.Dom.Event.KeyCode.DivisionSign;
                    break;

                case Jeeel.Code.CharCode.YenMark:
                case Jeeel.Code.CharCode.Underscore:
                    keyCode = Jeeel.Dom.Event.KeyCode.Underscore;
                    break;

                case 0:
                    keyCode = Jeeel.Dom.Event.KeyCode.Application;
                    break;
            }
        }

        return keyCode;
    },
    
    /**
     * イベントをストップする
     * 
     * @param {Boolean} [nonstopSelfEvent] イベントをそのまま実行するかどうか
     * @param {Boolean} [nonstopParentEvent] イベントをそのまま伝達するかどうか
     * @return {Jeeel.Dom.Event} 自インスタンス
     */
    stop: function (nonstopSelfEvent, nonstopParentEvent) {
        if (this._event.preventDefault && ! nonstopSelfEvent) {
            this._event.preventDefault();
        }

        if (this._event.stopPropagation && ! nonstopParentEvent) {
            this._event.stopPropagation();
        }

        if ('returnValue' in this._event && ! nonstopSelfEvent) {
            this._event.returnValue = false;
        }

        if ('cancelBubble' in this._event && ! nonstopParentEvent) {
            this._event.cancelBubble = true;
        }

        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Event} event 基となるEventインスタンス
     * @constructor
     */
    constructor: Jeeel.Dom.Event,
    
    /**
    * 指定したEventオブジェクトからkeyCodeとcharCodeを取得する
    *
    * @return {Integer[]} 0にkeyCode, 1にcharCode
    */
    _getCode: function () {

        var keyCode  = this._event.keyCode;
        var charCode = this._event.charCode;
        var which    = this._event.which;

        if (this._event.type.toLowerCase() == 'keypress') {
            if (Jeeel.UserAgent.isGeckoEngine()) {
                if (keyCode == 0) {
                    keyCode = charCode;
                }

                charCode = keyCode;
            } else if (Jeeel.UserAgent.isTridentEngine() || Jeeel.UserAgent.isOpera()) {
                charCode = keyCode;
            }

            keyCode  = 0;
        } else {
            charCode = 0;
        }

        return [keyCode, charCode];
    }
};

/**
 * Eventインスタンスの取得を行う
 *
 * @param {Integer} [nestCount] ネスト数(イベントのコールバックを0としたネストの数)
 * @return {Jeeel.Dom.Event} Eventインスタンス
 * @throws {Error} イベントのコールバックから呼ばれていない時に投げられる
 * @example
 * <div onclick="test();">
 * </div>
 * <script>
 * function test() {
 *   // var e = Jeeel.Dom.Event.getEventObject(); //これはエラーになる
 *   var e = Jeeel.Dom.Event.getEventObject(1); //これが正しい
 * }
 * </script>
 */
Jeeel.Dom.Event.getEventObject = function (nestCount) {
    nestCount = +nestCount || 0;
    
    var caller = arguments.callee.caller;
    
    while (caller && nestCount--) {
        caller = caller.caller;
    }
    
    if ( ! caller || ! caller.arguments) {
        throw new Error('Eventインスタンスの取得はイベントのコールバックにて行ってください。');
    }

    var args = caller.arguments;
    
    if (args[0] instanceof this) {
        return args[0];
    }

    var e = args[0] || Jeeel._global.event;

    if ( ! Jeeel.Type.isEvent(e)) {
        throw new Error('Eventインスタンスの取得はイベントのコールバックにて行ってください。');
    }

    return new this(e);
};

/**
 * イベントの種類を内部的に取得する
 *
 * @param {String} type イベントのタイプ
 * @return {String} イベントの種類を示す文字列(MouseEvent等)
 * @private
 */
Jeeel.Dom.Event._getEventType = function (type) {
    var eventType;
    
    switch (type) {
        case Jeeel.Dom.Event.Type.KEY_DOWN:
        case Jeeel.Dom.Event.Type.KEY_PRESS:
        case Jeeel.Dom.Event.Type.KEY_UP:
            eventType = Jeeel.Dom.Event.Type.KEYBOARD_EVENT;
            break;
            
        case Jeeel.Dom.Event.Type.DRAG_START:
        case Jeeel.Dom.Event.Type.DRAG_END:
        case Jeeel.Dom.Event.Type.DRAG_ENTER:
        case Jeeel.Dom.Event.Type.DRAG_OVER:
        case Jeeel.Dom.Event.Type.DRAG_LEAVE:
        case Jeeel.Dom.Event.Type.DRAG:
        case Jeeel.Dom.Event.Type.DROP:
            eventType = Jeeel.Dom.Event.Type.DRAG_EVENT;
            break;
        
        case Jeeel.Dom.Event.Type.CLICK:
        case Jeeel.Dom.Event.Type.DOUBLE_CLICK:
        case Jeeel.Dom.Event.Type.MOUSE_DOWN:
        case Jeeel.Dom.Event.Type.MOUSE_UP:
        case Jeeel.Dom.Event.Type.MOUSE_MOVE:
        case Jeeel.Dom.Event.Type.MOUSE_OVER:
        case Jeeel.Dom.Event.Type.MOUSE_OUT:
        case Jeeel.Dom.Event.Type.MOUSE_WHEEL:
        case Jeeel.Dom.Event.Type.CONTEXT_MENU:
            eventType = Jeeel.Dom.Event.Type.MOUSE_EVENT;
            break;
            
        case Jeeel.Dom.Event.Type.TOUCH_START:
        case Jeeel.Dom.Event.Type.TOUCH_MOVE:
        case Jeeel.Dom.Event.Type.TOUCH_END:
        case Jeeel.Dom.Event.Type.TOUCH_CANCEL:
            eventType = Jeeel.Dom.Event.Type.TOUCH_EVENT;
            break;
            
        case Jeeel.Dom.Event.Type.BLUR:
        case Jeeel.Dom.Event.Type.FOCUS:
        case Jeeel.Dom.Event.Type.RESIZE:
        case Jeeel.Dom.Event.Type.SCROLL:
            eventType = Jeeel.Dom.Event.Type.UI_EVENT;
            break;
      
        default:
            eventType = Jeeel.Dom.Event.Type.EVENT;
            break;
    }
    
    return eventType;
};

/**
 * イベントの種類を取得する
 *
 * @param {Event|String} event イベントインスタンスもしくはイベントのタイプ(click等)
 * @return {String} イベントの種類を示す文字列(MouseEvent等)
 */
Jeeel.Dom.Event.getEventType = function (event) {
  
    var type;
    
    if (Jeeel.Type.isEvent(event)) {
        type = event.type.toLowerCase();
    } else if (Jeeel.Type.isString(event)) {
        type = event.toLowerCase();
    }
    
    if ( ! Jeeel.Type.isString(type)) {
        return 'NonEvent';
    }

    return this._getEventType(type);
};

/**
 * イベントの登録を行う<br />
 * タッチパネル系の場合はマウスイベントを対応するイベントに自動変換する
 *
 * @param {Element} element HTML要素
 * @param {String} type イベントタイプ
 * @param {Function} listener 登録イベントメソッド
 * @param {Mixied} [thisArg] コールバック中のthisに相当する値
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
 */
Jeeel.Dom.Event.addEventListener = function (element, type, listener, thisArg, var_args) {
    var m = this.Manager.getInstance();
    m.addEventListener.apply(m, arguments);
};

/**
 * イベントの削除を行う<br />
 * タッチパネル系の場合はマウスイベントを対応するイベントに自動変換する
 *
 * @param {Element} element HTML要素
 * @param {String} type イベントタイプ
 * @param {Function} listener 登録イベントメソッド
 */
Jeeel.Dom.Event.removeEventListener = function (element, type, listener) {
    this.Manager.getInstance().removeEventListener(element, type, listener);
};

/**
 * 複数のElementに対してのイベントを上位Elementに委譲して登録を行う<br />
 * タッチパネル系の場合はマウスイベントを対応するイベントに自動変換する
 *
 * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
 * @param {String} type イベントタイプ
 * @param {Function} listener 登録イベントメソッド
 * @param {Mixied} [thisArg] コールバック中のthisに相当する値
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
 */
Jeeel.Dom.Event.delegate = function (elementList, type, listener, thisArg, var_args) {
    var m = this.Manager.getInstance();
    m.delegate.apply(m, arguments);
};

/**
 *  複数のElementに対してのイベントを上位Elementに委譲してたものの削除を行う<br />
 * タッチパネル系の場合はマウスイベントを対応するイベントに自動変換する
 *
 * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
 * @param {String} type イベントタイプ
 * @param {Function} listener 登録イベントメソッド
 */
Jeeel.Dom.Event.undelegate = function (elementList, type, listener) {
    this.Manager.getInstance().undelegate(elementList, type, listener);
};

/**
 * イベントの呼び出しを行う
 *
 * @param {Element} element HTML要素
 * @param {String} type イベントタイプ
 * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
 * @ignore 未完成
 */
Jeeel.Dom.Event.dispatchEvent = function (element, type, option) {

    var evType = this.getEventType(type);
    var view = element.ownerDocument;

    view = view.defaultView || view.parentWindow || Jeeel._global;

    if ( ! (option instanceof Jeeel.Dom.Event.Option)) {
        option = Jeeel.Dom.Event.Option.prototype;
    }
        
    var ev;
    
    if (Jeeel._doc.createEvent) {
        ev = Jeeel._doc.createEvent(evType);
    } else if (Jeeel._doc.createEventObject) {
        ev = Jeeel._doc.createEventObject(evType);
    }
    
    switch (evType) {
        case this.Type.MOUSE_EVENT:
            option.initMouseEvent(ev, type, view);
            break;
            
        case this.Type.DRAG_EVENT:
            option.initDragEvent(ev, type, view);
            break;

        case this.Type.KEYBOARD_EVENT:
            option.initKeyboardEvent(ev, type, view);
            break;
            
        case this.Type.TOUCH_EVENT:
            option.initTouchEvent(ev, type, view);
            break;

        case this.Type.UI_EVENT:
            option.initUIEvent(ev, type, view);
            break;

        case this.Type.EVENT:
        default:
            option.initEvent(ev, type);
            break;
    }
        
    if (element.dispatchEvent) {  
        element.dispatchEvent(ev);
    }
    else if (element.fireEvent) {
        element.fireEvent("on" + type, ev);
    }
};

/**
 * マウス操作無効化イベント
 * 
 * @private
 */
Jeeel.Dom.Event._disableMouse = function () {
    Jeeel.Dom.Event.getEventObject().stop(false, true);

    return false;
};

/**
 * 指定したElementのマウスEventを無効化する
 * 
 * @param {Element} element 対象のElement
 */
Jeeel.Dom.Event.disableMouseEvent = function (element) {
    element.onmousedown = element.onmouseup
                        = element.onmouseover
                        = element.ondrag
                        = element.ondragstart
                        = element.ondragend
                        = this._disableMouse;
};

Jeeel.file.Jeeel.Dom.Event = ['Type', 'KeyCode', 'Listener', 'Manager', 'Option'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Event, Jeeel.file.Jeeel.Dom.Event);

/**
 * イベントの種類の列挙体
 */
Jeeel.Dom.Event.Type = {
    
    /**
     * フォーカスが外れた時に発生
     *
     * @type String
     * @constant
     */
    BLUR: 'blur',
    
    /**
     * フォーカスが当たった時に発生
     *
     * @type String
     * @constant
     */
    FOCUS: 'focus',
    
    /**
     * 要素のサイズが変更された時に発生
     *
     * @type String
     * @constant
     */
    RESIZE: 'resize',
    
    /**
     * スクロールが行われた時に発生
     *
     * @type String
     * @constant
     */
    SCROLL: 'scroll',
    
    /**
     * フォーム要素の選択、入力内容が変更された時に発生
     *
     * @type String
     * @constant
     */
    CHANGE: 'change',
    
    /**
     * テキストが選択された時に発生
     *
     * @type String
     * @constant
     */
    SELECT: 'select',
    
    /**
     * フォームを送信しようとした時に発生
     *
     * @type String
     * @constant
     */
    SUBMIT: 'submit',
    
    /**
     * フォームがリセットされた時に発生
     *
     * @type String
     * @constant
     */
    RESET: 'reset',
    
    /**
     * 画像の読み込みを中断した時に発生
     *
     * @type String
     * @constant
     */
    ABORT: 'abort',
    
    /**
     * 画像の読み込み中にエラーが発生した時に発生
     *
     * @type String
     * @constant
     */
    ERROR: 'error',
    
    /**
     * ページや画像の読み込みが完了した時に発生
     *
     * @type String
     * @constant
     */
    LOAD: 'load',
    
    /**
     * ウィンドウを閉じた時、他のページに切り替えた時、ページをリロード（更新）した時に発生
     *
     * @type String
     * @constant
     */
    UNLOAD: 'unload',
    
    /**
     * ウィンドウを閉じた時、他のページに切り替えた時、ページをリロード（更新）する直前に発生
     *
     * @type String
     * @constant
     */
    BEFORE_UNLOAD: 'beforeunload',

    /**
     * postMessageを受け取った時に発生
     *
     * @type String
     * @constant
     */
    MESSAGE: 'message',
    
    /**
     * 要素やリンクをクリックした時に発生
     *
     * @type String
     * @constant
     */
    CLICK: 'click',
    
    /**
     * 要素をダブルクリックした時に発生
     *
     * @type String
     * @constant
     */
    DOUBLE_CLICK: 'dblclick',

    /**
     * 押していたキーをあげた時に発生
     *
     * @type String
     * @constant
     */
    KEY_UP: 'keyup',

    /**
     * キーを押した時に発生
     *
     * @type String
     * @constant
     */
    KEY_DOWN: 'keydown',

    /**
     * キーを押してる時に発生
     *
     * @type String
     * @constant
     */
    KEY_PRESS: 'keypress',

    /**
     * マウスが離れたした時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_OUT: 'mouseout',

    /**
     * マウスが離れたした時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_OVER: 'mouseover',

    /**
     * クリックしたマウスを上げた時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_UP: 'mouseup',

    /**
     * マウスでクリックした時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_DOWN: 'mousedown',

    /**
     * マウスを動かしている時に発生
     *
     * @type String
     * @constant
     */
    MOUSE_MOVE: 'mousemove',
    
    /**
     * マウスのホイールを回した時に発生s
     * 
     * @type String
     * @constant
     */
    MOUSE_WHEEL: 'mousewheel',
    
    /**
     * コンテキストメニューを表示しようとした時に発生
     *
     * @type String
     * @constant
     */
    CONTEXT_MENU: 'contextmenu',
    
    /**
     * 貼り付けをした時に発生
     *
     * @type String
     * @constant
     */
    PASTE: 'paste',
    
    /**
     * ドラッグ開始時に発生
     *
     * @type String
     * @constant
     */
    DRAG_START: 'dragstart',
    
    /**
     * ドラッグ終了時に発生
     *
     * @type String
     * @constant
     */
    DRAG_END: 'dragend',
    
    /**
     * ドラッグ要素がドロップ要素に入った時に発生
     *
     * @type String
     * @constant
     */
    DRAG_ENTER: 'dragenter',
    
    /**
     * ドラッグ要素がドロップ要素と重なっている間発生
     *
     * @type String
     * @constant
     */
    DRAG_OVER: 'dragover',
    
    /**
     * ドラッグ要素がドロップ要素から出た時に発生
     *
     * @type String
     * @constant
     */
    DRAG_LEAVE: 'dragleave',
    
    /**
     * ドラッグしている間継続して発生
     *
     * @type String
     * @constant
     */
    DRAG: 'drag',
    
    /**
     * ドロップした時に発生
     *
     * @type String
     * @constant
     */
    DROP: 'drop',
    
    /**
     * タッチパネル式の媒体で要素にタッチした時に発生
     *
     * @type String
     * @constant
     */
    TOUCH_START: 'touchstart',
    
    /**
     * タッチパネル式の媒体で要素にタッチしたまま動かした時に発生
     *
     * @type String
     * @constant
     */
    TOUCH_MOVE: 'touchmove',
    
    /**
     * タッチパネル式の媒体で要素にタッチした状態から離れた時に発生
     *
     * @type String
     * @constant
     */
    TOUCH_END: 'touchend',
    
    /**
     * タッチパネル式の媒体で要素にタッチ中に電話がかかってきら場合などにに発生
     *
     * @type String
     * @constant
     */
    TOUCH_CANCEL: 'touchcancel',
    
    /**
     * タッチパネル式の媒体で縦と横持ちを変えた時に発生
     *
     * @type String
     * @constant
     */
    ORIENTATION_CHANGE: 'orientationchange',
    
    /**
     * メディアの再生が開始された時に発生
     *
     * @type String
     * @constant
     */
    PLAY: 'play',
    
    /**
     * メディアが一時停止された時に発生
     *
     * @type String
     * @constant
     */
    PAUSE: 'pause',
    
    /**
     * メディアのリソースが終端に達したために再生が停止した時に発生
     *
     * @type String
     * @constant
     */
    ENDED: 'ended',
    
    /**
     * メディアのボリュームが変化及びミュート切り替え時に発生
     *
     * @type String
     * @constant
     */
    VOLUME_CHANGE: 'volumechange',
    
    /**
     * マウスイベントを示す
     *
     * @type String
     * @constant
     */
    MOUSE_EVENT: 'MouseEvent',
    
    /**
     * ドラッグイベントを示す
     *
     * @type String
     * @constant
     */
    DRAG_EVENT: 'DragEvent',
    
    /**
     * タッチイベントを示す
     *
     * @type String
     * @constant
     */
    TOUCH_EVENT: 'TouchEvent',
    
    /**
     * キーボードイベントを示す
     *
     * @type String
     * @constant
     */
    KEYBOARD_EVENT: 'KeyboardEvent',
    
    /**
     * UIイベントを示す
     *
     * @type String
     * @constant
     */
    UI_EVENT: 'UIEvent',

    /**
     * その他のイベントを示す
     *
     * @type String
     * @constant
     */
    EVENT: 'Event'
};

(function () {
    var wheel = 'on' + Jeeel.Dom.Event.Type.MOUSE_WHEEL;
    
    // Firefoxのホイールイベント
    if (Jeeel._doc && ! (wheel in Jeeel._global || wheel in Jeeel._doc)) {
        Jeeel.Dom.Event.Type.MOUSE_WHEEL = 'DOMMouseScroll';
    }
})();

/**
 * キーボードのコードに関する列挙体
 */
Jeeel.Dom.Event.KeyCode = {

    /**
     * A
     *
     * @type Integer
     * @constant
     */
    A: 65,

    /**
     * B
     *
     * @type Integer
     * @constant
     */
    B: 66,

    /**
     * C
     *
     * @type Integer
     * @constant
     */
    C: 67,

    /**
     * D
     *
     * @type Integer
     * @constant
     */
    D: 68,

    /**
     * E
     *
     * @type Integer
     * @constant
     */
    E: 69,

    /**
     * F
     *
     * @type Integer
     * @constant
     */
    F: 70,

    /**
     * G
     *
     * @type Integer
     * @constant
     */
    G: 71,

    /**
     * H
     *
     * @type Integer
     * @constant
     */
    H: 72,

    /**
     * I
     *
     * @type Integer
     * @constant
     */
    I: 73,

    /**
     * J
     *
     * @type Integer
     * @constant
     */
    J: 74,

    /**
     * K
     *
     * @type Integer
     * @constant
     */
    K: 75,

    /**
     * L
     *
     * @type Integer
     * @constant
     */
    L: 76,

    /**
     * M
     *
     * @type Integer
     * @constant
     */
    M: 77,

    /**
     * N
     *
     * @type Integer
     * @constant
     */
    N: 78,

    /**
     * O
     *
     * @type Integer
     * @constant
     */
    O: 79,

    /**
     * P
     *
     * @type Integer
     * @constant
     */
    P: 80,

    /**
     * Q
     *
     * @type Integer
     * @constant
     */
    Q: 81,

    /**
     * R
     *
     * @type Integer
     * @constant
     */
    R: 82,

    /**
     * S
     *
     * @type Integer
     * @constant
     */
    S: 83,

    /**
     * T
     *
     * @type Integer
     * @constant
     */
    T: 84,

    /**
     * U
     *
     * @type Integer
     * @constant
     */
    U: 85,

    /**
     * V
     *
     * @type Integer
     * @constant
     */
    V: 86,

    /**
     * W
     *
     * @type Integer
     * @constant
     */
    W: 87,

    /**
     * X
     *
     * @type Integer
     * @constant
     */
    X: 88,

    /**
     * Y
     *
     * @type Integer
     * @constant
     */
    Y: 89,

    /**
     * Z
     *
     * @type Integer
     * @constant
     */
    Z: 90,

    /**
     * 0
     *
     * @type Integer
     * @constant
     */
    0: 48,

    /**
     * 1
     *
     * @type Integer
     * @constant
     */
    1: 49,

    /**
     * 2
     *
     * @type Integer
     * @constant
     */
    2: 50,

    /**
     * 3
     *
     * @type Integer
     * @constant
     */
    3: 51,

    /**
     * 4
     *
     * @type Integer
     * @constant
     */
    4: 52,

    /**
     * 5
     *
     * @type Integer
     * @constant
     */
    5: 53,

    /**
     * 6
     *
     * @type Integer
     * @constant
     */
    6: 54,

    /**
     * 7
     *
     * @type Integer
     * @constant
     */
    7: 55,

    /**
     * 8
     *
     * @type Integer
     * @constant
     */
    8: 56,

    /**
     * 9
     *
     * @type Integer
     * @constant
     */
    9: 57,

    /**
     * テンキー0
     *
     * @type Integer
     * @constant
     */
    T0: 96,

    /**
     * テンキー1
     *
     * @type Integer
     * @constant
     */
    T1: 97,

    /**
     * テンキー2
     *
     * @type Integer
     * @constant
     */
    T2: 98,

    /**
     * テンキー3
     *
     * @type Integer
     * @constant
     */
    T3: 99,

    /**
     * テンキー4
     *
     * @type Integer
     * @constant
     */
    T4: 100,

    /**
     * テンキー5
     *
     * @type Integer
     * @constant
     */
    T5: 101,

    /**
     * テンキー6
     *
     * @type Integer
     * @constant
     */
    T6: 102,

    /**
     * テンキー7
     *
     * @type Integer
     * @constant
     */
    T7: 103,

    /**
     * テンキー8
     *
     * @type Integer
     * @constant
     */
    T8: 104,

    /**
     * テンキー9
     *
     * @type Integer
     * @constant
     */
    T9: 105,

    /**
     * テンキー&lowast;
     *
     * @type Integer
     * @constant
     */
    TMultiplicationSign: 106,

    /**
     * テンキー+
     *
     * @type Integer
     * @constant
     */
    TAdditionSign: 107,

    /**
     * テンキー-
     *
     * @type Integer
     * @constant
     */
    TSubtractionSign: 109,

    /**
     * テンキー.
     *
     * @type Integer
     * @constant
     */
    TPeriod: 110,

    /**
     * テンキー/
     *
     * @type Integer
     * @constant
     */
    TDivisionSign: 111,

    /**
     * F1
     *
     * @type Integer
     * @constant
     */
    F1: 112,

    /**
     * F2
     *
     * @type Integer
     * @constant
     */
    F2: 113,

    /**
     * F3
     *
     * @type Integer
     * @constant
     */
    F3: 114,

    /**
     * F4
     *
     * @type Integer
     * @constant
     */
    F4: 115,

    /**
     * F5
     *
     * @type Integer
     * @constant
     */
    F5: 116,

    /**
     * F6
     *
     * @type Integer
     * @constant
     */
    F6: 117,

    /**
     * F7
     *
     * @type Integer
     * @constant
     */
    F7: 118,

    /**
     * F8
     *
     * @type Integer
     * @constant
     */
    F8: 119,

    /**
     * F9
     *
     * @type Integer
     * @constant
     */
    F9: 120,

    /**
     * F10
     *
     * @type Integer
     * @constant
     */
    F10: 121,

    /**
     * F11
     *
     * @type Integer
     * @constant
     */
    F11: 122,

    /**
     * F12
     *
     * @type Integer
     * @constant
     */
    F12: 123,

    /**
     * BackSpace
     *
     * @type Integer
     * @constant
     */
    BackSpace: 8,

    /**
     * Enter
     *
     * @type Integer
     * @constant
     */
    Enter: 13,

    /**
     * Shift
     *
     * @type Integer
     * @constant
     */
    Shift: 16,

    /**
     * Ctrl
     *
     * @type Integer
     * @constant
     */
    Ctrl: 17,

    /**
     * Alt
     *
     * @type Integer
     * @constant
     */
    Alt: 18,

    /**
     * Pause
     *
     * @type Integer
     * @constant
     */
    Pause: 19,

    /**
     * 変換
     *
     * @type Integer
     * @constant
     */
    Change: 28,

    /**
     * 無変換
     *
     * @type Integer
     * @constant
     */
    NonChange: 29,

    /**
     * スペース
     *
     * @type Integer
     * @constant
     */
    Space: 32,

    /**
     * PageUp
     *
     * @type Integer
     * @constant
     */
    PageUp: 33,

    /**
     * PageDown
     *
     * @type Integer
     * @constant
     */
    PageDown: 34,

    /**
     * End
     *
     * @type Integer
     * @constant
     */
    End: 35,

    /**
     * Home
     *
     * @type Integer
     * @constant
     */
    Home: 36,

    /**
     * ←
     *
     * @type Integer
     * @constant
     */
    Left: 37,

    /**
     * ↑
     *
     * @type Integer
     * @constant
     */
    Up: 38,

    /**
     * →
     *
     * @type Integer
     * @constant
     */
    Right: 39,

    /**
     * ↓
     *
     * @type Integer
     * @constant
     */
    Down: 40,

    /**
     * Insert
     *
     * @type Integer
     * @constant
     */
    Insert: 45,

    /**
     * Delete
     *
     * @type Integer
     * @constant
     */
    Delete: 46,

    /**
     * Windowsキー
     *
     * @type Integer
     * @constant
     */
    Windows: 91,

    /**
     * Esc
     *
     * @type Integer
     * @constant
     */
    Esc: 243,

    /**
     * Tab
     *
     * @type Integer
     * @constant
     */
    Tab: 9,

    /**
     * Applicationキー
     *
     * @type Integer
     * @constant
     */
    Application: 93,

    /**
     * NumLock
     *
     * @type Integer
     * @constant
     */
    NumLock: 144,

    /**
     * ScrollLock
     *
     * @type Integer
     * @constant
     */
    ScrollLock: 145,

    /**
     * &lowast;
     *
     * @type Integer
     * @constant
     */
    MultiplicationSign: 186,

    /**
     * +
     *
     * @type Integer
     * @constant
     */
    AdditionSign: 187,

    /**
     * ,
     *
     * @type Integer
     * @constant
     */
    Comma: 188,

    /**
     * -
     *
     * @type Integer
     * @constant
     */
    SubtractionSign: 189,

    /**
     * .
     *
     * @type Integer
     * @constant
     */
    Period: 190,

    /**
     * &frasl;
     *
     * @type Integer
     * @constant
     */
    DivisionSign: 191,

    /**
     * &#64;
     *
     * @type Integer
     * @constant
     */
    Atmark: 192,

    /**
     * [
     *
     * @type Integer
     * @constant
     */
    LeftBracket: 219,

    /**
     * \
     *
     * @type Integer
     * @constant
     */
    YenMark: 220,

    /**
     * ]
     *
     * @type Integer
     * @constant
     */
    RightBracket: 221,

    /**
     * ^
     *
     * @type Integer
     * @constant
     */
    Caret: 222,

    /**
     * _
     *
     * @type Integer
     * @constant
     */
    Underscore: 226
};

Jeeel.Dom.Event.KeyCode.getKey = function (keyCode) {
    return Jeeel.Hash.search(keyCode, this, true);
};

/**
 * コンストラクタ
 * 
 * @class イベントリスナーを管理するクラス
 * @param {Element} element リスナー管理対象のElement
 */
Jeeel.Dom.Event.Listener = function (element) {
    this._element = element;
    
    this._tasks = {};
    
    this.listener = Jeeel.Function.simpleBind(this.listener, this);
};

Jeeel.Dom.Event.Listener.prototype = {
  
    /**
     * リスナー登録要素
     * 
     * @type Element
     * @private
     */
    _element: null,
    
    /**
     * タスクリスト
     * 
     * @type Hash
     * @private
     */
    _tasks: {},
    
    /**
     * Elementを保持しているかどうかを返す
     * 
     * @param {Element} elm 検索Element
     * @return {Boolean} 保持しているかどうか
     */
    hasElement: function (elm) {
        return this._element === elm;
    },
    
    /**
     * 登録を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Array} [args] コールバックに渡す引数のリスト(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
     */
    add: function (type, listener, thisArg, args) {
        type = this._getType(type);
        
        var lowerType = type.toLowerCase();
        
        if ( ! this._tasks[lowerType]) {
            this._tasks[lowerType] = [];
            this._setListener(type);
        }
        
        if ( ! args) {
            args = [];
        }
        
        var tasks = this._tasks[lowerType];
        
        Array.prototype.unshift.call(args, null, null);

        tasks[tasks.length] = {
            listener: listener, 
            thisArg: thisArg,
            useThis: Jeeel.Type.isSet(thisArg),
            args: args
        };
        
        tasks = null;
        
        return this;
    },
    
    /**
     * 削除を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     */
    remove: function (type, listener) {
        type = this._getType(type);
        
        var lowerType = type.toLowerCase();
        
        if ( ! this._tasks[lowerType]) {
            return this;
        }
        
        var tasks = this._tasks[lowerType],
            l = tasks.length,
            i = 0;
            
        if (l === 1) {
            delete this._tasks[lowerType];
            this._unsetListener(type);
            tasks = null;
            return this;
        }

        for (; i < l; i++) {
            if (tasks[i].listener === listener) {
                tasks.splice(i, 1);
                break;
            }
        }
        
        tasks = null;
        
        return this;
    },
    
    /**
     * 複数のElementに対してのイベントを上位Elementに委譲して登録を行う
     *
     * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Array} [args] コールバックに渡す引数のリスト(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
     */
    delegate: function (elementList, type, listener, thisArg, args) {
        type = this._getType(type);
        
        var lowerType = type.toLowerCase();
        
        elementList = new Jeeel.Dom.ElementOperator(elementList);

        var parent = elementList.getCommonParent();
        
        if (parent && (this._element === parent || this._element === parent.ownerDocument)) {
            if ( ! this._tasks[lowerType]) {
                this._tasks[lowerType] = [];
                this._setListener(type);
            }
            
            if ( ! args) {
                args = [];
            }
            
            var tasks = this._tasks[lowerType];
            
            Array.prototype.unshift.call(args, null, null);
            
            tasks[tasks.length] = {
                elementList: elementList.getAll(),
                listener: listener, 
                thisArg: thisArg,
                useThis: Jeeel.Type.isSet(thisArg),
                args: args
            };
            
            tasks = null;
        }
        
        return this;
    },
    
    /**
     *  複数のElementに対してのイベントを上位Elementに委譲してたものの削除を行う
     *
     * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     */
    undelegate: function (elementList, type, listener) {
        type = this._getType(type);
        
        var lowerType = type.toLowerCase();
        
        if ( ! this._tasks[lowerType]) {
            return this;
        }
        
        elementList = new Jeeel.Dom.ElementOperator(elementList);
        
        var parent = elementList.getCommonParent();
        
        if (this._element !== parent && this._element !== parent.ownerDocument) {
            return this;
        }
        
        var tasks = this._tasks[lowerType],
            l = tasks.length,
            i = 0;
            
        if (l === 1) {
            delete this._tasks[lowerType];
            this._unsetListener(type);
            tasks = null;
            return this;
        }

        for (; i < l; i++) {
            if (tasks[i].elementList && tasks[i].listener === listener) {
                tasks.splice(i, 1);
                break;
            }
        }
        
        tasks = null;
        
        return this;
    },
    
    /**
     * イベントから実際に呼ばれるリスナー
     * 
     * @param {Event} e イベントオブジェクト
     */
    listener: function (e) {
        e = new Jeeel.Dom.Event(e || Jeeel._global.event, this._element);
        
        var tasks = this._tasks[e.type].concat(),
            task, args, i = 0,
            j, k, targets, target, elmList, elm, brk;

        while(task = tasks[i++]) {
            args = task.args;
            elmList = task.elementList;
            
            args[0] = e;
            
            if (elmList) {
                targets = e.getBubblingTargets();
                brk = false;
                j = 0;
                
                while(target = targets[j++]) {
                    k = 0;
                    
                    while(elm = elmList[k++]) {
                        if (target === elm) {
                            if ( ! task.useThis) {
                                task.thisArg = target;
                            }
                            
                            args[1] = target;
                            task.listener.apply(task.thisArg, args);
                            brk = true;
                            break;
                        }
                    }
                    
                    if (brk) {
                        break;
                    }
                }
            } else {
                if ( ! task.useThis) {
                    task.thisArg = e.currentTarget;
                }
                
                args[1] = e.currentTarget;
                task.listener.apply(task.thisArg, args);
            }
            
            if ( ! task.useThis) {
                task.thisArg = null;
            }
            
            args[0] = args[1] = null;
        }
        
        // メモリリークを防ぐため
        tasks = task = targets = target = elmList = elm = e = args = null;
    },
    
    /**
     * イベントタイプを渡して変換する
     * 
     * @param {String} type イベントタイプ
     * @return {String} イベントタイプ
     */
    _getType: function (type) {},

    /**
     * 実際にリスナーを登録する
     * 
     * @param {String} type イベントタイプ
     * @private
     */
    _setListener: function (type) {},
    
    /**
     * 実際にリスナーを削除する
     * 
     * @param {String} type イベントタイプ
     * @private
     */
    _unsetListener: function (type) {}
};

(function () {
    var getType, add, remove;
    
    var isTouchPanelMobile = Jeeel.UserAgent.isAndroid()
                          || Jeeel.UserAgent.isIPhone()
                          || Jeeel.UserAgent.isIPad()
                          || Jeeel.UserAgent.isIPod();

    if (Jeeel._global && isTouchPanelMobile) {
        /**
         * @ignore
         */
        getType = function (type) {
            switch (type) {
                case Jeeel.Dom.Event.Type.MOUSE_DOWN:
                    type = Jeeel.Dom.Event.Type.TOUCH_START;
                    break;

                case Jeeel.Dom.Event.Type.MOUSE_MOVE:
                    type = Jeeel.Dom.Event.Type.TOUCH_MOVE;
                    break;

                case Jeeel.Dom.Event.Type.MOUSE_UP:
                    type = Jeeel.Dom.Event.Type.TOUCH_END;
                    break;

                default:
                    break;
            }
            
            return type;
        };
    } else {
        getType = Jeeel.Function.Template.RETURN_ARGUMENT;
    }
    
    if (Jeeel._global && Jeeel._global.addEventListener) {
        /**
         * @ignore
         */
        add = function (type) {
            this._element.addEventListener(type, this.listener, false);
        };
        
        /**
         * @ignore
         */
        remove = function (type) {
            this._element.removeEventListener(type, this.listener, false);
        };
    } else if (Jeeel._global && Jeeel._global.attachEvent) {
        /**
         * @ignore
         */
        add = function (type) {
            this._element.attachEvent("on" + type, this.listener);
        };
        
        /**
         * @ignore
         */
        remove = function (type) {
            this._element.detachEvent("on" + type, this.listener);
        };
    } else {
        /**
         * @ignore
         */
        add = remove = function (type) {
            Jeeel.errorDump('このブラウザはイベント登録に対応していません。');
        };
    }
    
    Jeeel.Dom.Event.Listener.prototype._getType = getType;
    Jeeel.Dom.Event.Listener.prototype._setListener = add;
    Jeeel.Dom.Event.Listener.prototype._unsetListener = remove;
    
    getType = add = remove = null;
})();

(function () {
    var instance;
    
    /**
     * コンストラクタ
     * 
     * @class 全てのイベントを管理するシングルトンクラス
     */
    Jeeel.Dom.Event.Manager = function () {
        if (instance) {
            return instance;
        }

        instance = this;
        
        this._listeners = [];
    };
    
    /**
     * インスタンスを取得する
     * 
     * @return {Jeeel.Dom.Event.Manager} インスタンス
     */
    Jeeel.Dom.Event.Manager.getInstance = function () {
        return (instance || new this());
    };
})();



Jeeel.Dom.Event.Manager.prototype = {
  
    /**
     * リスナー配列
     * 
     * @type Jeeel.Dom.Event.Listener[]
     * @private
     */
    _listeners: [],
    
    /**
     * イベントの登録を行う
     *
     * @param {Element} element HTML要素
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
     */
    addEventListener: function (element, type, listener, thisArg, var_args) {
        var args = Array.prototype.slice.call(arguments, 4, arguments.length);
        this._getListener(element).add(type, listener, thisArg, args);
        
        return this;
    },
    
    /**
     * イベントの削除を行う
     *
     * @param {Element} element HTML要素
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     */
    removeEventListener: function (element, type, listener) {
        this._getListener(element).remove(type, listener);
        
        return this;
    },
    
    /**
     * 複数のElementに対してのイベントを上位Elementに委譲して登録を行う
     *
     * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Event、次の引数はイベント発生Element、3つ目以降に任意引数)
     */
    delegate: function (elementList, type, listener, thisArg, var_args) {
        elementList = new Jeeel.Dom.ElementOperator(elementList);
        var args = Array.prototype.slice.call(arguments, 4, arguments.length);
        this._getListener(elementList.getCommonParent()).delegate(elementList, type, listener, thisArg, args);
        
        return this;
    },
    
    /**
     *  複数のElementに対してのイベントを上位Elementに委譲してたものの削除を行う
     *
     * @param {Element} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     */
    undelegate: function (elementList, type, listener) {
        elementList = new Jeeel.Dom.ElementOperator(elementList);
        this._getListener(elementList.getCommonParent()).undelegate(elementList, type, listener);
        
        return this;
    },
    
    /**
     * Listenerインスタンスを取得する
     * 
     * @param {Element} elm Element
     * @return {Jeeel.Dom.Event.Listener} Listenerインスタンス
     * @private
     */
    _getListener: function (elm) {
        var i, listener = this._listeners;
        
        for (i = listener.length; i--;) {
            if (listener[i].hasElement(elm)) {
                return listener[i];
            }
        }
        
        return listener[listener.length] = new Jeeel.Dom.Event.Listener(elm);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Event.Manager
};

/**
 * コンストラクタ
 * 
 * @class イベントの作成時のパラメータを管理するクラス
 */
Jeeel.Dom.Event.Option = function () {
    this._touches = [];
    this._targetTouches = [];
    this._changedTouches = [];
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Dom.Event.Option} 作成したインスタンス
 */
Jeeel.Dom.Event.Option.create = function () {
    return new this();
};

Jeeel.Dom.Event.Option.prototype = {
    _canBubble: true,
    _cancelable: true, 
    _viewArg: null, 
    _ctrlKeyArg: false, 
    _altKeyArg: false, 
    _shiftKeyArg: false, 
    _metaKeyArg: false, 
    _keyCodeArg: 0, 
    _charCodeArg: 0,
    _detail: 1,
    _screenX: 0,
    _screenY: 0,
    _clientX: 0,
    _clientY: 0,
    _button: 0,
    _relatedTarget: null,
    _touches: [],
    _targetTouches: [],
    _changedTouches: [],
    _scale: 1.0,
    _rotation: 0,
    _dataTransfer: null,
    
    setCanBubble: function (canBubble) {
        this._canBubble = !!canBubble;
        
        return this;
    },
    
    setCancelable: function (cancelable) {
        this._cancelable = !!cancelable;
        
        return this;
    },
    
    setViewArg: function (viewArg) {
        this._viewArg = viewArg;
        
        return this;
    },
    
    setCtrlKeyArg: function (ctrlKeyArg) {
        this._ctrlKeyArg = !!ctrlKeyArg;
        
        return this;
    },
    
    setAltKeyArg: function (altKeyArg) {
        this._altKeyArg = !!altKeyArg;
        
        return this;
    },
    
    setShiftKeyArg: function (shiftKeyArg) {
        this._shiftKeyArg = !!shiftKeyArg;
        
        return this;
    },
    
    setMetaKeyArg: function (metaKeyArg) {
        this._metaKeyArg = !!metaKeyArg;
        
        return this;
    },
    
    setKeyCodeArg: function (keyCodeArg) {
        this._keyCodeArg = +keyCodeArg;
        
        return this;
    },
    
    setCharCodeArg: function (charCodeArg) {
        this._charCodeArg = +charCodeArg;
        
        return this;
    },
    
    setDetail: function (detail) {
        this._detail = +detail;
        
        return this;
    },
    
    setScreen: function (x, y) {
        this._screenX = +x;
        this._screenY = +y;
        
        return this;
    },
    
    setClient: function (x, y) {
        this._clientX = +x;
        this._clientY = +y;
        
        return this;
    },
    
    setButton: function (button) {
        this._button = +button;
        
        return this;
    },
    
    setRelatedTarget: function (relatedTarget) {
        this._relatedTarget = relatedTarget;
        
        return this;
    },
    
    setTouches: function (touches) {
        this._touches = touches;
        
        return this;
    },
    
    setTargetTouches: function (targetTouches) {
        this._targetTouches = targetTouches;
        
        return this;
    },
    
    setChangedTouches: function (changedTouches) {
        this._changedTouches = changedTouches;
        
        return this;
    },
    
    setScale: function (scale) {
        this._scale = +scale;

        return this;
    },
    
    setRotation: function (rotation) {
        this._rotation = +rotation;
        
        return this;
    },
    
    setDataTransfer: function (dataTransfer) {
        this._dataTransfer = dataTransfer;
        
        return this;
    },
    
    getEventOption: function (type) {
        return [
            type,
            this._canBubble,
            this._cancelable
        ];
    },
    
    getMouseEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._detail,
            this._screenX,
            this._screenY,
            this._clientX,
            this._clientY,
            this._ctrlKeyArg,
            this._altKeyArg,
            this._shiftKeyArg,
            this._metaKeyArg,
            this._button,
            this._relatedTarget
        ];
    },
    
    getDragEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._detail,
            this._screenX,
            this._screenY,
            this._clientX,
            this._clientY,
            this._ctrlKeyArg,
            this._altKeyArg,
            this._shiftKeyArg,
            this._metaKeyArg,
            this._button,
            this._relatedTarget,
            this._dataTransfer
        ];
    },
    
    getKeyboardEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._ctrlKeyArg,
            this._altKeyArg,
            this._shiftKeyArg,
            this._metaKeyArg,
            this._keyCodeArg,
            this._charCodeArg
        ];
    },
    
    getTouchEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._detail,
            this._screenX,
            this._screenY,
            this._clientX,
            this._clientY,
            this._ctrlKeyArg,
            this._altKeyArg,
            this._shiftKeyArg,
            this._metaKeyArg,
            this._touches,
            this._targetTouches,
            this._changedTouches,
            this._scale,
            this._rotation
        ];
    },
    
    getUIEventOption: function (type, view) {
        return [
            type,
            this._canBubble,
            this._cancelable,
            this._viewArg || view,
            this._detail
        ];
    },
    
    initEvent: function (event, type) {
        if (event.initEvent) {
            event.initEvent.apply(event, this.getEventOption(type));
            return event;
        }
        
        event.type = type;
        event.cancelBubble = this._canBubble;
        
        return event;
    },
    
    initMouseEvent: function (event, type, view) {
        if (event.initMouseEvent) {
            event.initMouseEvent.apply(event, this.getMouseEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.screenX = this._screenX;
        event.screenY = this._screenY;
        event.clientX = this._clientX;
        event.clientY = this._clientY;
        event.ctrlKey = this._ctrlKeyArg;
        event.altKey = this._altKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.metaKey = this._metaKeyArg;
        event.button = this._button;
        event.relatedTarget = this._relatedTarget;
        
        return event;
    },
    
    initDragEvent: function (event, type, view) {
        if (event.initDragEvent) {
            event.initDragEvent.apply(event, this.getDragEventOption(type, view));
            return event;
        } else if (event.initMouseEvent) {
            event.initMouseEvent.apply(event, this.getDragEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.screenX = this._screenX;
        event.screenY = this._screenY;
        event.clientX = this._clientX;
        event.clientY = this._clientY;
        event.ctrlKey = this._ctrlKeyArg;
        event.altKey = this._altKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.metaKey = this._metaKeyArg;
        event.button = this._button;
        event.relatedTarget = this._relatedTarget;
        event.dataTransfer = this._dataTransfer;
        
        return event;
    },
    
    initKeyboardEvent: function (event, type, view) {
        if (event.initKeyboardEvent) {
            event.initKeyboardEvent.apply(event, this.getKeyboardEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.ctrlKey = this._ctrlKeyArg;
        event.altKey = this._altKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.metaKey = this._metaKeyArg;
        event.keyCode = this._keyCodeArg;
        event.charCode = this._charCodeArg;
        
        return event;
    },
    
    initTouchEvent: function (event, type, view) {
        if (event.initTouchEvent) {
            event.initTouchEvent.apply(event, this.getTouchEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.screenX = this._screenX;
        event.screenY = this._screenY;
        event.clientX = this._clientX;
        event.clientY = this._clientY;
        event.ctrlKey = this._ctrlKeyArg;
        event.altKey = this._altKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.metaKey = this._metaKeyArg;
        event.touches = this._touches;
        event.targetTouches = this._targetTouches;
        event.changedTouches = this._changedTouches;
        event.scale = this._scale;
        event.rotation = this._rotation;
        
        return event;
    },
    
    initUIEvent: function (event, type, view) {
        if (event.initUIEvent) {
            event.initUIEvent.apply(event, this.getUIEventOption(type, view));
            return event;
        }
        
        this.initEvent(event, type);
        
        event.screenX = this._screenX;
        event.screenY = this._screenY;
        event.clientX = this._clientX;
        event.clientY = this._clientY;
        event.ctrlKey = this._ctrlKeyArg;
        event.shiftKey = this._shiftKeyArg;
        event.altKey = this._altKeyArg;
        
        return event;
    }
};
Jeeel.directory.Jeeel.Dom.Style = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Style/';
    }
};

/**
 * コンストラクタ
 * 
 * @class スタイルを扱うクラス
 * @param {Element} element スタイルの操作対象Element
 * @example
 * 通常のスタイルに加え以下のクロスブラウザ実装と疑似実装を行っている
 * なおキャメルケースで記述しているがハイフネーション形式でも問題なく動作する
 * opacity
 * backgroundPositionX
 * backgroundPositionY
 * perspective
 * backfaceVisibility
 * transformOrigin
 * transformStyle
 * transform
 * rotate
 * rotateX
 * rotateY
 * rotateZ
 * rotate3d
 * translate
 * translateX
 * translateY
 * translateZ
 * translate3d
 * scale
 * scaleX
 * scaleY
 * scaleZ
 * scale3d
 * skew
 * skewX
 * skewY
 * matrix
 * matrix3d
 * transition
 * transitionProperty
 * transitionDuration
 * transitionTimingFunction
 * transitionDelay
 */
Jeeel.Dom.Style = function (element) {
    this._style = element && element.style || null;
    
    if (element) {
        this._computedStyle = element.parentNode && Jeeel.Document.getComputedStyle(element) || null;
    }
    
    this._hook = element && new this.constructor.Hook(element, this);
    this._customStyle = this._style &&  new this.constructor.Custom(this._style, this._computedStyle);
    this._bundler = this._customStyle && new this.constructor.Bundler(this._customStyle);
    this._defaultDisplay = this.constructor.getDefaultDisplay(element && element.nodeName);
    this._animationQueue = [];
    this._nextAnimate = Jeeel.Function.simpleBind(this._nextAnimate, this);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Style} style 操作スタイル
 * @return {Jeeel.Dom.Style} 作成したインスタンス
 */
Jeeel.Dom.Style.create = function (style) {
    return new this(style);
};

(function () {
    var cache = {};
    
    /**
     * 初期状態のdisplayの値を取得する
     * 
     * @param {String} nodeName 取得したいノード名
     * @return {String} 取得したdisplayの初期値
     */
    Jeeel.Dom.Style.getDefaultDisplay = function (nodeName) {
      
        if ( ! nodeName) {
            return 'inline';
        }
        
        if (nodeName in cache) {
            return cache[nodeName];
        }
        
        var elm = Jeeel.Document.createElement(nodeName);
        var body = Jeeel.Document.getBody();

        body.appendChild(elm);

        var display = Jeeel.Document.getComputedStyle(elm).display;

        body.removeChild(elm);

        // 任意にスタイルが設定されていた場合で且displayの値がnoneもしくは不明の場合はiframe内で再取得
        if (display === 'none' || display === '') {
            var iframe = Jeeel.Document.createElement('iframe');

            iframe.frameBorder = iframe.width = iframe.height = 0;

            body.appendChild(iframe);

            var iframeDoc = iframe.contentDocument || iframe.contentWindow && iframe.contentWindow.document;
            
            iframeDoc.write((Jeeel.Document.getDocument().compatMode === 'CSS1Compat' ? '<!doctype html>' : '' ) + '<html><body>');
            iframeDoc.close();

            elm = iframeDoc.createElement(nodeName);

            iframeDoc.body.appendChild(elm);

            display = Jeeel.Document.getComputedStyle(elm).display;

            body.removeChild(iframe);
        }
        
        cache[nodeName] = display;

        return display;
    };
})();

Jeeel.Dom.Style.prototype = {
  
    /**
     * 操作対象スタイル
     * 
     * @type CSSStyleDeclaration
     * @private
     */
    _style: null,
    
    /**
     * 操作フック
     * 
     * @type Jeeel.Dom.Style.Hook
     * @private
     */
    _hook: null,
    
    /**
     * 操作フック
     * 
     * @type Jeeel.Dom.Style.Bundler
     * @private
     */
    _bundler: null,
    
    /**
     * カスタムスタイル
     * 
     * @type Jeeel.Dom.Style.Custom
     * @private
     */
    _customStyle: null,
    
    /**
     * 計算済みスタイル
     * 
     * @type CSSStyleDeclaration
     * @private
     */
    _computedStyle: null,
    
    /**
     * デフォルトの表示状態(inlineかblock、もしくはnoneの可能性もある: head)
     * 
     * @type String
     * @private
     */
    _defaultDisplay: '',
    
    _oldDisplay: '',
    
    _animated: false,
    
    _currentAnimation: null,
    
    _animationQueue: [],
    
    /**
     * 要素のstyleを取得する
     * 
     * @return {CSSStyleDeclaration} スタイル
     */
    getElementStyle: function () {
        return this._style;
    },
    
    /**
     * 要素の計算済みstyleを取得する
     * 
     * @return {CSSStyleDeclaration} スタイル
     */
    getComputedStyle: function () {
        return this._computedStyle;
    },
    
    /**
     * スタイルを取得する
     *
     * @param {String} style スタイル名
     * @return {String} スタイル値
     */
    getStyle: function (style) {
        style = Jeeel.String.toCamelCase(style);
        
        // まずフックを参照し、続いて通常のスタイル、カスタムスタイル、計算済みスタイルから参照する
        return (this._hook[style] && this._hook[style]()) 
            || this._style[style]
            || (this._customStyle[style] && this._customStyle[style]()) 
            || (this._computedStyle && this._computedStyle[style])
            || null;
    },

    /**
     * スタイルの設定を行う
     *
     * @param {String} style スタイル名
     * @param {String} value スタイル値
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    setStyle: function (style, value) {
        var styleName = Jeeel.String.toCamelCase(style);
        
        // カスタムスタイルに対して設定を行う
        if (this._customStyle[styleName]) {
            this._customStyle[styleName](value);
            
            return this;
        }
        
        this._style[styleName] = value;

        return this;
    },
    
    /**
     * 複数のスタイルの設定を行う
     *
     * @param {Hash} styles スタイル名と値のペアリスト
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    setStyleList: function (styles) {
        styles = this._bundler.bundle(styles);
        
        for (var style in styles) {
            var styleName = Jeeel.String.toCamelCase(style);
            
            try {
                if (this._customStyle[styleName]) {
                    this._customStyle[styleName](styles[style]);

                    continue;
                }

                this._style[styleName] = styles[style];
            } catch (e) {}
        }
        
        return this;
    },
    
    /**
     * アニメーションを開始する
     * 
     * @param {Jeeel.Dom.Style.Animation} animation アニメーションインスタンス
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    animate: function (animation) {},
    
    /**
     * アニメーションを開始する
     * 
     * @param {Hash} params アニメーション変化の数値
     * @param {Hash} [options] アニメーションのオプション(指定できるオプション: duration, easing, complete, step, enqueue)
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    animate: function (params, options) {},
    
    /**
     * アニメーションを開始する
     * 
     * @param {Hash} params アニメーション変化の数値
     * @param {Integer|String} [duration] アニメーションが完結するまでの時間(ミリ秒)か定義文字列(fast, slow, defaultがある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーション終了時に呼ばれるコールバック
     * @param {Function} [step] アニメーション更新時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    animate: function (params, duration, easing, complete, step) {},
    
    /**
     * 現在実行中のアニメーションを停止させ、次のアニメーションを実行する
     * 
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    stop: function () {
        this._animated = false;
        
        if (this._currentAnimation) {
            for (var i = this._currentAnimation.length; i--;) {
                this._currentAnimation[i].stop();
            }
        }
        
        this._nextAnimate(true);
        
        return this;
    },
    
    /**
     * 現在実行中のアニメーションを終了させ、次のアニメーションを実行する
     * 
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    end: function () {
        this._animated = false;
        
        if (this._currentAnimation) {
            for (var i = this._currentAnimation.length; i--;) {
                this._currentAnimation[i].end();
            }
        }
        
        this._nextAnimate(true);
        
        return this;
    },
    
    /**
     * 現在待機中のアニメーションのキューを破棄する
     * 
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    clear: function () {
        this._animationQueue = [];
        
        return this;
    },
    
    /**
     * アニメーションキューの実行を遅延させる
     * 
     * @param {Integer} delayTime 遅延時間(ミリ秒)
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    delay: function (delayTime) {
        return this._enqueueAnimation({
            animate: function (next) {
                Jeeel.Timer.setTimeout(next, delayTime);
            }
        });
    },
    
    /**
     * 表示する
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    show: function (speed, easing, complete) {
        
        if (speed || speed === 0) {
            return this.animate({display: 'show'}, speed, easing, complete);
        }
        
        var display = this._style.display;
        
        if (display !== '' && display !== 'none') {
            return this;
        }
        
        this._style.display = this._getShowedDisplay();
        
        return this;
    },
    
    /**
     * 隠す
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    hide: function (speed, easing, complete) {
      
        if (speed || speed === 0) {
            return this.animate({display: 'hide'}, speed, easing, complete);
        }
      
        this._style.display = 'none';
        
        return this;
    },
    
    /**
     * 表示の切り替えをする
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    toggle: function (speed, easing, complete) {
        if (speed || speed === 0) {
            return this.animate({display: 'toggle'}, speed, easing, complete);
        }
      
        return this._style.display === 'none' ? this.show() : this.hide();
    },
    
    /**
     * フェードインを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    fadeIn: function (speed, easing, complete) {
        return this.animate({opacity: 'show'}, speed, easing, complete);
    },
    
    /**
     * フェードアウトを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    fadeOut: function (speed, easing, complete) {
        return this.animate({opacity: 'hide'}, speed, easing, complete);
    },
    
    /**
     * フェードトグルを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    fadeToggle: function (speed, easing, complete) {
        return this.animate({opacity: 'toggle'}, speed, easing, complete);
    },
    
    /**
     * スライドアップを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    slideUp: function (speed, easing, complete) {
        return this.animate({height: 'hide'}, speed, easing, complete);
    },
    
    /**
     * スライドダウンを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    slideDown: function (speed, easing, complete) {
        return this.animate({height: 'show'}, speed, easing, complete);
    },
    
    /**
     * スライドトグルを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @return {Jeeel.Dom.Style} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    slideToggle: function (speed, easing, complete) {
        return this.animate({height: 'toggle'}, speed, easing, complete);
    },
    
    /**
     * 指定座標に移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Dom.Style} 自インスタンス
     */
    shiftTo: function (x, y) {
        return this.setStyleList({left: x + 'px', top:  y + 'px'});
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Style} style 操作スタイル
     */
    constructor: Jeeel.Dom.Style,
    
    _getShowedDisplay: function () {
        var display = this._style.display;
        
        if ( ! this._computedStyle) {
            return this._defaultDisplay;
        }
        
        if (this._oldDisplay) {
            return this._oldDisplay;
        }
        
        var computedDisplay;
        
        if (display === 'none') {
            computedDisplay = this._defaultDisplay;
        } else {
            computedDisplay = this._computedStyle.display;
        }
        
        if (display === '' && computedDisplay === 'none') {
            this._oldDisplay =  this._defaultDisplay;
        } else {
            this._oldDisplay = computedDisplay;
        }
        
        return this._oldDisplay;
    },
    
    _enqueueAnimation: function (animate) {
        this._animationQueue.push(animate);
        
        return this;
    },
    
    _dequeueAnimation: function () {
        return this._animationQueue.shift();
    },
    
    _nextAnimate: function (shutdown) {
        var animation = this._dequeueAnimation();
        
        if ( ! animation) {
            if (shutdown) {
                return;
            }
            
            this._currentAnimation = null;
            
            return this.end();
        }
        
        var res = [animation];
        
        if (this._currentAnimation) {
            for (var i = this._currentAnimation.length; i--;) {
                if (this._currentAnimation[i].isAnimating && this._currentAnimation[i].isAnimating()) {
                    res.push(this._currentAnimation[i]);
                }
            }
        }
        
        this._currentAnimation = res;
        
        this._animated = true;
        
        animation.animate(this._nextAnimate);
    },
    
    _init: function () {
        delete this._init;
        
        this.animate = function (params, duration, easing, complete, step) {
            var animation;
            var queue = true;
            
            if (params instanceof this.constructor.Animation) {
                animation = params;
            } else {
                animation = new this.constructor.Animation(this._hook.getElement(), this, params);
                
                if (Jeeel.Type.isHash(duration)) {
                    animation.setDuration(duration.duration)
                             .setEasing(duration.easing)
                             .setCompleteCallback(duration.complete)
                             .setStepCallback(duration.step);
                             
                    if (duration.enqueue === false) {
                        queue = false;
                    }
                } else {
                    animation.setDuration(duration)
                             .setEasing(easing)
                             .setCompleteCallback(complete)
                             .setStepCallback(step);
                }
            }
            
            if (queue) {
                this._enqueueAnimation(animation);

                if ( ! this._animated) {
                    this._nextAnimate();
                }
            } else {
                if (this._currentAnimation) {
                    this._currentAnimation.push(animation);
                } else {
                    this._currentAnimation = [animation];
                }
                
                animation.animate();
            }

            return this;
        };
    }
};

Jeeel.Dom.Style.prototype._init();

Jeeel._Object.JeeelDomStyle = {
    
    cssShow: {position: 'absolute', visibility: 'hidden', display: 'block'},
    
    swapShow: function (domStyle, callback) {
        return this.swap(domStyle, this.cssShow, callback);
    },
    
    swap: function (domStyle, styles, callback) {
        var old = {}, key;

        for (key in styles) {
            var style = styles[key];
            
            old[key] = domStyle[key];
            domStyle[key] = style;
        }
        
        var res = callback();
        
        for (key in old) {
            domStyle[key] = old[key];
        }
        
        return res;
    }
};

Jeeel.file.Jeeel.Dom.Style = ['Hook', 'Custom', 'Bundler', 'Animation'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style, Jeeel.file.Jeeel.Dom.Style);Jeeel.directory.Jeeel.Dom.Style.Hook = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Style + 'Hook/';
    }
};

/**
 * コンストラクタ
 * 
 * @class フックに対して操作を行うクラス
 * @param {Element} element 要素
 * @param {Jeeel.Dom.Style} style スタイル
 */
Jeeel.Dom.Style.Hook = function (element, style) {
    this._element = element;
    this._style = style;
};

/**
 * フックを登録する
 * 
 * @param {String} name 
 * @param {Function} get 
 */
Jeeel.Dom.Style.Hook.register = function (name, get) {
    if (typeof get !== 'function') {
        throw new Error('フックではありません。');
    }
    
    this.prototype[name] = get;
};

Jeeel.Dom.Style.Hook.prototype = {
    
    _element: null,
    _style: null,
    
    getElement: function () {
        return this._element;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Style} style 操作スタイル
     */
    constructor: Jeeel.Dom.Style.Hook
};

Jeeel.file.Jeeel.Dom.Style.Hook = ['Default'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style.Hook, Jeeel.file.Jeeel.Dom.Style.Hook);/**
 * フックの初期登録を行う
 */
(function () {
    
    if ( ! Jeeel._elm) {
        return;
    }
    
    var cssWidth = ['Left', 'Right'],
        cssHeight = ['Top', 'Bottom'];
    
    /**
     * @ignore
     */
    function getWidth(elm, style) {
        var val = elm.offsetWidth;
        
        if (val > 0) {
            for (var i = cssWidth.length; i--;) {
                val -= parseFloat(style.getStyle('padding' + cssWidth[i])) || 0;

                val -= parseFloat(style.getStyle('border' + cssWidth[i] + 'Width')) || 0;
            }

            return val + 'px';
        }
        
        return 0 + 'px';
    }
    
    /**
     * @ignore
     */
    function getHeight(elm, style) {
        var val = elm.offsetHeight;
        
        if (val > 0) {
            for (var i = cssHeight.length; i--;) {
                val -= parseFloat(style.getStyle('padding' + cssHeight[i])) || 0;

                val -= parseFloat(style.getStyle('border' + cssHeight[i] + 'Width')) || 0;
            }

            return val + 'px';
        }
        
        return 0 + 'px';
    }
    
    var module = Jeeel._Object.JeeelDomStyle;
    var parts = [], i = 0;
    
    // widthの登録
    parts[i++] = {
        name: 'width',
        
        get: function () {
            if (this._element.offsetWidth !== 0) {
                return getWidth(this._element, this._style);
            }
            
            var elm = this._element;
            var style = this._style;
            
            return module.swapShow(elm.style, function () {
                return getWidth(elm, style);
            });
        }
    };
    
    // heightの登録
    parts[i++] = {
        name: 'height',
        
        get: function () {
            if (this._element.offsetWidth !== 0) {
                return getHeight(this._element, this._style);
            }
            
            var elm = this._element;
            var style = this._style;
            
            return module.swapShow(elm.style, function () {
                return getHeight(elm, style);
            });
        }
    };
    
    for (i = parts.length; i--;) {
        Jeeel.Dom.Style.Hook.register(parts[i].name, parts[i].get);
    }

    // 念のためメモリリーク対策
    parts = null;
})();Jeeel.directory.Jeeel.Dom.Style.Custom = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Style + 'Custom/';
    }
};

/**
 * コンストラクタ
 * 
 * @class カスタムスタイルに対して操作を行うクラス
 * @param {Style} style 要素のスタイル
 * @param {Style} [computedStyle] 計算済みスタイル
 */
Jeeel.Dom.Style.Custom = function (style, computedStyle) {
    this._style = style;
    this._computedStyle = computedStyle || {};
};

/**
 * カスタムスタイルを登録する
 * 
 * @param {Function} part Jeeel.Dom.Style.Custom.createPartで作成したパーツ
 */
Jeeel.Dom.Style.Custom.register = function (part) {
    if ( ! part.partName || typeof part !== 'function') {
        throw new Error('カスタムパーツではありません。');
    }
    
    this.prototype[part.partName] = part;
};

/**
  * カスタムスタイルのパーツを作成する
  * 
  * @param {String} name キャメルケースの名前
  * @param {Function} get ゲッター
  * @param {Function} set セッター
  * @param {String} [originName] 本来の名前がある場合に指定(ハイフネーション)
  * @param {Function} [filter] フィルタ
  * @return {Function} カスタムパーツ
  */
Jeeel.Dom.Style.Custom.createPart = function (name, get, set, originName, filter) {
    var f = function(val, isFilter) {
        if (isFilter) {
            return filter.call(this, val);
        } else if (typeof val === 'undefined') {
            return get.call(this);
        }

        return set.call(this, val);
    };

    f.get = get;
    f.set = set;
    f.partName = name;
    f.originName = originName || null;
    f.usableFilter = !!filter;

    return f;
};

Jeeel.Dom.Style.Custom.prototype = {
    
    _style: null,
    
    _computedStyle: null,
    
    /**
     * コンストラクタ
     * 
     * @param {Style} style 操作スタイル
     */
    constructor: Jeeel.Dom.Style.Custom
};

Jeeel.file.Jeeel.Dom.Style.Custom = ['Default'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style.Custom, Jeeel.file.Jeeel.Dom.Style.Custom);/**
 * カスタムスタイルの初期登録を行う
 */
(function () {
    
    if ( ! Jeeel._elm) {
        return;
    }
    
    var style = Jeeel._elm.style;
    var parts = [], i = 0, part, name, get, set, filter;
    
    // floatの登録
    parts[i] = {name: 'float'};
    
    if ('float' in style) {
        name = 'float';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style['float'] || this._computedStyle['float'] || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (floatStyle) {
            this._style['float'] = floatStyle;
        };
        
        filter = null;
    } else if ('cssFloat' in style) {
        name = 'float';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.cssFloat || this._computedStyle.cssFloat || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (floatStyle) {
            this._style.cssFloat = floatStyle;
        };
        
        filter = null;
    } else if ('styleFloat' in style) {
        name = 'float';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.styleFloat || this._computedStyle.styleFloat || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (floatStyle) {
            this._style.styleFloat = floatStyle;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return 'none';
        };
        
        /**
         * @ignore
         */
        set = function (floatStyle) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    // opacityの登録
    parts[i] = {name: 'opacity'};
    
    if ('opacity' in style) {
        name = 'opacity';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.opacity || this._computedStyle.opacity || '1.0';
        };
        
        /**
         * @ignore
         */
        set = function (opacity) {
            this._style.opacity = opacity;
        };
        
        filter = null;
    } else if ('MozOpacity' in style) {
        name = '-moz-opacity';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozOpacity || this._computedStyle.MozOpacity || '1.0';
        };
        
        /**
         * @ignore
         */
        set = function (opacity) {
            this._style.MozOpacity = opacity;
        };
        
        filter = null;
    } else if ('filter' in style) {
        name = 'filter';
        
        /**
         * @ignore
         */
        get = function () {
            var match = (this._style.filter || this._computedStyle.filter).match(/(?:progid:DXImageTransform\.Microsoft\.)?Alpha\(.*opacity=(-?[0-9.]+).*\)/i);
            return '' + ((match && match[1] || 100) / 100);
        };
        
        /**
         * @ignore
         */
        set = function (opacity) {

            var css = this.opacity(opacity, true);
            
            this._style.cssText += ';' + css;
        };
        
        /**
         * @ignore
         */
        filter = function (opacity) {
            opacity = opacity * 100;

            var hack = '';
            
            if ( ! this._style.zoom) {
                hack = '; zoom: 1';
            }
            
            var filter = this._style.filter || this._computedStyle.filter;

            if ( ! filter) {
                filter = 'alpha(opacity=' + opacity + ')';
            } else if ( ! filter.match(/(?:progid:DXImageTransform\.Microsoft\.)?Alpha\(/i)) {
                filter += ' alpha(opacity=' + opacity + ')';
            } else {
                filter = filter.replace(/(?:progid:DXImageTransform\.Microsoft\.)?Alpha\(.*opacity=(-?[0-9.]+).*\)/i, 'alpha(opacity=' + opacity + ')');
            }
            
            return filter + hack;
        };
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return 1.0;
        };
        
        /**
         * @ignore
         */
        set = function (opacity) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    // background-position-xの登録
    parts[i] = {name: 'backgroundPositionX'};
    
    if ('backgroundPositionX' in style) {
        name = 'background-position-x';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.backgroundPositionX || this._computedStyle.backgroundPositionX || '0%';
        };
        
        /**
         * @ignore
         */
        set = function (position) {
            this._style.backgroundPositionX = position;
        };
        
        filter = null;
    } else if ('backgroundPosition' in style) {
        name = 'backgroundPosition';
        
        /**
         * @ignore
         */
        get = function () {
            var pos = (this._style.backgroundPosition || this._computedStyle.backgroundPosition).split(' ');
            
            if (pos.length > 1) {
                return pos[0];
            }
            
            return '0%';
        };
        
        /**
         * @ignore
         */
        set = function (position) {
            this._style.backgroundPosition = this.backgroundPositionX(position, true);
        };
        
        /**
         * @ignore
         */
        filter = function (position) {
            var pos = (this._style.backgroundPosition || this._computedStyle.backgroundPosition).split(' ');
            
            if (pos.length <= 1) {
                pos = [
                    position,
                    '0%'
                ];
            } else {
                pos[0] = position;
            }
            
            return position.join(' ');
        };
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return '0%';
        };
        
        /**
         * @ignore
         */
        set = function (position) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // background-position-yの登録
    parts[i] = {name: 'backgroundPositionY'};
    
    if ('backgroundPositionY' in style) {
        name = 'background-position-y';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.backgroundPositionY || this._computedStyle.backgroundPositionY || '0%';
        };
        
        /**
         * @ignore
         */
        set = function (position) {
            this._style.backgroundPositionY = position;
        };
        
        filter = null;
    } else if ('backgroundPosition' in style) {
        name = 'backgroundPosition';
        
        /**
         * @ignore
         */
        get = function () {
            var pos = (this._style.backgroundPosition || this._computedStyle.backgroundPosition).split(' ');
            
            if (pos.length > 1) {
                return pos[1];
            }
            
            return '0%';
        };
        
        /**
         * @ignore
         */
        set = function (position) {
            this._style.backgroundPosition = this.backgroundPositionY(position, true);
        };
        
        /**
         * @ignore
         */
        filter = function (position) {
            var pos = (this._style.backgroundPosition || this._computedStyle.backgroundPosition).split(' ');
            
            if (pos.length <= 1) {
                pos = [
                    '0%',
                    position
                ];
            } else {
                pos[1] = position;
            }
            
            return position.join(' ');
        };
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return '0%';
        };
        
        /**
         * @ignore
         */
        set = function (position) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // perspectiveの登録
    parts[i] = {name: 'perspective'};
    
    if ('perspective' in style) {
        name = 'perspective';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.perspective || this._computedStyle.perspective || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (perspective) {
            this._style.perspective = perspective;
        };
        
        filter = null;
    } else if ('MozPerspective' in style) {
        name = '-moz-perspective';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozPerspective || this._computedStyle.MozPerspective || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (perspective) {
            this._style.MozPerspective = perspective;
        };
        
        filter = null;
    } else if ('WebkitPerspective' in style) {
        name = '-webkit-perspective';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitPerspective || this._computedStyle.WebkitPerspective || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (perspective) {
            this._style.WebkitPerspective = perspective;
        };
        
        filter = null;
    } else if ('MsPerspective' in style) {
        name = '-ms-perspective';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsPerspective || this._computedStyle.MsPerspective || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (perspective) {
            this._style.MsPerspective = perspective;
        };
        
        filter = null;
    } else if ('OPerspective' in style) {
        name = '-o-perspective';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OPerspective || this._computedStyle.OPerspective || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (perspective) {
            this._style.OPerspective = perspective;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return 'none';
        };
        
        /**
         * @ignore
         */
        set = function (perspective) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // backface-visibilityの登録
    parts[i] = {name: 'backfaceVisibility'};
    
    if ('backfaceVisibility' in style) {
        name = 'backface-visibility';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.backfaceVisibility || this._computedStyle.backfaceVisibility || 'visible';
        };
        
        /**
         * @ignore
         */
        set = function (backfaceVisibility) {
            this._style.backfaceVisibility = backfaceVisibility;
        };
        
        filter = null;
    } else if ('MozBackfaceVisibility' in style) {
        name = '-moz-backface-visibility';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozBackfaceVisibility || this._computedStyle.MozBackfaceVisibility || 'visible';
        };
        
        /**
         * @ignore
         */
        set = function (backfaceVisibility) {
            this._style.MozBackfaceVisibility = backfaceVisibility;
        };
        
        filter = null;
    } else if ('WebkitBackfaceVisibility' in style) {
        name = '-webkit-backface-visibility';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitBackfaceVisibility || this._computedStyle.WebkitBackfaceVisibility || 'visible';
        };
        
        /**
         * @ignore
         */
        set = function (backfaceVisibility) {
            this._style.WebkitBackfaceVisibility = backfaceVisibility;
        };
        
        filter = null;
    } else if ('MsBackfaceVisibility' in style) {
        name = '-ms-backface-visibility';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsBackfaceVisibility || this._computedStyle.MsBackfaceVisibility || 'visible';
        };
        
        /**
         * @ignore
         */
        set = function (backfaceVisibility) {
            this._style.MsBackfaceVisibility = backfaceVisibility;
        };
        
        filter = null;
    } else if ('OBackfaceVisibility' in style) {
        name = '-o-backface-visibility';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OBackfaceVisibility || this._computedStyle.OBackfaceVisibility || 'visible';
        };
        
        /**
         * @ignore
         */
        set = function (backfaceVisibility) {
            this._style.OBackfaceVisibility = backfaceVisibility;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return 'visible';
        };
        
        /**
         * @ignore
         */
        set = function (backfaceVisibility) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // transform-originの登録
    parts[i] = {name: 'transformOrigin'};
    
    if ('transformOrigin' in style) {
        name = 'transform-origin';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.transformOrigin || this._computedStyle.transformOrigin || '50% 50% 0';
        };
        
        /**
         * @ignore
         */
        set = function (transformOrigin) {
            this._style.transformOrigin = transformOrigin;
        };
        
        filter = null;
    } else if ('MozTransformOrigin' in style) {
        name = '-moz-transform-origin';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozTransformOrigin || this._computedStyle.MozTransformOrigin || '50% 50% 0';
        };
        
        /**
         * @ignore
         */
        set = function (transformOrigin) {
            this._style.MozTransformOrigin = transformOrigin;
        };
        
        filter = null;
    } else if ('WebkitTransformOrigin' in style) {
        name = '-webkit-transform-origin';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitTransformOrigin || this._computedStyle.WebkitTransformOrigin || '50% 50% 0';
        };
        
        /**
         * @ignore
         */
        set = function (transformOrigin) {
            this._style.WebkitTransformOrigin = transformOrigin;
        };
        
        filter = null;
    } else if ('MsTransformOrigin' in style) {
        name = '-ms-transform-origin';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsTransformOrigin || this._computedStyle.MsTransformOrigin || '50% 50% 0';
        };
        
        /**
         * @ignore
         */
        set = function (transformOrigin) {
            this._style.MsTransformOrigin = transformOrigin;
        };
        
        filter = null;
    } else if ('OTransformOrigin' in style) {
        name = '-o-transform-origin';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OTransformOrigin || this._computedStyle.OTransformOrigin || '50% 50% 0';
        };
        
        /**
         * @ignore
         */
        set = function (transformOrigin) {
            this._style.OTransformOrigin = transformOrigin;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return '50% 50% 0';
        };
        
        /**
         * @ignore
         */
        set = function (transformOrigin) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // transform-styleの登録
    parts[i] = {name: 'transformStyle'};
    
    if ('transformStyle' in style) {
        name = 'transform-style';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.transformStyle || this._computedStyle.transformStyle || 'flat';
        };
        
        /**
         * @ignore
         */
        set = function (transformStyle) {
            this._style.transformStyle = transformStyle;
        };
        
        filter = null;
    } else if ('MozTransformStyle' in style) {
        name = '-moz-transform-style';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozTransformStyle || this._computedStyle.MozTransformStyle || 'flat';
        };
        
        /**
         * @ignore
         */
        set = function (transformStyle) {
            this._style.MozTransformStyle = transformStyle;
        };
        
        filter = null;
    } else if ('WebkitTransformStyle' in style) {
        name = '-webkit-transform-style';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitTransformStyle || this._computedStyle.WebkitTransformStyle || 'flat';
        };
        
        /**
         * @ignore
         */
        set = function (transformStyle) {
            this._style.WebkitTransformStyle = transformStyle;
        };
        
        filter = null;
    } else if ('MsTransformStyle' in style) {
        name = '-ms-transform-style';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsTransformStyle || this._computedStyle.MsTransformStyle || 'flat';
        };
        
        /**
         * @ignore
         */
        set = function (transformStyle) {
            this._style.MsTransformStyle = transformStyle;
        };
        
        filter = null;
    } else if ('OTransformStyle' in style) {
        name = '-o-transform-style';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OTransformStyle || this._computedStyle.OTransformStyle || 'flat';
        };
        
        /**
         * @ignore
         */
        set = function (transformStyle) {
            this._style.OTransformStyle = transformStyle;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return 'flat';
        };
        
        /**
         * @ignore
         */
        set = function (transformStyle) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    

    // transformの登録
    parts[i] = {name: 'transform'};
    
    if ('transform' in style) {
        name = 'transform';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.transform || this._computedStyle.transform || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (transform) {
            this._style.transform = transform;
        };
        
        filter = null;
    } else if ('MozTransform' in style) {
        name = '-moz-transform';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozTransform || this._computedStyle.MozTransform || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (transform) {
            this._style.MozTransform = transform;
        };
        
        filter = null;
    } else if ('WebkitTransform' in style) {
        name = '-webkit-transform';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitTransform || this._computedStyle.WebkitTransform || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (transform) {
            this._style.WebkitTransform = transform;
        };
        
        filter = null;
    } else if ('MsTransform' in style) {
        name = '-ms-transform';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsTransform || this._computedStyle.MsTransform || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (transform) {
            this._style.MsTransform = transform;
        };
        
        filter = null;
    } else if ('OTransform' in style) {
        name = '-o-transform';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OTransform || this._computedStyle.OTransform || 'none';
        };
        
        /**
         * @ignore
         */
        set = function (transform) {
            this._style.OTransform = transform;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return 'none';
        };
        
        /**
         * @ignore
         */
        set = function (transform) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // rotateの登録
    parts[i] = {name: 'rotate'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/rotate\(([^\)]+)\)/i);
        return match && match[1] || '0deg';
    };
    
    /**
     * @ignore
     */
    set = function (rotate) {
        this.transform(this.rotate(rotate, true));
    };
    
    /**
     * @ignore
     */
    filter = function (rotate) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'rotate(' + rotate + ')';
        } else if (trs.indexOf('rotate(') < 0) {
            trs += ' rotate(' + rotate + ')';
        } else {
            trs = trs.replace(/rotate\(([^\)]+)\)/i, 'rotate(' + rotate + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // rotateXの登録
    parts[i] = {name: 'rotateX'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/rotateX\(([^\)]+)\)/i);
        return match && match[1] || '0deg';
    };
    
    /**
     * @ignore
     */
    set = function (rotateX) {
        this.transform(this.rotateX(rotateX, true));
    };
    
    /**
     * @ignore
     */
    filter = function (rotateX) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'rotateX(' + rotateX + ')';
        } else if (trs.indexOf('rotateX(') < 0) {
            trs += ' rotateX(' + rotateX + ')';
        } else {
            trs = trs.replace(/rotateX\(([^\)]+)\)/i, 'rotateX(' + rotateX + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // rotateYの登録
    parts[i] = {name: 'rotateY'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/rotateY\(([^\)]+)\)/i);
        return match && match[1] || '0deg';
    };
    
    /**
     * @ignore
     */
    set = function (rotateY) {
        this.transform(this.rotateY(rotateY, true));
    };
    
    /**
     * @ignore
     */
    filter = function (rotateY) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'rotateY(' + rotateY + ')';
        } else if (trs.indexOf('rotateY(') < 0) {
            trs += ' rotateY(' + rotateY + ')';
        } else {
            trs = trs.replace(/rotateY\(([^\)]+)\)/i, 'rotateY(' + rotateY + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // rotateZの登録
    parts[i] = {name: 'rotateZ'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/rotateZ\(([^\)]+)\)/i);
        return match && match[1] || '0deg';
    };
    
    /**
     * @ignore
     */
    set = function (rotateZ) {
        this.transform(this.rotateZ(rotateZ, true));
    };
    
    /**
     * @ignore
     */
    filter = function (rotateZ) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'rotateZ(' + rotateZ + ')';
        } else if (trs.indexOf('rotateZ(') < 0) {
            trs += ' rotateZ(' + rotateZ + ')';
        } else {
            trs = trs.replace(/rotateZ\(([^\)]+)\)/i, 'rotateZ(' + rotateZ + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // rotate3dの登録
    parts[i] = {name: 'rotate3d'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/rotate3d\(([^\)]+)\)/i);
        return match && match[1] || '0, 0, 0, 0deg';
    };
    
    /**
     * @ignore
     */
    set = function (rotate3d) {
        this.transform(this.rotate3d(rotate3d, true));
    };
    
    /**
     * @ignore
     */
    filter = function (rotate3d) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'rotate3d(' + rotate3d + ')';
        } else if (trs.indexOf('rotate3d(') < 0) {
            trs += ' rotate3d(' + rotate3d + ')';
        } else {
            trs = trs.replace(/rotate3d\(([^\)]+)\)/i, 'rotate3d(' + rotate3d + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // translateの登録
    parts[i] = {name: 'translate'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/translate\(([^\)]+)\)/i);
        return match && match[1] || '0px';
    };
    
    /**
     * @ignore
     */
    set = function (translate) {
        this.transform(this.translate(translate, true));
    };
    
    /**
     * @ignore
     */
    filter = function (translate) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'translate(' + translate + ')';
        } else if (trs.indexOf('translate(') < 0) {
            trs += ' translate(' + translate + ')';
        } else {
            trs = trs.replace(/translate\([^\)]+\)/i, 'translate(' + translate + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // translateXの登録
    parts[i] = {name: 'translateX'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/translateX\(([^\)]+)\)/i);
        return match && match[1] || '0px';
    };
    
    /**
     * @ignore
     */
    set = function (translateX) {
        this.transform(this.translateX(translateX, true));
    };
    
    /**
     * @ignore
     */
    filter = function (translateX) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'translateX(' + translateX + ')';
        } else if (trs.indexOf('translateX(') < 0) {
            trs += ' translateX(' + translateX + ')';
        } else {
            trs = trs.replace(/translateX\([^\)]+\)/i, 'translateX(' + translateX + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // translateYの登録
    parts[i] = {name: 'translateY'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/translateY\(([^\)]+)\)/i);
        return match && match[1] || '0px';
    };
    
    /**
     * @ignore
     */
    set = function (translateY) {
        this.transform(this.translateY(translateY, true));
    };
    
    /**
     * @ignore
     */
    filter = function (translateY) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'translateY(' + translateY + ')';
        } else if (trs.indexOf('translateY(') < 0) {
            trs += ' translateY(' + translateY + ')';
        } else {
            trs = trs.replace(/translateY\([^\)]+\)/i, 'translateY(' + translateY + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // translateZの登録
    parts[i] = {name: 'translateZ'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/translateZ\(([^\)]+)\)/i);
        return match && match[1] || '0px';
    };
    
    /**
     * @ignore
     */
    set = function (translateZ) {
        this.transform(this.translateZ(translateZ, true));
    };
    
    /**
     * @ignore
     */
    filter = function (translateZ) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'translateZ(' + translateZ + ')';
        } else if (trs.indexOf('translateZ(') < 0) {
            trs += ' translateZ(' + translateZ + ')';
        } else {
            trs = trs.replace(/translateZ\([^\)]+\)/i, 'translateZ(' + translateZ + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // translate3dの登録
    parts[i] = {name: 'translate3d'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/translate3d\(([^\)]+)\)/i);
        return match && match[1] || '0px, 0px, 0px';
    };
    
    /**
     * @ignore
     */
    set = function (translate3d) {
        this.transform(this.translate3d(translate3d, true));
    };
    
    /**
     * @ignore
     */
    filter = function (translate3d) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'translate3d(' + translate3d + ')';
        } else if (trs.indexOf('translate3d(') < 0) {
            trs += ' translate3d(' + translate3d + ')';
        } else {
            trs = trs.replace(/translate3d\([^\)]+\)/i, 'translate3d(' + translate3d + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // scaleの登録
    parts[i] = {name: 'scale'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/scale\(([^\)]+)\)/i);
        return match && match[1] || '1';
    };
    
    /**
     * @ignore
     */
    set = function (scale) {
        this.transform(this.scale(scale, true));
    };
    
    /**
     * @ignore
     */
    filter = function (scale) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'scale(' + scale + ')';
        } else if (trs.indexOf('scale(') < 0) {
            trs += ' scale(' + scale + ')';
        } else {
            trs = trs.replace(/scale\([^\)]+\)/i, 'scale(' + scale + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // scaleXの登録
    parts[i] = {name: 'scaleX'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/scaleX\(([^\)]+)\)/i);
        return match && match[1] || '1';
    };
    
    /**
     * @ignore
     */
    set = function (scaleX) {
        this.transform(this.scaleX(scaleX, true));
    };
    
    /**
     * @ignore
     */
    filter = function (scaleX) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'scaleX(' + scaleX + ')';
        } else if (trs.indexOf('scaleX(') < 0) {
            trs += ' scaleX(' + scaleX + ')';
        } else {
            trs = trs.replace(/scaleX\([^\)]+\)/i, 'scaleX(' + scaleX + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // scaleYの登録
    parts[i] = {name: 'scaleY'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/scaleY\(([^\)]+)\)/i);
        return match && match[1] || '1';
    };
    
    /**
     * @ignore
     */
    set = function (scaleY) {
        this.transform(this.scaleY(scaleY, true));
    };
    
    /**
     * @ignore
     */
    filter = function (scaleY) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'scaleY(' + scaleY + ')';
        } else if (trs.indexOf('scaleY(') < 0) {
            trs += ' scaleY(' + scaleY + ')';
        } else {
            trs = trs.replace(/scaleY\([^\)]+\)/i, 'scaleY(' + scaleY + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // scaleZの登録
    parts[i] = {name: 'scaleZ'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/scaleZ\(([^\)]+)\)/i);
        return match && match[1] || '1';
    };
    
    /**
     * @ignore
     */
    set = function (scaleZ) {
        this.transform(this.scaleZ(scaleZ, true));
    };
    
    /**
     * @ignore
     */
    filter = function (scaleZ) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'scaleZ(' + scaleZ + ')';
        } else if (trs.indexOf('scaleZ(') < 0) {
            trs += ' scaleZ(' + scaleZ + ')';
        } else {
            trs = trs.replace(/scaleZ\([^\)]+\)/i, 'scaleZ(' + scaleZ + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // scale3dの登録
    parts[i] = {name: 'scale3d'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/scale3d\(([^\)]+)\)/i);
        return match && match[1] || '1, 1, 1';
    };
    
    /**
     * @ignore
     */
    set = function (scale3d) {
        this.transform(this.scale3d(scale3d, true));
    };
    
    /**
     * @ignore
     */
    filter = function (scale3d) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'scale3d(' + scale3d + ')';
        } else if (trs.indexOf('scale3d(') < 0) {
            trs += ' scale3d(' + scale3d + ')';
        } else {
            trs = trs.replace(/scale3d\([^\)]+\)/i, 'scale3d(' + scale3d + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // skewの登録
    parts[i] = {name: 'skew'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/skew\(([^\)]+)\)/i);
        return match && match[1] || '0deg, 0deg';
    };
    
    /**
     * @ignore
     */
    set = function (skew) {
        this.transform(this.skew(skew, true));
    };
    
    /**
     * @ignore
     */
    filter = function (skew) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'skew(' + skew + ')';
        } else if (trs.indexOf('skew(') < 0) {
            trs += ' skew(' + skew + ')';
        } else {
            trs = trs.replace(/skew\([^\)]+\)/i, 'skew(' + skew + ')');
        }
        
        this.transform(trs);
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // skewXの登録
    parts[i] = {name: 'skewX'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/skewX\(([^\)]+)\)/i);
        return match && match[1] || '0deg';
    };
    
    /**
     * @ignore
     */
    set = function (skewX) {
        this.transform(this.skewX(skewX, true));
    };
    
    /**
     * @ignore
     */
    filter = function (skewX) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'skewX(' + skewX + ')';
        } else if (trs.indexOf('skewX(') < 0) {
            trs += ' skewX(' + skewX + ')';
        } else {
            trs = trs.replace(/skewX\([^\)]+\)/i, 'skewX(' + skewX + ')');
        }
        
        this.transform(trs);
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // skewYの登録
    parts[i] = {name: 'skewY'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/skewY\(([^\)]+)\)/i);
        return match && match[1] || '0deg';
    };
    
    /**
     * @ignore
     */
    set = function (skewY) {
        this.transform(this.skewY(skewY, true));
    };
    
    /**
     * @ignore
     */
    filter = function (skewY) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'skewY(' + skewY + ')';
        } else if (trs.indexOf('skewY(') < 0) {
            trs += ' skewY(' + skewY + ')';
        } else {
            trs = trs.replace(/skewY\([^\)]+\)/i, 'skewY(' + skewY + ')');
        }
        
        this.transform(trs);
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // matrixの登録
    parts[i] = {name: 'matrix'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/matrix\(([^\)]+)\)/i);
        return match && match[1] || '1, 0, 0, 1, 0, 0';
    };
    
    /**
     * @ignore
     */
    set = function (matrix) {
        this.transform(this.matrix(matrix, true));
    };
    
    /**
     * @ignore
     */
    filter = function (matrix) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'matrix(' + matrix + ')';
        } else if (trs.indexOf('matrix(') < 0) {
            trs += ' matrix(' + matrix + ')';
        } else {
            trs = trs.replace(/matrix\(([^\)]+)\)/i, 'matrix(' + matrix + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // matrix3dの登録
    parts[i] = {name: 'matrix3d'};
    
    /**
     * @ignore
     */
    get = function () {
        var match = this.transform().match(/matrix3d\(([^\)]+)\)/i);
        return match && match[1] || '1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1';
    };
    
    /**
     * @ignore
     */
    set = function (matrix3d) {
        this.transform(this.matrix3d(matrix3d, true));
    };
    
    /**
     * @ignore
     */
    filter = function (matrix3d) {
        var trs = this.transform();
        
        if ( ! trs || trs === 'none') {
            trs = 'matrix3d(' + matrix3d + ')';
        } else if (trs.indexOf('matrix3d(') < 0) {
            trs += ' matrix3d(' + matrix3d + ')';
        } else {
            trs = trs.replace(/matrix3d\(([^\)]+)\)/i, 'matrix3d(' + matrix3d + ')');
        }
        
        return trs;
    };
    
    parts[i].originName = name || 'transform';
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    

    // transitionの登録
    parts[i] = {name: 'transition'};
    
    if ('transition' in style) {
        name = 'transition';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.transition || this._computedStyle.transition || 'all 0 ease 0';
        };
        
        /**
         * @ignore
         */
        set = function (transition) {
            this._style.transition = transition;
        };
        
        filter = null;
    } else if ('MozTransition' in style) {
        name = '-moz-transition';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozTransition || this._computedStyle.MozTransition || 'all 0 ease 0';
        };
        
        /**
         * @ignore
         */
        set = function (transition) {
            this._style.MozTransition = transition;
        };
        
        filter = null;
    } else if ('WebkitTransition' in style) {
        name = '-webkit-transition';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitTransition || this._computedStyle.WebkitTransition || 'all 0 ease 0';
        };
        
        /**
         * @ignore
         */
        set = function (transition) {
            this._style.WebkitTransition = transition;
        };
        
        filter = null;
    } else if ('MsTransition' in style) {
        name = '-ms-transition';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsTransition || this._computedStyle.MsTransition || 'all 0 ease 0';
        };
        
        /**
         * @ignore
         */
        set = function (transition) {
            this._style.MsTransition = transition;
        };
        
        filter = null;
    } else if ('OTransition' in style) {
        name = '-o-transition';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OTransition || this._computedStyle.OTransition || 'all 0 ease 0';
        };
        
        /**
         * @ignore
         */
        set = function (transition) {
            this._style.OTransition = transition;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return 'all 0 ease 0';
        };
        
        /**
         * @ignore
         */
        set = function (transition) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // transition-propertyの登録
    parts[i] = {name: 'transitionProperty'};
    
    if ('transitionProperty' in style) {
        name = 'transition-property';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.transitionProperty || this._computedStyle.transitionProperty || 'all';
        };
        
        /**
         * @ignore
         */
        set = function (transitionProperty) {
            this._style.transitionProperty = transitionProperty;
        };
        
        filter = null;
    } else if ('MozTransitionProperty' in style) {
        name = '-moz-transition-property';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozTransitionProperty || this._computedStyle.MozTransitionProperty || 'all';
        };
        
        /**
         * @ignore
         */
        set = function (transitionProperty) {
            this._style.MozTransitionProperty = transitionProperty;
        };
        
        filter = null;
    } else if ('WebkitTransitionProperty' in style) {
        name = '-webkit-transition-property';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitTransitionProperty || this._computedStyle.WebkitTransitionProperty || 'all';
        };
        
        /**
         * @ignore
         */
        set = function (transitionProperty) {
            this._style.WebkitTransitionProperty = transitionProperty;
        };
        
        filter = null;
    } else if ('MsTransitionProperty' in style) {
        name = '-ms-transition-property';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsTransitionProperty || this._computedStyle.MsTransitionProperty || 'all';
        };
        
        /**
         * @ignore
         */
        set = function (transitionProperty) {
            this._style.MsTransitionProperty = transitionProperty;
        };
        
        filter = null;
    } else if ('OTransitionProperty' in style) {
        name = '-o-transition-property';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OTransitionProperty || this._computedStyle.OTransitionProperty || 'all';
        };
        
        /**
         * @ignore
         */
        set = function (transitionProperty) {
            this._style.OTransitionProperty = transitionProperty;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return 'all';
        };
        
        /**
         * @ignore
         */
        set = function (transitionProperty) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // transition-durationの登録
    parts[i] = {name: 'transitionDuration'};
    
    if ('transitionDuration' in style) {
        name = 'transition-duration';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.transitionDuration || this._computedStyle.transitionDuration || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDuration) {
            this._style.transitionDuration = transitionDuration;
        };
        
        filter = null;
    } else if ('MozTransitionDuration' in style) {
        name = '-moz-transition-duration';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozTransitionDuration || this._computedStyle.MozTransitionDuration || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDuration) {
            this._style.MozTransitionDuration = transitionDuration;
        };
        
        filter = null;
    } else if ('WebkitTransitionDuration' in style) {
        name = '-webkit-transition-duration';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitTransitionDuration || this._computedStyle.WebkitTransitionDuration || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDuration) {
            this._style.WebkitTransitionDuration = transitionDuration;
        };
        
        filter = null;
    } else if ('MsTransitionDuration' in style) {
        name = '-ms-transition-duration';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsTransitionDuration || this._computedStyle.MsTransitionDuration || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDuration) {
            this._style.MsTransitionDuration = transitionDuration;
        };
        
        filter = null;
    } else if ('OTransitionDuration' in style) {
        name = '-o-transition-duration';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OTransitionDuration || this._computedStyle.OTransitionDuration || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDuration) {
            this._style.OTransitionDuration = transitionDuration;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDuration) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // transition-timing-functionの登録
    parts[i] = {name: 'transitionTimingFunction'};
    
    if ('transitionTimingFunction' in style) {
        name = 'transition-timing-function';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.transitionTimingFunction || this._computedStyle.transitionTimingFunction || 'ease';
        };
        
        /**
         * @ignore
         */
        set = function (transitionTimingFunction) {
            this._style.transitionTimingFunction = transitionTimingFunction;
        };
        
        filter = null;
    } else if ('MozTransitionTimingFunction' in style) {
        name = '-moz-transition-timing-function';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozTransitionTimingFunction || this._computedStyle.MozTransitionTimingFunction || 'ease';
        };
        
        /**
         * @ignore
         */
        set = function (transitionTimingFunction) {
            this._style.MozTransitionTimingFunction = transitionTimingFunction;
        };
        
        filter = null;
    } else if ('WebkitTransitionTimingFunction' in style) {
        name = '-webkit-transition-timing-function';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitTransitionTimingFunction || this._computedStyle.WebkitTransitionTimingFunction || 'ease';
        };
        
        /**
         * @ignore
         */
        set = function (transitionTimingFunction) {
            this._style.WebkitTransitionTimingFunction = transitionTimingFunction;
        };
        
        filter = null;
    } else if ('MsTransitionTimingFunction' in style) {
        name = '-ms-transition-timing-function';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsTransitionTimingFunction || this._computedStyle.MsTransitionTimingFunction || 'ease';
        };
        
        /**
         * @ignore
         */
        set = function (transitionTimingFunction) {
            this._style.MsTransitionTimingFunction = transitionTimingFunction;
        };
        
        filter = null;
    } else if ('OTransitionTimingFunction' in style) {
        name = '-o-transition-timing-function';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OTransitionTimingFunction || this._computedStyle.OTransitionTimingFunction || 'ease';
        };
        
        /**
         * @ignore
         */
        set = function (transitionTimingFunction) {
            this._style.OTransitionTimingFunction = transitionTimingFunction;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return 'ease';
        };
        
        /**
         * @ignore
         */
        set = function (transitionTimingFunction) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    
    // transition-delayの登録
    parts[i] = {name: 'transitionDelay'};
    
    if ('transitionDelay' in style) {
        name = 'transition-delay';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.transitionDelay || this._computedStyle.transitionDelay || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDelay) {
            this._style.transitionDelay = transitionDelay;
        };
        
        filter = null;
    } else if ('MozTransitionDelay' in style) {
        name = '-moz-transition-delay';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MozTransitionDelay || this._computedStyle.MozTransitionDelay || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDelay) {
            this._style.MozTransitionDelay = transitionDelay;
        };
        
        filter = null;
    } else if ('WebkitTransitionDelay' in style) {
        name = '-webkit-transition-delay';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.WebkitTransitionDelay || this._computedStyle.WebkitTransitionDelay || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDelay) {
            this._style.WebkitTransitionDelay = transitionDelay;
        };
        
        filter = null;
    } else if ('MsTransitionDelay' in style) {
        name = '-ms-transition-delay';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.MsTransitionDelay || this._computedStyle.MsTransitionDelay || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDelay) {
            this._style.MsTransitionDelay = transitionDelay;
        };
        
        filter = null;
    } else if ('OTransitionDelay' in style) {
        name = '-o-transition-delay';
        
        /**
         * @ignore
         */
        get = function () {
            return this._style.OTransitionDelay || this._computedStyle.OTransitionDelay || '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDelay) {
            this._style.OTransitionDelay = transitionDelay;
        };
        
        filter = null;
    } else {
        name = null;
        
        /**
         * @ignore
         */
        get = function () {
            return '0';
        };
        
        /**
         * @ignore
         */
        set = function (transitionDelay) {};
        
        filter = null;
    }
    
    parts[i].originName = name;
    parts[i].get = get;
    parts[i].set = set;
    parts[i].filter = filter;
    
    i++;
    
    for (i = parts.length; i--;) {
        part = Jeeel.Dom.Style.Custom.createPart(parts[i].name, parts[i].get, parts[i].set, parts[i].originName, parts[i].filter);
        
        Jeeel.Dom.Style.Custom.register(part);
    }

    // 念のためメモリリーク対策
    style = parts = part = name = get = set = filter = null;
})();Jeeel.directory.Jeeel.Dom.Style.Bundler = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Style + 'Bundler/';
    }
};

/**
 * コンストラクタ
 * 
 * @class カスタムスタイルに対して操作を行うクラス
 * @param {Style} customStyle 要素のスタイル
 */
Jeeel.Dom.Style.Bundler = function (customStyle) {
    this._customStyle = customStyle;
};

/**
 * バンドラーを登録する
 * 
 * @param {Function} filter バンドルのフィルター
 */
Jeeel.Dom.Style.Bundler.register = function (filter) {
    if (typeof filter !== 'function') {
        throw new Error('フィルターではありません。');
    }
    
    this.prototype._bundleFilters.push(filter);
};

Jeeel.Dom.Style.Bundler.prototype = {
    
    _customStyle: null,
    
    _bundleFilters: [],
    
    bundle: function (styles) {
      
        for (var i = this._bundleFilters.length; i--;) {
            styles = this._bundleFilters[i](styles, this._customStyle);
        }
        
        return styles;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Style} style 操作スタイル
     */
    constructor: Jeeel.Dom.Style.Bundler
};

Jeeel.file.Jeeel.Dom.Style.Bundler = ['Default'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style.Bundler, Jeeel.file.Jeeel.Dom.Style.Bundler);/**
 * バンドラーの初期登録を行う
 */
(function () {
    
    if ( ! Jeeel._elm) {
        return;
    }
    
    var parts = [], i = 0;
    
    // background-positionの登録
    parts[i++] = function (styles) {
        var cnt = !!(styles['background-position-x'] || styles['backgroundPositionX'])
                + !!(styles['background-position-y'] || styles['backgroundPositionY']);
        
        if (cnt < 2) {
            return styles;
        }
        
        styles.backgroundPosition = (styles['background-position-x'] || styles['backgroundPositionX']) + ' '
                                  + (styles['background-position-y'] || styles['backgroundPositionY']);
                                
        delete styles['background-position-x'];
        delete styles['backgroundPositionX'];
        delete styles['background-position-y'];
        delete styles['backgroundPositionY'];
        
        return styles;
    };
    
    // transformの登録
    parts[i++] = function (styles, customStyle) {
        var list = [
            'rotate', 'rotateX', 'rotateY', 'rotateZ', 'rotate3d', 
            'translate', 'translateX', 'translateY', 'translateZ', 'translate3d', 
            'scale', 'scaleX', 'scaleY', 'scaleZ', 'scale3d',
            'skew', 'skewX', 'skewY',
            'matrix', 'matrix3d'
        ];
        
        var res = [];
        var exists = [];
        
        for (var i = list.length; i--;) {
            if (styles[list[i]]) {
                res.push(list[i] + '(' + styles[list[i]] + ')');
                exists.push(list[i]);
                delete styles[list[i]];
            }
        }

        if (res.length === 0) {
            return styles;
        }
        
        var trs = customStyle.transform();
        
        if (trs === 'none') {
            trs = '';
        } else {
            for (var i = exists.length; i--;) {
                var reg = new RegExp(exists[i] + '\\([^)]+\\)');
                trs = trs.replace(reg, '');
            }
        }
        
        styles.transform = trs + res.join(' ');

        return styles;
    };
    
    for (i = parts.length; i--;) {
        Jeeel.Dom.Style.Bundler.register(parts[i]);
    }

    // 念のためメモリリーク対策
    parts = null;
})();Jeeel.directory.Jeeel.Dom.Style.Animation = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Style + 'Animation/';
    }
};

/**
 * コンストラクタ
 * 
 * @class アニメーションを管理するクラス
 * @param {Element} element エレメント
 * @param {Jeeel.Dom.Style} style スタイル
 * @param {Hash} params アニメーションで変化させる値のリスト(キーにはスタイル名、値には変化させたい終端値を入力<br />
 *                       値は100px等の絶対値の他に、+=や-=を前に付けた相対値やtoggle、show、hide等の特殊値がある(特殊値はdisplay, width, height, opacity, margin系, padding系にしか効かない)<br />
 *                       また値を配列や連想配列にすることでスタイルそれぞれにイージング関数やオプションを適用できる<br />
 *                       [value, easing, option]とするか、{value: value, easing: easing, option: option}とすることが出来る<br />
 *                       オプションはそれ自体が更に連想配列である必要があり、付けることが出来るキーはlimitである
 * @param {Integer|String} [duration] アニメーションを何ミリ秒で完結させるか
 * @param {Function|String} [easing] イージング関数
 * @param {Function} [complete] アニメーション終了時のコールバック
 * @param {Function} [step] アニメーション更新時のコールバック(引数にはeasingでの変化値が渡される)
 */
Jeeel.Dom.Style.Animation = function (element, style, params, duration, easing, complete, step) {
  
    this.step = Jeeel.Function.simpleBind(this.step, this);
    
    var keys = [], styles = {};
    var custom = this.constructor.Custom.getInstance();
    var filter = new Jeeel.Filter.Hash.Unique(true, true);
    
    for (var key in params) {
        var name = Jeeel.String.toCamelCase(key);
        
        var prms = this._toInnerStyle(params[key]);
        
        if (custom[name]) {
            var cnvPrms = custom[name](prms.value);
            
            for (var prm in cnvPrms) {
                keys[keys.length] = prm;
                styles[prm] = {
                    value: cnvPrms[prm],
                    easing: prms.easing
                };
            }
            
            continue;
        }
        
        keys[keys.length] = name;
        styles[name] = prms;
    }
    
    this._targetStyles = filter.filter(keys);
    
    this._style = style;
    this._element = element;
    this._hook = new this.constructor.Hook(element, style);
    this._params = styles;
    
    this.setDuration(duration)
        .setEasing(easing)
        .setCompleteCallback(complete)
        .setStepCallback(step);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Jeeel.Dom.Style} style スタイル
 * @param {Hash} params アニメーションで変化させる値のリスト
 * @param {Integer|String} [duration] アニメーションを何ミリ秒で完結させるか
 * @param {Function|String} [easing] イージング関数
 * @param {Function} [complete] アニメーション終了時のコールバック
 * @param {Function} [step] アニメーション更新時のコールバック
 * @return {Jeeel.Dom.Style.Animation} 作成したインスタンス
 */
Jeeel.Dom.Style.Animation.create = function (style, params, duration, easing, complete, step) {
    return new this(style, params, duration, easing, complete, step);
};

/**
 * アニメーション中の要素リスト
 * 
 * @type Element[]
 */
Jeeel.Dom.Style.Animation.animated = [];

Jeeel.Dom.Style.Animation.prototype = {
  
    /**
     * スタイル
     * 
     * @type Jeeel.Dom.Style
     * @private
     */
    _style: null,
    
    /**
     * 要素
     * 
     * @type Element
     * @private
     */
    _element: null,
    
    /**
     * アニメーションフック
     * 
     * @type Jeeel.Dom.Style.Animation.Hook
     * @private
     */
    _hook: null,
    
    /**
     * アニメーション中に更新する対象のスタイルのリスト
     * 
     * @type String[]
     * @private
     */
    _targetStyles: null,
    
    /**
     * アニメーション中に更新する前のスタイルの状態
     * 
     * @type Hash
     * @private
     */
    _defaultParams: {},
    
    /**
     * アニメーションで更新されるべき変化数値とその単位
     * 
     * @type Hash
     * @private
     */
    _deltaParams: {},
    
    /**
     * アニメーションで最終的に適用するスタイルの値
     * 
     * @type Hash
     * @private
     */
    _endParams: {},
    
    /**
     * アニメーションで変化させたいスタイルの名前と値のリスト
     * 
     * @type Hash
     * @private
     */
    _params: {},
    
    /**
     * アニメーションをどのくらいかけて行うかの数値(ミリ秒)
     * 
     * @type Integer
     * @private
     */
    _duration: null,
    
    /**
     * イージング関数
     * 
     * @type Function
     * @private
     */
    _easing: null, 
    
    /**
     * アニメーション終了時に呼ばれるコールバック
     * 
     * @type Function
     * @private
     */
    _complete: null,
    
    /**
     * アニメーション更新時に呼ばれるコールバック
     * 
     * @type Function
     * @private
     */
    _step: null,
    
    /**
     * アニメーション終了時のコールバックが呼ばれた後の最終コールバック
     * 
     * @type Function
     * @private
     */
    _lastCallback: null,
    
    /**
     * アニメーションフレームのタスクID
     * 
     * @type Integer
     * @private
     */
    _frameId: null,
    
    /**
     * アニメーションが開始されたタイムスタンプ
     * 
     * @type Integer
     * @private
     */
    _st: 0,
    
    /**
     * アニメーションが開始されてから経過した時間
     * 
     * @type Integer
     * @private
     */
    _ct: 0,
    
    /**
     * アニメーション完了時間を設定する
     * 
     * @param {Integer|String} duration 完了時間もしくはその定数
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    setDuration: function (duration) {
        this._duration = this.constructor.Speed.getSpeed(duration);
        
        return this;
    },
    
    /**
     * イージング関数を設定する
     * 
     * @param {Function|String} easing イージング関数
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    setEasing: function (easing) {
        this._easing = (Jeeel.Type.isFunction(easing) ? easing : this.constructor.Easing[easing]) || this.constructor.Easing.swing;
        
        return this;
    },
    
    /**
     * アニメーション終了時のコールバックを設定する
     * 
     * @param {Function} callback アニメーション終了時のコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    setCompleteCallback: function (callback, thisArg) {
        if ( ! callback) {
            return this;
        }
        
        if (callback.splice) {
            thisArg = callback[1];
            callback = callback[0];
        }
        
        this._complete = {func: callback, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * アニメーション更新時のコールバックを設定する
     * 
     * @param {Function} callback アニメーション更新時のコールバック(初期値0、最終値1の時のイージングが渡される)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    setStepCallback: function (callback, thisArg) {
        if ( ! callback) {
            return this;
        }
      
        if (callback.splice) {
            thisArg = callback[1];
            callback = callback[0];
        }
      
        this._step = {func: callback, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * アニメーションが実行中かどうかを取得する
     * 
     * @return {Boolean} 実行中かどうか
     */
    isAnimating: function () {
        return !!this._frameId;
    },

    /**
     * アニメーションの初期化と開始を一括で行う
     * 
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    animate: function (callback) {
        this._lastCallback = callback;
        
        this.init();
        this.start();
        
        return this;
    },
    
    /**
     * アニメーションの初期化を行う
     * 
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    init: function () {
        if (this._frameId) {
            this.constructor.Frame.removeTask(this._frameId);
        }
        
        this._frameId = null;
        this._ct = 0;

        this._defaultParams = {};
        this._deltaParams = {};
        this._endParams = {};
        
        var initCss = {};
        var op = this.constructor.StyleOperator;
        var relativeReg = /^(\+|-)=/i;
        var unitReg = /[^0-9.]+$/i;
        
        for (var i = this._targetStyles.length; i--;) {
            var key  = this._targetStyles[i];
            var prm  = '' + this._params[key].value;
            var pre  = prm.match(relativeReg);
            var unit = prm.match(unitReg);
            var limit = this._params[key].limit;
            var fprm, prmLimit;
            
            unit = unit && unit[0] || '';
            
            this._defaultParams[key] = op.filter(key, this._style.getStyle(key));
            
            if (pre) {
                prm = prm.replace(relativeReg, '');
                pre = pre[1];
                
                fprm = op.filter(key, prm);
                
                fprm = (pre === '+' ? this._add : this._sub)(this._defaultParams[key], fprm);
            } else {
                fprm = op.filter(key, prm);
            }
            
            // 制限が課せられていた場合下準備をする
            if (limit) {
                prmLimit = {};
                
                if (limit.useUpper) {
                    prmLimit.upper = op.filter(key, limit.upper);
                    
                    if (fprm.splice && ( ! prmLimit.upper.splice || fprm.length !== prmLimit.upper.length)) {
                        delete prmLimit.upper;
                    } else {
                        prmLimit.useUpper = true;
                    }
                }

                if (limit.useLower) {
                    prmLimit.lower = op.filter(key, limit.lower);
                    
                    if (fprm.splice && ( ! prmLimit.lower.splice || fprm.length !== prmLimit.lower.length)) {
                        delete prmLimit.lower;
                    } else {
                        prmLimit.useLower = true;
                    }
                }
                
                if ( ! (prmLimit.useUpper || prmLimit.useLower)) {
                    prmLimit = null;
                } else {
                    prmLimit.reverse = limit.reverse;
                }
            }
            
            this._deltaParams[key] = {
                value: this._sub(fprm, this._defaultParams[key]),
                unit: unit,
                easing: this._params[key].easing || this._easing,
                limit: prmLimit
            };
            
            this._endParams[key] = op.unfilter(key, fprm, this._deltaParams[key].unit);
            
            if (key === 'width' || key === 'height') {
                var style = this._style.getElementStyle();
                this._endParams['overflow'] = style.overflow;
                this._endParams['overflow-x'] = style.overflowX;
                this._endParams['overflow-y'] = style.overflowY;
                
                initCss['overflow'] = 'hidden';
            }
            
            if (this._hook[prm]) {
                var res = this._hook[prm](key, this._defaultParams[key], this._deltaParams[key], this._endParams[key]);
                
                if ( ! res) {
                    continue;
                }
                
                var prmKey;
                
                for (prmKey in res.init) {
                    if (prmKey === key) {
                        this._defaultParams[prmKey] = op.filter(prmKey, res.init[prmKey]);
                    }
                    
                    initCss[prmKey] = res.init[prmKey];
                }
                
                for (prmKey in res.delta) {
                    if (this._deltaParams[prmKey]) {
                        this._deltaParams[prmKey] = Jeeel.Hash.merge(this._deltaParams[prmKey], res.delta[prmKey]);
                    } else {
                        this._deltaParams[prmKey] = res.delta[prmKey];
                    }
                    
                    if ( ! this._deltaParams[prmKey].easing) {
                        this._deltaParams[prmKey].easing = this._easing;
                    }
                }
                
                for (prmKey in res.end) {
                    this._endParams[prmKey] = res.end[prmKey];
                }
            }
        }
        
        this._style.setStyleList(initCss);

        return this;
    },

    /**
     * アニメーションを開始する
     * 
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    start: function () {
      
        if ( ! this._frameId) {
            
            this._st = new Date().getTime() - this._ct;
            
            this._frameId = this.constructor.Frame.addTask(this.step);
            
            this.constructor.animated.push(this._element);
        }
        
        return this;
    },
    
    /**
     * アニメーションを一時停止する
     * 
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    stop: function () {
        if (this._frameId) {
            this.constructor.Frame.removeTask(this._frameId);
            
            this._frameId = null;
            
            for (var i = this.constructor.animated.length; i--;) {
                if (this.constructor.animated[i] === this._element) {
                    this.constructor.animated.splice(i, 1);
                    break;
                }
            }
        }
        
        return this;
    },
    
    /**
     * アニメーションを最小単位だけ進める
     * 
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    step: function (time) {
        
        var ct = time - this._st;
        var brk = false;
        
        if (ct > this._duration) {
            ct = this._duration;
            brk = true;
        }
        
        this._ct = ct;
        
        var css = this._getCss();

        this._style.setStyleList(css);
        
        if (this._step) {
            this._step.func.call(this._step.thisArg || this, this._easing(ct, 0, 1, this._duration));
        }
        
        if (brk) {
            return this.end();
        }

        return this;
    },
    
    /**
     * アニメーションを終了する
     * 
     * @return {Jeeel.Dom.Style.Animation} 自インスタンス
     */
    end: function () {
        
        // まだアニメーションが稼働中の場合は止める
        if (this._frameId) {
            this.stop();
        }
        
        // 最終状態のスタイルに変更する
        this._style.setStyleList(this._endParams);
        
        if (this._complete) {
            this._complete.func.call(this._complete.thisArg || this);
        }
        
        if (this._lastCallback) {
            this._lastCallback();
        }
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Style.Animation,
    
    /**
     * 加算する
     * 
     * @param {Number|Number[]} a 加算元
     * @param {Number|Number[]} b 加算先
     * @return {Number|Number[]} 加算結果
     */
    _add: function (a, b) {
        if (a.splice) {
            var res = [];
            
            for (var i = a.length; i--;) {
                res[i] = a[i] + b[i];
            }
            
            return res;
        }
        
        return a + b;
    },
    
    /**
     * 減算する
     * 
     * @param {Number|Number[]} a 減算元
     * @param {Number|Number[]} b 減算先
     * @return {Number|Number[]} 減算結果
     */
    _sub: function (a, b) {
        if (a.splice) {
            var res = [];
            
            for (var i = a.length; i--;) {
                res[i] = a[i] - b[i];
            }
            
            return res;
        }
        
        return a - b;
    },
    
    /**
     * CSSを取得する
     * 
     * @return {Hash} CSSリスト
     */
    _getCss: function () {
        var css = {};
        var op = this.constructor.StyleOperator;
        
        for (var i = this._targetStyles.length; i--;) {
            var key = this._targetStyles[i];
            var defaultPrm = this._defaultParams[key];
            var deltaParam = this._deltaParams[key];
            var limit = deltaParam.limit;
            var res, j, chn = false;
            
            // 配列の時のループ
            if (defaultPrm.splice) {
                res = [];
                
                for (j = defaultPrm.length; j--;) {
                    res[j] = deltaParam.easing(this._ct, defaultPrm[j], deltaParam.value[j], this._duration);
                }
                
                // リミットの処理
                if (limit) {
                    if (limit.reverse) {
                        if (limit.useUpper) {
                            for (j = res.length; j--;) {
                                if (res[j] > limit.upper[j]) {
                                    defaultPrm[j] = limit.upper[j] + (limit.upper[j] - defaultPrm[j]);
                                    res[j] = limit.upper[j] - (res[j] - limit.upper[j]);
                                    deltaParam.value[j] = -deltaParam.value[j];
                                    chn = true;
                                }
                            }
                        }

                        if (limit.useLower) {
                            for (j = res.length; j--;) {
                                if (res[j] < limit.lower[j]) {
                                    defaultPrm[j] = limit.lower[j] - (defaultPrm[j] - limit.lower[j]);
                                    res[j] = limit.lower[j] + (limit.lower[j] - res[j]);
                                    deltaParam.value[j] = -deltaParam.value[j];
                                    chn = true;
                                }
                            }
                        }
                        
                        if (chn) {
                            this._endParams[key] = op.unfilter(key, this._add(defaultPrm, deltaParam.value), deltaParam.unit);
                        }
                    } else {
                        if (limit.useUpper) {
                            for (j = res.length; j--;) {
                                if (res[j] > limit.upper[j]) {
                                    res[j] = limit.upper[j];
                                    chn = true;
                                }
                            }
                        }

                        if (limit.useLower) {
                            for (j = res.length; j--;) {
                                if (res[j] < limit.lower[j]) {
                                    res[j] = limit.lower[j];
                                    chn = true;
                                }
                            }
                        }
                        
                        if (chn) {
                            this._endParams[key] = op.unfilter(key, res, deltaParam.unit);
                        }
                    }
                }
                
            } else {
                res = deltaParam.easing(this._ct, defaultPrm, deltaParam.value, this._duration);
                
                // リミットの処理
                if (limit) {
                    if (limit.reverse) {
                        if (limit.useUpper && res > limit.upper) {
                            this._defaultParams[key] = defaultPrm = limit.upper + (limit.upper - defaultPrm);
                            res = limit.upper - (res - limit.upper);
                            deltaParam.value = -deltaParam.value;
                            chn = true;
                        }

                        if (limit.useLower && res < limit.lower) {
                            this._defaultParams[key] = defaultPrm = limit.lower - (defaultPrm - limit.lower);
                            res = limit.lower + (limit.lower - res);
                            deltaParam.value = -deltaParam.value;
                            chn = true;
                        }

                        if (chn) {
                            this._endParams[key] = op.unfilter(key, this._add(defaultPrm, deltaParam.value), deltaParam.unit);
                        }
                    } else {
                        if (limit.useUpper && res > limit.upper) {
                            res = limit.upper;
                            chn = true;
                        }

                        if (limit.useLower && res < limit.lower) {
                            res = limit.lower;
                            chn = true;
                        }

                        if (chn) {
                            this._endParams[key] = op.unfilter(key, res, deltaParam.unit);
                        }
                    }
                }
            }
            
            css[key] = op.unfilter(key, res, deltaParam.unit);
        }
        
        return css;
    },
    
    /**
     * 内部で用いるスタイルに変換する
     */
    _toInnerStyle: function (style) {
        var res = {}, op;
        
        if (Jeeel.Type.isHash(style)) {
          
            if (Jeeel.Type.isArray(style)) {
                res.value   = style[0];
                res.easing  = (Jeeel.Type.isFunction(style[1]) ? style[1] : this.constructor.Easing[style[1]]);
                
                op = style[2];
            } else {
                res.value   = ('value' in style) ? style.value : '0px';
                res.easing  = (Jeeel.Type.isFunction(style.easing) ? style.easing : this.constructor.Easing[style.easing]);
                
                op = style.option;
            }
            
            this._analyzeOption(res, op);
            
        } else {
            res.value = style;
        }
        
        return res;
    },
    
    /**
     * オプションの解析
     */
    _analyzeOption: function (res, option) {
        if ( ! option) {
            return;
        }
        
        if (option.limit) {
            var limit = {
                upper: option.limit.upper,
                useUpper: 'upper' in option.limit,
                lower: option.limit.lower,
                useLower: 'lower' in option.limit,
                reverse: !!option.limit.reverse
            };
            
            if (limit.useUpper || limit.useLower) {
                res.limit = limit;
            }
        }
    }
};

Jeeel.file.Jeeel.Dom.Style.Animation = ['Frame', 'Hook', 'Custom', 'StyleOperator', 'Speed', 'Easing'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style.Animation, Jeeel.file.Jeeel.Dom.Style.Animation);
/**
 * @staticClass アニメーションフレームを制御するスタティッククラス
 */
Jeeel.Dom.Style.Animation.Frame = {
    
    /**
     * FPS
     * 
     * @type Integer
     * @private
     */
    _fps: 60,
    
    /**
     * animation/frame
     * 
     * @type Number
     * @private
     */
    _apf: 1,
    
    /**
     * frameCount
     * 
     * @type Number
     * @private
     */
    _fcount: 0,
    
    /**
     * アニメーションフレーム内でのタスクリスト
     * 
     * @type Function[]
     * @private
     */
    _tasks: [],
    
    /**
     * アニメーションタスクのIDをキーにしたハッシュマップ
     * 
     * @type Hash
     * @private
     */
    _taskHashs: {},
    
    /**
     * 現在までに追加したタスク数の合計
     * 
     * @type Integer
     * @private
     */
    _taskCount: 0,
    
    /**
     * ロック
     * 
     * @type Integer
     * @private
     */
    _lock: false,
    
    /**
     * requestAnimationFrame関数を使用するかどうか
     * 
     * @type Boolean
     * @private
     */
    _useRaf: true,
    
    /**
     * アニメーションフレームのリクエストID
     * 
     * @type Integer
     * @private
     */
    _requestId: null,
    
    /**
     * アニメーションの1秒間の描画回数を設定する
     * 
     * @param {Integer} fps 1秒毎のフレーム描画回数
     * @return {Jeeel.Dom.Style.Animation.Frame} 自クラス
     */
    setFps: function (fps) {
        var requested = !!this._requestId;
        
        if (requested) {
            this.stop();
        }
        
        this._fps = +fps;
        this._apf = 60 / this._fps;
        
        if (requested) {
            this.start();
        }
        
        return this;
    },
    
    /**
     * requestAnimationFrameを使用するかどうかを設定する
     * 
     * @param {Boolean} enable 使用するかどうか
     */
    useAnimationFrame: function (enable) {
        var requested = !!this._requestId;
        
        if (requested) {
            this.stop();
        }
        
        this._useRaf = !!enable;
        
        if (requested) {
            this.start();
        }
        
        return this;
    },
    
    /**
     * アニメーションタスクを追加する
     * 
     * @param {Function} task タスク
     * @return {Integer} タスクID
     */
    addTask: function (task) {
        this._taskCount++;
        
        this._tasks[this._tasks.length] = this._taskHashs[this._taskCount] = task;
        
        this.start();
        
        return this._taskCount;
    },
    
    /**
     * アニメーションタスクを削除する
     * 
     * @param {Integer} id 削除対象のタスクID
     * @return {Jeeel.Dom.Style.Animation.Frame} 自クラス
     */
    removeTask: function (id) {
        var task = this._taskHashs[id];
        
        if ( ! task) {
            return this;
        }
        
        for (var i = this._tasks.length; i--;) {
            if (this._tasks[i] === task) {
                this._tasks.splice(i, 1);
                break;
            }
        }
        
        delete this._taskHashs[id];
        
        if ( ! this._tasks.length) {
            this.stop();
        }
        
        return this;
    },
    
    /**
     * アニメーションフレームを開始する
     * 
     * @return {Jeeel.Dom.Style.Animation.Frame} 自クラス
     */
    start: function () {
        
        if (this._requestId) {
            return this;
        }

        this._fcount = 0;
        this._requestId = this._requestAnimationFrame(this.animate);
        
        return this;
    },
    
    /**
     * アニメーションフレームを停止する
     * 
     * @return {Jeeel.Dom.Style.Animation.Frame} 自クラス
     */
    stop: function () {
        
        if ( ! this._requestId) {
            return this;
        }
        
        this._cancelAnimationFrame(this._requestId);
        
        this._requestId = null;
        
        return this;
    },
    
    /**
     * アニメーションフレームのタスクを実行する
     * 
     * @param {Integer} time タイムスタンプ
     */
    animate: function (time) {
        
        this._fcount++;
        
        if (this._fcount >= this._apf) {
            this._fcount -= this._apf;
        } else {
            this._requestId = this._requestAnimationFrame(this.animate);
            
            return;
        }
        
        // setTimeoutで疑似作成している場合のタイムスタンプを作成
        if ( ! time) {
            time = new Date().getTime();
        }
        
        // タスク中にremoveTaskを呼ばれるとおかしいんで複製する
        var cloneTasks = this._tasks.concat();
        
        for (var i = 0, l = cloneTasks.length; i < l; i++) {
            cloneTasks[i](time);
        }
        
        this._requestId = this._requestAnimationFrame(this.animate);
    },
    
    /**
     * アニメーションフレームの呼び出しを要求する
     * 
     * @param {Function} callback 呼び出し関数
     * @return {Integer} リクエストID
     * @private
     */
    _requestAnimationFrame: function (callback) {
        var win = Jeeel._global;
        
        if (this._useRaf) {
            return (win.requestAnimationFrame
                || win.webkitRequestAnimationFrame
                || win.mozRequestAnimationFrame
                || win.oRequestAnimationFrame
                || win.msRequestAnimationFrame
                || Jeeel.Timer.setTimeout)(callback, 1000 / 60);
        }
        
        return Jeeel.Timer.setTimeout(callback, 1000 / 60);
    },
    
    /**
     * アニメーションフレームの呼び出しをキャンセルする
     * 
     * @param {Integer} id リクエストID
     * @private
     */
    _cancelAnimationFrame: function (id) {
        var win = Jeeel._global;
        
        if (this._useRaf) {
            return (win.cancelAnimationFrame
                || win.webkitCancelRequestAnimationFrame
                || win.mozCancelRequestAnimationFrame
                || win.oCancelRequestAnimationFrame
                || win.msCancelRequestAnimationFrame
                || Jeeel.Timer.clearTimeout)(id);
        }
        
        return Jeeel.Timer.clearTimeout(id);
    },
    
    /**
     * 初期化
     */
    _init: function () {
        delete this._init;
        
        if ( ! Jeeel._global) {
            return;
        }
        
        this.animate = Jeeel.Function.simpleBind(this.animate, this);
    }
};

Jeeel.Dom.Style.Animation.Frame._init();Jeeel.directory.Jeeel.Dom.Style.Animation.Hook = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Style.Animation + 'Hook/';
    }
};

/**
 * コンストラクタ
 * 
 * @class フックに対して操作を行うクラス
 * @param {Element} element 要素
 * @param {Jeeel.Dom.Style} style スタイル
 */
Jeeel.Dom.Style.Animation.Hook = function (element, style) {
    this._element = element;
    this._style = style;
};

/**
 * フックを登録する
 * 
 * @param {String} name 名前
 * @param {Function} get 取得メソッド
 */
Jeeel.Dom.Style.Animation.Hook.register = function (name, get) {
    if (typeof get !== 'function') {
        throw new Error('フックではありません。');
    }
    
    this.prototype[name] = get;
};

Jeeel.Dom.Style.Animation.Hook.prototype = {
    
    _element: null,
    _style: null,
    
    /**
     * コンストラクタ
     * 
     * @param {Style} style 操作スタイル
     * @constructor
     */
    constructor: Jeeel.Dom.Style.Animation.Hook
};

Jeeel.file.Jeeel.Dom.Style.Animation.Hook = ['Default'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style.Animation.Hook, Jeeel.file.Jeeel.Dom.Style.Animation.Hook);/**
 * フックの初期登録を行う
 */
(function () {
    
    if ( ! Jeeel._elm) {
        return;
    }
    
    var displayParts = [
        'height', 
        'width', 
        'opacity', 
        'marginTop', 
        'marginBottom', 
        'marginLeft', 
        'marginRight', 
        'paddingTop', 
        'paddingBottom', 
        'paddingLeft', 
        'paddingRight'
    ];
    
    var parts = [], i = 0;
    
    // showの登録
    parts[i++] = {
        name: 'show',
        
        get: function (key, defaultPrm, deltaPrm, endPrm) {
            if ( ! Jeeel.Hash.inHash(key, displayParts, true)) {
                return null;
            }
            
            var showDisp = this._style._getShowedDisplay();
            var nowDisp  = this._style.getStyle('display');
            var delta    = {unit: 'px'};
            
            if (nowDisp !== 'none') {
                return null;
            }
            
            if (key === 'opacity') {
                delta.unit = 0;
            }

            delta.value = defaultPrm;
            
            /**
             * @ignore
             */
            var res = {
                init: {},
                
                delta: {},
                
                end: {}
            };
            
            res.init[key]  = '0' + (key === 'opacity' ? '' : 'px');
            res.init.display = showDisp;
            res.delta[key] = delta;
            res.end[key]   = this._style.getStyle(key);
            
            return res;
        }
    };
    
    // hideの登録
    parts[i++] = {
        name: 'hide',
        
        get: function (key, defaultPrm, deltaPrm, endPrm) {
            if ( ! Jeeel.Hash.inHash(key, displayParts, true)) {
                return null;
            }
            
            var nowDisp  = this._style.getStyle('display');
            var delta    = {unit: 'px'};
            
            if (nowDisp === 'none') {
                return null;
            }
            
            if (key === 'opacity') {
                delta.unit = 0;
            }

            delta.value = -defaultPrm;
            
            /**
             * @ignore
             */
            var res = {
                init: {},
                
                delta: {},
                
                end: {
                    display: 'none'
                }
            };
            
            res.delta[key] = delta;
            res.end[key]   = this._style.getStyle(key);
            
            return res;
        }
    };
    
    // toggleの登録
    parts[i++] = {
        name: 'toggle',
        
        get: function (key, defaultPrm, deltaPrm, endPrm) {
            if ( ! Jeeel.Hash.inHash(key, displayParts, true)) {
                return null;
            }
            
            var nowDisp  = this._style.getStyle('display');
            
            return nowDisp === 'none' ? this.show(key, defaultPrm, deltaPrm, endPrm) : this.hide(key, defaultPrm, deltaPrm, endPrm);
        }
    };
    
    for (i = parts.length; i--;) {
        Jeeel.Dom.Style.Animation.Hook.register(parts[i].name, parts[i].get);
    }

    // 念のためメモリリーク対策
    parts = null;
})();Jeeel.directory.Jeeel.Dom.Style.Animation.Custom = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Style.Animation + 'Custom/';
    }
};

(function () {
    
    var instance;
    
    /**
     * コンストラクタ
     * 
     * @class カスタムスタイルに対して操作を行うクラス
     */
    Jeeel.Dom.Style.Animation.Custom = function () {
      
        if (instance) {
            return instance;
        }
        
        if ( ! (this instanceof this.constructor)) {
            return new Jeeel.Dom.Style.Animation.Custom();
        }
        
        instance = this;
    };
    
    /**
     * インスタンスを取得する
     * 
     * @return {Jeeel.Dom.Style.Animation.Custom} インスタンス
     */
    Jeeel.Dom.Style.Animation.Custom.getInstance = function () {
        if (instance) {
            return instance;
        }
        
        return new this();
    };
})();

/**
 * カスタムスタイルを登録する
 * 
 * @param {String} name 名前
 * @param {Function} get ゲッター
 */
Jeeel.Dom.Style.Animation.Custom.register = function (name, get) {
    if (typeof get !== 'function') {
        throw new Error('フックではありません。');
    }
    
    this.prototype[name] = get;
};

Jeeel.Dom.Style.Animation.Custom.prototype = {
    
    /**
     * コンストラクタ
     * 
     * @param {Style} style 操作スタイル
     * @constructor
     */
    constructor: Jeeel.Dom.Style.Animation.Custom
};

Jeeel.file.Jeeel.Dom.Style.Animation.Custom = ['Default'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style.Animation.Custom, Jeeel.file.Jeeel.Dom.Style.Animation.Custom);/**
 * カスタムアニメーションの初期登録を行う
 */
(function () {
  
    if ( ! Jeeel._elm) {
        return;
    }
    
    var displayParts = {
        display: [
            'height', 
            'width', 
            'opacity', 
            'marginTop', 
            'marginBottom', 
            'marginLeft', 
            'marginRight', 
            'paddingTop', 
            'paddingBottom', 
            'paddingLeft', 
            'paddingRight'
        ],
        
        width: [
            'width', 
            'marginLeft', 
            'marginRight', 
            'paddingLeft', 
            'paddingRight'
        ],
        
        height: [
            'height', 
            'marginTop', 
            'marginBottom', 
            'paddingTop', 
            'paddingBottom'
        ]
    };
    
    var parts = [], i = 0;
    
    // widthの登録
    parts[i++] = {
        name: 'width',
        
        get: function (value) {
            if ( ! (value === 'show' || value === 'hide' || value === 'toggle')) {
                return {width: value};
            }
            
            var res = {};
            
            for (var i = displayParts.width.length; i--;) {
                res[displayParts.width[i]] = value;
            }
            
            return res;
        }
    };
    
    // heightの登録
    parts[i++] = {
        name: 'height',
        
        get: function (value) {
            if ( ! (value === 'show' || value === 'hide' || value === 'toggle')) {
                return {width: value};
            }
            
            var res = {};
            
            for (var i = displayParts.height.length; i--;) {
                res[displayParts.height[i]] = value;
            }
            
            return res;
        }
    };
    
    // displayの登録
    parts[i++] = {
        name: 'display',
        
        get: function (value) {
            if ( ! (value === 'show' || value === 'hide' || value === 'toggle')) {
                return {display: value};
            }
            
            var res = {};
            
            for (var i = displayParts.display.length; i--;) {
                res[displayParts.display[i]] = value;
            }
            
            return res;
        }
    };
    
    // background-positionの登録
    parts[i++] = {
        name: 'backgroundPosition',
        
        get: function (value) {
            var pos = value.replace(/\s+/g, ' ').split(' ');
            var res = {
                backgroundPositionX: pos[0],
                backgroundPositionY: pos[1]
            };

            return res;
        }
    };
    
    // transformの登録
    parts[i++] = {
        name: 'transform',
        
        get: function (value) {
            var trs = value.replace(/,\s+/g, ',').replace(/\s+/g, ' ').split(' ');
            var reg = /^([a-zA-Z\-]+)\(([^\)]+)\)$/i;
            var res = {};
            
            for (var i = trs.length; i--;) {
                var matches = trs[i].match(reg);
                
                if (matches) {
                    res[matches[1]] = matches[2];
                }
            }
            
            return res;
        }
    };
    
    for (i = parts.length; i--;) {
        Jeeel.Dom.Style.Animation.Custom.register(parts[i].name, parts[i].get);
    }

    // 念のためメモリリーク対策
    parts = null;
})();Jeeel.directory.Jeeel.Dom.Style.Animation.StyleOperator = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom.Style.Animation + 'StyleOperator/';
    }
};

/**
 * @class アニメーションの値に特殊な加工を施して変換するクラス
 * @static
 */
Jeeel.Dom.Style.Animation.StyleOperator = {
    
    _operators: {},
    
    register: function (operator) {
        this._operators[operator.name] = operator;
    },
    
    /**
     * スタイルフィルターのパーツを作成する
     * 
     * @param {String} name キャメルケースの名前
     * @param {Function} filter アニメーション用の値に変換するフィルタ
     * @param {Function} unfilter アニメーション用の値から通常の値に変換するフィルタ
     * @return {Hash} フィルタパーツ
     */
    createOperator: function (name, filter, unfilter) {
        return {
            name: name,
            filter: filter,
            unfilter: unfilter
        };
    },
    
    filter: function (key, val) {
        var op = this._operators[key];
        
        if (op) {
            return op.filter(val);
        }
        
        return parseFloat(val);
    },
    
    unfilter: function (key, val, unit) {
        var op = this._operators[key];
        
        if (op) {
            return op.unfilter(val);
        }
        
        return val + (unit || 0);
    }
};

Jeeel.file.Jeeel.Dom.Style.Animation.StyleOperator = ['Default'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Style.Animation.StyleOperator, Jeeel.file.Jeeel.Dom.Style.Animation.StyleOperator);/**
 * カスタムスタイルの初期登録を行う
 */
(function () {
  
    if ( ! Jeeel._elm) {
        return;
    }
    
    var elmStyle = Jeeel._elm.cloneNode(false).style;
    
    var limit = Jeeel.Number.limit;
    var operators = [], i = 0, operator, filter, unfilter;
    
    elmStyle.cssText = 'color: rgba(255, 255, 255, 1);';
    
    // colorの登録
    operators[i] = {name: 'color'};
    
    // rgba形式に対応しているかどうかで振り分ける
    if (elmStyle.color) {
      
        /**
         * @ignore
         */
        filter = function (val) {
            var color = new Jeeel.Object.Color.Rgb(val);
            return [
                color.red,
                color.green,
                color.blue,
                color.alpha
            ];
        };

        /**
         * @ignore
         */
        unfilter = function (val) {
            return 'rgba(' 
                + limit(Math.floor(val[0]), 0, 255) + ','
                + limit(Math.floor(val[1]), 0, 255) + ','
                + limit(Math.floor(val[2]), 0, 255) + ','
                + limit(val[3], 0, 1) + ')';
        };
    } else {
        
        /**
         * @ignore
         */
        filter = function (val) {
            var color = new Jeeel.Object.Color.Rgb(val);
            return [
                color.red,
                color.green,
                color.blue
            ];
        };

        /**
         * @ignore
         */
        unfilter = function (val) {
            return 'rgb(' 
                + limit(Math.floor(val[0]), 0, 255) + ','
                + limit(Math.floor(val[1]), 0, 255) + ','
                + limit(Math.floor(val[2]), 0, 255) + ')';
        };
    }

    operators[i].filter = filter;
    operators[i].unfilter = unfilter;
    
    i++;
    
    
    // background-colorの登録
    operators[i] = {name: 'backgroundColor'};
    
    operators[i].filter = filter;
    operators[i].unfilter = unfilter;
    
    i++;
    
    
    // border-colorの登録
    operators[i] = {name: 'borderColor'};
    
    operators[i].filter = filter;
    operators[i].unfilter = unfilter;
    
    i++;
    
    
    // border-top-colorの登録
    operators[i] = {name: 'borderTopColor'};
    
    operators[i].filter = filter;
    operators[i].unfilter = unfilter;
    
    i++;
    
    
    // border-right-colorの登録
    operators[i] = {name: 'borderRightColor'};
    
    operators[i].filter = filter;
    operators[i].unfilter = unfilter;
    
    i++;
    
    
    // border-bottom-colorの登録
    operators[i] = {name: 'borderBottomColor'};
    
    operators[i].filter = filter;
    operators[i].unfilter = unfilter;
    
    i++;
    
    
    // border-left-colorの登録
    operators[i] = {name: 'borderLeftColor'};
    
    operators[i].filter = filter;
    operators[i].unfilter = unfilter;
    
    i++;
    
    
    // outline-colorの登録
    operators[i] = {name: 'outlineColor'};
    
    operators[i].filter = filter;
    operators[i].unfilter = unfilter;
    
    i++;
    
    for (i = operators.length; i--;) {
        operator = Jeeel.Dom.Style.Animation.StyleOperator.createOperator(operators[i].name, operators[i].filter, operators[i].unfilter);
        
        Jeeel.Dom.Style.Animation.StyleOperator.register(operator);
    }
    
})();
/**
 * @class スピードに関するクラス
 * @static
 */
Jeeel.Dom.Style.Animation.Speed = {
    
    getSpeed: function (duration) {
      
        // 数値で且正の値だった場合はそのまま返す
        if (duration > 0) {
            return duration;
        }
        
        duration = ('' + duration).toUpperCase();
        
        return (duration in this.SPEEDS ? this.SPEEDS[duration] : this.SPEEDS.DEFAULT);
    }
};

/**
 * @namespace 規定の速度を示す列挙体
 */
Jeeel.Dom.Style.Animation.Speed.SPEEDS = {
    /**
     * 遅い
     * 
     * @type Integer
     * @constant
     */
    SLOW: 600,
    
    /**
     * 早い
     * 
     * @type Integer
     * @constant
     */
    FAST: 200,
    
    /**
     * デフォルト
     * 
     * @type Integer
     * @constant
     */
    DEFAULT: 400
};

/**
 * @namespace イージング関数を保持するネームスペース<br />
 * t: currentTime(経過時間: 秒)<br />
 * b: beginningValue(初期値)<br />
 * c: changeInValue(変動値)<br />
 * d: duration(継続時間: 秒)
 */
Jeeel.Dom.Style.Animation.Easing = {
  
    /**
     * y = x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    linear: function (t, b, c, d) {
        return c * t / d + b; 
    },
    
    /**
     * y = -( cos(x * π) ) / 2 + 0.5
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    swing: function (t, b, c, d) {
        return ((-Math.cos(t / d * Math.PI) / 2) + 0.5) * c + b;
    },
    
    /**
     * y = x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeNone: function (t, b, c, d) {
        return c * t / d + b; 
    },
    
    /**
     * y = 2x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInQuad: function (t, b, c, d) {
        return c * (t /= d) * t + b;
    },
    
    easeOutQuad: function (t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
    },
    
    easeInOutQuad: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return c / 2 * t * t + b;
        }
        
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },
    
    /**
     * y = 3x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInCubic: function (t, b, c, d) {
        return c * (t /= d) * t * t + b;
    },
    
    easeOutCubic: function (t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
    },
    
    easeInOutCubic: function (t, b, c, d) {
        if ((t /= d / 2) < 1) { 
            return c / 2 * t * t * t + b;
        }
        
        return c / 2 * ((t -= 2) * t * t + 2) + b;
    },
    
    easeOutInCubic: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutCubic(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInCubic((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = 4x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInQuart: function (t, b, c, d) {
        return c * (t /= d) * t * t * t + b;
    },
    
    easeOutQuart: function (t, b, c, d) {
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    },
    
    easeInOutQuart: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return c / 2 * t * t * t * t + b;
        }
        
        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    },
    
    easeOutInQuart: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutQuart(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInQuart((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = 5x
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInQuint: function (t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
    },

    easeOutQuint: function (t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    },
    
    easeInOutQuint: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return c / 2 * t * t * t * t * t + b;
        }
        
        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    },
    
    easeOutInQuint: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutQuint(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInQuint((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = -cos(x * n/2) + 1
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInSine: function (t, b, c, d) {
        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    },
    
    easeOutSine: function (t, b, c, d) {
        return c * Math.sin(t / d * (Math.PI / 2)) + b;
    },
    
    easeInOutSine: function (t, b, c, d) {
        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    },
    
    easeOutInSine: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutSine(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInSine((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = 2 ^ (10 * (x - 1)) : xが0の時はyも0
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInExpo: function (t, b, c, d) {
        return (t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001);
    },
    
    easeOutExpo: function (t, b, c, d) {
        return (t === d ? b + c : c * 1.001 * (-Math.pow(2, -10 * t / d) + 1) + b);
    },
    
    easeInOutExpo: function (t, b, c, d) {
        if (t === 0) {
            return b;
        } else if (t === d) {
            return b + c;
        } else if ((t /= d / 2) < 1) {
            return c / 2 * Math.pow(2, 10 * (t - 1)) + b - c * 0.0005;
        }
        
        return c / 2 * 1.0005 * (-Math.pow(2, -10 * --t) + 2) + b;
    },
    
    easeOutInExpo: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutExpo(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInExpo((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    /**
     * y = -0.5(1 - x * x) + 1
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @return {Number} 現在値
     */
    easeInCirc: function (t, b, c, d) {
        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    },
    
    easeOutCirc: function (t, b, c, d) {
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    },
    
    easeInOutCirc: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
        }
        
        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    },
    
    easeOutInCirc: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutCirc(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInCirc((t * 2) - d, b + c / 2, c / 2, d);
    },
    
    easeInElastic: function (t, b, c, d, a, p) {
        var s;
        
        if (t === 0) {
            return b;  
        } else if ((t /= d) === 1) {
            return b + c;  
        } else if ( ! p) {
            p = d * 0.3;
        }
        
        if ( ! a || a < Math.abs(c)) { 
            a = c; 
            s = p / 4; 
        } else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }

        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    },
    
    easeOutElastic: function (t, b, c, d, a, p) {
        var s;
        
        if (t === 0) {
            return b;  
        } else if ((t /= d) === 1) {
            return b + c;  
        } else if ( ! p) {
            p = d * 0.3;
        }
        
        if ( ! a || a < Math.abs(c)) {
            a = c;
            s = p / 4; 
        } else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        
        return(a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p ) + c + b);
    },
    
    easeInOutElastic: function (t, b, c, d, a, p) {
        var s;
        
        if (t === 0) {
            return b;  
        } else if ((t /= d / 2) === 2) {
            return b + c;  
        } else if ( ! p) {
            p = d * (0.3 * 1.5);
        }
        
        if ( ! a || a < Math.abs(c)) { 
            a = c; 
            s = p / 4; 
        } else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        
        if (t < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        }
        
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
    },
    
    easeOutInElastic: function (t, b, c, d, a, p) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutElastic(t * 2, b, c / 2, d, a, p);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInElastic((t * 2) - d, b + c / 2, c / 2, d, a, p);
    },
    
    /**
     * y = x * x * ( 2.70158 * x - 1.70158 )
     * 
     * @param {Integer} t 経過時間
     * @param {Number} b 初期値
     * @param {Number} c 変動値
     * @param {Integer} d 継続時間
     * @param {Number} [s] 反動などの強さ
     * @return {Number} 現在値
     */
    easeInBack: function (t, b, c, d, s) {
        if ( ! s) {
            s = 1.70158;
        }
        
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    
    easeOutBack: function (t, b, c, d, s) {
        if ( ! s) {
            s = 1.70158;
        }
        
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    
    easeInOutBack: function (t, b, c, d, s) {
        if ( ! s) {
            s = 1.70158;
        }
        
        if ((t /= d / 2) < 1) {
            return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
        }
        
        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
    },
    
    easeOutInBack: function (t, b, c, d, s) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutBack(t * 2, b, c / 2, d, s);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInBack((t * 2) - d, b + c / 2, c / 2, d, s);
    },
    
    easeInBounce: function (t, b, c, d) {
        return c - Jeeel.Dom.Style.Animation.Easing.easeOutBounce(d - t, 0, c, d) + b;
    },
    
    easeOutBounce: function (t, b, c, d) {
        if ((t /= d) < (1 / 2.75)) {
            return c * (7.5625 * t * t) + b;
        } else if (t < (2 / 2.75)) {
            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
        } else if (t < (2.5 / 2.75)) {
            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
        } else {
            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
        }
    },
    
    easeInOutBounce: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeInBounce(t * 2, 0, c, d) * 0.5 + b;
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    },
    
    easeOutInBounce: function (t, b, c, d) {
        if (t < d / 2) {
            return Jeeel.Dom.Style.Animation.Easing.easeOutBounce(t * 2, b, c / 2, d);
        }
        
        return Jeeel.Dom.Style.Animation.Easing.easeInBounce(t * 2 - d, b + c / 2, c / 2, d);
    }
};
Jeeel.directory.Jeeel.Dom.Element = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Element/';
    }
};

/**
 * コンストラクタ
 *
 * @class Elementをラップして操作系を強化するクラス
 * @param {Element} element 対象Element
 */
Jeeel.Dom.Element = function (element) {
    this._element = element;
    this._style = new Jeeel.Dom.Style(element);
    this._searcher = new Jeeel.Dom.Core.Searcher(element);
    this._doc = new Jeeel.Dom.Document(element && element.ownerDocument || Jeeel._doc);
};

/**
 * インスタンスを作成する
 *
 * @param {Element} element 対象Element
 * @return {Jeeel.Dom.Element} 作成したインスタンス
 */
Jeeel.Dom.Element.create = function (element) {
    return new this(element);
};

Jeeel.Dom.Element.prototype = {

    /**
     * 基となるElement(この操作モジュールを保持するElement)
     *
     * @type Element
     * @private
     */
    _element: null,
    
    /**
     * 操作Document
     * 
     * @type Jeeel.Dom.Document
     * @private
     */
    _doc: null,
    
    /**
     * 検索インスタンス
     * 
     * @type Jeeel.Dom.Core.Searcher
     * @private
     */
    _searcher: null,
    
    /**
     * ElementのStyleラッパー
     * 
     * @type Jeeel.Dom.Style
     * @private
     */
    _style: null,
    
    _moveCache: [],

    /**
     * 基となるElementを取得する
     *
     * @return {Element} 取得したElement
     */
    getElement: function () {
        return this._element;
    },
    
    /**
     * このElementを所有しているDocumentを取得する
     * 
     * @return {Document} Document
     */
    getOwnerDocument: function () {
        return this._element.ownerDocument;
    },
    
    /**
     * このElementを所有しているWindowを取得する
     * 
     * @return {Window} Window
     */
    getOwnerWindow: function () {
        var dc = this.getOwnerDocument();
        return dc.defaultView || dc.parentWindow;
    },

    /**
     * このElement内から指定IDのHTML要素を取得する
     *
     * @param {String} id 検索ID
     * @return {Element} 取得したElement
     */
    getElementById: function (id) {
        return this._searcher.getElementById(id);
    },

    /**
     * このElement内から指定ClassのHTML要素を取得する
     *
     * @param {String|String[]} className 検索Class
     * @return {Element[]} 取得したElement配列
     */
    getElementsByClassName: function (className) {
        return this._searcher.getElementsByClassName(className);
    },
    
    /**
     * このElement内から指定NameのHTML要素を取得する
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする
     *
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch=false] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか
     * @return {Element[]} 取得したElement配列
     */
    getElementsByName: function (name, submitSearch) {
        return this._searcher.getElementsByName(name, submitSearch);
    },
    
    /**
     * このElement内から指定TagのHTML要素を取得する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Element[]} 取得したElement配列
     */
    getElementsByTagName: function (tagName) {
        return this._searcher.getElementsByTagName(tagName);
    },
    
    /**
     * このElement内から指定属性が指定値のHTML要素を取得する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByAttribute: function (attribute, value) {
        return this._searcher.getElementsByAttribute(attribute, value);
    },

    /**
     * このElement内から指定プロパティが指定値のHTML要素を取得する<br />
     * Elementのプロパティである事に注意
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value プロパティ値('*'を指定すると任意の値の意味になる)
     * @return {Element[]} 取得したElement配列
     */
    getElementsByProperty: function (property, value) {
        return this._searcher.getElementsByProperty(property, value);
    },
    
    /**
     * このElement内部に絞り込みを掛ける<br />
     * 現在のHTML内に存在しない要素は取れない
     *
     * @param {String} selector CSSと同じ絞り込みセレクタ
     * @return {Element[]} 絞り込んだElement配列
     * @see Jeeel.Dom.Selector
     */
    getElementsBySelector: function (selector) {
        return this._searcher.getElementsBySelector(selector);
    },
    
    /**
     * このElement内のHTML要素を指定範囲検索する
     * 
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {Function} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Element[]} 範囲検索に引っかかったElement配列
     * @see Jeeel.Dom.SearchOption
     */
    searchElementsByRange: function (rect, option) {},
    
    /**
     * このElementのIDを取得する
     *
     * @return {String} ID
     */
    getId: function () {
        return this._element.id;
    },
    
    /**
     * このElementのIDを設定する
     *
     * @param {String} id ID
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setId: function (id) {
        this._element.id = id;
        
        return this;
    },

    /**
     * このElementのNameを取得する
     *
     * @return {String} Name
     */
    getName: function () {
        return this._element.name;
    },
    
    /**
     * このElementのNameを設定する
     *
     * @param {String} name Name
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setName: function (name) {
        this._element.name = name;
        
        return this;
    },
    
    /**
     * このElementのTagNameを取得する
     *
     * @return {String} TagName
     */
    getTagName: function () {
        return this._element.nodeName.toLowerCase();
    },
    
    /**
     * このElement内のクラス名を全て取得する
     *
     * @return {String[]} クラス名のリスト
     */
    getClassNames: function () {},

    /**
     * クラス名を追加する
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    addClassName: function (className) {},

    /**
     * クラス名の削除を行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    removeClassName: function (className) {},

    /**
     * クラス名が存在していたら削除し、存在していなかったら追加を行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    toggleClassName: function (className) {},

    /**
     * クラス名を消去する
     *
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    clearClassName: function () {
        this._element.className = '';

        return this;
    },

    /**
     * 指定したクラス名を保持しているかどうかを返す
     *
     * @param {String} className クラス名
     * @return {Boolean} クラス名を保持していたかどうか
     */
    hasClassName: function (className) {},

    /**
     * 属性値を取得する
     *
     * @param {String} attribute 属性名
     * @return {String} 属性値
     */
    getAttribute: function (attribute) {
        return this._element.getAttribute(attribute);
    },

    /**
     * 属性値の設定を行う
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setAttribute: function (attribute, value) {
        this._element.setAttribute(attribute, value);

        return this;
    },
    
    /**
     * 属性値が設定されているかどうかを返す
     * 
     * @param {String} attribute 属性名
     * @return {Boolean} 属性値が設定されているかどうか
     */
    hasAttribute: function (attribute) {
        return this._element.getAttribute(attribute) !== null;
    },
    
    /**
     * 属性値の削除を行う
     *
     * @param {String} attribute 属性名
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    removeAttribute: function (attribute) {
        this._element.removeAttribute(attribute);

        return this;
    },

    /**
     * プロパティを取得する
     *
     * @param {String} property プロパティ名
     * @return {Mixied} プロパティ値
     */
    getProperty: function (property) {
        if (property === 'value' && Jeeel.Dom.Behavior.Placeholder.isHolded(this._element)) {
            return '';
        }
      
        return this._element[property];
    },

    /**
     * プロパティの設定を行う
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value プロパティ値
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setProperty: function (property, value) {
        this._element[property] = value;

        return this;
    },

    /**
     * スタイルを取得する
     *
     * @param {String} style スタイル名
     * @return {String} スタイル値
     * @see Jeeel.Dom.Style
     */
    getStyle: function (style) {
        return this._style.getStyle(style);
    },

    /**
     * スタイルの設定を行う
     *
     * @param {String} style スタイル名
     * @param {String} value スタイル値
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style
     */
    setStyle: function (style, value) {
        this._style.setStyle(style, value);

        return this;
    },
    
    /**
     * 複数のスタイルの設定を行う
     *
     * @param {Hash} styles スタイル名と値のペアリスト
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setStyleList: function (styles) {
        this._style.setStyleList(styles);

        return this;
    },
    
    /**
     * DOMの独自データを取得する(属性値data-&#8727;)<br />
     * IE8以下ではメモリリークを起こす非推奨メソッド
     * 
     * @param {String} key データキー
     * @return {String} データ
     */
    getData: function (key) {},
    
    /**
     * DOMの独自データを設定する(属性値data-&#8727;)<br />
     * IE8以下ではメモリリークを起こす非推奨メソッド
     * 
     * @param {String} key データキー
     * @param {String} data データ
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setData: function (key, data) {},
    
    /**
     * Jeeelの独自データを取得する<brr />
     * IE以外ではプロパティが拡張されるので注意(詳しくはJeeel.Storage.Objectを参照)<br />
     * またネームスペースは初期値を用いる
     * 
     * @param {String} key データキー
     * @return {Mixied} データ
     * @see Jeeel.Storage.Object
     */
    getCustomData: function (key) {
        return Jeeel.Storage.Object(this._element).get(key);
    },
    
    /**
     * Jeeelの独自データを設定する<brr />
     * IE以外ではプロパティが拡張されるので注意(詳しくはJeeel.Storage.Objectを参照)<br />
     * またネームスペースは初期値を用いる
     * 
     * @param {String} key データキー
     * @param {Mixied} data データ
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Storage.Object
     */
    setCustomData: function (key, data) {
        
        Jeeel.Storage.Object(this._element).set(key, data);
        
        return this;
    },

    /**
     * このElementの左上絶対軸座標を返す
     * 
     * @return {Jeeel.Object.Point} 左上の座標
     */
    getPosition: function () {
        var pos = new Jeeel.Object.Point(0, 0);
        var el = this._element;
        var body = this._doc.getBody();
        
        while (el) {
            pos.x += el.offsetLeft;
            pos.y += el.offsetTop;

            el = el.offsetParent;
        }
        
        el = this._element.parentNode;
        
        while (el && el !== body) {
            pos.x -= el.scrollLeft;
            pos.y -= el.scrollTop;

            el = el.parentNode;
        }
        
        return pos;
    },
    
    /**
     * このElementのサイズを取得する
     * 
     * @return {Jeeel.Object.Size} サイズ
     */
    getSize: function () {
        return new Jeeel.Object.Size(parseInt(this._style.getStyle('width')), parseInt(this._style.getStyle('height')));
    },
    
    /**
     * このElementの左上絶対座標とサイズを併せ持った構造体を取得する
     * 
     * @return {Jeeel.Object.Rect} レクト
     */
    getRect: function () {
        return new Jeeel.Object.Rect(this.getPosition(), this.getSize());
    },
    
    /**
     * このElementのスクロール位置を取得する
     * 
     * @return {Jeeel.Object.Point} スクロール位置
     */
    getScrollPosition: function () {
        return new Jeeel.Object.Point(this._element.scrollLeft, this._element.scrollTop);
    },
    
    /**
     * このElementの親からの相対位置を取得する
     * 
     * @return {Jeeel.Object.Point} 親要素からの相対位置
     */
    getRelativePosition: function () {
        var el = this._element;
        var pos = new Jeeel.Object.Point(el.offsetLeft, el.offsetTop);
        
        var body = this._doc.getBody();
        
        el = el.parentNode;
        
        if (el && el !== body) {
            pos.x -= el.scrollLeft;
            pos.y -= el.scrollTop;
        }
        
        return pos;
    },

    /**
     * innerHtmlを取得する
     * 
     * @return {String} Html文字列
     */
    getHtml: function () {
        return this._element.innerHTML;
    },

    /**
     * innerHtmlの設定を行う
     *
     * @param {String} html Html文字列
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setHtml: function (html) {
        this._element.innerHTML = html;

        return this;
    },

    /**
     * Textを取得する<br />
     * TextNodeを全て結合して取り出す
     *
     * @return {String} Html文字列
     */
    getText: function () {},

    /**
     * Textの設定を行う<br />
     * innerHtml内にエスケープした文字列を代入する
     *
     * @param {String} text 設定文字列
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setText: function (text) {
        this._element.innerHTML = Jeeel.String.escapeHtml(text, true);

        return this;
    },
    
    /**
     * このElementの次のElementを取得する
     *
     * @param {Integer} [nextCount] いくつ次を参照するか
     * @return {Element} 取得したElement
     */
    getNextNode: function (nextCount) {
        if ( ! Jeeel.Type.isInteger(nextCount)) {
            nextCount = 1;
        } else if (nextCount < 0) {
            return null;
        }

        var children = this._element.parentNode.children;

        for (var i = 0, l = children.length - nextCount; i < l; i++) {
            if (children[i] === this._element){
                return children[i + nextCount];
            }
        }

        return null;
    },

    /**
     * このElementの前のElementを取得する
     *
     * @param {Integer} [prevCount] いくつ前を参照するか
     * @return {Element} 取得したElement
     */
    getPrevNode: function (prevCount) {
        if ( ! Jeeel.Type.isInteger(prevCount)) {
            prevCount = 1;
        } else if (prevCount < 0) {
            return null;
        }

        var children = this._element.parentNode.children;

        for (var i = prevCount, l = children.length; i < l; i++) {
            if (children[i] === this._element) {
                return children[i - prevCount];
            }
        }

        return null;
    },
    
    /**
     * このElementの親のElementを取得する
     *
     * @param {Integer} [parentCount] いくつ上階層の親を参照するか
     * @return {Element} 取得したElement
     */
    getParentNode: function (parentCount) {
        if ( ! Jeeel.Type.isInteger(parentCount)) {
            parentCount = 1;
        } else if (parentCount < 0) {
            return null;
        }
        
        var parent = this._element;

        while (parent && parentCount--) {
            parent = parent.parentNode;
        }

        return parent;
    },

    /**
     * このElementの子リストを取得する
     *
     * @return {Element[]} 取得したElementリスト
     */
    getChildren: function () {
        var children = this._element.children;
        var res = [];

        for (var i = children.length; i--;) {
            res[i] = children[i];
        }

        return res;
    },
    
    /**
     * このElementの階層の深さを返す<br />
     * documentが最上層となり数値0を返す<br />
     * なおdom上に存在しないElementについてはこの限りではない
     * 
     * @return {Integer} 階層の深さレベル
     */
    getHierarchy: function () {
        var h = 0;
        var parent = this._element.parentNode;
        
        while(parent) {
            parent = parent.parentNode;
            h++;
        }
        
        return h;
    },

    /**
     * このElementの前に追加Elementを挿入する
     *
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertBefore: function (addElement) {
        this._element.parentNode.insertBefore(addElement, this._element);
        return this;
    },

    /**
     * このElementの後に追加Elementを挿入する
     *
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertAfter: function (addElement) {
        var next = this.getNextNode();
        this._element.parentNode.insertBefore(addElement, next);
        return this;
    },

    /**
     * このElementの一番上に追加Elementを挿入する
     *
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertTop: function (addElement) {
        var first = this._element.firstChild;

        if (first) {
            this._element.insertBefore(addElement, first);
        } else {
            this._element.appendChild(addElement);
        }
        
        return this;
    },

    /**
     * このElementの一番下に追加Elementを挿入する
     *
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertBottom: function (addElement) {
        this._element.appendChild(addElement);
        return this;
    },

    /**
     * このElementの指定した子Elementの前に追加Elementを挿入する
     *
     * @param {Element} child このElement内の子Element
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertChildBefore: function (child, addElement) {
        this._element.insertBefore(child, addElement);
        return this;
    },

    /**
     * このElementの指定した子Elementの後に追加Elementを挿入する
     *
     * @param {Element} child このElement内の子Element
     * @param {Element} addElement 追加Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    insertChildAfter: function (child, addElement) {
        var next = child.nextSibling;
        this._element.insertBefore(addElement, next);
        return this;
    },

    /**
     * このElementの指定したElementで囲う<br />
     * ただしElementをコピーされる
     *
     * @param {String|Element} wrap 囲みElement
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @ignore
     */
    wrapSelf: function (wrap) {
        if (Jeeel.Type.isElement(wrap)) {
            wrap = wrap.cloneNode(true);
        } else {
            wrap = this._doc.createElementList(wrap)[0];
        }

        var parent = this._element.parentNode;

        parent.replaceChild(wrap, this._element);
        wrap.appendChild(this._element);

        return this;
    },
    
    /**
     * このElementの子リストを指定要素で囲む<br />
     * 但し、要素を渡した場合その要素はコピーされる
     * 
     * @param {String|Element} wrap 子リストを囲むHTML文字列もしくはHTML要素
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @ignore
     */
    wrapInner: function (wrap) {
        if (Jeeel.Type.isElement(wrap)) {
            wrap = wrap.cloneNode(true);
        } else {
            wrap = this._doc.createElementList(wrap)[0];
        }
        
        if ( ! wrap) {
            return this;
        }
        
        var wrapOwner = wrap;
        
        while (wrap.firstChild) {
            wrap = wrap.firstChild;
        }
        
        var flag = this._doc.createDocumentFragment();
        
        while(this._element.firstChild) {
            flag.appendChild(this._element.firstChild);
        }
        
        wrap.appendChild(flag);
        
        this._element.appendChild(wrapOwner);
        
        return this;
    },

    /**
     * このElementの子供に追加する
     *
     * @param {Element|Element[]} child 追加子Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    appendChild: function (child) {
        if (Jeeel.Type.isArray(child)) {
            var tmp = this._doc.createDocumentFragment();
            
            for (var i = 0, l = child.length; i < l; i++) {
                tmp.appendChild(child[i]);
            }
            
            child = tmp;
        }

        this._element.appendChild(child);
        
        return this;
    },

    /**
     * このElementの子供を削除する
     *
     * @param {Element|Element[]} child 削除子Element
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    removeChild: function (child) {
        if ( ! Jeeel.Type.isArray(child)) {
            child = [child];
        }

        for (var i = child.length; i--;) {
            this._element.removeChild(child[i]);
        }

        return this;
    },
    
    /**
     * このElementの子供を全て削除する
     *
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    clearChildNodes: function () {
        var f, elm = this._element;

        while (f = elm.firstChild) {
            elm.removeChild(f);
        }

        return this;
    },

    /**
     * このElementの子リストにforeachをかける<br />
     * 但し対象は通常Nodeに限る(TextNode等は除外)<br />
     * 詳しくはJeeel.Hash.forEach参照
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Hash.forEach
     */
    each: function (eachMethod, thisArg) {
        Jeeel.Hash.forEach(this._element.children, eachMethod, thisArg);
        
        return this;
    },

    /**
     * このElementを複製する
     *
     * @param {Boolean} [isDeep] ディープコピーを行うかどうか
     * @return {Element} 複製したElement
     */
    clone: function (isDeep) {
        return this._element.cloneNode(isDeep);
    },
    
    /**
     * このElementを表示する
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    show: function (speed, easing, complete, thisArg) {
        this._style.show(speed, easing, complete && [complete, thisArg || this]);
        
        return this;
    },

    /**
     * このElementを隠す
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    hide: function (speed, easing, complete, thisArg) {
        this._style.hide(speed, easing, complete && [complete, thisArg || this]);
        
        return this;
    },

    /**
     * このElementの表示状態を切り替える
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    toggle: function (speed, easing, complete, thisArg) {
        this._style.toggle(speed, easing, complete && [complete, thisArg || this]);
        
        return this;
    },
    
    /**
     * フェードインを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    fadeIn: function (speed, easing, complete, thisArg) {
        this._style.fadeIn(speed, easing, complete && [complete, thisArg || this]);
        
        return this;
    },
    
    /**
     * フェードアウトを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    fadeOut: function (speed, easing, complete, thisArg) {
        this._style.fadeOut(speed, easing, complete && [complete, thisArg || this]);
        
        return this;
    },
    
    /**
     * フェードトグルを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    fadeToggle: function (speed, easing, complete, thisArg) {
        this._style.fadeToggle(speed, easing, complete && [complete, thisArg || this]);
        
        return this;
    },
    
    /**
     * スライドアップを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    slideUp: function (speed, easing, complete, thisArg) {
        this._style.slideUp(speed, easing, complete && [complete, thisArg || this]);
        
        return this;
    },
    
    /**
     * スライドダウンを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    slideDown: function (speed, easing, complete, thisArg) {
        this._style.slideDown(speed, easing, complete && [complete, thisArg || this]);
        
        return this;
    },
    
    /**
     * スライドトグルを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    slideToggle: function (speed, easing, complete, thisArg) {
        this._style.slideToggle(speed, easing, complete && [complete, thisArg || this]);
        
        return this;
    },
    
    /**
     * アニメーションを開始する
     * 
     * @param {Hash} params アニメーション変化の数値
     * @param {Integer|String} [duration] アニメーションが完結するまでの時間(ミリ秒)か定義文字列(fast, slow, defaultがある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーション終了時に呼ばれるコールバック
     * @param {Function} [step] アニメーション更新時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    animate: function (params, duration, easing, complete, step, thisArg) {
      
        // スタイルのanimateのオーバーロードを使用させない
        if (params instanceof Jeeel.Dom.Style.Animation) {
            return this;
        } else if (duration && Jeeel.Type.isHash(duration)) {
            return this;
        }
        
        this._style.animate(params, duration, easing, complete && [complete, thisArg || this], step && [step, thisArg || this]);
        
        return this;
    },
    
    /**
     * アニメーション管理インスタンスを取得する
     * 
     * @return {Jeeel.Dom.Element.Animator} 管理インスタンス
     */
    getAnimator: function () {
        return new this.constructor.Animator(this._style, this);
    },

    /**
     * このElementを移動可能にする
     * 
     * @param {Element|Element[]} dispatchTargets このElement上でマウスを押し込むと移動を始める(デフォルトはこのElement)
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    movable: function (dispatchTargets) {
        var i, l, cache, index = this._searchMoveCacheIndex();

        if ( ! dispatchTargets) {
            dispatchTargets = [this._element];
        } else if ( ! Jeeel.Type.isArray(dispatchTargets)) {
            dispatchTargets = [dispatchTargets];
        }

        if (index >= 0) {
            cache = this._moveCache[index];

            for (i = 0, l = cache.dispatch.length; i < l; i++) {
                Jeeel.Dom.Event.removeEventListener(cache.dispatch[i], Jeeel.Dom.Event.Type.MOUSE_DOWN, cache.down, this);
            }

            for (i = 0, l = dispatchTargets.length; i < l; i++) {
                Jeeel.Dom.Event.addEventListener(dispatchTargets[i], Jeeel.Dom.Event.Type.MOUSE_DOWN, cache.down, this);
            }

            cache.dispatch = dispatchTargets;

            return this;
        }

        cache = this._moveCache[this._moveCache.length] = {
            dispatch: dispatchTargets,
            target: this._element,
            position: '',
            point: null,
            down: function (ev) {
                ev.stop();

                this._doc.addEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, cache.move, this)
                          .addEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, cache.up, this);

                cache.point = ev.getRelativeMousePoint(this._element);
            },
            move: function (ev) {
                ev.stop();

                var p = ev.mousePoint;

                var top  = p.y - cache.point.y;
                var left = p.x - cache.point.x;

                this.setStyleList({
                    top: top + 'px',
                    left: left + 'px'
                });
            },
            up: function (ev) {
                ev.stop();

                this._doc.removeEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, cache.move)
                          .removeEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, cache.up);
            }
        };

        for (i = dispatchTargets.length; i--;) {
            Jeeel.Dom.Event.addEventListener(dispatchTargets[i], Jeeel.Dom.Event.Type.MOUSE_DOWN, cache.down, this);
        }

        cache.position = this.getStyle('position');

        this.setStyle('position', 'absolute');

        return this;
    },
    
    /**
     * このElementを移動不可能にする
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    immovable: function () {
        var index = this._searchMoveCacheIndex();

        if (index < 0) {
            return this;
        }

        var cache = this._moveCache[index];

        for (var i = cache.dispatch.length; i--;) {
            Jeeel.Dom.Event.removeEventListener(cache.dispatch[i], Jeeel.Dom.Event.Type.MOUSE_DOWN, cache.down, this);
        }

        this.setStyle('position', cache.position);

        this._moveCache.splice(index, 1);

        return this;
    },
    
    /**
     * IE6のためのバグ回避を簡単に行うメソッド<br />
     * ダイアログの様なpositionを変えて、selectタグの下にもぐりこんでしまう場合に指定する
     * 
     * @param {Hash} [style] BGのiframeのスタイルをカスタムに指定するための値(基本は指定しない)
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    setShim: function (style) {},
    
    /**
     * このElementを指定座標に移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    shiftTo: function (x, y) {
        this._style.shiftTo(x, y);
        
        return this;
    },
    
    /**
     * このElementのスクロールを行う
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @ignore
     */
    scroll: function (x, y) {
        this._element.scrollLeft = x;
        this._element.scrollTop = y;
        
        return this;
    },
    
    /**
     * このElementを取り除く
     *
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    remove: function () {
        if ( ! this._element.parentNode) {
            return this;
        }
        
        var parent = this._element.parentNode;
        parent.removeChild(this._element);
        
        return this;
    },

    /**
     * このElementの位置を任意のElementに置き換える
     *
     * @param {Element} replaceElement 置き換えElement
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    replace: function (replaceElement) {
        var parent = this._element.parentNode;
        
        parent.replaceChild(replaceElement, this._element);
        
        return this;
    },
    
    /**
     * このElementを上に移動する
     *
     * @param {Integer} [upCount] 上に動かす距離
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    up: function (upCount) {
        var prev = this.getPrevNode(upCount);

        if (prev) {
            this._element.parentNode.insertBefore(this._element, prev);
        }
        
        return this;
    },

    /**
     * このElementを下に移動する
     *
     * @param {Integer} [downCount] 下に動かす距離
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    down: function (downCount) {
        if (Jeeel.Type.isInteger(downCount)) {
            downCount++;
        } else {
            downCount = 2;
        }

        var next = this.getNextNode(downCount);
        
        this._element.parentNode.insertBefore(this._element, next);
        
        return this;
    },

    /**
     * このElementとDom上のEleentの位置を入れ替える<br />
     * replaceメソッドはDom上のElementとDom外のElementの交換
     *
     * @param {Element} swapElement 交換対象のElement(同じDom上にあり階層関係に不一致がないことが条件)
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    swap: function (swapElement) {
        var thisParent = this._element.parentNode;
        var swapParent = swapElement.parentNode;
        var thisNext = this.getNextNode();
        var swapNext = Jeeel.Dom.Element.create(swapElement).getNextNode();

        if (thisParent) {
            thisParent.insertBefore(swapElement, thisNext);
        }

        if (swapParent) {
            swapParent.insertBefore(this._element, swapNext);
        }
        
        return this;
    },
    
    /**
     * このElementを一番上に移動する
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    upTop: function () {
        var first = this._element.parentNode.firstChild;

        this._element.parentNode.insertBefore(this._element, first);
        
        return this;
    },

    /**
     * このElementを一番下に移動する
     * 
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    downBottom: function () {
        this._element.parentNode.insertBefore(this._element, null);
        
        return this;
    },

    /**
     * このElementにイベントを追加する<br />
     * 引数はJeeel.Dom.Event, このElementになる
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    addEventListener: function (type, listener, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        Jeeel.Dom.Event.addEventListener(this._element, type, listener, thisArg);
        
        return this;
    },

    /**
     * イベントの削除を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録イベントメソッド
     * @return {Jeeel.Dom.Element} 自インスタンス
     */
    removeEventListener: function (type, listener) {
        Jeeel.Dom.Event.removeEventListener(this._element, type, listener);

        return this;
    },
    
    /**
     * このElementに設定されているイベントを任意のタイミングで実行する
     *
     * @param {String} type イベントタイプ
     * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
     * @return {Jeeel.Dom.Element} 自インスタンス
     * @ignore 未完成
     */
    dispatchEvent: function (type, option) {
        Jeeel.Dom.Event.dispatchEvent(this._element, type, option);
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Element} element 対象Element
     * @constructor
     */
    constructor: Jeeel.Dom.Element,
    
    /**
     * 移動のためのキャッシュのインデックスを取得する
     * 
     * @return {Integer} インデックス
     */
    _searchMoveCacheIndex: function () {
        for (var i = this._moveCache.length; i--;) {
            if (this._element === this._moveCache[i].target) {
                return i;
            }
        }

        return -1;
    },
    
    /**
     * @ignore
     */
    _init: function () {
        if ( ! Jeeel._doc) {
            delete this._init;
            return;
        }
        
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var txt = Jeeel.Dom.Node.TEXT_NODE;
        var div = Jeeel._elm;
        
        var _first, _option, _rect;
        var slice = Array.prototype.slice;
        
        /**
         * @ignore
         */
        function _searchRange(res, target) {
            var trect = Jeeel.Dom.Element.create(target).getRect();

            if ( ! _first && _option(_rect, trect)) {
                res[res.length] = target;
            }
            
            _first = false;

            var child = target.firstChild;

            while(child) {

                if (child.nodeType === nodeType) {
                    _searchRange(res, child);
                }

                child = child.nextSibling;
            }
        }
        
        /**
         * @ignore
         */
        function _searchTxt(res, target) {
            if (target.nodeType === txt) {
                res[res.length] = target.data;
            }

            var child = target.firstChild;

            while(child) {

                _searchTxt(res, child);

                child = child.nextSibling;
            }
        }
        
        /**
         * @ignore
         */
        this.searchElementsByRange = function (rect, option) {
            if ( ! rect) {
                return [];
            }

            if ( ! option) {
                option = Jeeel.Dom.SearchOption.RANGE_OVERLAY;
            }
            
            _rect = rect;
            _option = option;

            var res = [];
            
            _searchRange(res, this._element);

            return res;
        };
        
        if (div.classList) {
            
            /**
             * @ignore
             */
            this.getClassNames = function () {
                return slice.call(this._element.classList);
            };
            
            /**
             * @ignore
             */
            this.addClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.add(className[i]);
                }
                
                return this;
            };
            
            /**
             * @ignore
             */
            this.removeClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.remove(className[i]);
                }

                return this;
            };
            
            /**
             * @ignore
             */
            this.toggleClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.toggle(className[i]);
                }

                return this;
            };
            
            /**
             * @ignore
             */
            this.hasClassName = function (className) {
                return this._element.classList.contains(className);
            };
            
        } else {
          
            /**
             * @ignore
             */
            this.getClassNames = function () {
                return this._element.className.replace(/\s+/g, ' ').split(' ');
            };
            
            /**
             * @ignore
             */
            this.addClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var ec = this._element.className;
                
                for (var i = 0, l = className.length; i < l; i++) {
                    if ( ! className[i]) {
                        continue;
                    } else if (ec === className[i] || ec.search('\\b' + className[i] + '\\b') !== -1) {
                        continue;
                    }
                    
                    ec += (ec ? ' ' : '') + className[i];
                }
                
                this._element.className = ec;
                
                return this;
            };
            
            /**
             * @ignore
             */
            this.removeClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var ec = this._element.className;
                
                for (var i = 0, l = className.length; i < l; i++) {
                    if ( ! className[i]) {
                        continue;
                    }
                    
                    ec = ec.replace(new RegExp('\\b' + className[i] + '\\b\\s*','g'),'');
                }
                
                this._element.className = ec.replace(/\s+$/g, '');
                
                return this;
            };
            
            /**
             * @ignore
             */
            this.toggleClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }

                var classNames = this.getClassNames();

                for (var i = 0, l = className.length; i < l; i++) {
                    if (Jeeel.Hash.inHash(className[i], classNames, true)) {
                        this.removeClassName(className[i]);
                    } else {
                        this.addClassName(className[i]);
                    }
                }

                return this;
            };
            
            /**
             * @ignore
             */
            this.hasClassName = function (className) {
                if ( ! className) {
                    return false;
                }
                
                var ec = this._element.className;
                
                return ec === className
                    || ec.search('\\b' + className + '\\b') !== -1;
            };
        }
        
        if (div.dataset) {
          
            /**
             * @ignore
             */
            this.getData = function (key) {
                key = Jeeel.String.toCamelCase(key);
                
                if (key in this._element.dataset) {
                    return this._element.dataset[key];
                }
                
                return null;
            };
            
            /**
             * @ignore
             */
            this.setData = function (key, data) {
                key = Jeeel.String.toCamelCase(key);
                
                this._element.dataset[key] = data;
                
                return this;
            };
        } else {
            
            /**
             * @ignore
             */
            this.getData = function (key) {
                key = 'data-' + Jeeel.String.toHyphenation(key);
                
                return this._element.getAttribute(key);
            };
            
            /**
             * @ignore
             */
            this.setData = function (key, data) {
                key = 'data-' + Jeeel.String.toHyphenation(key);
                data = '' + data;
                
                this._element.setAttribute(key, data);
                
                return this;
            };
        }
        
        /**
         * @ignore
         */
        this.getText = function () {
            var res = [];

            _searchTxt(res, this._element);

            return res.join('');
        };
        
        if (Jeeel.UserAgent.isInternetExplorer(6)) {
          
            /**
             * @ignore
             */
            this.setShim = function (style) {
                var child = this._element.firstChild;
                var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;

                while(child) {
                    if (child.nodeType === nodeType) {
                        if (child.tagName.toUpperCase() === 'IFRAME' && child.className === 'jeeel-bgiframe') {
                            return this;
                        }
                    }

                    child = child.nextSibling;
                }

                var elm = this._doc.createElement('iframe');
                var domStyle = elm.style;
                
                elm.className = 'jeeel-bgiframe';
                elm.frameBorder = '0';
                elm.tabIndex = -1;
                elm.src = style.src;
                
                style = Jeeel.Hash.merge({
                    top     : 'auto',
                    left    : 'auto',
                    width   : 'auto',
                    height  : 'auto',
                    opacity : false,
                    src     : 'javascript: void(0);'
                }, style || {});

                var prop = function (val) {
                    return Jeeel.Type.isNumber(val) && (val + 'px') || val;
                };
                
                if (style.top === 'auto') {
                    domStyle.top = 'expression(((parseInt(this.parentNode.currentStyle.borderTopWidth) || 0) * -1) + \'px\')';
                } else {
                    domStyle.top = prop(style.top);
                }
                
                if (style.left === 'auto') {
                    domStyle.left = 'expression(((parseInt(this.parentNode.currentStyle.borderLeftWidth) || 0) * -1) + \'px\')';
                } else {
                    domStyle.left = prop(style.left);
                }
                
                if (style.width === 'auto') {
                    domStyle.width = '100%';
                } else {
                    domStyle.width = prop(style.width);
                }
                
                if (style.height === 'auto') {
                    domStyle.height = '100%';
                } else {
                    domStyle.height = prop(style.height);
                }
                
                var css = 'z-index: -1; zoom: 1; position: absolute; display: block; ';
                
                if (style.opacity === false) {
                    css += 'filter: alpha(opacity=\'0\');';
                }
                
                domStyle.cssText = css;

                return this.insertTop(elm);
            };
        } else {
            /**
             * @ignore
             */
            this.setShim = Jeeel.Function.Template.RETURN_THIS;
        }
 
        delete this._init;
    }
};

Jeeel.Dom.Element.prototype._init();

Jeeel.file.Jeeel.Dom.Element = ['Animator', 'Abstract', 'Textarea'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Element, Jeeel.file.Jeeel.Dom.Element);

/**
 * コンストラクタ
 * 
 * @class Elementラッパーからメソッドをチェインしてアニメーションを実行・管理できるクラス
 * @param {Jeeel.Dom.Style} style スタイル
 * @param {Jeeel.Dom.Element} returnInstance アニメーションを実行した後に返す戻り値
 */
Jeeel.Dom.Element.Animator = function (style, returnInstance) {
    this._style = style;
    this._returnInstance = returnInstance;
    this._params = {};
};

Jeeel.Dom.Element.Animator.prototype = {
    
    /**
     * スタイルインスタンス
     * 
     * @type Jeeel.Dom.Style
     * @private
     */
    _style: null,
    
    /**
     * animate実行時の戻り値
     * 
     * @type Jeeel.Dom.Element
     * @private
     */
    _returnInstance: null,
    
    /**
     * アニメーションで変化させたいスタイルの名前と値のリスト
     * 
     * @type Hash
     * @private
     */
    _params: {},
  
    /**
     * アニメーションをどのくらいかけて行うかの数値(ミリ秒)
     * 
     * @type Integer
     * @private
     */
    _duration: null,
    
    /**
     * イージング関数
     * 
     * @type Function
     * @private
     */
    _easing: null, 
    
    /**
     * アニメーション終了時に呼ばれるコールバック
     * 
     * @type Function
     * @private
     */
    _complete: null,
    
    /**
     * アニメーション更新時に呼ばれるコールバック
     * 
     * @type Function
     * @private
     */
    _step: null,
    
    /**
     * キューの仕様の有無
     * 
     * @type Boolean
     * @private
     */
    _enqueue: true,
    
    /**
     * アニメーションの対象のスタイルを設定する
     * 
     * @param {String} key スタイル名
     * @param {String|Number|Hash} param スタイルの最終変化値<br />
     *                                    100px等の絶対値の他に、+=や-=を前に付けた相対値やtoggle、show、hide等の特殊値がある(特殊値はdisplay, width, height, opacity, margin系, padding系にしか効かない)<br />
     *                                    また配列や連想配列にすることでスタイルそれぞれにイージング関数を適用できる<br />
     *                                    [value, easing]とするか、{value: value, easing: easing}とすることが出来る
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    set: function (key, param) {
        this._params[key] = param;
        
        return this;
    },
    
    /**
     * アニメーションの対象のスタイルを全て設定する
     * 
     * @param {Hash} params アニメーション対象のスタイル全て
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    setAll: function (params) {
      
        for (var key in params) {
            this._params[key] = params[key];
        }
        
        return this;
    },
    
    /**
     * アニメーションの対象のスタイルを全て破棄する
     * 
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    clear: function () {
        this._params = {};
        
        return this;
    },
  
    /**
     * アニメーション完了時間を設定する
     * 
     * @param {Integer|String} duration 完了時間もしくはその定数
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    setDuration: function (duration) {
        this._duration = duration;
        
        return this;
    },
    
    /**
     * イージング関数を設定する
     * 
     * @param {Function|String} easing イージング関数
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    setEasing: function (easing) {
        this._easing = easing;
        
        return this;
    },
    
    /**
     * アニメーション終了時のコールバックを設定する
     * 
     * @param {Function} callback アニメーション終了時のコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはオーナーインスタンスになる)
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    setCompleteCallback: function (callback, thisArg) {
        if (callback) {
            this._complete = [callback, thisArg || this._returnInstance];
        } else {
            this._complete = null;
        }
        
        return this;
    },
    
    /**
     * アニメーション更新時のコールバックを設定する
     * 
     * @param {Function} callback アニメーション更新時のコールバック(初期値0、最終値1の時のイージングが渡される)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはオーナーインスタンスになる)
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    setStepCallback: function (callback, thisArg) {
        if (callback) {
            this._step = [callback, thisArg || this._returnInstance];
        } else {
            this._step = null;
        }
        
        return this;
    },
    
    /**
     * アニメーション実行時にキューを使用するかどうかを設定する
     * 
     * @param {Boolean} useQueue キューを使用するかどうか
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    useQueue: function (useQueue) {
        this._enqueue = !!useQueue;
        
        return this;
    },

    /**
     * アニメーションキューの実行を遅延させる
     * 
     * @param {Integer} delayTime 遅延時間(ミリ秒)
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    delay: function (delayTime) {
        this._style.delay(delayTime);
        
        return this;
    },
    
    /**
     * 現在実行中のアニメーションを停止させ、次のアニメーションを実行する
     * 
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    stop: function () {
        this._style.stop();
        
        return this;
    },
    
    /**
     * 現在実行中のアニメーションを終了させ、次のアニメーションを実行する
     * 
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    end: function () {
        this._style.end();
        
        return this;
    },
    
    /**
     * 現在待機中のアニメーションのキューを破棄する
     * 
     * @return {Jeeel.Dom.Element.Animator} 自インスタンス
     */
    clearQueue: function () {
        this._style.clear();
        
        return this;
    },
    
    /**
     * アニメーションを実行する
     * 
     * @return {Jeeel.Dom.Element} オーナーインスタンス
     */
    animate: function () {
        this._style.animate(this._params, {
            duration: this._duration, 
            easing: this._easing, 
            complete: this._complete, 
            step: this._step,
            enqueue: this._enqueue
        });
        
        return this._returnInstance;
    },
    
    /**
     * アニメーションが実行中かどうかを返す
     * 
     * @return {Boolean} 実行中かどうか
     */
    isAnimated: function () {
        return Jeeel.Hash.inHash(this._returnInstance.getElement(), Jeeel.Dom.Style.Animation.animated, true);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Element.Animator
};
/**
 * コンストラクタ
 * 
 * @abstractClass Elementクラスの抽象クラス
 * @ignore 未完成
 */
Jeeel.Dom.Element.Abstract = function () {};

Jeeel.Dom.Element.Abstract.prototype = {

    /**
     * 対象のElement
     * 
     * @type Element
     * @protected
     */
    _element: null,

    /**
     * 内部で使用しているHTML要素を取得する
     *
     * @return {Element} HTML要素
     */
    getElement: function () {
        return this._element;
    },

    /**
     * IDを取得する
     *
     * @return {String} ID
     */
    getId: function () {
        return this._element.id;
    },

    /**
     * IDを設定する
     *
     * @param {String} id ID
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    setId: function (id) {
        this._element.id = id;

        return this;
    },

    /**
     * このElement内のクラス名を全て取得する
     *
     * @return {String[]} クラス名のリスト
     */
    getClassNames: function () {},

    /**
     * クラス名を追加する
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    addClassName: function (className) {},

    /**
     * クラス名の削除を行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    removeClassName: function (className) {},

    /**
     * クラス名が存在していたら削除し、存在していなかったら追加を行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    toggleClassName: function (className) {},

    /**
     * クラス名を消去する
     *
     * @return {Jeeel.Dom.Element.Abstract} 自インスタンス
     */
    clearClassName: function () {
        this._element.className = '';

        return this;
    },

    /**
     * 指定したクラス名を保持しているかどうかを返す
     *
     * @param {String} className クラス名
     * @return {Boolean} クラス名を保持していたかどうか
     */
    hasClassName: function (className) {},

    /**
     * Nameを取得する
     *
     * @return {String} Name
     */
    getName: function () {
        return this._element.name;
    },

    /**
     * Nameを設定する
     *
     * @param {String} name Name
     * @return {this} 自インスタンス
     */
    setName: function (name) {
        this._element.name = name;

        return this;
    },

    /**
     * TagNameを取得する
     *
     * @return {String} TagName
     */
    getTagName: function () {
        return this._element.tagName;
    },

    /**
     * スタイルを取得する
     *
     * @return {CSSStyleDeclaration} スタイル
     */
    getStyle: function () {
        return this._element.style;
    },

    /**
     * イベントリスナーをセットする
     *
     * @param {String} type イベントの種類(Jeeel.Dom.Event.Type参照)
     * @param {Function} listener 登録リスナー
     * @return {this} 自インスタンス
     */
    setEvent: function (type, listener) {
        this._element['on' + type] = listener;

        return this;
    },
    
    _init: function () {
      
        if ( ! Jeeel._doc) {
            delete this._init;
            return;
        }
        
        var div = (Jeeel.Document || Jeeel._doc).createElement('div');
        var slice = Array.prototype.slice;
        
        var self = this;
        
        if (div.classList) {
            self.getClassNames = function () {
                return slice.call(this._element.classList);
            };
            
            self.addClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.add(className[i]);
                }
                
                return this;
            };
            
            self.removeClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.remove(className[i]);
                }

                return this;
            };
            
            self.toggleClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                var classList = this._element.classList;
                
                for (var i = className.length; i--;) {
                    classList.toggle(className[i]);
                }

                return this;
            };
            
            self.hasClassName = function (className) {
                return this._element.classList.contains(className);
            };
            
        } else {
            self.getClassNames = function () {
                return this._element.className.split(' ');
            };
            
            self.addClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var ec = this._element.className;
                
                for (var i = 0, l = className.length; i < l; i++) {
                    if ( ! className[i]) {
                        continue;
                    } else if (ec === className[i] || ec.search('\\b' + className[i] + '\\b') !== -1) {
                        continue;
                    }
                    
                    ec += (ec ? ' ' : '') + className[i];
                }
                
                this._element.className = ec;
                
                return this;
            };
            
            self.removeClassName = function (className) {
                if ( ! className) {
                    return this;
                }
                
                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }
                
                var ec = this._element.className;
                
                for (var i = 0, l = className.length; i < l; i++) {
                    if ( ! className[i]) {
                        continue;
                    }
                    
                    ec = ec.replace(new RegExp('\\b' + className[i] + '\\b\\s*','g'),'');
                }
                
                this._element.className = ec.replace(/\s+$/g, '');
                
                return this;
            };
            
            self.toggleClassName = function (className) {
                if ( ! className) {
                    return this;
                }

                if ( ! Jeeel.Type.isArray(className)) {
                    className = [className];
                }

                var classNames = this.getClassNames();

                for (var i = 0, l = className.length; i < l; i++) {
                    if (Jeeel.Hash.inHash(className[i], classNames, true)) {
                        this.removeClassName(className[i]);
                    } else {
                        this.addClassName(className[i]);
                    }
                }

                return this;
            };
            
            self.hasClassName = function (className) {
                if ( ! className) {
                    return false;
                }
                
                var ec = this._element.className;
                
                return ec === className
                    || ec.search('\\b' + className + '\\b') !== -1;
            };
        }
        
        delete this._init;
    }
};

Jeeel.Dom.Element.Abstract.prototype._init();

/**
 * コンストラクタ
 *
 * @class テキストエリアを使いやすくするラッパークラス
 * @augments Jeeel.Dom.Element.Abstract
 * @param {Element} textarea テキストエリア
 * @ignore 未完成
 */
Jeeel.Dom.Element.Textarea = function (textarea) {
    Jeeel.Dom.Element.Abstract.call(this);
    
    this._element = textarea;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Element} textarea テキストエリア
 * @return {Jeeel.Dom.Element.Textarea} 作成したインスタンス
 */
Jeeel.Dom.Element.Textarea.create = function (textarea) {
    return new this(textarea);
};

Jeeel.Dom.Element.Textarea.prototype = {
  
    /**
     * テキストエリア内の文字列を得る
     *
     * @return {String} 取得した文字列
     */
    getText: function () {
        return this._element.value;
    },

    /**
     * テキストエリア内の文字列を設定する
     *
     * @param {String} text セットする文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    setText: function (text) {
        this._element.value = text;

        return this;
    },

    /**
     * テキストエリア内の文字列を前方検索する
     *
     * @param {String} search 検索文字列
     * @param {Integer} [from] 検索開始位置
     * @return {Integer} 検索結果(見つかった文字列の最初の位置見つからない場合は-1)
     */
    indexOf: function (search, from) {
        return this.getText().indexOf(search, from);
    },

    /**
     * テキストエリア内の文字列を後方検索する
     *
     * @param {String} search 検索文字列
     * @param {Integer} [from] 検索開始位置
     * @return {Integer} 検索結果(見つかった文字列の最初の位置見つからない場合は-1)
     */
    lastIndexOf: function (search, from) {
        return this.getText().lastIndexOf(search, from);
    },

    /**
     * テキストエリア内の文字列を置き換えたものを得る
     *
     * @param {RegExp} regexp 検索表現
     * @param {String} text 置き換える文字列
     * @return {String} 置き換え後の文字列
     */
    replace: function (regexp, text) {
        return this.getText().replace(regexp, text);
    },

    /**
     * テキストエリアの選択している開始位置を取得する
     *
     * @return {Integer} 選択している開始位置
     */
    getSelectionStart: function () {
        var start;

        if (Jeeel.UserAgent.isInternetExplorer()) {
            start = this._getIeSelection().start;
        } else {
            start = this._element.selectionStart;
        }

        return start;
    },

    /**
     * テキストエリアの選択している開始位置を設定する
     *
     * @param {Integer} start 設定開始位置
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    setSelectionStart: function (start) {
        this._element.selectionStart = start;

        return this;
    },

    /**
     * テキストエリアの選択している終了位置を取得する
     *
     * @return {Integer} 選択している終了位置
     */
    getSelectionEnd: function () {
        var end;

        if (Jeeel.UserAgent.isInternetExplorer()) {
            end = this._getIeSelection().end;
        } else {
            end = this._element.selectionEnd;
        }

        return end;
    },

    /**
     * テキストエリアの選択している終了位置を設定する
     *
     * @param {Integer} end 設定終了位置
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    setSelectionEnd: function (end) {
        this._element.selectionEnd = end;

        return this;
    },

    /**
     * テキストエリアの選択している終了位置を取得する
     *
     * @return {Integer} 選択している終了位置
     */
    getSelectionLength: function () {
        return this.getSelectionEnd() - this.getSelectionStart();
    },

    /**
     * テキストエリアの選択文字列を取得する
     *
     * @return {String} 選択文字列
     */
    getSelectedText: function () {
        var start = this.getSelectionStart();
        var end   = this.getSelectionEnd();

        var baseText = this.getText();

        return baseText.substring(start, end);
    },

    /**
     * テキストエリアの選択文字列を設定する
     *
     * @param {String} text 選択文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    setSelectedText: function (text) {
        var start = this.getSelectionStart();
        var end   = this.getSelectionEnd();

        this.replaceTo(start, end, text);

        this.setSelectionStart(start + text.length);
        this.setSelectionEnd(start + text.length);
    },

    /**
     * 指定した位置の文字列を指定文字列で置き換える
     *
     * @param {Integer} start 開始位置
     * @param {Integer} end 終了位置
     * @param {String} text 置き換える文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    replaceTo: function (start, end, text) {
        var baseText = this.getText();
        var length   = baseText.length;

        var aboveTxt = baseText.substr(0, start);
        var postTxt  = baseText.substr(end, length);

        this._element.value = aboveTxt + text + postTxt;

        return this;
    },

    /**
     * 現在選択している文字列の開始位置、または現在のカーソル位置に文字列を挿入する
     *
     * @param {String} text 挿入文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    insert: function (text) {
        var index = this.getSelectionStart();

        return this.insertTo(index, text);
    },

    /**
     * 指定した位置に文字列を挿入する
     *
     * @param {Integer} index 挿入位置
     * @param {String} text 挿入文字列
     * @return {Jeeel.Dom.Element.Textarea} 自インスタンス
     */
    insertTo: function (index, text) {
        var baseText = this.getText();
        var length   = baseText.length;

        var aboveTxt = baseText.substr(0, index);
        var postTxt  = baseText.substr(index, length);

        this._element.value = aboveTxt + text + postTxt;

        return this;
    },

    _getIeSelection: function () {
        this._element.focus();
        var range = Jeeel._doc.selection.createRange();
        var clone = range.duplicate();

        clone.moveToElementText(this._element);
        clone.setEndPoint('EndToEnd', range);
        
        var pos ={};

        pos.start = clone.text.length - range.text.length;
        pos.end = clone.text.length - range.text.length + range.text.length;
        
        return pos;
    }
};

Jeeel.Class.extend(Jeeel.Dom.Element.Textarea, Jeeel.Dom.Element.Abstract);
Jeeel.directory.Jeeel.Dom.ElementOperator = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'ElementOperator/';
    }
};

/**
 * コンストラクタ
 *
 * @class 複数のElementを一度に操作する特殊なクラス
 * @param {String|Hash} elementList セレクタ文字列もしくは、対象Element及び複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
 */
Jeeel.Dom.ElementOperator = function (elementList) {
    
    if (Jeeel.Type.isString(elementList)) {
        elementList = Jeeel.Document.getElementsBySelector(elementList);
    } else {
        elementList = this.constructor._flat(elementList);
    }
    
    for (var i = elementList.length; i--;) {
        this[i] = elementList[i];
        elementList[i] = new Jeeel.Dom.Element(elementList[i]);
    }
    
    var self = this;

    self._elementList = elementList;
    self.length = elementList.length;

    if (arguments[1] instanceof this.constructor) {
        self._prev = arguments[1];
    }
};

/**
 * インスタンスを作成する
 *
 * @param {String|Hash} elementList セレクタ文字列もしくは、対象Element及び複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
 * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
 */
Jeeel.Dom.ElementOperator.create = function (elementList) {
    return new this(elementList, arguments[1]);
};

/**
 * Elementのリスト上になるように成形する
 *
 * @param {Hash} elementList 元の要素
 * @return {Element[]} 変形後の要素
 * @protected
 */
Jeeel.Dom.ElementOperator._flat = (function (elementList) {
    var f = new Jeeel.Filter.Hash.Unique(true, true);
    
    return function (elementList) {
        var res = this._flatExec(elementList);

        return f.filter(res);
    };
})();

/**
 * Jeeel.Dom.ElementOperator._flatで使用する内部メソッド
 *
 * @param {Hash} elementList 元の要素
 * @return {Element[]} 変形後の要素
 * @protected
 */
Jeeel.Dom.ElementOperator._flatExec = function (elementList) {

    if (Jeeel.Type.isNode(elementList)) {
        return [elementList];
    }
    else if (elementList instanceof this) {
        return elementList.getAll();
    }
    else if (elementList instanceof Jeeel.Dom.Element) {
        return [elementList.getElement()];
    }
    else if (elementList instanceof Jeeel.Net.Form) {
        return [elementList.getForm()];
    }
    else if ( ! Jeeel.Type.isHash(elementList)) {
        return [];
    }
    else if ( ! Jeeel.Type.isArray(elementList)) {
        elementList = Jeeel.Hash.getValues(elementList);
    }

    var res = [];

    for (var i = 0, l = elementList.length; i < l; i++) {
        if (Jeeel.Type.isNode(elementList[i])) {
            res[res.length] = elementList[i];
        } else if (Jeeel.Type.isHash(elementList[i])) {
            var tmp = this._flatExec(elementList[i]);
            res = res.concat(tmp);
        }
    }

    return res;
};

Jeeel.Dom.ElementOperator.prototype = {

    /**
     * 絞り込みを掛ける前のインスタンス
     * 
     * @type Jeeel.Dom.ElementOperator
     * @protected
     */
    _prev: null,

    /**
     * 基となるElement(この操作モジュールを保持するElement)
     *
     * @type Jeeel.Dom.Element[]
     * @protected
     */
    _elementList: [],

    /**
     * 現在操作している要素数
     * 
     * @type Integer
     * @readOnly
     */
    length: 0,

    /**
     * 指定したインデックスの要素を取得する
     *
     * @param {Integer} index インデックス(負の数を指定すると後ろから参照する)
     * @return {Element} 取得要素
     */
    get: function (index) {
        if ( ! Jeeel.Type.isInteger(index) || this.length <= index) {
            return null;
        }

        if (0 > index) {
            index = this.length + index;
        }

        return this[index] || null;
    },

    /**
     * 全要素を取得する
     *
     * @return {Element[]} 全要素のリスト
     */
    getAll: function () {
        var res = [];
        
        for (var i = this.length; i--;) {
            res[i] = this[i];
        }
        
        return res;
    },

    /**
     * 指定したElementに対応するインデックスを取得する
     *
     * @param {Element} element 検索Element
     * @return {Integer} インデックス(見つからない場合は-1)
     */
    getIndex: function (element) {
        var res = -1;
        
        for (var i = this.length; i--;) {
            if (this[i] === element) {
                res = i;
            }
        }

        return res;
    },

    /**
     * 操作対象に新規にElementを追加する
     *
     * @param {Hash} element 追加するElementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    add: function (element) {
        element = this.constructor._flat(element);

        var skip = 0;

        for (var i = 0, l = element.length; i < l; i++) {

            var brk = false;

            for (var j = 0; j < this.length; j++) {
                if (element[i] === this[j]) {
                    skip++;
                    brk = true;
                    break;
                }
            }

            if (brk) {
                continue;
            }

            this[this.length + i - skip] = element[i];
            var tmp = new Jeeel.Dom.Element(element[i]);
            
            this._elementList[this._elementList.length] = tmp;
        }

        this.length = this._elementList.length;

        return this;
    },

    /**
     * 絞り込み動作を行う前の要素を操作対象に追加する
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    andSelf: function () {
        return this.add(this._prev);
    },

    /**
     * 直前の絞り込み動作を行う前の状態のインスタンスを返す
     *
     * @return {Jeeel.Dom.ElementOperator} 直前のインスタンス(ない場合は要素が空のインスタンス)
     */
    end: function () {
        return (this._prev ? this._prev : this.constructor.create());
    },

    /**
     * 指定要素の子リストにElementを追加する
     *
     * @param {Element} child 追加Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    appendChild: function (child, index) {
        if ( ! index) {
            index = 0;
        } else if ( ! (index in this._elementList)) {
            return this;
        }

        this._elementList[index].appendChild(this.constructor._flat(child));

        return this;
    },

    /**
     * 指定要素の子リストからElementを取り除く
     *
     * @param {Element} child 削除Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeChild: function (child, index) {
        if ( ! index) {
            index = 0;
        } else if ( ! (index in this._elementList)) {
            return this;
        }

        this._elementList[index].removeChild(this.constructor._flat(child));

        return this;
    },
    
    /**
     * 全ての要素の子供を全て削除する
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    clearChildNodes: function () {
        return this._callMethod('clearChildNodes');
    },

    /**
     * 全ての要素それぞれを指定Elementで囲う<br />
     * それぞれを囲うElementはコピーされる
     *
     * @param {String|Element} wrapElement 囲いElement(Jeeel.Dom.ElementOperatorやJeeel.Dom.Elementでも可能)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @ignore
     */
    wrap: function (wrapElement) {
      
        if (Jeeel.Type.isString(wrapElement)) {
            wrapElement = Jeeel.Document.createElementList(wrapElement);
        }

        wrapElement = this.constructor._flat(wrapElement)[0];

        return this._callMethod('wrapSelf', [wrapElement]);
    },
    
    /**
     * 指定要素のIDを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} ID
     */
    getId: function (index) {
        return this._getCall(index, 'getId');
    },
    
    /**
     * IDを指定要素に設定する
     *
     * @param {String} id ID
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setId: function (id, index) {
        if ( ! index) {
            index = 0;
        } else if ( ! (index in this._elementList)) {
            return this;
        }
        
        this._elementList[index].setId(id);

        return this;
    },
    
    /**
     * 指定要素のNameを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} Name
     */
    getName: function (index) {
        return this._getCall(index, 'getName');
    },
    
    /**
     * Nameを全ての要素に設定する
     *
     * @param {String} name Name
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setName: function (name) {
        return this._callMethod('setName', [name]);
    },
    
    /**
     * 指定要素のTagNameを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} Name
     */
    getTag: function (index) {
        return this._getCall(index, 'getTagName');
    },

    /**
     * 指定要素のクラス名のリストを全て取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String[]} クラス名リスト
     */
    getClass: function (index) {
        return this._getCall(index, 'getClassNames') || [];
    },

    /**
     * クラス名を全ての要素に追加する
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addClass: function (className) {
        return this._callMethod('addClassName', [className]);
    },

    /**
     * 指定したクラス名を全ての要素から取り除く
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeClass: function (className) {
        return this._callMethod('removeClassName', [className]);
    },

    /**
     * 指定したクラス名が存在していたら削除し、<br />
     * 存在していなかったら追加を全ての要素に対して行う
     *
     * @param {String|String[]} className クラス名もしくはクラス名リスト
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    toggleClass: function (className) {
        return this._callMethod('toggleClassName', [className]);
    },

    /**
     * 全ての要素のクラス名を消去する
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    clearClass: function () {
        return this._callMethod('clearClassName');
    },
    
    /**
     * 指定したクラス名を保持しているかどうかを返す
     *
     * @param {String} className クラス名
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Boolean} クラス名を保持していたかどうか
     */
    hasClass: function (className, index) {
        return this._getCall(index, 'hasClassName', [className]);
    },

    /**
     * 指定要素から属性取得する
     *
     * @param {String} attribute 属性名
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} 属性値
     */
    getAttr: function (attribute, index) {
        return this._getCall(index, 'getAttribute', [attribute]);
    },

    /**
     * 属性値を全ての要素に設定する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setAttr: function (attribute, value) {
        return this._callMethod('setAttribute', [attribute, value]);
    },
    
    /**
     * 属性値を全ての要素から削除する
     *
     * @param {String} attribute 属性名
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeAttr: function (attribute) {
        return this._callMethod('removeAttribute', [attribute]);
    },

    /**
     * 指定要素からプロパティを取得する
     *
     * @param {String} property プロパティ名
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Mixied} プロパティ値
     */
    getProp: function (property, index) {
        return this._getCall(index, 'getProperty', [property]);
    },

    /**
     * プロパティを全ての要素に設定する
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value プロパティ値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setProp: function (property, value) {
        return this._callMethod('setProperty', [property, value]);
    },

    /**
     * 指定要素からスタイルを取得する
     *
     * @param {String} css スタイル名
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} スタイル値
     * @see Jeeel.Dom.Style
     */
    getCss: function (css, index) {
        return this._getCall(index, 'getStyle', [css]);
    },

    /**
     * スタイルを全ての要素に設定する
     *
     * @param {String} css スタイル名
     * @param {String} value スタイル値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style
     */
    setCss: function (css, value) {
        return this._callMethod('setStyle', [css, value]);
    },
    
    /**
     * 複数のスタイルを全ての要素に設定する
     *
     * @param {Hash} cssList スタイル名と値のペアリスト
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setCssList: function (cssList) {
        return this._callMethod('setStyleList', [cssList]);
    },
    
    /**
     * 指定要素からDOMの独自データを取得する(属性値data-&#8727;)<br />
     * IE8以下ではメモリリークを起こす非推奨メソッド
     * 
     * @param {String} key データキー
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} データ
     */
    getData: function (key, index) {
        return this._getCall(index, 'getData', [key]);
    },
    
    /**
     * DOMの独自データを全ての要素に設定する(属性値data-&#8727;)<br />
     * IE8以下ではメモリリークを起こす非推奨メソッド
     * 
     * @param {String} key データキー
     * @param {String} data データ
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setData: function (key, data) {
        return this._callMethod('setData', [key, data]);
    },
    
    /**
     * 指定要素からJeeelの独自データを取得する<brr />
     * IE以外ではプロパティが拡張されるので注意(詳しくはJeeel.Storage.Objectを参照)<br />
     * またネームスペースは初期値を用いる
     * 
     * @param {String} key データキー
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Mixied} データ
     * @see Jeeel.Storage.Object
     */
    getCustomData: function (key, index) {
        return this._getCall(index, 'getCustomData', [key]);
    },
    
    /**
     * Jeeelの独自データを全ての要素に設定する<brr />
     * IE以外ではプロパティが拡張されるので注意(詳しくはJeeel.Storage.Objectを参照)<br />
     * またネームスペースは初期値を用いる
     * 
     * @param {String} key データキー
     * @param {Mixied} data データ
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Storage.Object
     */
    setCustomData: function (key, data) {
        return this._callMethod('setCustomData', [key, data]);
    },
    
    /**
     * 指定要素の左上絶対軸座標を返す
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Object.Point} 左上の座標
     */
    getPos: function (index) {
        return this._getCall(index, 'getPosition');
    },
    
    /**
     * 指定要素のサイズを取得する
     * 
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Object.Size} サイズ
     */
    getSize: function (index) {
        return this._getCall(index, 'getSize');
    },
    
    /**
     * 指定要素の左上絶対座標とサイズを併せ持った構造体を取得する
     * 
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Object.Rect} レクト
     */
    getRect: function (index) {
        return this._getCall(index, 'getRect');
    },
    
    /**
     * 指定要素のスクロール位置を取得する
     * 
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Jeeel.Object.Point} スクロール位置
     */
    getScrollPos: function (index) {
        return this._getCall(index, 'getScrollPosition');
    },

    /**
     * 指定要素のinnerHTMLを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} 取得HTML
     */
    getHtml: function (index) {
        return this._getCall(index, 'getHtml');
    },

    /**
     * 全ての要素のinnerHTMLに指定HTMLを書き込む
     *
     * @param {String} html 設定HTML
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setHtml: function (html) {
        return this._callMethod('setHtml', [html]);
    },

    /**
     * 指定要素のTextを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {String} 取得Text
     */
    getText: function (index) {
        return this._getCall(index, 'getText');
    },

    /**
     * 全ての要素にTextを書き込む<br />
     * その際innerHtmlが書き変わる
     *
     * @param {String} text 設定Text
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setText: function (text) {
        return this._callMethod('setText', [text]);
    },

    /**
     * 指定要素のvalueを取得する
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Mixied} 取得value
     */
    getVal: function (index) {
        return this.getProp('value', index);
    },

    /**
     * 全ての要素のvalueを取得する
     *
     * @return {Array} 取得value
     */
    getValAll: function () {
        var res = [];

        for (var i = this.length; i--;) {
            res[i] = this.getVal(i);
        }

        return res;
    },

    /**
     * 全ての要素のvalueに指定HTMLを書き込む
     *
     * @param {Mixied} value 設定値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    setVal: function (value) {
        return this.setProp('value', value);
    },

    /**
     * 指定要素の内部に含まれているInputのリストを返す<br />
     * 名前が指定されており、送信される状態の要素のみ対象になる
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Hash} input,select,button,textareaのリスト(キーはそれぞれのname)
     */
    getInput: function (index) {},

    /**
     * 指定要素の内部に含まれているInput値のリストを返す<br />
     * 名前が指定されており、送信される状態の要素のみ対象になる
     *
     * @param {Integer} [index] インデックス(省略は0)
     * @return {Hash} input,select,button,textareaのリスト(キーはそれぞれのname)
     */
    getInputVal: function (index) {},
    
    /**
     * 全ての要素のElementの共通の親を返す<br />
     * ただし全てがDom上に存在しないと正しい値は取れない
     * 
     * @return {Node} 共通の親最上階層はDocument(Dom上に存在しない要素が居た場合はnullを返す)
     */
    getCommonParent: function () {},
    
    /**
     * 指定したクラス名を持つ要素のみを新規にインスタンス作成して返す
     *
     * @param {String|String[]} className 許可クラスリストもしくは許可クラス
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterClass: function (className) {
      
        if ( ! Jeeel.Type.isArray(className)) {
            className = [className];
        }

        var res = this._each(
            function () {
                var tmp = this.getClassNames();

                for (var i = 0, l = tmp.length; i < l; i++) {
                    if (Jeeel.Hash.inHash(tmp[i], className)) {
                        return this;
                    }
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した名前の要素のみを新規にインスタンス作成して返す
     *
     * @param {String|String[]} name 許可名リストもしくは許可名
     * @param {Boolean} [submitSearch] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか(初期値はfalse)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterName: function (name, submitSearch) {},
    
    /**
     * 指定したタグの要素のみを新規にインスタンス作成して返す
     *
     * @param {String|String[]} tag 許可タグリストもしくは許可タグ
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterTag: function (tag) {
      
        if ( ! Jeeel.Type.isArray(tag)) {
            tag = [tag];
        }

        var res = this._each(
            function () {
                var tmp = this.getTagName();

                if (Jeeel.Hash.inHash(tmp, tag)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 指定した属性がある値の要素のみを新規にインスタンス作成して返す
     *
     * @param {String} attribute 属性名
     * @param {String|String[]} value 許可値リストもしくは許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterAttr: function (attribute, value) {
        
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
      
        var res = this._each(
            function () {
                var tmp = this.getAttribute(attribute);

                if (Jeeel.Hash.inHash(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 指定したプロパティがある値の要素のみを新規にインスタンス作成して返す
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value 許可値リストもしくは許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterProp: function (property, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getProperty(property);

                if (Jeeel.Hash.inHash(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定したスタイルがある値の要素のみを新規にインスタンス作成して返す
     *
     * @param {String} css スタイル名
     * @param {String|String[]} value 許可値リストもしくは許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterCss: function (css, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getStyle(css);

                if (Jeeel.Hash.inHash(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した範囲検索ひヒットした要素のみを新規にインスタンス作成して返す
     *
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {Function} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     * @see Jeeel.Dom.SearchOption
     */
    filterRange: function (rect, option) {
        var res = [], trect;
        
        if ( ! option) {
            option = Jeeel.Dom.SearchOption.RANGE_OVERLAY;
        }
      
        var res = this._each(
            function () {
                trect = this.getRect();

                if (option(rect, trect)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した要素のみを新規にインスタンス作成して返す
     *
     * @param {Hash} element 許可Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterElement: function (element) {
        element = this.constructor._flat(element);
        
        var res = [];
        
        for (var i = 0; i < this.length; i++) {
            if (Jeeel.Hash.inHash(this[i], element)) {
                res[res.length] = this[i];
            }
        }

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定したクラス名を持つ要素を全て取り除き新規にインスタンス作成して返す
     *
     * @param {String|String[]} className 非許可クラスリストもしくは非許可クラス
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterClass: function (className) {
      
        if ( ! Jeeel.Type.isArray(className)) {
            className = [className];
        }

        var res = this._each(
            function () {
                var tmp = this.getClassNames();

                for (var i = 0, l = tmp.length; i < l; i++) {
                    if ( ! Jeeel.Hash.inHash(tmp[i], className)) {
                        return this;
                    }
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した名前の要素を全て取り除き新規にインスタンス作成して返す
     *
     * @param {String|String[]} name 非許可名リストもしくは非許可名
     * @param {Boolean} [submitSearch] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか(初期値はfalse)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterName: function (name, submitSearch) {},
    
   /**
     * 指定したタグの要素を全て取り除き新規にインスタンス作成して返す
     *
     * @param {String|String[]} tag 許可タグリストもしくは許可タグ
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterTag: function (tag) {
      
        if ( ! Jeeel.Type.isArray(tag)) {
            tag = [tag];
        }

        var res = this._each(
            function () {
                var tmp = this.getTagName();

                if ( ! Jeeel.Hash.inHash(tmp, tag)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 指定した属性がある値の要素を全て取り除き新規にインスタンスを作成して返す
     *
     * @param {String} attribute 属性名
     * @param {String|String[]} value 非許可値リストもしくは非許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterAttr: function (attribute, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getAttribute(attribute);

                if ( ! Jeeel.Hash.inHash(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 指定したプロパティがある値の要素を全て取り除き新規にインスタンスを作成して返す
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value 非許可値リストもしくは非許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterProp: function (property, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getProperty(property);

                if ( ! Jeeel.Hash.inHash(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定したスタイルがある値の要素を全て取り除き新規にインスタンスを作成して返す
     *
     * @param {String} css スタイル名
     * @param {String|String[]} value 非許可値リストもしくは非許可値
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterCss: function (css, value) {
        if ( ! Jeeel.Type.isArray(value)) {
            value = [value];
        }
        
        var res = this._each(
            function () {
                var tmp = this.getStyle(css);

                if ( !  Jeeel.Hash.inHash(tmp, value)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した範囲検索ヒットした要素を全て取り除き新規にインスタンスを作成して返す
     *
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {Function} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     * @see Jeeel.Dom.SearchOption
     */
    revFilterRange: function (rect, option) {
        var res = [], trect;
        
        if ( ! option) {
            option = Jeeel.Dom.SearchOption.RANGE_OVERLAY;
        }
      
        var res = this._each(
            function () {
                trect = this.getRect();

                if ( ! option(rect, trect)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定した要素を全て取り除き新規にインスタンス作成して返す
     *
     * @param {Hash} element 非許可Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    revFilterElement: function (element) {
        element = this.constructor._flat(element);

        var res = this._each(
            function () {
                var tmp = this.getElement();

                if ( ! Jeeel.Hash.inHash(tmp, element)) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * インデックスが偶数の要素のみを纏めて新規インスタンスとして返す
     *
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterEven: function () {
        var res = this._each(
            function (val, key) {

                if ((key & 1) === 1) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * インデックスが奇数の要素のみを纏めて新規インスタンスとして返す
     *
     * @return {Jeeel.Dom.ElementOperator} 作成したインスタンス
     */
    filterOdd: function () {
        var res = this._each(
            function (val, key) {

                if ((key & 1) === 0) {
                    return this;
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 指定したインデックスの要素を対象にElementラッパーを作成する
     *
     * @param {Integer} index インデックス(負の数を指定すると後ろから参照する)
     * @return {Jeeel.Dom.ElementOperator} 取得したElementラッパー
     */
    $GET: function (index) {
        return this.constructor.create(this.get(index), this);
    },

    /**
     * 全要素内の指定名のinput要素を対象にElementラッパーを作成する<br />
     * 名前が指定されており、送信される状態の要素のみ対象になる
     *
     * @param {String} [name] 名前を指定する場合は指定する
     * @return {Jeeel.Dom.ElementOperator} 取得したElementラッパー
     */
    $INPUT: function (name) {

        var res = [];

        for (var i = 0; i < this.length; i++) {
            var tmp = this.getInput(i);

            if (name) {
                tmp = tmp[name];
            }

            tmp = this.constructor._flat(tmp);
            res = res.concat(tmp);
        }

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定IDのHTML要素を取得する
     *
     * @param {String} id 検索ID
     * @return {Jeeel.Dom.ElementOperator} 取得したElementラッパー(取得できなかった場合はnull)
     */
    $ID: function (id) {
        if ( ! id) {
            return null;
        }

        var res = null;

        this._each(
            function () {
                var tmp = this.getElementById(id);

                if (tmp) {
                    res = tmp;
                    return Jeeel.Hash.FOR_EACH_EXIT;
                }
            }
        );

        return res && this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定ClassのHTML要素を取得する
     *
     * @param {String|String[]} className 検索Class
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $CLASS: function (className) {
        if ( ! className) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByClassName(className);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定NameのHTML要素を取得する
     * なおsubmitSearchを指定すると<br />
     * この動作は一部本来のgetElementsByNameと違い、<br />
     * c[]等で配列指定した値に対してもヒットする
     *
     * @param {String|String[]} name 検索Name
     * @param {Boolean} [submitSearch] 送信時と同じようにc[]等の配列指定をヒットさせるかどうか(初期値はfalse)
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $NAME: function (name, submitSearch) {
        if ( ! name) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByName(name, submitSearch);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定TagのHTML要素を取得する
     *
     * @param {String|String[]} tagName 検索Tag
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $TAG: function (tagName) {
        if ( ! tagName) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByTagName(tagName);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定属性が指定値のHTML要素を取得する
     *
     * @param {String} attribute 属性名
     * @param {String} value 属性値('*'を指定すると任意の値の意味になる)
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $ATTR: function (attribute, value) {
        if ( ! attribute) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByAttribute(attribute, value);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素の子リストから指定プロパティが指定値のHTML要素を取得する<br />
     * Elementのプロパティである事に注意
     *
     * @param {String} property プロパティ名
     * @param {Mixied} value 指定値('*'を指定すると任意の値の意味になる)
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $PROP: function (property, value) {
        if ( ! property) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsByProperty(property, value);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 全ての要素の子リストからセレクタにヒットするのHTML要素を取得する
     *
     * @param {String} selector CSSと同じ絞り込みセレクタ
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     * @see Jeeel.Dom.Selector
     */
    $QUERY: function (selector) {
        if ( ! selector) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.getElementsBySelector(selector);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },
    
    /**
     * 全ての要素の次の要素を検索取得する
     * 
     * @param {Integer} [nextCount] いくつ次を参照するか
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $NEXT: function (nextCount) {
        if (nextCount === 0) {
            return this.clone(false);
        }

        var res = this._getCalls('getNextNode', [nextCount]);

        return this.constructor.create(res, this);
    },
    
    /**
     * 全ての要素の前の要素を検索取得する
     * 
     * @param {Integer} [prevCount] いくつ前を参照するか
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $PREV: function (prevCount) {
        if (prevCount === 0) {
            return this.clone(false);
        }

        var res = this._getCalls('getPrevNode', [prevCount]);

        return this.constructor.create(res, this);
    },
    
    /**
     * 全ての要素の子要素を取得する
     * 
     * @return {Jeeel.Dom.ElementOperator} 取得したElement配列ラッパー
     */
    $CHILDREN: function () {
        var res = this._getCalls('getChildren');

        return this.constructor.create(res, this);
    },
    
    /**
     * 全ての要素の子リストからHTML要素を指定範囲検索する
     *
     * @param {Jeeel.Object.Rect} rect 対象範囲
     * @param {String} [option] 検索オプション(デフォルトは重なったElement)
     * @return {Jeeel.Dom.ElementOperator} 範囲検索に引っかかったElement配列ラッパー
     * @see Jeeel.Dom.SearchOption
     */
    $RANGE: function (rect, option) {
        if ( ! rect) {
            return this.constructor.create([], this);
        }

        var res = [];

        this._each(
            function () {
                var tmp = this.searchElementsByRange(rect, option);

                if (tmp.length) {
                    res = Jeeel.Hash.merge(res, tmp);
                }
            }
        );

        return this.constructor.create(res, this);
    },

    /**
     * 全ての要素内にforeachをかける<br />
     * その際foreachに渡される値はJeeel.Dom.ElementOperator型となる<br />
     * 詳しくはJeeel.Hash.forEach参照
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Hash.forEach
     */
    $EACH: function (eachMethod, thisArg) {
        var res = [];
        
        for (var i = 0; i < this.length; i++) {
            res[i] = new this.constructor(this[i]);
        }

        Jeeel.Hash.forEach(res, eachMethod, thisArg);
        
        return this;
    },

    /**
     * 全ての要素内にforeachをかける<br />
     * その際foreachに渡される値はElement型となる<br />
     * 詳しくはJeeel.Hash.forEach参照
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Hash.forEach
     */
    each: function (eachMethod, thisArg) {
        Jeeel.Hash.forEach(this.getAll(), eachMethod, thisArg);
        
        return this;
    },
    
    /**
     * 全ての要素をDom上から取り除く
     *
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    remove: function () {
        return this._callMethod('remove');
    },
    
    /**
     * 全ての要素を表示する
     *
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    show: function (speed, easing, complete, thisArg) {
        return this._callMethod('show', [speed, easing, complete, thisArg || this]);
    },

    /**
     * 全ての要素を隠す
     *
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    hide: function (speed, easing, complete, thisArg) {
        return this._callMethod('hide', [speed, easing, complete, thisArg || this]);
    },

    /**
     * 全ての要素の表示状態を切り替える
     *
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    toggle: function (speed, easing, complete, thisArg) {
        return this._callMethod('toggle', [speed, easing, complete, thisArg || this]);
    },
    
    /**
     * 全ての要素に対してフェードインを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    fadeIn: function (speed, easing, complete, thisArg) {
        return this._callMethod('fadeIn', [speed, easing, complete, thisArg || this]);
    },
    
    /**
     * 全ての要素に対してフェードアウトを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    fadeOut: function (speed, easing, complete, thisArg) {
        return this._callMethod('fadeOut', [speed, easing, complete, thisArg || this]);
    },
    
    /**
     * 全ての要素に対してフェードトグルを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    fadeToggle: function (speed, easing, complete, thisArg) {
        return this._callMethod('fadeToggle', [speed, easing, complete, thisArg || this]);
    },
    
    /**
     * 全ての要素に対してスライドアップを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    slideUp: function (speed, easing, complete, thisArg) {
        return this._callMethod('slideUp', [speed, easing, complete, thisArg || this]);
    },
    
    /**
     * 全ての要素に対してスライドダウンを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    slideDown: function (speed, easing, complete, thisArg) {
        return this._callMethod('slideDown', [speed, easing, complete, thisArg || this]);
    },
    
    /**
     * 全ての要素に対してスライドトグルを行う
     * 
     * @param {Integer|String} [speed] 指定するとアニメーションになる(ミリ秒かfast, slow, defaultの文字列定数がある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーションにした際に終了時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    slideToggle: function (speed, easing, complete, thisArg) {
        return this._callMethod('slideToggle', [speed, easing, complete, thisArg || this]);
    },
    
    /**
     * アニメーションを開始する
     * 
     * @param {Hash} params アニメーション変化の数値
     * @param {Integer|String} [duration] アニメーションが完結するまでの時間(ミリ秒)か定義文字列(fast, slow, defaultがある)
     * @param {Function|String} [easing] アニメーションの数値の変化度合いを変える関数もしくはそれを表す文字列(Jeeel.Dom.Style.Animation.Easingの中の関数名、例:swing等)
     * @param {Function} [complete] アニメーション終了時に呼ばれるコールバック
     * @param {Function} [step] アニメーション更新時に呼ばれるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @see Jeeel.Dom.Style.Animation.Easing
     */
    animate: function (params, duration, easing, complete, step, thisArg) {
        return this._callMethod('animate', [params, duration, easing, complete, step, thisArg || this]);
    },
    
    /**
     * アニメーション管理インスタンスを取得する
     * 
     * @return {Jeeel.Dom.ElementOperator.Animator} 管理インスタンス
     */
    getAnimator: function () {
        return new this.constructor.Animator(this._getCalls('getAnimator'), this);
    },
    
    /**
     * 全ての要素を指定座標に移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    shiftTo: function (x, y) {
        return this._callMethod('shiftTo', [x, y]);
    },
    
    /**
     * 全ての要素のスクロールを行う
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @ignore
     */
    scroll: function (x, y) {
        return this._callMethod('scroll', [x, y]);
    },

    /**
     * 全ての要素にクリックイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addClick: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.CLICK, callback, thisArg);
    },
    
    /**
     * 全ての要素にマウスダウンイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addMouseDown: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_DOWN, callback, thisArg);
    },
    
    /**
     * 全ての要素にマウスアップイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addMouseUp: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_UP, callback, thisArg);
    },
    
    /**
     * 全ての要素にマウスムーブイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addMouseMove: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_MOVE, callback, thisArg);
    },

    /**
     * 全ての要素にロードイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addLoad: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.LOAD, callback, thisArg);
    },

    /**
     * 全ての要素にマウスオーバーイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addOver: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_OVER, callback, thisArg);
    },

    /**
     * 全ての要素にマウスアウトイベントの登録をする
     *
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addOut: function (callback, thisArg) {
        return this.addEvent(Jeeel.Dom.Event.Type.MOUSE_OUT, callback, thisArg);
    },

    /**
     * 全ての要素にマウスホバーイベントの登録をする
     *
     * @param {Function} overCallback マウスオーバーイベントコールバック
     * @param {Function} outCallback マウスアウトイベントのコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addHover: function (overCallback, outCallback, thisArg) {

        this.addOver(overCallback, thisArg);
        return this.addOut(outCallback, thisArg);
    },
    
    /**
     * 全ての要素にイベントの登録をする
     *
     * @param {String} type イベントタイプ
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    addEvent: function (type, callback, thisArg) {
        var thisArgVal = thisArg;
        
        this._each(
            function () {
                if ( ! Jeeel.Type.isSet(thisArg)) {
                    thisArgVal = Jeeel.Dom.ElementOperator.create(this);
                }
                
                this.addEventListener(type, callback, thisArgVal);
            }
        );

        return this;
    },

    /**
     * 全ての要素からクリックイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeClick: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.CLICK, callback);
    },
    
    /**
     * 全ての要素からマウスダウンイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeMouseDown: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_DOWN, callback);
    },
    
    /**
     * 全ての要素からマウスアップイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeMouseUp: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_UP, callback);
    },
    
    /**
     * 全ての要素からマウスムーブイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeMouseMove: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_MOVE, callback);
    },

    /**
     * 全ての要素からロードイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeLoad: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.LOAD, callback);
    },

    /**
     * 全ての要素からマウスオーバーイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeOver: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_OVER, callback);
    },

    /**
     * 全ての要素からマウスアウトイベントを削除する
     *
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeOut: function (callback) {
        return this.removeEvent(Jeeel.Dom.Event.Type.MOUSE_OUT, callback);
    },

    /**
     * 全ての要素からマウスホバーイベントを削除する
     *
     * @param {Function} overCallback マウスオーバーイベントコールバック
     * @param {Function} outCallback マウスアウトイベントのコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeHover: function (overCallback, outCallback) {

        this.removeOver(overCallback);
        return this.removeOut(outCallback);
    },
    
    /**
     * 全ての要素からイベントを削除する
     *
     * @param {String} type イベントタイプ
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    removeEvent: function (type, callback) {
        return this._callMethod('removeEventListener', [type, callback]);
    },
    
    /**
     * 全ての要素に対してのイベントを上位Elementに委譲して登録を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} callback イベントコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    delegate: function (type, callback, thisArg) {
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }

        Jeeel.Dom.Event.delegate(this, type, callback, thisArg);
        
        return this;
    },
    
    /**
     * 全ての要素に対してのイベントを上位Elementに委譲してたものの削除を行う
     *
     * @param {String} type イベントタイプ
     * @param {Function} callback イベントコールバック
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     */
    undelegate: function (type, callback) {
        Jeeel.Dom.Event.undelegate(this, type, callback);

        return this;
    },
     
    /**
     * このElementに設定されているイベントを任意のタイミングで実行する
     *
     * @param {String} type イベントタイプ
     * @param {Jeeel.Dom.Event.Option} [option] マウスイベントやキーボードイベント等のイベント時のパラメータを指定する
     * @ignore 未完成
     */
    dispatchEvent: function (type, option) {
        return this._callMethod('dispatchEvent', [type, option]);
    },
    
    /**
     * インスタンスを複製する
     *
     * @param {Boolean} [isDeep] 要素まで複製するかどうか
     * @return {Jeeel.Dom.ElementOperator} 複製後のインスタンス
     */
    clone: function (isDeep) {
        
        if (isDeep) {
            return new this.constructor(this._getCalls('clone', [true]), this._prev);
        }
        
        return new this.constructor(this._elementList, this._prev);
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Hash} elementList 対象Elementまたは複数のElementリスト(Jeeel.Dom.ElementOperatorやJeeel.Dom.Element自体やリストでも可能)
     * @constructor
     */
    constructor: Jeeel.Dom.ElementOperator,
    
    /**
     * メソッドの内部呼び出しを行う
     * 
     * @param {String} methodName メソッド名
     * @param {Array} [args] 引数を指定する場合に渡す
     * @return {Jeeel.Dom.ElementOperator} 自インスタンス
     * @private
     */
    _callMethod: function (methodName, args) {
        this._each(
            function () {
                this[methodName].apply(this, args || []);
            }
        );

        return this;
    },
    
    /**
     * 戻り値を持ったメソッドの内部呼び出しを行う
     * 
     * @param {Integer} index 要素Index
     * @param {String} methodName メソッド名
     * @param {Array} [args] 引数を指定する場合に渡す
     * @return {Mixied} 戻り値
     * @private
     */
    _getCall: function (index, methodName, args) {
        if ( ! index) {
            index = 0;
        }
        
        if ( ! (index in this._elementList)) {
            return null;
        }
        
        var elm = this._elementList[index];
        
        return elm[methodName].apply(elm, args || []);
    },
    
    /**
     * インデックスを指定せずに戻り値を持った内部呼び出しを行う
     * 
     * @param {String} methodName メソッド名
     * @param {Array} [args] 引数を指定する場合に渡す
     * @return {Mixied} 戻り値
     * @private
     */
    _getCalls: function (methodName, args) {
        return this._each(
            function () {
                return this[methodName].apply(this, args || []);
            }
        );
    },

    /**
     * 内部的にforeachを掛ける
     *
     * @param {Function} eachMethod コールバックメソッド
     * @param {Mixied} [thisArg] thisに相当する値
     * @return {Hash} コールバックメソッド中に返した戻り値の配列
     * @private
     */
    _each: function (eachMethod, thisArg) {
        var tmp, res = [];
        
        var exit = Jeeel.Hash.FOR_EACH_EXIT;
        
        for (var i = 0, l = this.length; i < l; i++) {
            
            tmp = eachMethod.call(this._elementList[i], this._elementList[i], i);
            
            if (tmp === exit) {
                break;
            }
            
            res[res.length] = tmp;
        }
        
        return res;
    },
    
    /**
     * @ignore
     */
    _init: function () {
        var ief = new Jeeel.Filter.Html.Form(),
            ivf = new Jeeel.Filter.Html.FormValue(),
            auf = new Jeeel.Filter.Hash.Unique(true, true);
        
        /**
         * @ignore
         */
        this.filterName = function (name, submitSearch) {
            if ( ! Jeeel.Type.isArray(name)) {
                name = [name];
            }

            var res;

            if (submitSearch) {
                for (var i = name.length; i--;) {
                    name[i] = new RegExp('^' + Jeeel.String.escapeRegExp(name[i]) + '(?:$|\\[)');
                }

                res = this._each(
                    function () {
                        var tmp = this.getName();

                        for (var i = name.length; i--;) {
                            if (tmp.match(name[i])) {
                                return this;
                            }
                        }
                    }
                );
            } else {
                res = this._each(
                    function () {
                        var tmp = this.getName();

                        if (Jeeel.Hash.inHash(tmp, name)) {
                            return this;
                        }
                    }
                );
            }

            return this.constructor.create(res, this);
        };
        
        /**
         * @ignore
         */
        this.revFilterName = function (name, submitSearch) {
            if ( ! Jeeel.Type.isArray(name)) {
                name = [name];
            }

            var res;

            if (submitSearch) {
                for (var i = name.length; i--;) {
                    name[i] = new RegExp('^' + Jeeel.String.escapeRegExp(name[i]) + '(?:$|\\[)');
                }

                res = this._each(
                    function () {
                        var tmp =this.getName();

                        for (var i = name.length; i--;) {
                            if ( ! tmp.match(name[i])) {
                                return this;
                            }
                        }
                    }
                );
            } else {
                res = this._each(
                    function () {
                        var tmp = this.getName();

                        if ( ! Jeeel.Hash.inHash(tmp, name)) {
                            return this;
                        }
                    }
                );
            }

            return this.constructor.create(res, this);
        };
        
        /**
         * @ignore
         */
        this.getInput = function (index) {
            if ( ! index) {
                index = 0;
            } else if ( ! (index in this._elementList)) {
                return {};
            }

            return ief.filter(this[index]);
        };
        
        /**
         * @ignore
         */
        this.getInputVal = function (index) {
            if ( ! index) {
                index = 0;
            } else if ( ! (index in this._elementList)) {
                return {};
            }

            return ivf.filter(this[index]);
        };
        
        /**
         * @ignore
         */
        this.getCommonParent = function () {
            var elms = this._elementList,
                min = -1,
                hirs = [],
                args = [],
                p, i, l;

            for (i = elms.length; i--;) {
                hirs[i] = elms[i].getHierarchy();

                if (min < 0 || min > hirs[i]) {
                    min = hirs[i];
                }
            }

            for (i = elms.length; i--;) {
                args[i] = elms[i].getParentNode(hirs[i] - min);
            }

            args = auf.filter(args);
            
            l = args.length;

            while(l > 1) {

                for (i = l; i--;) {
                    p = args[i].parentNode;

                    if (args[i].ownerDocument && ! p) {
                        return null;
                    }

                    args[i] = p;
                }

                args = auf.filter(args);
                
                l = args.length;
            }

            return args[0];
        };
        
        delete this._init;
    }
};

Jeeel.Dom.ElementOperator.prototype._init();

Jeeel.file.Jeeel.Dom.ElementOperator = ['Animator'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.ElementOperator, Jeeel.file.Jeeel.Dom.ElementOperator);
/**
 * コンストラクタ
 * 
 * @class Elementラッパーの複数のアニメーターを管理する操作インスタンス
 * @param {Jeeel.Dom.Element.Animator[]} animators 操作対象のElementのアニメーターインスタンス
 * @param {Jeeel.Dom.ElementOperator} returnInstance アニメーションを実行した後に返す戻り値
 */
Jeeel.Dom.ElementOperator.Animator = function (animators, returnInstance) {
    this._animators = animators;
    this._returnInstance = returnInstance;
};

Jeeel.Dom.ElementOperator.Animator.prototype = {
    
    /**
     * アニメーターリスト
     * 
     * @type Jeeel.Dom.Element.Animator[]
     * @private
     */
    _animators: null,
    
    /**
     * 戻り値インスタンス
     * 
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _returnInstance: null,

    /**
     * アニメーションの対象のスタイルを設定する
     * 
     * @param {String} key スタイル名
     * @param {String|Number|Hash} param スタイルの最終変化値<br />
     *                                    100px等の絶対値の他に、+=や-=を前に付けた相対値やtoggle、show、hide等の特殊値がある(特殊値はdisplay, width, height, opacity, margin系, padding系にしか効かない)<br />
     *                                    また配列や連想配列にすることでスタイルそれぞれにイージング関数を適用できる<br />
     *                                    [value, easing]とするか、{value: value, easing: easing}とすることが出来る
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    set: function (key, param) {
        return this._callMethod('set', [key, param]);
    },
    
    /**
     * アニメーションの対象のスタイルを全て設定する
     * 
     * @param {Hash} params アニメーション対象のスタイル全て
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    setAll: function (params) {
        return this._callMethod('setAll', [params]);
    },
    
    /**
     * アニメーションの対象のスタイルを全て破棄する
     * 
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    clear: function () {
        return this._callMethod('clear');
    },
  
    /**
     * アニメーション完了時間を設定する
     * 
     * @param {Integer|String} duration 完了時間もしくはその定数
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    setDuration: function (duration) {
        return this._callMethod('setDuration', [duration]);
    },
    
    /**
     * イージング関数を設定する
     * 
     * @param {Function|String} easing イージング関数
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    setEasing: function (easing) {
        return this._callMethod('setEasing', [easing]);
    },
    
    /**
     * アニメーション終了時のコールバックを設定する
     * 
     * @param {Function} callback アニメーション終了時のコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはオーナーインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    setCompleteCallback: function (callback, thisArg) {
        return this._callMethod('setCompleteCallback', [callback, thisArg || this._returnInstance]);
    },
    
    /**
     * アニメーション更新時のコールバックを設定する
     * 
     * @param {Function} callback アニメーション更新時のコールバック(初期値0、最終値1の時のイージングが渡される)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはオーナーインスタンスになる)
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    setStepCallback: function (callback, thisArg) {
        return this._callMethod('setStepCallback', [callback, thisArg || this._returnInstance]);
    },
    
    /**
     * アニメーション実行時にキューを使用するかどうかを設定する
     * 
     * @param {Boolean} useQueue キューを使用するかどうか
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    useQueue: function (useQueue) {
        return this._callMethod('useQueue', [useQueue]);
    },

    /**
     * アニメーションキューの実行を遅延させる
     * 
     * @param {Integer} delayTime 遅延時間(ミリ秒)
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    delay: function (delayTime) {
        return this._callMethod('delay', [delayTime]);
    },
    
    /**
     * 現在実行中のアニメーションを停止させ、次のアニメーションを実行する
     * 
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    stop: function () {
        return this._callMethod('stop');
    },
    
    /**
     * 現在実行中のアニメーションを終了させ、次のアニメーションを実行する
     * 
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    end: function () {
        return this._callMethod('end');
    },
    
    /**
     * 現在待機中のアニメーションのキューを破棄する
     * 
     * @return {Jeeel.Dom.ElementOperator.Animator} 自インスタンス
     */
    clearQueue: function () {
        return this._callMethod('clearQueue');
    },
    
    /**
     * アニメーションを実行する
     * 
     * @return {Jeeel.Dom.ElementOperator} オーナーインスタンス
     */
    animate: function () {
        this._callMethod('animate');
        
        return this._returnInstance;
    },
    
    /**
     * アニメーションが実行中かどうかを返す
     * 
     * @return {Boolean} 実行中かどうか
     */
    isAnimated: function () {
        for (var i = this._animators.length; i--;) {
            if (this._animators[i].isAnimated()) {
                return true;
            }
        }
        
        return false;
    },
    
    _callMethod: function (key, args) {
        for (var i = this._animators.length; i--;) {
            var animator = this._animators[i];
            
            animator[key].apply(animator, args || []);
        }
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.ElementOperator.Animator
};Jeeel.directory.Jeeel.Dom.Selector = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Selector/';
    }
};

/**
 * コンストラクタ
 *
 * @class セレクタを扱うクラス
 * @param {String} selector CSSセレクタ
 * @example
 * 以下が対応もしくは認識するセレクタの一覧(CSS1, CSS2, CSS3, CSS4の一部 + 独自セレクタ)
 * *
 * E
 * E[foo]
 * E[foo="bar"]
 * E[foo="bar" i]
 * E[foo~="bar"]
 * E[foo^="bar"]
 * E[foo$="bar"]
 * E[foo*="bar"]
 * E[foo|="en"]
 * E:root
 * E:empty
 * E:nth-child(n)
 * E:nth-last-child(n)
 * E:nth-of-type(n)
 * E:nth-last-of-type(n)
 * E:last-child
 * E:first-of-type
 * E:last-of-type
 * E:only-child
 * E:only-of-type
 * E:column(selector)
 * E:nth-column(n)
 * E:nth-last-column(n)
 * E:dir(ltr)
 * E:lang(fr)
 * E:any-link
 * E:link
 * E:visited
 * E:local-link
 * E:local-link(0)
 * E:target
 * E:scope
 * E:active
 * E:hover
 * E:focus
 * E:enabled
 * E:disabled
 * E:checked
 * E:indeterminate
 * E:required
 * E:optional
 * E:read-only
 * E:read-write
 * E::first-line
 * E::first-letter
 * E::before
 * E::after
 * E.warning
 * E#myid
 * E:not(s)
 * E:not(s1, s2)
 * E:matches(s1, s2)
 * E F
 * E > F
 * E + F
 * E ~ F
 * E! > F
 * E:-jeeel-hidden
 * E:-jeeel-visible
 * E:-jeeel-animated
 * ただし、:link, :visitedはセキュリティ上の理由でJSから取得する手段が無いためCSSと違った挙動をし、::before, ::after, ::first-line, ::first-letterは完全に無視される。
 * また、:active, :hover, :focusは今のところ全て空になる
 */
Jeeel.Dom.Selector = function (selector) {
    this._selector = selector;
    
    this._compile();
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} selector CSSセレクタ
 * @return {Jeeel.Dom.Selector} 作成したインスタンス
 */
Jeeel.Dom.Selector.create = function (selector) {
    return new this(selector);
};

Jeeel.Dom.Selector.prototype = {

    /**
     * CSSセレクタ
     *
     * @type String
     * @private
     */
    _selector: '',

    /**
     * CSSセレクタの対象別リスト
     *
     * @type Jeeel.Dom.Selector.NodeList[]
     * @private
     */
    _nodeLists: [],

    /**
     * セレクタの情報からElementのリストを得る
     *
     * @param {Element} root 検索ルート要素
     * @return {Element[]} Elementリスト
     */
    search: function (root) {
        
        this._resetCaches();
        
        return this._search(root);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Selector,
    
    /**
     * 通常検索を行う
     * 
     * @param {Element} root 検索のルートノード
     * @return {Element[]} 検索結果のリスト
     */
    _search: function (root) {
        var nodeLists = this._nodeLists;
        
        var i, l = 0, res = [];
        
        for (i = nodeLists.length; i--;) {
            res[i] = [];

            if (l < nodeLists[i].length) {
                l = nodeLists[i].length;
            }
            
            nodeLists[i].init([root]);
        }
        
        while (l--) {
            for (i = nodeLists.length; i--;) {
                res[i] = nodeLists[i].search();
                
                nodeLists[i].next();
            }
        }
        
        var tmp = res;
        
        res = [];
        
        for (i = nodeLists.length; i--;) {
            res = tmp[i].concat(res);
        }

        return this._uniqueSort(root, res);
    },
    
    /**
     * 指定した要素のリストをソーティングし、且重複を削除する
     * 
     * @param {Element} root ルートノード
     * @param {Element[]} elements 要素リスト
     * @return {Element[]} ソート・フィルタ後の要素リスト
     */
    _uniqueSort: function (root, elements) {
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var i, l, p, cnt, element, nodes = [];
        var idxLength = 0;
        
        for (i = 0, l = elements.length; i < l; i++) {
            element = elements[i];
            nodes[i] = {
                node: element,
                idxs: []
            };
            
            while (element && element !== root) {
                p = element.previousSibling;
                cnt = 1;

                while (p) {
                    if (p.nodeType === nodeType) {
                        cnt++;
                    }

                    p = p.previousSibling;
                }

                nodes[i].idxs.push(cnt);
                
                element = element.parentNode;
            }
            
            nodes[i].idxs.reverse();
            
            if (idxLength < nodes[i].idxs.length) {
                idxLength = nodes[i].idxs.length;
            }
        }
        
        nodes.sort(function (a, b) {
            var aidxs = a.idxs;
            var bidxs = b.idxs;
            
            for (var i = 0; i < idxLength; i++) {
                if ( ! aidxs[i] && ! bidxs[i]) {
                    break;
                } else if ( ! aidxs[i]) {
                    return -1;
                } else if ( ! bidxs[i]) {
                    return 1;
                }
                
                if (aidxs[i] < bidxs[i]) {
                    return -1;
                } else if (aidxs[i] > bidxs[i]) {
                    return 1;
                }
            }
            
            return 0;
        });
        
        var belm, res = [];
        
        for (i = 0, l = nodes.length; i < l; i++) {
            
            if (belm !== nodes[i].node) {
                res.push(nodes[i].node);
            }
            
            belm = nodes[i].node;
        }
        
        return res;
    },

    /**
     * CSSセレクタから対象となるDataのリストを作成する
     *
     * @private
     */
    _compile: function () {
        this._nodeLists = this.constructor.Compiler.compile(this._selector);
    },
    
    _resetCaches: function () {
        Jeeel._Object.JeeelDomSelector.resetCache();
    }
};

/**
 * @private
 */
Jeeel._Object.JeeelDomSelector = {
    _caches: [],
    
    resetCache: function () {
        this._caches = [];
    },
    
    getSameCellCols: function (cell, reverse) {
        var name;

        var cells;
        
        var owner = cell.parentNode;
        var i, j;
        
        while (true) {
            name = owner.nodeName.toUpperCase();
            
            if (name === 'THEAD' || name === 'TBODY' || name === 'TFOOT') {
                break;
            }
            
            owner = owner.parentNode;
        }
        
        for ( i = this._caches.length; i--;) {
            if (this._caches[i].key === owner) {
                cells = this._caches[i].val;
            }
        }
        
        if ( ! cells) {
            cells = this._analyzeCells(owner);
        }
        
        var res = [];
        
        for (i = cells.length; i--;) {
            for (j = cells[i].length; j--;) {
                if (cells[i][j] === cell) {
                    
                    res.push(reverse ? cells[i].length - j : j + 1);
                }
            }
        }
        
        this._caches.push({
            key: owner,
            val: cells
        });
        
        return res;
    },
    
    _analyzeCells: function (owner) {
        var cells = [];

        var tr = owner.firstChild;
        var rowLen = 0, cell, name, i, j;

        while (tr) {
            if (tr.nodeName.toUpperCase() === 'TR') {

                if ( ! cells[rowLen]) {
                    cells[rowLen] = [];
                }

                cell = tr.firstChild;

                var row = rowLen, col = 0;

                while (cell) {
                    name = cell.nodeName.toUpperCase();

                    if (name === 'TD' || name === 'TH') {

                        while(cells[row] && cells[row][col]) {
                            col++;
                        }

                        for (i = cell.rowSpan; i--;) {
                            for (j = cell.colSpan; j--;) {

                                if ( ! cells[row + i]) {
                                    cells[row + i] = [];
                                }

                                if ( ! cells[row + i][col + j]) {
                                    cells[row + i][col + j] = cell;
                                }
                            }
                        }

                        col += cell.colSpan;
                    }

                    cell = cell.nextSibling;
                }

                rowLen++;
            }

            tr = tr.nextSibling;
        }
        
        return cells;
    }
};

Jeeel.file.Jeeel.Dom.Selector = ['Compiler', 'NodeList', 'Node', 'Mock'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Selector, Jeeel.file.Jeeel.Dom.Selector);

/**
 * @staticClass セレクタをコンパイルするためのクラス
 */
Jeeel.Dom.Selector.Compiler = {
    
    /**
     * セレクタのコンパイルを行う
     * 
     * @param {String} selector セレクタ
     * @return {Jeeel.Dom.Selector.NodeList[]} コンパイル結果
     */
    compile: function (selector) {
      
        // 余分なコメント、前後のスペースの削除
        selector = selector.replace(/\/\*[\s\S]*?\*\//g, '')
                           .replace(/^\s+/g, '')
                           .replace(/\s\s*$/g, '');
        
        var parenthesisCount = 0;
        var bracketCount = 0;
        var quote = null;
        var i, j, l, $continue, chr, bchr = null, filtered = [];
        
        var res = [];
        
        for (i = 0, l = selector.length; i < l; i++) {
            chr = selector.charAt(i);
            
            switch (chr) {
                case '[':
                    bracketCount++;
                    $continue = true;
                    break;
                    
                case ']':
                    bracketCount--;
                    $continue = true;
                    break;
                    
                case '(':
                    parenthesisCount++;
                    $continue = true;
                    break;
                    
                case ')':
                    parenthesisCount--;
                    $continue = true;
                    break;
                  
                case "'":
                case '"':
                    if ( ! quote) {
                        quote = chr;
                    } else if (quote === chr) {
                        quote = null;
                    }
                    $continue = true;
                    break;
                    
                default:
                    $continue = false;
                    break;
            }
            
            if ($continue) {
                bchr = chr;
                filtered.push(chr);
                continue;
            }
            
            switch (chr) {
                case ' ':
                    if (quote) {
                        filtered.push(chr);
                    } else if (bchr !== chr) {
                        
                        switch (bchr) {
                            case '+':
                            case '~':
                            case '>':
                            case '/':
                                break;
                            
                            default:
                                filtered.push(chr);
                                break;
                        }
                    }
                    break;
                
                case '+':
                case '~':
                case '>':
                case '/':
                    if ( ! quote && bchr === ' ') {
                        filtered.pop();
                    }
                    
                    filtered.push(chr);
                    break;
                    
                case ',':
                    if ( ! parenthesisCount && ! bracketCount && ! quote) {
                        j = 0;
                        
                        while (filtered[j] && filtered[j] === ' ') {
                            filtered[j++] = '';
                        }
                        
                        while (filtered[filtered.length - 1] === ' ') {
                            filtered.pop();
                        }
                        
                        res[res.length] = this.compileNodeList(filtered.join(''));
                        filtered = [];
                    } else {
                        filtered.push(chr);
                    }
                    break;

                default:
                    filtered.push(chr);
                    break;
            }
            
            bchr = chr;
        }
        
        if ( ! parenthesisCount && ! bracketCount && ! quote) {
            
            j = 0;
            
            while (filtered[j] && filtered[j] === ' ') {
                filtered[j++] = '';
            }
            
            while (filtered[filtered.length - 1] === ' ') {
                filtered.pop();
            }

            res[res.length] = this.compileNodeList(filtered.join(''));
        }
        
        return res;
    },
    
    /**
     * ノードリストのコンパイルを行う
     * 
     * @param {String} selector セレクタ
     * @return {Jeeel.Dom.Selector.NodeList} コンパイル結果
     */
    compileNodeList: function (selector) {
        
        if (Jeeel.Dom.Selector.NodeList.caches[selector]) {
            return Jeeel.Dom.Selector.NodeList.caches[selector];
        }
        
        var nodeList = new Jeeel.Dom.Selector.NodeList(selector);
        
        var parenthesisCount = 0;
        var bracketCount = 0;
        var quote = null;
        var i, l, ref, type = 'default', newType = null;
        var beforeIndex = -1;

        for (i = 0, l = selector.length; i < l; i++) {
            var chr = selector.charAt(i);
            
            switch (chr) {
                case '[':
                    bracketCount++;
                    continue;
                    break;
                    
                case ']':
                    bracketCount--;
                    continue;
                    break;
                    
                case '(':
                    parenthesisCount++;
                    continue;
                    break;
                    
                case ')':
                    parenthesisCount--;
                    continue;
                    break;
                
                case "'":
                case '"':
                    if ( ! quote) {
                        quote = chr;
                    } else if (quote === chr) {
                        quote = null;
                    }
                    continue;
                    break;
                    
            }
            
            if (parenthesisCount || bracketCount || quote) {
                continue;
            }
            
            switch (chr) {
                case ' ':
                    newType = 'default';
                    break;
                    
                case '>':
                    newType = 'child';
                    break;
                    
                case '+':
                    newType = 'next';
                    break;
                    
                case '~':
                    newType = 'sbrother';
                    break;
                    
                case '/':
                    newType = 'reference';
                    break;
                    
                default:
                    continue;
                    break;
            }
            
            nodeList[nodeList.length++] = this.compileNode(selector.substring(beforeIndex + 1, i), type, ref);
            beforeIndex = i;
            type = newType;
            
            if (newType === 'reference') {
                beforeIndex = selector.indexOf('/', i + 1);
                
                if (beforeIndex < 0) {
                    throw new Error('Selector compile error.');
                }
                
                ref = selector.substring(i + 1, beforeIndex);
                
                i = beforeIndex;
            }
        }
        
        if (parenthesisCount || bracketCount || quote) {
            throw new Error('Selector compile error.');
        }
        
        nodeList[nodeList.length++] = this.compileNode(selector.substring(beforeIndex + 1, l), type, ref);
        
        var targetCnt = 0;
        
        for (i = nodeList.length; i--;) {
            if (nodeList[i].isTarget) {
                nodeList.targetIndex = i;
                targetCnt++;
            }
        }
        
        if (targetCnt > 1) {
            throw new Error('Selector compile error.');
        }
        
        return nodeList;
    },
    
    /**
     * ノードのコンパイルを行う
     * 
     * @param {String} selector セレクタ
     * @param {String} [relationType] このノードと他ノードの関係を示す文字列
     * @param {String} [ref] 属性参照のキー
     * @return {Jeeel.Dom.Selector.Node} コンパイル結果
     */
    compileNode: function (selector, relationType, ref) {
      
        if ( ! relationType) {
            relationType = 'default';
        }
        
        var cache = Jeeel.Dom.Selector.Node.caches[selector];
        
        if (cache && cache[relationType]) {
            return cache[relationType];
        }
        
        var node = new Jeeel.Dom.Selector.Node(selector, relationType, ref);
        
        var parenthesisCount = 0;
        var bracketCount = 0;
        var quote = null;
        var attrs = [];
        var beforeIndex = -1;
        var type = 'tag', newType;
        var i, l, chr, bchar, sp;
        
        for (i = 0, l = selector.length; i < l; i++) {
            chr = selector.charAt(i);
            
            sp = false;
            
            switch (chr) {
                case '#':
                    if ( ! parenthesisCount || ! bracketCount || ! quote) {
                        newType = 'id';
                    }
                    break;
                    
                case '.':
                    if ( ! parenthesisCount || ! bracketCount || ! quote) {
                        newType = 'class';
                    }
                    break;
                    
                case ':':
                    if (bchar === ':') {
                        continue;
                    } else if ( ! parenthesisCount || ! bracketCount || ! quote) {
                        newType = 'mock';
                    }
                    break;
                    
                case '!':
                    if ( ! parenthesisCount || ! bracketCount || ! quote) {
                        newType = 'parent';
                    }
                    break;
                    
                case '[':
                    if ( ! parenthesisCount || ! bracketCount || ! quote) {
                        newType = 'attr';
                        sp = true;
                    }
                    bracketCount++;
                    break;
                    
                case ']':
                    bracketCount--;
                    bchar = chr;
                    continue;
                    break;
                    
                case '(':
                    parenthesisCount++;
                    break;
                    
                case ')':
                    parenthesisCount--;
                    bchar = chr;
                    continue;
                    break;
                    
                case "'":
                case '"':
                    if ( ! quote) {
                        quote = chr;
                    } else if (quote === chr) {
                        quote = null;
                    }
                    bchar = chr;
                    continue;
                    break;
                    
                default:
                    continue;
                    break;
            }
            
            bchar = chr;
            
            sp = sp && bracketCount && ( ! parenthesisCount && ! quote);
            
            if ( ! sp && (parenthesisCount || bracketCount || quote)) {
                continue;
            }
            
            switch (type) {
                case 'tag':
                    node.tag = selector.substring(beforeIndex + 1, i).toUpperCase() || '*';
                    break;
                    
                case 'id':
                    node.id = selector.substring(beforeIndex + 1, i);
                    break;
                    
                case 'class':
                    node.classes.push(selector.substring(beforeIndex + 1, i));
                    break;
                    
                case 'attr':
                    attrs.push(selector.substring(beforeIndex + 1, i - 1));
                    break;
                    
                case 'mock':
                    node.mocks.push(this.compileMock(node, selector.substring(beforeIndex + 1, i)));
                    break;
                    
                case 'parent':
                    throw new Error('Selector compile error.');
                    break;
            }
            
            type = newType;
            beforeIndex = i;
        }
        
        switch (type) {
            case 'tag':
                node.tag = selector.substring(beforeIndex + 1, l).toUpperCase();
                
                if (node.tag === 'HTML' || node.tag === 'BODY' || node.tag === 'HEAD') {
                    node.isOnlyNode = true;
                }
                break;

            case 'id':
                if (node.id) {
                    throw new Error('Selector compile error.');
                }
                
                node.id = selector.substring(beforeIndex + 1, l);
                
                if ( ! node.id) {
                    throw new Error('Selector compile error.');
                }
                break;

            case 'class':
                node.classes.push(selector.substring(beforeIndex + 1, l));
                break;

            case 'attr':
                attrs.push(selector.substring(beforeIndex + 1, l - 1));
                break;

            case 'mock':
                node.mocks.push(this.compileMock(node, selector.substring(beforeIndex + 1, l)));
                break;
                
            case 'parent':
                if (selector.charAt(selector.length - 1) === chr) {
                    node.isTarget = true;
                }
                break;
        }
        
        node.attrs = this.compileAttribute(attrs);
        
        if ( ! node.isOnlyNode) {
            for (i = node.mocks.length; i--;) {
                if (node.mocks[i].isOnlyMock) {
                    node.isOnlyNode = true;
                    break;
                }
            }
        }
        
        return node;
    },
    
    /**
     * 複数のノードのコンパイルを行う
     * 
     * @param {String} selector セレクタ
     * @return {Jeeel.Dom.Selector.Node[]} コンパイル結果
     */
    compileNodes: function (selector) {
        var selectors = selector.replace(/\s+/g, '').split(',');
        var nodes = [];
        
        for (var i = 0, l = selectors.length; i < l; i++) {
            nodes[i] = this.compileNode(selectors[i]);
        }
        
        return nodes;
    },
    
    /**
     * 属性のコンパイルを行う
     * 
     * @param {String[]} selectors セレクタリスト
     * @return {Hash[]} コンパイル後の属性リスト
     */
    compileAttribute: function (selectors) {
        var attrReg = /([a-z0-9_\-]+)\s*(?:([\^|$*~]?=)\s*([\s\S]*))?/gi;
        var attrs = [];
        
        for (var i = 0, l = selectors.length; i < l; i++) {
            selectors[i].replace(attrReg, function (match, name, eq, value) {
                
                name = name.toLowerCase();
                
                if (eq) {
                    
                    var flg;
                    
                    value = value.replace(/^(["'])([\s\S]*)\1(?:\s+(i))?$/g, function (match, quot, orgValue, flag) {
                        flg = flag;
                        
                        return orgValue;
                    });
                    
                    if (flg !== 'i') {
                        flg = Jeeel.Dom.Selector.Node.IGNORE_CASE[name] ? 'i' : '';
                    }

                    switch (eq.charAt(0)) {
                        case '=':
                            attrs[attrs.length] = {
                                name: name,
                                reg: new RegExp('^' + Jeeel.String.escapeRegExp(value) + '$', 'g' + flg)
                            };
                            break;
                            
                        case '~':
                            attrs[attrs.length] = {
                                name: name,
                                reg: new RegExp('(?:^| )' + Jeeel.String.escapeRegExp(value) + '(?: |$)', 'g' + flg)
                            };
                            break;

                        case '^':
                            attrs[attrs.length] = {
                                name: name,
                                reg: new RegExp('^' + Jeeel.String.escapeRegExp(value), 'g' + flg)
                            };
                            break;

                        case '$':
                            attrs[attrs.length] = {
                                name: name,
                                reg: new RegExp(Jeeel.String.escapeRegExp(value) + '$', 'g' + flg)
                            };
                            break;

                        case '*':
                            attrs[attrs.length] = {
                                name: name,
                                reg: new RegExp(Jeeel.String.escapeRegExp(value), 'g' + flg)
                            };
                            break;
                            
                        case '|':
                            attrs[attrs.length] = {
                                name: name,
                                reg: new RegExp('^' + Jeeel.String.escapeRegExp(value) + '(?:-|$)', 'g' + flg)
                            };
                            break;

                        default:
                            break;
                    }

                    return '';
                }

                attrs[attrs.length] = {
                    name: name,
                    reg: '*'
                };

                return '';
            });
        }
        
        return attrs;
    },
    
    /**
     * 疑似クラスのコンパイルを行う
     * 
     * @param {Jeeel.Dom.Selector.Node} node 疑似クラスを所有するノード
     * @param {String} selector セレクタ
     * @return {Jeeel.Dom.Selector.Mock} コンパイル後の疑似クラス
     */
    compileMock: function (node, selector) {
        var mock = new Jeeel.Dom.Selector.Mock(node, selector);
        
        var reg = /^([a-z0-9_\-]+)(?:\((.*)\))?$/i;
        
        selector.replace(reg, function (match, name, args) {
            mock.name = name.toLowerCase();
            
            args = Jeeel.String.trim(args);
            
            if (args) {
                mock.args = args;
            }
        });
        
        return mock.compile();
    }
};
/**
 * コンストラクタ
 * 
 * @class セレクタの1つのグループを管理するクラス
 * @param {String} selector セレクタ
 */
Jeeel.Dom.Selector.NodeList = function (selector) {
    this.selector = selector;
    
    this.constructor.caches[selector] = this;
};

/**
 * インスタンスキャッシュ
 * 
 * @type Hash
 */
Jeeel.Dom.Selector.NodeList.caches = {};

Jeeel.Dom.Selector.NodeList.prototype = {
    
    /**
     * 元のselector
     * 
     * @type String
     */
    selector: '',
    
    /**
     * 要素数
     * 
     * @type Integer
     */
    length: 0,
    
    /**
     * 検索対象となるノードのインデックス
     * 
     * @type Integer
     */
    targetIndex: -1,
    
    /**
     * 検索結果の要素リスト
     * 
     * @type Element[]
     * @private
     */
    _elements: null,
    
    /**
     * 検索結果の要素リストの履歴
     * 
     * @type Element[]
     * @private
     */
    _histories: null,
    
    /**
     * 現在の実行ノードのインデックス
     * 
     * @type Integer
     * @private
     */
    _currentIndex: 0,
    
    /**
     * 初期化を行う
     * 
     * @param {Element[]} elements 要素リスト
     * @return {Jeeel.Dom.Selector.NodeList} 自インスタンス
     */
    init: function (elements) {
        this._elements = elements;
        this._histories = [];
        this._currentIndex = 0;
        
        return this;
    },
    
    /**
     * 次の要素単位に移る
     * 
     * @return {Jeeel.Dom.Selector.NodeList} 自インスタンス
     */
    next: function () {
        this._currentIndex++;
        
        return this;
    },
    
    /**
     * 現在の要素位置で検索を行い検索結果を返す
     * 
     * @return {Element[]} 要素リスト
     */
    search: function () {
        if (this.length <= this._currentIndex) {
            return this._elements;
        }
        
        var nodeType = Jeeel.Dom.Node.ELEMENT_NODE;
        var i, l, res = [], node = this[this._currentIndex];
        var tmp, history = [];
        var targetIndex = this.targetIndex;
        
        var search = function (target, f) {
            if ( ! f && node.isMatch(target)) {
                res.push(target);
                
                if (targetIndex >= 0) {
                    history.push({
                        idx: i,
                        elm: target
                    });
                }
                
                if (node.isOnlyNode) {
                    return;
                }
            } else if ( ! f && res.length && node.isOnlyNode) {
                return;
            }

            var child;

            switch (node.relationType) {
                
                case 'default':
                    child = target.firstChild;
                    
                    while(child) {

                        if (child.nodeType === nodeType) {
                            search(child, false);
                        }

                        child = child.nextSibling;
                    }
                    break;
              
                case 'child':
                    child = target.firstChild;
                    
                    while(f && child) {

                        if (child.nodeType === nodeType) {
                            search(child, false);
                        }

                        child = child.nextSibling;
                    }
                    break;
                    
                case 'next':
                    child = target.nextSibling;
                    
                    while(f && child) {

                        if (child.nodeType === nodeType) {
                            search(child, false);
                            break;
                        }

                        child = child.nextSibling;
                    }
                    break;
                    
                case 'sbrother':
                    child = target.nextSibling;
                    
                    while(f && child) {

                        if (child.nodeType === nodeType) {
                            search(child, false);
                        }

                        child = child.nextSibling;
                    }
                    break;
                    
                case 'reference':
                    break;
            }
        };
        
        for (i = 0, l = this._elements.length; i < l; i++) {
            search(this._elements[i], true);
        }
        
        this._elements = res;
        
        if (targetIndex >= 0) {
            this._histories.push(history);

            var j = this._currentIndex;

            while (targetIndex < j--) {
                history = this._histories[j + 1];

                tmp = [];
                
                var map = {};

                for (i = 0, l = history.length; i < l; i++) {
                  
                    if (map[history[i].idx]) {
                        history[i].idx = map[history[i].idx];
                    } else {
                        tmp.push(this._histories[j][history[i].idx]);
                        
                        map[history[i].idx] = history[i].idx = tmp.length - 1;
                    }
                }

                this._histories[j] = tmp;
            }

            if (this._currentIndex === this.length - 1) {
                for (i = 0; i < this.length; i++) {
                    if (this[i].isTarget) {
                        return this._convertHistory(this._histories[i]);
                    }
                }
            }
        }
        
        return this._elements;
    },
    
    _convertHistory: function (history) {
        var res = [];
        
        for (var i = history.length; i--;) {
            res[i] = history[i].elm;
        }
        
        return res;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Selector.NodeList
};
/**
 * コンストラクタ
 * 
 * @class セレクタの中で要素を示すクラス(スペース, ~, +, > などを除いたセレクタ)
 * @param {String} selector セレクタ
 * @param {String} relationType 一つ前のノードとの関係性を示す文字列
 * @param {String} [referenceKey] relationTypeが属性参照だった場合に指定
 */
Jeeel.Dom.Selector.Node = function (selector, relationType, referenceKey) {
    this.selector = selector;
    this.relationType = relationType || null;
    this.referenceKey = referenceKey || null;
    this.classes = [];
    this.mocks = [];
    
    if ( ! this.constructor.caches[selector]) {
        this.constructor.caches[selector] = {};
    }
    
    this.constructor.caches[selector][relationType] = this;
};

/**
 * キャッシュ
 * 
 * @type Hash
 */
Jeeel.Dom.Selector.Node.caches = {};

Jeeel.Dom.Selector.Node.IGNORE_CASE = {
    align: true,
    charset: true,
    type: true,
    'http-equiv': true,
    method: true,
    'accept-charset': true,
    lang: true,
    dir: true,
    rel: true,
    shape: true
};

Jeeel.Dom.Selector.Node.prototype = {
    
    /**
     * セレクタ
     * 
     * @type String
     */
    selector: '',
    
    /**
     * 関係文字列
     * 
     * @type String
     */
    relationType: null,
    
    /**
     * 関係が属性参照だった場合の属性名
     * 
     * @type String
     */
    referenceKey: null,
    
    /**
     * 関係が属性参照だった場合の複数のIDリスト
     * 
     * @type String[]
     */
    referenceAttrs: null,
    
    /**
     * タグ名
     * 
     * @type String
     */
    tag: '*',
    
    /**
     * ID名
     * 
     * @type String
     */
    id: '',
    
    /**
     * クラス名のリスト
     * 
     * @type String[]
     */
    classes: [],
    
    /**
     * 属性リスト
     * 
     * @type Hash[]
     */
    attrs: [],
    
    /**
     * 疑似クラスリスト
     * 
     * @type Jeeel.Dom.Selector.Mock[]
     */
    mocks: [],
    
    /**
     * このノードのヒットする要素が一つのみかどうか
     * 
     * @type Boolean
     */
    isOnlyNode: false,
    
    /**
     * この要素が検索結果の対象になるかどうか
     * 
     * @type Boolean
     */
    isTarget: false,
    
    /**
     * 指定した要素がセレクタと一致するかどうか返す
     * 
     * @param {Element} element 調べる要素
     * @return {Boolean} 一致したかどうか
     */
    isMatch: function (element) {
        
        var i, l;
        
        // ID
        if (this.id && this.id !== element.id) {
            return false;
        }
        
        var nodeName = element.nodeName.toUpperCase();
        
        // TAG
        if (this.tag !== '*' && this.tag !== nodeName) {
            return false;
        }
        
        var tmp, name, reg, val, classes;
        
        // CLASS
        if (this.classes.length) {
            tmp = element.classList;

            if (tmp) {
                classes = [];

                for (i = tmp.length; i--;) {
                    classes[i] = tmp.item(i);
                }
            } else if (element.className && ('baseVal' in Object(element.className))) {
                classes = element.className.baseVal.replace(/\s+/g, ' ').split(' ');
            } else {
                classes = element.className.replace(/\s+/g, ' ').split(' ');
            }

            for (i = this.classes.length; i--;) {
                if ( ! Jeeel.Hash.inHash(this.classes[i], classes, true)) {
                    return false;
                }
            }
        }
        
        // ATTR
        if (this.attrs.length) {
            for (i = this.attrs.length; i--;) {
                name = this.attrs[i].name;
                reg = this.attrs[i].reg;
                val = element.getAttribute(name);
                
                if (val === null) {
                    return false;
                } else if (reg === '*') {
                    continue;
                } else if ( ! val.match(reg)) {
                    return false;
                }
            }
        }
        
        // MOCK
        for (i = 0, l = this.mocks.length; i < l; i++) {
            if ( ! this.mocks[i].isMatch(element)) {
                return false;
            }
        }
        
        return true;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Selector.Node
};
/**
 * コンストラクタ
 * 
 * @class 擬似クラスと擬似要素を扱うクラス
 * @param {Jeeel.Dom.Selector.Node} node 親ノード
 * @param {String} selector セレクタ
 */
Jeeel.Dom.Selector.Mock = function (node, selector) {
    this.node = node;
    this.selector = selector;
};

/**
 * @namespace 擬似クラスのロジックを保有するネームスペース
 */
Jeeel.Dom.Selector.Mock.LOGIC = {
  
    /**
     * 否定擬似クラスを解析するロジック(:not)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    not: function (args) {
        return {
            isMatch: function (element) {
                for (var i = this._nodes.length; i--;) {
                    if (this._nodes[i].isMatch(element)) {
                        return false;
                    }
                }
                
                return true;
            },
            
            _nodes: Jeeel.Dom.Selector.Compiler.compileNodes(args)
        };
    },
    
    /**
     * :matches擬似クラスを解析するロジック(:matches)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    matches: function (args) {
        return {
            isMatch: function (element) {
                for (var i = this._nodes.length; i--;) {
                    if (this._nodes[i].isMatch(element)) {
                        return true;
                    }
                }
                
                return false;
            },
            
            _nodes: Jeeel.Dom.Selector.Compiler.compileNodes(args)
        };
    },
    
    /**
     * 言語擬似クラスを解析するロジック(:dir)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    dir: function (args) {
        if (args) {
            args = args.toLowerCase();
        }
        
        return {
            isMatch: (args ? function (element) {
                while(element) {
                    
                    if (element.dir) {
                        return element.dir.toLowerCase() === args;
                    }
                    
                    element = element.parentNode;
                }
                
                return false;
            } : Jeeel.Function.Template.RETURN_FALSE)
        };
    },
    
    /**
     * 言語擬似クラスを解析するロジック(:lang)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    lang: function (args) {
      
        if (args) {
            args = new RegExp('^' + args.toLowerCase() + '(?:-|$)', 'i');
        }
        
        return {
            isMatch: (args ? function (element) {
                while(element) {
                    
                    if (element.lang) {
                        return !!element.lang.match(args);
                    }
                    
                    element = element.parentNode;
                }
                
                return false;
            } : Jeeel.Function.Template.RETURN_FALSE)
        };
    },
    
    /**
     * :any-link擬似クラスを解析するロジック(:any-link)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    anyLink: function (args) {
        return {
            isMatch: function (element) {
                return element.nodeName.toUpperCase() === 'A' && !!element.href;
            }
        };
    },
    
    /**
     * :link擬似クラスを解析するロジック(:link)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    link: function (args) {
        return {
            isMatch: function (element) {
                return element.nodeName.toUpperCase() === 'A' && !!element.href;
            }
        };
    },
    
    /**
     * :visited擬似クラスを解析するロジック(:visited)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    visited: function (args) {
        return {
            isMatch: Jeeel.Function.Template.RETURN_FALSE
        };
    },
    
    /**
     * :local-link擬似クラスを解析するロジック(:local-link)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    localLink: function (args) {
        
        var limitHierarchy = false;
        
        if (args) {
            args = +args;
            
            limitHierarchy = ! isNaN(args);
            
            args++;
        }
        
        return {
            isMatch: (limitHierarchy ? function (element) { 
                var baseUrl = Jeeel.String.escapeRegExp(Jeeel.UserAgent.getBaseUrl());
                
                return element.nodeName.toUpperCase() === 'A' && element.href.match(new RegExp('^' + baseUrl + '(?:\\/[^\\/]*){' + args + '}$'));
            } : function (element) {
                var baseUrl = Jeeel.String.escapeRegExp(Jeeel.UserAgent.getBaseUrl());
                
                return element.nodeName.toUpperCase() === 'A' && element.href.match(new RegExp('^' + baseUrl));
            })
        };
    },
    
    /**
     * ターゲット擬似クラスを解析するロジック(:target)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    target: function (args) {
        return {
            isMatch: function (element) {
                var fragment = Jeeel.UserAgent.getFragment();
                
                if (element.id === fragment) {
                    return element;
                }
                
                return element.nodeName.toUpperCase() === 'A' && element.name === fragment;
            }
        };
    },
    
    /**
     * :scope擬似クラスを解析するロジック(:scope)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    scope: function (args) {
        return {};
    },
    
    /**
     * :active擬似クラスを解析するロジック(:active)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    active: function (args) {
        return {
            isMatch: Jeeel.Function.Template.RETURN_FALSE
        };
    },
    
    /**
     * :hover擬似クラスを解析するロジック(:hover)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    hover: function (args) {
        return {
            isMatch: Jeeel.Function.Template.RETURN_FALSE
        };
    },

    /**
     * :focus擬似クラスを解析するロジック(:focus)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    focus: function (args) {
        return {
            isMatch: Jeeel.Function.Template.RETURN_FALSE
        };
    },
    
    /**
     * :enabled擬似クラスを解析するロジック(:enabled)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    enabled: function (args) {
        return {
            isMatch: function (element) {
                return ! element.disabled;
            }
        };
    },
    
    /**
     * :disabled擬似クラスを解析するロジック(:disabled)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    disabled: function (args) {
        return {
            isMatch: function (element) {
                return element.disabled;
            }
        };
    },
    
    /**
     * :checked擬似クラスを解析するロジック(:checked)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    checked: function (args) {
        return {
            isMatch: function (element) {
                return element.checked;
            }
        };
    },
    
    /**
     * :indeterminate擬似クラスを解析するロジック(:indeterminate)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    indeterminate: function (args) {
        return {
            isMatch: function (element) {
                return element.nodeName.toUpperCase() === 'INPUT' && element.type && element.type.toLowerCase() === 'checkbox' && element.indeterminate;
            }
        };
    },
    
    /**
     * :required擬似クラスを解析するロジック(:required)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    required: function (args) {
        return {
            isMatch: function (element) {
                return element.required;
            }
        };
    },
    
    /**
     * :optional擬似クラスを解析するロジック(:optional)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    optional: function (args) {
        return {
            isMatch: function (element) {
                return 'required' in element && !element.required;
            }
        };
    },
    
    /**
     * :read-only擬似クラスを解析するロジック(:read-only)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    readOnly: function (args) {
        return {
            isMatch: function (element) {
                
                if (element.contentEditable === 'true') {
                    return false;
                }
                
                var e = element;
                
                while (e.contentEditable === 'inherit') {

                    e = e.parentNode;
                    
                    if (e.contentEditable === 'true') {
                        return false;
                    }
                }
                
                return element.readOnly;
            }
        };
    },
    
    /**
     * :read-write擬似クラスを解析するロジック(:read-write)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    readWrite: function (args) {
        return {
            isMatch: function (element) {
                
                if (element.contentEditable === 'true') {
                    return true;
                }
                
                var e = element;
                
                while (e.contentEditable === 'inherit') {

                    e = e.parentNode;
                    
                    if (e.contentEditable === 'true') {
                        return true;
                    }
                }
                
                return 'readOnly' in element && ! element.readOnly;
            }
        };
    },
    
    /**
     * :root擬似クラスを解析するロジック(:root)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    root: function (args) {
        return {
            isMatch: function (element) {
                return element.ownerDocument.documentElement === element;
            },
            
            isOnlyMock: true
        };
    },
    
    /**
     * :empty擬似クラスを解析するロジック(:empty)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    empty: function (args) {
        return {
            isMatch: function (element) {
                
                var type1 = Jeeel.Dom.Node.ELEMENT_NODE;
                var type2 = Jeeel.Dom.Node.TEXT_NODE;
                var child = element.firstChild;
                
                while (child) {
                    if (child.nodeType === type1 || child.nodeType === type2) {
                        return false;
                    }
                    
                    child = child.nextSibling;
                }
                
                return true;
            }
        };
    },
    
    /**
     * :first-child擬似クラスを解析するロジック(:first-child)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    firstChild: function (args) {
        return {
            isMatch: function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                var p = element.previousSibling;
                  
                while (p) {
                    if (p.nodeType === type) {
                        return false;
                    }
                    
                    p = p.previousSibling;
                }
                
                return true;
            }
        };
    },
    
    /**
     * :nth-child擬似クラスを解析するロジック(:nth-child)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    nthChild: function (args) {
        var val = +args;
        
        var isMatch, isNth;
        
        if (val) {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                var cnt = 1;
                  
                var p = element.previousSibling;
                  
                while (p) {
                    if (p.nodeType === type) {
                        cnt++;
                    }
                    
                    p = p.previousSibling;
                }

                return val === cnt;
            };
        } else if (args === 'odd') {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                var cnt = 1;
                  
                var p = element.previousSibling;
                  
                while (p) {
                    if (p.nodeType === type) {
                        cnt++;
                    }
                    
                    p = p.previousSibling;
                }

                return !!(cnt & 1);
            };
        } else if (args === 'even') {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                var cnt = 1;
                  
                var p = element.previousSibling;
                  
                while (p) {
                    if (p.nodeType === type) {
                        cnt++;
                    }
                    
                    p = p.previousSibling;
                }

                return !(cnt & 1);
            };
        } else {
            isNth = this._getNth(args);
            
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                var cnt = 1;
                  
                var p = element.previousSibling;
                  
                while (p) {
                    if (p.nodeType === type) {
                        cnt++;
                    }
                    
                    p = p.previousSibling;
                }

                return isNth(cnt);
            };
        }
        
        return {
            isMatch: isMatch
        };
    },
    
    /**
     * :last-child擬似クラスを解析するロジック(:last-child)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    lastChild: function (args) {
        return {
            isMatch: function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                var n = element.nextSibling;
                  
                while (n) {
                    if (n.nodeType === type) {
                        return false;
                    }
                    
                    n = n.nextSibling;
                }
                
                return true;
            }
        };
    },
    
    /**
     * :nth-last-child擬似クラスを解析するロジック(:nth-last-child)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    nthLastChild: function (args) {
        var val = +args;
        
        var isMatch, isNth;
        
        if (val) {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                var cnt = 1;
                  
                var n = element.nextSibling;
                  
                while (n) {
                    if (n.nodeType === type) {
                        cnt++;
                    }
                    
                    n = n.nextSibling;
                }

                return val === cnt;
            };
        } else if (args === 'odd') {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                var cnt = 1;
                  
                var n = element.nextSibling;
                  
                while (n) {
                    if (n.nodeType === type) {
                        cnt++;
                    }
                    
                    n = n.nextSibling;
                }

                return !!(cnt & 1);
            };
        } else if (args === 'even') {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                var cnt = 1;
                  
                var n = element.nextSibling;
                  
                while (n) {
                    if (n.nodeType === type) {
                        cnt++;
                    }
                    
                    n = n.nextSibling;
                }

                return !(cnt & 1);
            };
        } else {
            isNth = this._getNth(args);
            
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                var cnt = 1;
                  
                var n = element.nextSibling;
                  
                while (n) {
                    if (n.nodeType === type) {
                        cnt++;
                    }
                    
                    n = n.nextSibling;
                }

                return isNth(cnt);
            };
        }
        
        return {
            isMatch: isMatch
        };
    },
    
    /**
     * :only-child擬似クラスを解析するロジック(:only-child)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    onlyChild: function (args) {
        return {
            isMatch: function (element) {
                
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                var cnt = 0;
                  
                var n = element.parentNode.firstChild.nextSibling;
                  
                while (n) {
                    if (n.nodeType === type) {
                        cnt++;
                    }
                    
                    n = n.nextSibling;
                }
                
                return cnt === 1;
            }
        };
    },
    
    /**
     * :first-of-type擬似クラスを解析するロジック(:first-of-type)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    firstOfType: function (args) {
        return {
            isMatch: function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                
                var p = element.previousSibling;
                
                while (p) {
                    if (p.nodeType === type && p.nodeName === nodeName) {
                        return false;
                    }
                    
                    p = p.previousSibling;
                }
                
                return true;
            }
        };
    },
    
    /**
     * :nth-of-type擬似クラスを解析するロジック(:nth-of-type)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    nthOfType: function (args) {
        var val = +args;
        
        var isMatch, isNth;
        
        if (val) {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                var cnt = 1;
                var p = element.previousSibling;
                
                while (p) {
                    if (p.nodeType === type && p.nodeName === nodeName) {
                        cnt++;
                    }
                    
                    p = p.previousSibling;
                }
                
                return cnt === val;
            };
        } else if (args === 'odd') {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                var cnt = 1;
                var p = element.previousSibling;
                
                while (p) {
                    if (p.nodeType === type && p.nodeName === nodeName) {
                        cnt++;
                    }
                    
                    p = p.previousSibling;
                }
                
                return !!(cnt & 1);
            };
        } else if (args === 'even') {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                var cnt = 1;
                var p = element.previousSibling;
                
                while (p) {
                    if (p.nodeType === type && p.nodeName === nodeName) {
                        cnt++;
                    }
                    
                    p = p.previousSibling;
                }
                
                return !(cnt & 1);
            };
        } else {
            isNth = this._getNth(args);
            
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                var cnt = 1;
                var p = element.previousSibling;
                
                while (p) {
                    if (p.nodeType === type && p.nodeName === nodeName) {
                        cnt++;
                    }
                    
                    p = p.previousSibling;
                }
                
                return isNth(cnt);
            };
        }
        
        return {
            isMatch: isMatch
        };
    },
    
    /**
     * :last-of-type擬似クラスを解析するロジック(:last-of-type)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    lastOfType: function (args) {
        return {
            isMatch: function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                
                var n = element.nextSibling;
                
                while (n) {
                    if (n.nodeType === type && n.nodeName === nodeName) {
                        return false;
                    }
                    
                    n = n.nextSibling;
                }
                
                return true;
            }
        };
    },
    
    /**
     * :nth-last-of-type擬似クラスを解析するロジック(:nth-last-of-type)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    nthLastOfType: function (args) {
        var val = +args;
        
        var isMatch, isNth;
        
        if (val) {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                var cnt = 1;
                var n = element.nextSibling;
                
                while (n) {
                    if (n.nodeType === type && n.nodeName === nodeName) {
                        cnt++;
                    }
                    
                    n = n.nextSibling;
                }
                
                return cnt === val;
            };
        } else if (args === 'odd') {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                var cnt = 1;
                var n = element.nextSibling;
                
                while (n) {
                    if (n.nodeType === type && n.nodeName === nodeName) {
                        cnt++;
                    }
                    
                    n = n.nextSibling;
                }
                
                return !!(cnt & 1);
            };
        } else if (args === 'even') {
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                var cnt = 1;
                var n = element.nextSibling;
                
                while (n) {
                    if (n.nodeType === type && n.nodeName === nodeName) {
                        cnt++;
                    }
                    
                    n = n.nextSibling;
                }
                
                return !(cnt & 1);
            };
        } else {
            isNth = this._getNth(args);
            
            isMatch = function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                var cnt = 1;
                var n = element.nextSibling;
                
                while (n) {
                    if (n.nodeType === type && n.nodeName === nodeName) {
                        cnt++;
                    }
                    
                    n = n.nextSibling;
                }
                
                return isNth(cnt);
            };
        }
        
        return {
            isMatch: isMatch
        };
    },
    
    /**
     * :only-of-type擬似クラスを解析するロジック(:only-of-type)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    onlyOfType: function (args) {
        return {
            isMatch: function (element) {
                var type = Jeeel.Dom.Node.ELEMENT_NODE;
                
                if (element.parentNode.nodeType !== type) {
                    return false;
                }
                
                var nodeName = element.nodeName;
                var n = element.nextSibling;
                var p = element.previousSibling;
                
                while (n || p) {
                    
                    if (n) {
                        if (n.nodeType === type && n.nodeName === nodeName) {
                            return false;
                        }

                        n = n.nextSibling;
                    }
                    
                    if (p) {
                        if (p.nodeType === type && p.nodeName === nodeName) {
                            return false;
                        }

                        p = p.previousSibling;
                    }
                }
                
                return true;
            }
        };
    },
    
    /**
     * :nth-match擬似クラスを解析するロジック(:nth-match)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     * @ignore 未完成
     */
    nthMatch: function (args) {
        
        var isNth, nodes;
        
        args = args.match(/^(odd|even|[0-9n+\-]+)\s+of\s+(.+)$/g);
        
        isNth = this._getNth(args[1]);
        nodes = Jeeel.Dom.Selector.Compiler.compileNodes(args[2]);
        
        if ( ! (args[1] && args[2])) {
            throw new Error('Selector compile error.');
        }
        
        return {};
    },
    
    /**
     * :column擬似クラスを解析するロジック(:column)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    column: function (args) {
        var node = Jeeel.Dom.Selector.Compiler.compileNode(args);
        
        return {
            isMatch: function (element) {
                var name = element.nodeName.toUpperCase();
                
                if ( ! (name === 'TD' || name === 'TH')) {
                    return false;
                }
                
                return node.isMatch(element);
            }
        };
    },
    
    /**
     * :nth-column擬似クラスを解析するロジック(:nth-column)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    nthColumn: function (args) {
        var val = +args;
        
        var isMatch, isNth;
        
        if (val) {
            isMatch = function (element) {
                var name = element.nodeName.toUpperCase();
                
                if ( ! (name === 'TD' || name === 'TH')) {
                    return false;
                }
                
                var cols = Jeeel._Object.JeeelDomSelector.getSameCellCols(element);
                
                for (var i = cols.length; i--;) {
                    if (cols[i] === val) {
                        return true;
                    }
                }
                
                return false;
            };
        } else if (args === 'odd') {
            isMatch = function (element) {
                var name = element.nodeName.toUpperCase();
                
                if ( ! (name === 'TD' || name === 'TH')) {
                    return false;
                }
                
                var cols = Jeeel._Object.JeeelDomSelector.getSameCellCols(element);
                
                for (var i = cols.length; i--;) {
                    if (cols[i] & 1) {
                        return true;
                    }
                }
                
                return false;
            };
        } else if (args === 'even') {
            isMatch = function (element) {
                var name = element.nodeName.toUpperCase();
                
                if ( ! (name === 'TD' || name === 'TH')) {
                    return false;
                }
                
                var cols = Jeeel._Object.JeeelDomSelector.getSameCellCols(element);
                
                for (var i = cols.length; i--;) {
                    if ( ! (cols[i] & 1)) {
                        return true;
                    }
                }
                
                return false;
            };
        } else {
            isNth = this._getNth(args);
            
            isMatch = function (element) {
                var name = element.nodeName.toUpperCase();
                
                if ( ! (name === 'TD' || name === 'TH')) {
                    return false;
                }
                
                var cols = Jeeel._Object.JeeelDomSelector.getSameCellCols(element);
                
                for (var i = cols.length; i--;) {
                    if (isNth(cols[i])) {
                        return true;
                    }
                }
                
                return false;
            };
        }
        
        return {
            isMatch: isMatch
        };
    },
    
    /**
     * :nth-last-column擬似クラスを解析するロジック(:nth-last-column)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    nthLastColumn: function (args) {
        var val = +args;
        
        var isMatch, isNth;
        
        if (val) {
            isMatch = function (element) {
                var name = element.nodeName.toUpperCase();
                
                if ( ! (name === 'TD' || name === 'TH')) {
                    return false;
                }
                
                var cols = Jeeel._Object.JeeelDomSelector.getSameCellCols(element, true);
                
                for (var i = cols.length; i--;) {
                    if (cols[i] === val) {
                        return true;
                    }
                }
                
                return false;
            };
        } else if (args === 'odd') {
            isMatch = function (element) {
                var name = element.nodeName.toUpperCase();
                
                if ( ! (name === 'TD' || name === 'TH')) {
                    return false;
                }
                
                var cols = Jeeel._Object.JeeelDomSelector.getSameCellCols(element, true);
                
                for (var i = cols.length; i--;) {
                    if (cols[i] & 1) {
                        return true;
                    }
                }
                
                return false;
            };
        } else if (args === 'even') {
            isMatch = function (element) {
                var name = element.nodeName.toUpperCase();
                
                if ( ! (name === 'TD' || name === 'TH')) {
                    return false;
                }
                
                var cols = Jeeel._Object.JeeelDomSelector.getSameCellCols(element, true);
                
                for (var i = cols.length; i--;) {
                    if ( ! (cols[i] & 1)) {
                        return true;
                    }
                }
                
                return false;
            };
        } else {
            isNth = this._getNth(args);
            
            isMatch = function (element) {
                var name = element.nodeName.toUpperCase();
                
                if ( ! (name === 'TD' || name === 'TH')) {
                    return false;
                }
                
                var cols = Jeeel._Object.JeeelDomSelector.getSameCellCols(element, true);
                
                for (var i = cols.length; i--;) {
                    if (isNth(cols[i])) {
                        return true;
                    }
                }
                
                return false;
            };
        }
        
        return {
            isMatch: isMatch
        };
    },
    
   /**
     * ::first-line擬似要素を解析するロジック(::first-line)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    firstLine: function (args) {
        return {};
    },
    
    /**
     * ::first-letter擬似要素を解析するロジック(::first-letter)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    firstLetter: function (args) {
        return {};
    },
    
    /**
     * ::before擬似要素を解析するロジック(::before)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    before: function (args) {
        return {};
    },
    
    /**
     * ::after擬似要素を解析するロジック(::after)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    after: function (args) {
        return {};
    },
    
    /**
     * カスタム擬似クラス、非表示要素に適用(:-jeeel-hidden)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    JeeelHidden: function (args) {
        return {
            isMatch: function (element) {
                
                if (element.nodeName.toUpperCase() === 'INPUT' && element.type === 'hidden') {
                    return true;
                }
                
                var style = Jeeel.Document.getComputedStyle(element);
                
                return style.display === 'none' || style.visibility === 'hidden';
            }
        };
    },
    
    /**
     * カスタム擬似クラス、表示要素に適用(:-jeeel-visible)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    JeeelVisible: function (args) {
        return {
            isMatch: function (element) {
                
                if (element.nodeName.toUpperCase() === 'INPUT' && element.type === 'hidden') {
                    return false;
                }
                
                var style = Jeeel.Document.getComputedStyle(element);
                
                return style.display !== 'none' && style.visibility !== 'hidden';
            }
        };
    },
    
    /**
     * カスタム擬似クラス、アニメーション中の要素に適用(:-jeeel-animated)
     * 
     * @param {String} args 引数
     * @return {Hash} ロジック構成要素
     */
    JeeelAnimated: function (args) {
        return {
            isMatch: function (element) {
                return Jeeel.Hash.inHash(element, Jeeel.Dom.Style.Animation.animated, true);
            }
        };
    },
    
    /**
     * nth系の引数部分を解析する関数を取得する
     * 
     * @param {String} nth 引数
     * @return {Function} 引数解析関数
     */
    _getNth: function (nth) {
        
        if (nth === 'odd') {
            return new Function('i',
                'return !!(i & 1);'
            );
        } else if (nth === 'even') {
            return new Function('i',
                'return !(i & 1);'
            );
        } else if (nth.match(/^[0-9]+$/g)) {
            return new Function('i',
                'return i === ' + nth + ';'
            );
        }
        
        var minus = !!nth.match(/-[0-9]*n/g);
        
        return new Function('i,n,pnth', 
            'if ( ! n) {n = 0;}var nth = ' + nth.replace(/(-?[0-9]+)n/g, '$1*n') + ';if (nth === pnth) {return false;}return (i === nth) || (' + (minus ? 'i < nth' : 'i > nth') + ' ? arguments.callee(i, n + 1, nth) : false);'
        );
    }
};

Jeeel.Dom.Selector.Mock.prototype = {
  
    /**
     * 擬似クラスセレクタ
     * 
     * @type String
     */
    selector: '',
    
    /**
     * 親ノード
     * 
     * @type Jeeel.Dom.Selector.Node
     */
    node: null,
    
    /**
     * 擬似クラスの名前
     * 
     * @type String
     */
    name: '',
    
    /**
     * 擬似クラスの引数
     * 
     * @type String
     */
    args: '',
    
    /**
     * 1つの要素にしかヒットしかないかどうか
     * 
     * @type Boolean
     */
    isOnlyMock: false,
    
    /**
     * 指定した要素がセレクタと一致するかどうか返す
     * 
     * @param {Element} element 調べる要素
     * @return {Boolean} 一致したかどうか
     */
    isMatch: function (element) {
        return true;
    },
    
    /**
     * 現在の情報を元にロジックを構築する
     * 
     * @return {Jeeel.Dom.Selector.Mock} 自インスタンス
     */
    compile: function () {
        
        var type = Jeeel.String.toCamelCase(this.name);
        var tmp = this.constructor.LOGIC[type] && this.constructor.LOGIC[type](this.args);
        
        if ( ! tmp) {
            return this;
        }
        
        for (var key in tmp) {
            this[key] = tmp[key];
        }

        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Dom.Selector.Mock
};Jeeel.directory.Jeeel.Dom.Behavior = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Dom + 'Behavior/';
    }
};

/**
 * @namespace DOMの挙動を変更するためのネームスペース
 */
Jeeel.Dom.Behavior = {
    
};

Jeeel.file.Jeeel.Dom.Behavior = ['Rollover', 'Placeholder', 'Autofocus', 'EditInplace', 'Autoresize'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Dom.Behavior, Jeeel.file.Jeeel.Dom.Behavior);

/**
 * ロールオーバーを有効にする
 * 
 * @return {Jeeel.Dom.Behavior} 自クラス
 */
Jeeel.Dom.Behavior.enableRollover = function () {
  
    Jeeel.Dom.Behavior.Rollover.addLoadEvent();
    
    return this;
};

/**
 * ロールオーバーを実現するためのクラス
 */
Jeeel.Dom.Behavior.Rollover = {
    
    _prefix: {
        on: '',
        off: ''
    },
    
    _suffix: {
        on: '_on',
        off: '_off'
    },
    
    /**
     * 読み込み時のイベントに登録する
     * 
     * @return {Jeeel.Dom.Behavior.Rollover} 自クラス
     */
    addLoadEvent: function () {
        Jeeel.addLoadEvent(function () {
            var elms = Jeeel.Document.getElementsByTagName('input');

            this.rollover(elms.concat(Jeeel.Document.getElementsByTagName('img')));

            elms = null;
        }, this);
        
        return this;
    },
    
    /**
     * 先頭のロールオーバーパターンを設定する
     * 
     * @param {String} prefixOn ロールオーバー時の先頭パターン
     * @param {String} prefixOff ロールアウト時の先頭パターン
     * @return {Jeeel.Dom.Behavior.Rollover} 自クラス
     */
    setPrefixPattern: function (prefixOn, prefixOff) {
        this._prefix = {
            on: prefixOn,
            off: prefixOff
        };
        
        return this;
    },
    
    /**
     * 後尾のロールオーバーパターンを設定する
     * 
     * @param {String} suffixOn ロールオーバー時の後尾パターン
     * @param {String} suffixOff ロールアウト時の後尾パターン
     * @return {Jeeel.Dom.Behavior.Rollover} 自クラス
     */
    setSuffixPattern: function (suffixOn, suffixOff) {
        this._suffix = {
            on: suffixOn,
            off: suffixOff
        };
        
        return this;
    },
    
    /**
     * イメージのロールオーバーを行う
     * 
     * @param {Element|Element[]} elements イメージもしくはイメージリスト(内部に他のElementが入っていた場合無視する)
     * @return {Jeeel.Dom.Behavior.Rollover} 自クラス
     */
    rollover: function (elements) {
        if (Jeeel.Type.isElement(elements)) {
            elements = [elements];
        }
        
        if ( ! Jeeel.Type.isArray(elements)) {
            throw new Error('引数が間違っています。');
        }
        
        var over, out;
        
        (function (pover, pout, sover, sout) {
            
            /**
             * @ignore
             */
            over = function () {
                var src = this.src;
                
                if (pout || pover) {
                    src = src.replace(new RegExp('/?' + Jeeel.String.escapeRegExp(pout) + '([^/]*)$'), '/' + pover + '$1');
                }
                
                if (sout || sover) {
                    src = src.replace(sout + '.', sover + '.');
                }
                
                this.src = src;
            };

            /**
             * @ignore
             */
            out = function () {
                var src = this.src;
                
                if (pover || pout) {
                    src = src.replace(new RegExp('/?' + Jeeel.String.escapeRegExp(pover) + '([^/]*)$'), '/' + pout + '$1');
                }
                
                if (sover || sout) {
                    src = src.replace(sover + '.', sout + '.');
                }
                
                this.src = src;
            };
        })(this._prefix.on, this._prefix.off, this._suffix.on, this._suffix.off);
        
        var reg = new RegExp('\\/?' + Jeeel.String.escapeRegExp(this._prefix.off) + '[^/]*' + Jeeel.String.escapeRegExp(this._suffix.off) + '\\.[^.]+$');
        
        for (var i = elements.length; i--;) {
            var element = elements[i];
            var tagName = element.tagName && element.tagName.toUpperCase();
            
            if (tagName === 'IMG' || tagName === 'INPUT' && element.type.toLowerCase() === 'image') {
                
                if ( ! element.src.match(reg)) {
                    continue;
                }
                
                elements[i].onmouseover = over;
                elements[i].onmouseout = out;
            }
        }
        
        return this;
    }
};

/**
 * プレースホルダを有効にする
 * 
 * @return {Jeeel.Dom.Behavior} 自クラス
 */
Jeeel.Dom.Behavior.enablePlaceholder = function () {
  
    Jeeel.Dom.Behavior.Placeholder.addLoadEvent();
    
    return this;
};

/**
 * HTML5のプレースホルダを実現するためのクラス
 */
Jeeel.Dom.Behavior.Placeholder = {
  
    /**
     * ストレージ取得の際に指定する名前
     * 
     * @type String
     * @constant
     */
    STORAGE_NAME: 'jeeel-dom-behavior-placeholder',
    
    /**
     * 使用可能な要素のリスト
     * 
     * @type Hash
     * @constant
     */
    USABLE_LIST: {
        NODES: ['INPUT', 'TEXTAREA'],
        TYPES: ['text', 'search', 'url', 'tel', 'email', 'password']
    },
    
    /**
     * 読み込み時のイベントに登録する
     * 
     * @return {Jeeel.Dom.Behavior.Placeholder} 自クラス
     */
    addLoadEvent: function () {
        Jeeel.addLoadEvent(function () {
            var elms = Jeeel.Document.getElementsByTagName('input');

            this.hold(elms.concat(Jeeel.Document.getElementsByTagName('textarea')));

            elms = null;
        }, this);
        
        return this;
    },
    
    /**
     * プレースホルダを適用する
     * 
     * @param {Element|Element[]} inputs プレースホルダを適用する要素
     * @return {Jeeel.Dom.Behavior.Placeholder} 自クラス
     */
    hold: function (inputs) {
        
        if (inputs instanceof Jeeel.Dom.ElementOperator) {
            inputs = inputs.getAll();
        } else if ( ! Jeeel.Type.isArray(inputs)) {
            inputs = [inputs];
        }
        
        var forms = [];
        
        for (var i = inputs.length; i--;) {
            
            var input = inputs[i];
            var nodeName = input.nodeName.toUpperCase();
            var plc = input.getAttribute('placeholder');
            
            if ( ! plc) {
                continue;
            } else if ( ! Jeeel.Hash.inHash(nodeName, this.USABLE_LIST.NODES, true)) {
                continue;
            } else if (nodeName === 'INPUT' && ! Jeeel.Hash.inHash(input.type, this.USABLE_LIST.TYPES, true)) {
                continue;
            }
            
            // オーナーのフォームに対して送信時にplaceholder用の値を削除するトリガーをセットする
            if (input.form && ! Jeeel.Hash.inHash(input.form, forms, true)) {
                Jeeel.Dom.Event.addEventListener(input.form, Jeeel.Dom.Event.Type.SUBMIT, this._submit, this);
                
                forms[forms.length] = input.form;
            }

            var storage = Jeeel.Storage.Object(input, this.STORAGE_NAME);
            
            storage.set('str', plc)
                   .set('color', input.style.color)
                   .set('holded', false);
            
            Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.FOCUS, this._focus, this);
            Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.BLUR, this._blur, this);
            
            this._blur({currentTarget: input});
        }
        
        return this;
    },
    
    /**
     * プレースホルダーが表示中かどうかを返す
     * 
     * @param {Element} input プレースホルダーの有無を確認する要素
     * @return {Boolean} プレースホルダーが表示中かどうか
     */
    isHolded: function (input) {
        
        if ( ! input || ! input.nodeName) {
            return false;
        }
        
        var nodeName = input.nodeName.toUpperCase();
        var plc = input.getAttribute('placeholder');

        if ( ! plc) {
            return false;
        } else if ( ! Jeeel.Hash.inHash(nodeName, this.USABLE_LIST.NODES, true)) {
            return false;
        } else if (nodeName === 'INPUT' && ! Jeeel.Hash.inHash(input.type, this.USABLE_LIST.TYPES, true)) {
            return false;
        } else if ( ! Jeeel.Storage.Object.exists(input, this.STORAGE_NAME)) {
            return false;
        }

        var storage = Jeeel.Storage.Object(input, this.STORAGE_NAME);

        return !!storage.get('holded');
    },
    
    _focus: function (e) {
        var elm = e.currentTarget;
        var storage = Jeeel.Storage.Object(elm, this.STORAGE_NAME);
        
        if (storage.get('holded')) {
            elm.value = '';
            
            elm.style.color = storage.get('color');
            
            storage.set('holded', false);
        }
    },
    
    _blur: function (e) {
        var elm = e.currentTarget;
        var storage = Jeeel.Storage.Object(elm, this.STORAGE_NAME);
        
        if ( ! elm.value) {
            var style = elm.style;
            
            storage.set('color', style.color)
                   .set('holded', true);
            
            style.color = '#B9AAC7';
            
            elm.value = storage.get('str');
        }
    },
    
    _submit: function (e) {
        var form = e.currentTarget;
        var inputs = form.elements;

        for (var i = inputs.length; i--;) {
            var input = inputs[i];
            
            if (this.isHolded(input)) {
                input.value = '';
            }
        }
    },
    
    _init: function () {
        delete this._init;
        
        if ( ! Jeeel._doc) {
            return;
        }
        
        var input = Jeeel._doc.createElement('input');
        
        input.type = 'text';
        
        if ('placeholder' in input) {
            this.hold = Jeeel.Function.Template.RETURN_THIS;
        }
        
        input = null;
    }
};

Jeeel.Dom.Behavior.Placeholder._init();

/**
 * オートフォーカスを有効にする
 * 
 * @return {Jeeel.Dom.Behavior} 自クラス
 */
Jeeel.Dom.Behavior.enableAutofocus = function () {
  
    Jeeel.Dom.Behavior.Autofocus.addLoadEvent();
    
    return this;
};

/**
 * HTML5のオートフォーカスを実現するためのクラス
 */
Jeeel.Dom.Behavior.Autofocus = {
    
    _focused: false,
    
    /**
     * 読み込み時のイベントに登録する
     * 
     * @return {Jeeel.Dom.Behavior.Autofocus} 自クラス
     */
    addLoadEvent: function () {
        Jeeel.addLoadEvent(function () {
            var elms = Jeeel.Document.getElementsByAttribute('autofocus', '*');

            this.focus(elms[0]);

            elms = null;
        }, this);
        
        return this;
    },
    
    /**
     * フォーカスを当てる
     * 
     * @param {Element} element フォーカス対象の要素
     * @return {Jeeel.Dom.Behavior.Autofocus} 自クラス
     */
    focus: function (element) {
        if ( ! element || this._focused) {
            return this;
        }
        
        var focus = element.getAttribute && element.getAttribute('autofocus');
        
        if ( ! focus) {
            return this;
        }
        
        element.focus();
        
        this._focused = true;
        
        return this;
    },
    
    _init: function () {
        delete this._init;
        
        if ( ! Jeeel._doc) {
            return;
        }
        
        var input = Jeeel._doc.createElement('input');
        
        input.type = 'text';
        
        if ('autofocus' in input) {
            this.focus = Jeeel.Function.Template.RETURN_THIS;
        }
        
        input = null;
    }
};

Jeeel.Dom.Behavior.Autofocus._init();

/**
 * エディットインプレースを有効にする
 * 
 * @param {Integer} [type)] 挙動の種類
 * @return {Jeeel.Dom.Behavior} 自クラス
 */
Jeeel.Dom.Behavior.enableEditInplace = function (type) {
  
    Jeeel.Dom.Behavior.EditInplace.addLoadEvent(type);
    
    return this;
};

/**
 * その場編集の機能を実現するためのクラス
 */
Jeeel.Dom.Behavior.EditInplace = {
    
    /**
     * ストレージ取得の際に指定する名前
     * 
     * @type String
     * @constant
     */
    STORAGE_NAME: 'jeeel-dom-behavior-editinplace',
    
    /**
     * フォーカスが当たった際に編集可能になる挙動を示す
     * 
     * @type String
     * @constant
     */
    EDIT_TYPE_FOCUS: 0,
    
    /**
     * マウスオーバーしたら編集可能になる挙動を示す
     * 
     * @type String
     * @constant
     */
    EDIT_TYPE_OVER: 1,
    
    /**
     * 使用可能な要素のリスト
     * 
     * @type Hash
     * @constant
     */
    USABLE_LIST: {
        NODES: ['INPUT', 'TEXTAREA'],
        TYPES: ['text', 'search', 'url', 'tel', 'email', 'password']
    },
    
    /**
     * 読み込み時のイベントに登録する
     * 
     * @param {Integer} [type)] 挙動の種類
     * @return {Jeeel.Dom.Behavior.EditInplace} 自クラス
     */
    addLoadEvent: function (type) {
        Jeeel.addLoadEvent(function () {
            var elms = Jeeel.Document.getElementsByTagName('input');

            this.enable(elms.concat(Jeeel.Document.getElementsByTagName('textarea')), type);

            elms = null;
        }, this);
        
        return this;
    },
    
    /**
     * その場編集を適用する
     * 
     * @param {Element|Element[]} inputs その場編集を適用する要素
     * @param {Integer} [type)] 挙動の種類
     * @return {Jeeel.Dom.Behavior.EditInplace} 自クラス
     */
    enable: function (inputs, type) {
        if (inputs instanceof Jeeel.Dom.ElementOperator) {
            inputs = inputs.getAll();
        } else if ( ! Jeeel.Type.isArray(inputs)) {
            inputs = [inputs];
        }
        
        for (var i = inputs.length; i--;) {
            var input = inputs[i];
            var nodeName = input.nodeName.toUpperCase();

            if ( ! Jeeel.Hash.inHash(nodeName, this.USABLE_LIST.NODES, true)) {
                continue;
            } else if (nodeName === 'INPUT' && ! Jeeel.Hash.inHash(input.type, this.USABLE_LIST.TYPES, true)) {
                continue;
            }
            
            switch (type) {
                case this.EDIT_TYPE_OVER:
                    Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.MOUSE_OVER, this._over, this);
                    Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.MOUSE_OUT, this._out, this);
                    Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.FOCUS, this._focus, this);
                    Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.BLUR, this._blur, this);
                    break;
                    
                case this.EDIT_TYPE_FOCUS:
                default:
                    Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.FOCUS, this._focus, this);
                    Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.BLUR, this._blur, this);
                    break;
            }
            
            this._hide(input);
        }
        
        return this;
    },
    
    _over: function (e) {
        var target = e.currentTarget;
        var storage = Jeeel.Storage.Object(target, this.STORAGE_NAME);
        
        if ( ! storage.get('focused')) {
            this._show(target);
        }
    },
    
    _out: function (e) {
        var target = e.currentTarget;
        var storage = Jeeel.Storage.Object(target, this.STORAGE_NAME);
        
        if ( ! storage.get('focused')) {
            this._hide(target);
        }
    },
    
    _focus: function (e) {
        var target = e.currentTarget;
        var storage = Jeeel.Storage.Object(target, this.STORAGE_NAME);
        
        storage.set('focused', true);
        
        this._show(target);
    },
    
    _blur: function (e) {
        var target = e.currentTarget;
        var storage = Jeeel.Storage.Object(target, this.STORAGE_NAME);
        
        storage.set('focused', false);
        
        this._hide(target);
    },
    
    _show: function (target) {
        var style = target.style;

        if ('readOnly' in target) {
            target.readOnly = false;
        }
        
        style.backgroundColor = '';
        style.borderStyle = '';
        style.cursor = '';

        if ('resize' in style) {
            style.resize = '';
        }
    },
    
    _hide: function (target) {
        var style = target.style;
        var css = [
            'background-color: transparent',
            'border-style: none',
            'cursor: pointer'
        ];
        
        if ('resize' in style) {
            css[css.length] = 'resize: none';
        }
        
        if ('readOnly' in target) {
            target.readOnly = true;
        }
        
        style.cssText += ';' + css.join(';');
    }
};

/**
 * オートリサイズを有効にする
 * 
 * @param {Hash} [limit] サイズ制限
 * @return {Jeeel.Dom.Behavior} 自クラス
 */
Jeeel.Dom.Behavior.enableAutoresize = function (limit) {
  
    Jeeel.Dom.Behavior.Autoresize.addLoadEvent(limit);
    
    return this;
};

/**
 * オートリサイズを実現するクラス
 */
Jeeel.Dom.Behavior.Autoresize = {
    
    /**
     * サイズ制限
     * 
     * @type Hash
     * @constant
     */
    LIMIT: {
        min: 15,
        max: -1
    },
    
    /**
     * ストレージ取得の際に指定する名前
     * 
     * @type String
     * @constant
     */
    STORAGE_NAME: 'jeeel-dom-behavior-autoresize',
    
    /**
     * 使用可能な要素のリスト
     * 
     * @type Hash
     * @constant
     */
    USABLE_LIST: {
        NODES: ['INPUT', 'TEXTAREA'],
        TYPES: ['text', 'search', 'url', 'tel', 'email', 'password']
    },
    
    /**
     * 読み込み時のイベントに登録する
     * 
     * @param {Hash} [limit] サイズ制限
     * @return {Jeeel.Dom.Behavior.Autoresize} 自クラス
     */
    addLoadEvent: function (limit) {
        Jeeel.addLoadEvent(function () {
            var elms = Jeeel.Document.getElementsByTagName('input');

            this.resize(elms.concat(Jeeel.Document.getElementsByTagName('textarea')), limit);

            elms = null;
        }, this);
        
        return this;
    },
    
    /**
     * オートリサイズを有効にする
     * 
     * @param {Element|Element[]} inputs オートリサイズを適用する要素
     * @param {Hash} [limit] サイズ制限
     * @return {Jeeel.Dom.Behavior.Autoresize} 自クラス
     */
    resize: function (inputs, limit) {
        if (inputs instanceof Jeeel.Dom.ElementOperator) {
            inputs = inputs.getAll();
        } else if ( ! Jeeel.Type.isArray(inputs)) {
            inputs = [inputs];
        }
        
        if ( ! limit) {
            limit = {};
        }
        
        var keys = ['width', 'height'], 
            key, i;
        
        for (i = keys.length; i--;) {
            
            key = keys[i];
            
            if ( ! limit[key]) {
                limit[key] = {};
            }
            
            if ( ! ('min' in limit[key])) {
                limit[key].min = limit.min || this.LIMIT.min;
            }

            if ( ! ('max' in limit[key])) {
                limit[key].max = limit.max || this.LIMIT.max;
            }
        }
        
        for (i = inputs.length; i--;) {
            var input = inputs[i];
            var nodeName = input.nodeName.toUpperCase();

            if ( ! Jeeel.Hash.inHash(nodeName, this.USABLE_LIST.NODES, true)) {
                continue;
            } else if (nodeName === 'INPUT' && ! Jeeel.Hash.inHash(input.type, this.USABLE_LIST.TYPES, true)) {
                continue;
            }
            
            Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.KEY_DOWN, this._keyDown, this);
            Jeeel.Dom.Event.addEventListener(input, Jeeel.Dom.Event.Type.KEY_UP, this._keyUp, this);
            
            input.style.overflow = 'hidden';
            
            var storage = Jeeel.Storage.Object(input, this.STORAGE_NAME);
            
            storage.set('limit', limit);
        }
    },
    
    _keyDown: function (e) {
        var target = e.currentTarget;
        var value = target.value;
        var charCode = String.fromCharCode(e.getKeyCode()) || '';
        
        if (charCode === '\u000D') {
            charCode = target.nodeName.toUpperCase() === 'TEXTAREA' && '\n' || '';
        } else if (charCode === '\u0008') {
            value = value.slice(0, value.length - 1);
            charCode = '';
        } else if ( ! e.shiftKey) {
            charCode = charCode.toLowerCase();
        }
        
        if (charCode.length > 1) {
            charCode = '';
        }
        
        this._setSize(target, value + (charCode || ''));
    },
    
    _keyUp: function (e) {
        var target = e.currentTarget;
        
        this._setSize(target, target.value);
    },
    
    _setSize: function (target, txt) {
        var nodeName = target.nodeName.toUpperCase();
        var isMultiline = nodeName === 'TEXTAREA';
        var wrapper = new Jeeel.Dom.Element(target);
        
        var size = Jeeel.String.getTextSize(txt, {
            fontSize: wrapper.getStyle('fontSize'),
            fontFamily: wrapper.getStyle('fontFamily'),
            whiteSpace: wrapper.getStyle('whiteSpace'),
            lineHeight: wrapper.getStyle('lineHeight'),
            border: wrapper.getStyle('border'),
            padding: wrapper.getStyle('padding')
        });
        
        var storage = Jeeel.Storage.Object(target, this.STORAGE_NAME);
        var limit = storage.get('limit');
        
        var keys = isMultiline ? ['width', 'height'] : ['width'], 
            key, i;
        
        for (i = keys.length; i--;) {
            key = keys[i];
            
            if (limit[key].min > size[key]) {
                size[key] = limit[key].min;
            }

            if (limit[key].max >= 0 && limit[key].max < size[key]) {
                size[key] = limit[key].max;
            }
        }
        
        wrapper.setStyleList(isMultiline ? {
            width: size.width + 'px',
            height: size.height + 'px'
        } : {
            width: size.width + 'px'
        });
    }
};

/**
 * @namespace 特殊検索に使用する列挙体
 */
Jeeel.Dom.SearchOption = {
    /**
     * 範囲に重なるものが対象
     * 
     * @param {Jeeel.Object.Rect} rect 検索範囲
     * @param {Jeeel.Object.Rect} targettRect 要素の範囲
     * @return {Boolean} 要素が検索範囲にマッチしたかどうか
     * @constant
     */
    RANGE_OVERLAY: function (rect, targettRect) {
        var s = rect.startPoint, e = rect.endPoint;
        var ts = targettRect.startPoint, te = targettRect.endPoint;

        return ! (ts.x <= s.x && te.x <= s.x || ts.x >= e.x && te.x >= e.x) && 
               ! (ts.y <= s.y && te.y <= s.y || ts.y >= e.y && te.y >= e.y);
    },
    
    /**
     * 範囲の内側にあるものが対象
     * 
     * @param {Jeeel.Object.Rect} rect 検索範囲
     * @param {Jeeel.Object.Rect} targettRect 要素の範囲
     * @return {Boolean} 要素が検索範囲にマッチしたかどうか
     * @constant
     */
    RANGE_INSIDE: function (rect, targettRect) {
        var s = rect.startPoint, e = rect.endPoint;
        var ts = targettRect.startPoint, te = targettRect.endPoint;

        return (s.x <= ts.x && ts.x <= e.x && s.x <= te.x && te.x <= e.x) &&
               (s.y <= ts.y && ts.y <= e.y && s.y <= te.y && te.y <= e.y);
    }
};Jeeel.directory.Jeeel.Net = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Net/';
    }
};

/**
 * @namespace ネット関連のネームスペース
 * @see Jeeel.Net.Ajax
 * @see Jeeel.Net.Form
 * @example
 * Netのネームスペース以下はサーバーとの通信を軸にしたメイン機能の一つ
 * その中でも以下のクラスの使用頻度は高い
 * Jeeel.Net.Ajax
 * Jeeel.Net.Form
 * 
 * Jeeel.Net.Ajax
 * Ajaxを制御するクラス
 * このクラスを使用するとHTTPパラメータの処理等を簡単に書けるようになる
 * 
 * 例：
 * var Test = {
 *     onSuccess: function (response) {
 *         console.log(response.responseText);
 *         console.log(response.getResponseJSON());
 *     }
 * };
 * var ajax = new Jeeel.Net.Ajax('/test/index', 'GET'); // Jeeel.Net.Ajax.create('/test/index', 'GET')や$AJAX('/test/index', 'GET')でも同じ意味である
 * ajax.setSuccessMethod(Test.onSuccess, Test); // 通信成功時のコールバックを設定する、2つめの引数は例によってコールバック中のthisである
 * ajax.set('a', 88); // 単純なHTTPパラメータを設定する
 * ajax.set('b'. [1, 2, 3, 4, 5, 6, [7, 8, 9, 10], {a: 'area'}]); // 多重配列や連想配列などの複雑なHTTPパラメータを設定する
 * ajax.setField('test', 77); // 通信には関係の無いレスポンスに引き渡すパラメータを設定する
 * ajax.execute(); // 実際にAjax通信を行う
 * 
 * 通信成功時などのコールバックの引数には基本的にJeeel.Net.Ajax.Responseインスタンスが渡される
 * 主なプロパティ・機能は以下になる
 * 
 * response.responseText // 通信結果のテキスト
 * response.getResponseJSON(); // responseTextをJSONとして処理し処理が出来なかったら代わりに空連想配列を返す
 * response.getResponseXML(); // responseXMLを処理して簡単アクセスが出来るJeeel.Dom.Xmlクラスのインスタンスに変換する
 * response.getField('test'); // ajax.setFieldで設定したキー test の値を取得する
 * 
 * 
 * Jeeel.Net.Form
 * 使い方によってはAjaxよりも多く使用する可能性のあるクラス
 * このクラスはform要素をラッパーし操作管理するクラスである
 * また、formだけでなくinput等のパラメータを扱う要素を含む要素をformとして扱いパラメータの変更も可能である
 * 
 * 例：
 * <form id="form">
 *   <input type="text" name="t" value="test" />
 *   <input type="radio" name="r" value="1" />
 *   <input type="radio" name="r" value="2" />
 *   <input type="radio" name="r" value="3" checked />
 *   <select name="s">
 *     <option value="1" selected>1</option>
 *     <option value="2">2</option>
 *     <option value="3">3</option>
 *   </select>
 *   <input type="text" name="t" value="test-new" />
 *   <input type="button" value="フォーム値表示" onclick="alert(Jeeel.Debug.objectExport($FORM(this.form).getAll()));" />
 * </form>
 * <div id="p-form">
 *   <input type="hidden" name="h[]" value="1" />
 *   <input type="hidden" name="h[]" value="2" />
 *   <input type="hidden" name="h[]" value="3" />
 *   <input type="hidden" name="h[a]" value="4" />
 *   <input type="hidden" name="g[a][state]" value="10" />
 *   <input type="hidden" name="g[b][state]" value="20" />
 *   <input type="hidden" name="g[b][txt]" value="test" />
 *   <input type="button" value="擬似フォーム値表示" onclick="alert(Jeeel.Debug.objectExport(Jeeel.Net.Form.createByPseudoForm(this.parentNode).getAll()));" />
 * </div>
 * var form1 = new Jeeel.Net.Form('form'); // Jeeel.Net.Form.create($ID('form'))や$FORM('form')でも同じである
 * var form2 = Jeeel.Net.Form.createByPseudoForm('p-form', '/test/index/', 'GET'); // 擬似フォームから作成する場合は可ならずこちら
 * form1.getAll(); // 指定されたフォーム、疑似フォームを解析しPHPと同じような連想配列を返す
 *                 // #formを検索するので以下の連想配列が返ってくる
 *                 // {t: 'test-new', r: '3', s: '1'}
 *                 
 * form2.getAll(); // #p-form検索するので以下の連想配列になる
 *                 // {h: {0: '1', 1: '2', 2: '3', a: '4'}, g: {a: {state: '10'}, b: {state: '20', txt: 'test'}}}
 * 
 * form1.set('r', 2); // radioボタンの2番目にチェックが付く
 * form2.set('r', 5); // 新たに名前がr、値が5のhiddenタグが生成され#p-form無いの一番下に追加される
 * form1.unset('s'); // セレクトボックスの名前が消される
 * form2.unset('g[b]'); // g[b]以下の要素の名前が破棄される
 * form2.unsetElement('h[a]'); // 要素をDOM上から取り去る
 * 
 * 以上のメソッドを順に実行すると上記のHTMLは以下のような形式に変化する
 * <form id="form">
 *   <input type="text" name="t" value="test" />
 *   <input type="radio" name="r" value="1" />
 *   <input type="radio" name="r" value="2" checked />
 *   <input type="radio" name="r" value="3" />
 *   <select name="">
 *     <option value="1" selected>1</option>
 *     <option value="2">2</option>
 *     <option value="3">3</option>
 *   </select>
 *   <input type="text" name="t" value="test-new" />
 *   <input type="button" value="フォーム値表示" onclick="alert(Jeeel.Debug.objectExport($FORM(this.form).getAll()));" />
 * </form>
 * <div id="p-form">
 *   <input type="hidden" name="h[]" value="1" />
 *   <input type="hidden" name="h[]" value="2" />
 *   <input type="hidden" name="h[]" value="3" />
 *   <input type="hidden" name="g[a][state]" value="10" />
 *   <input type="hidden" name="" value="20" />
 *   <input type="hidden" name="" value="test" />
 *   <input type="hidden" name="r" value="5" />
 *   <input type="button" value="擬似フォーム値表示" onclick="alert(Jeeel.Debug.objectExport(Jeeel.Net.Form.createByPseudoForm(this.parentNode).getAll()));" />
 * </div>
 * 
 * form1.submit(); // #formを送信する
 * form2.submit(); // #p-formの値を元にformを生成し送信する
 * form2.toAjax(); // インスタンスの値を元にJeeel.Net.Ajaxインスタンスを生成する
 */
Jeeel.Net = {
    
    /**
     * コンストラクタ
     *
     * @abstractClass ネット関係のクラスを作る際の抽象クラス
     * @implements Jeeel.Parameter.Filter.Interface, Jeeel.Parameter.Validator.Interface
     */
    Abstract: function () {
        this._params = new Jeeel.Parameter();
        this._params.addValidator(this);
        this._params.addFilter(this);
    }
};

Jeeel.Net.Abstract.prototype = {
    
    /**
     * 通信データ
     * 
     * @type Jeeel.Parameter
     * @protected
     */
    _params: null,
    
    /**
     * 通信パラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    get: function (key, defaultValue) {
        return this._params.get(key, defaultValue);
    },
    
    /**
     * 通信パラメータの全取得
     *
     * @return {Hash} 値リスト
     */
    getAll: function () {
        return this._params.getAll();
    },

    /**
     * 通信パラメータの設定
     *
     * @param {String} key キー
     * @param {Mixied} val 値
     * @return {Jeeel.Net.Abstract} 自インスタンス
     */
    set: function (key, val) {
        this._params.set(key, val);

        return this;
    },

    /**
     * 通信パラメータを全て設定する
     *
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Net.Abstract} 自インスタンス
     * @throws {Error} valsが配列式でない場合に起こる
     */
    setAll: function (vals) {

        if ( ! Jeeel.Type.isHash(vals)) {
            throw new Error('vals is not array or associative array.');
        }

        this._params.setAll(vals);

        return this;
    },

    /**
     * 指定したキーの通信パラメータを破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Net.Abstract} 自インスタンス
     */
    unset: function (key) {
        this._params.unset(key);

        return this;
    },

    /**
     * 指定キーの通信パラメータを保持しているかどうかを返す
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    has: function (key) {
        return this._params.has(key);
    },
    
    /**
     * 通信データのルールを追加する
     * 
     * @param {String} name フィールド名
     * @param {String} label ラベル
     * @param {Array|String} validationRules バリデートルール
     * @param {Array|String} filtrationRules フィルタールール
     * @return {Jeeel.Net.Abstract} 自インスタンス
     */
    addRule: function (name, label, validationRules, filtrationRules) {
        this._params.addField(name, label, validationRules, filtrationRules);
        
        return this;
    },
    
    /**
     * フィールドを削除する
     * 
     * @param {String} name フィールド名
     * @return {Jeeel.Net.Abstract} 自インスタンス
     */
    removeRule: function (name) {
        this._params.removeField(name);
        
        return this;
    },
    
    /**
     * 設定した全てのフィルタ・検証を行う
     * 
     * @return {Jeeel.Net.Abstract} 自インスタンス
     */
    validate: function () {
        this._params.validate();
        
        return this;
    },
    
    /**
     * バリーデータを全て通過したかどうかを返す
     *
     * @return {Boolean} 通過ならばtrueそれ以外はfalseを返す
     */
    isValid: function () {
        return this._params.isValid();
    },
    
    /**
     * フィルタ・検証後の値を全て取得する
     * 
     * @return {Hash} 取得値
     */
    getValidatedValues: function () {
        return this._params.getValidatedValues();
    },
    
    /**
     * エラーを全て返す
     *
     * @return {Hash} エラーのリスト
     */
    getErrors: function () {
        return this._params.getErrors();
    },
    
    /**
     * 指定したフィールドのエラーを取得する
     * 
     * @param {String} name フィールド名
     * @return {Jeeel.Parameter.Validator.Error|Mixed} エラー
     */
    getError: function(name) {
        return this._params.getError(name);
    },
    
    /**
     * 全てのエラーを文字列として取得する
     * 
     * @return {String[]|Array} エラーリスト
     */
    getErrorMessages: function () {
        return this._params.getErrorMessages();
    },
    
    /**
     * 指定したフィールドのエラーを文字列として取得する
     * 
     * @return {String|Mixed} エラー
     */
    getErrorMessage: function (name) {
        return this._params.getErrorMessage(name);
    },
    
    /**
     * バリデートメソッドを追加する
     * 
     * @param {String} name バリデート名
     * @param {Function} validation バリデートメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Abstract} 自インスタンス
     */
    addValidation: function (name, validation, thisArg) {
        if ( ! Jeeel.Type.isFunction(validation)) {
            throw new Error('validation must be a function.');
        }
        
        name = Jeeel.String.toPascalCase(name);
        
        this['_validate' + name] = thisArg ? Jeeel.Function.simpleBind(validation, thisArg) : validation;
        
        return this;
    },

    /**
     * バリデートメソッドが呼べるかどうかを返す
     * 
     * @param {String} name バリデート名
     * @return {Boolean} バリデートメソッドが呼べるかどうか
     */
    hasValidation: function (name) {
        name = '_validate' + Jeeel.String.toPascalCase(name);
        
        return !!(this[name] && typeof this[name] === 'function');
    },
    
    /**
     * バリデートメソッドを取得する
     * 
     * @param {String} name バリデート名
     * @return {Jeeel.Function.Callback} コールバック
     */
    getValidation: function (name) {
        name = '_validate' + Jeeel.String.toPascalCase(name);
        
        return this[name] && typeof this[name] === 'function' && new Jeeel.Function.Callback(name, this) || null;
    },
    
    /**
     * フィルタメソッドを追加する
     * 
     * @param {String} name フィルタ名
     * @param {Function} filtration フィルタメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Abstract} 自インスタンス
     */
    addFiltration: function (name, filtration, thisArg) {
        if ( ! Jeeel.Type.isFunction(filtration)) {
            throw new Error('filtration must be a function.');
        }
        
        name = Jeeel.String.toPascalCase(name);
        
        this['_filter' + name] = thisArg ? Jeeel.Function.simpleBind(filtration, thisArg) : filtration;
        
        return this;
    },
    
    /**
     * フィルタメソッドが呼べるかどうかを返す
     * 
     * @param {String} name フィルタ名
     * @return {Boolean} フィルタメソッドが呼べるかどうか
     */
    hasFiltration: function (name) {
        name = '_filter' + Jeeel.String.toPascalCase(name);
        
        return !!(this[name] && typeof this[name] === 'function');
    },
    
    /**
     * フィルタメソッドが取得する
     * 
     * @param {String} name フィルタ名
     * @return {Jeeel.Function.Callback} コールバック
     */
    getFiltration: function (name) {
        name = '_filter' + Jeeel.String.toPascalCase(name);
        
        return this[name] && typeof this[name] === 'function' && new Jeeel.Function.Callback(name, this) || null;
    }
};

Jeeel.Net.Abstract = Jeeel.Class.implement(Jeeel.Net.Abstract, Jeeel.Parameter.Filter.Interface);
Jeeel.Net.Abstract = Jeeel.Class.implement(Jeeel.Net.Abstract, Jeeel.Parameter.Validator.Interface);

Jeeel.file.Jeeel.Net = ['Form', 'Ajax', 'Jsonp', 'Beacon'];

if (Jeeel._extendMode.Net && Jeeel._global) {
    if (Jeeel._global.EventSource) {
        Jeeel.file.Jeeel.Net[Jeeel.file.Jeeel.Net.length] = 'Comet';
    }
    
    if (Jeeel._global.WebSocket) {
        Jeeel.file.Jeeel.Net[Jeeel.file.Jeeel.Net.length] = 'Socket';
    }
}

Jeeel._autoImports(Jeeel.directory.Jeeel.Net, Jeeel.file.Jeeel.Net);

/**
 * コンストラクタ
 *
 * @class フォームの操作及び送信を管理するクラス
 * @augments Jeeel.Net.Abstract
 * @param {String|Element} form フォームを示すIDもしくはフォーム自身
 * @throws {Error} 指定したformがフォームのIDもしくはフォーム自身でなかった場合に発生
 */
Jeeel.Net.Form = function (form) {
    
    Jeeel.Net.Abstract.call(this);
    
    if (Jeeel.Type.isString(form)) {
        form = Jeeel.Document.getElementById(form);
    }

    if ( ! form || ! form.tagName || form.tagName.toUpperCase() !== 'FORM') {
        throw new Error('指定されたIDまたはElementはform固有のものではありません。');
    }
    
    this._form = form;
    
    if (Jeeel.Type.isElement(arguments[1])) {
        this._pseudoForm = arguments[1];
    }
};

/**
 * インスタンスを作成する
 *
 * @param {String|Element} form フォームを示すIDもしくはフォーム自身
 * @return {Jeeel.Net.Form} 作成したインスタンス
 */
Jeeel.Net.Form.create = function (form) {
    return new this(form);
};

/**
 * 疑似フォームを設定し、新規フォームを介して値の設定や削除、送信を行う<br />
 * この機能を使うと指定した要素の中に含まれるinput等の値を設定・削除・送信を行う事が出来る
 * 
 * @param {String|Element} pseudoForm 疑似フォームを示すIDもしくは疑似フォーム自身(例えばdivタグやtrタグ等)
 * @param {String} [action] formのaction
 * @param {String} [method] formのmethod
 * @return {Jeeel.Net.Form} 作成したインスタンス
 * @throws {Error} 指定したpseudoFormがIDもしくはElementではなかった場合に発生
 */
Jeeel.Net.Form.createByPseudoForm = function (pseudoForm, action, method) {
    var newForm = Jeeel.Document.createElement('form');

    newForm.style.display = 'none';

    if (Jeeel.Type.isString(pseudoForm)) {
        pseudoForm = Jeeel.Document.getElementById(pseudoForm);
    }
    
    if ( ! Jeeel.Type.isElement(pseudoForm)) {
        throw new Error('指定されたpseudoFormがIDもしくはElementではありません。');
    }
    
    var res = new this(newForm, pseudoForm);
    
    if (action) {
        res.setAction(action);
    }
    
    if (method) {
        res.setMethod(method);
    }
    
    return res.setRemoveFormAtSubmit(true);
};

/**
 * formを新規作成して、インスタンスの作成を行う<br />
 * このメソッドを呼んだ場合formがbodyに追加され、<br />
 * submitメソッドが呼ばれた時にこのFormは削除される
 *
 * @param {String} [action] formのaction
 * @param {String} [method] formのmethod
 * @return {Jeeel.Net.Form} 作成したインスタンス
 */
Jeeel.Net.Form.newForm = function (action, method) {
    var newForm = Jeeel.Document.createElement('form');

    newForm.style.display = 'none';

    var res = new this(newForm);
    
    if (action) {
        res.setAction(action);
    }
    
    if (method) {
        res.setMethod(method);
    }
    
    return res.setRemoveFormAtSubmit(true);
};

/**
 * 指定したformを基に新規formを作成し、インスタンスの作成を行う<br />
 * 新規にformを作成した場合bodyに追加され、<br />
 * このインスタンスのsubmitメソッドが呼ばれた時に新規formは削除される
 *
 * @param {String|Element} form 基となるフォームを示すIDもしくはフォーム自身
 * @param {String|Element} [newForm] コピー先となるForm(指定しない場合は新規作成を行う)
 * @return {Jeeel.Net.Form} 作成したインスタンス
 * @throws {Error} newFormを指定したにも関わらずフォームのIDもしくはフォーム自身でなかった場合に発生
 */
Jeeel.Net.Form.copyBy = function (form, newForm) {

    var submitRemove = false;
    
    if (Jeeel.Type.isString(newForm)) {
        newForm = Jeeel.Document.getElementById(newForm);
    } else if ( ! Jeeel.Type.isElement(newForm)) {
        newForm = Jeeel.Document.createElement('form');
        newForm.style.display = 'none';
        submitRemove = true;
    }

    if ( ! newForm || ! newForm.nodeName || newForm.nodeName.toLowerCase() !== 'form') {
        throw new Error('引数newFormはform固有を示すものではありません。');
    }

    var base = new this(form);
    var res  = new this(newForm);

    res.setMethod(base.getMethod());
    res.setAction(base.getAction());
    res.setTarget(base.getTarget());
    res.setAll(base.getAll());

    return res.setRemoveFormAtSubmit(submitRemove);
};

/**
 * 名前がない要素の名前
 * 
 * @type String
 * @constant
 * @memberOf Jeeel.Net.Form
 */
Jeeel.Net.Form.UNKNOWN_NAME = '_UNKNOWN_';

/**
 * 上書き要素の名前
 * 
 * @type String
 * @constant
 * @memberOf Jeeel.Net.Form
 */
Jeeel.Net.Form.OVERWRITTEN_NAME = '_OVERWRITE_';

Jeeel.Net.Form.prototype = {

    /**
     * フォーム
     * 
     * @type Element
     * @private
     */
    _form: null,
    
    /**
     * 疑似フォーム
     * 
     * @type Element
     * @private
     */
    _pseudoForm: null,
    
    /**
     * フォームをsubmitメソッドを呼び出した後削除するかどうか
     * 
     * @type Boolean
     * @private
     */
    _submitRemove: false,
    
    _getName: Jeeel._Object.JeeelFilter.getInputName,
    
    /**
     * formに値をセットするためメソッド
     * 
     * @param {String} key キー
     * @param {Mixied} val 値
     * @param {Mixied} input 値を保持させるInputElement
     * @param {Boolean} [toForm] フォームに対して優先的に埋め込むかどうか
     * @private
     */
    _set: function (key, val, input, toForm) {},
    
    /**
     * formに強制的に値をセットするためメソッド
     * 
     * @param {Hash} vals 値
     * @private
     */
    _setAllForm: function (vals) {},

    /**
     * formのactionをセットする
     *
     * @param {String} action formのaction
     * @return {Jeeel.Net.Form} 自身のインスタンス
     */
    setAction: function (action) {
        this._form.action = action;

        return this;
    },

    /**
     * formのactionを取得する
     *
     * @return {String} formのaction
     */
    getAction: function () {
        return this._form.action;
    },

    /**
     * formのmethodをセットする
     *
     * @param {String} method formのmethod
     * @return {Jeeel.Net.Form} 自身のインスタンス
     */
    setMethod: function (method) {
        this._form.method = method;

        return this;
    },

    /**
     * formのmethodを取得する
     *
     * @return {String} formのmethod
     */
    getMethod: function () {
        return this._form.method;
    },

    /**
     * formのtargetをセットする
     *
     * @param {String} target formのtarget
     * @return {Jeeel.Net.Form} 自身のインスタンス
     */
    setTarget: function (target) {
        this._form.target = target;

        return this;
    },

    /**
     * formのtargetを取得する
     *
     * @return {String} formのtarget
     */
    getTarget: function () {
        return this._form.target;
    },

    /**
     * 保持しているフォームを取得する
     *
     * @return {Element} フォーム
     */
    getForm: function () {
        return this._form;
    },
    
    /**
     * 疑似フォームを取得する
     *
     * @return {Element} 疑似フォーム
     */
    getPseudoForm: function () {
        return this._pseudoForm;
    },

    /**
     * 保持しているフォームをDom上から取り除く
     *
     * @return {Jeeel.Net.Form} 自身のインスタンス
     */
    removeForm: function () {
        Jeeel.Dom.Element.create(this._form).remove();

        return this;
    },
    
    /**
     * 保持しているフォームをsubmit時にDom上から取り除くかどうかを取得する
     *
     * @return {Boolean} submit時に削除するかどうか
     */
    getRemoveFormAtSubmit: function () {
        return this._submitRemove;
    },
    
    /**
     * 保持しているフォームをsubmit時にDom上から取り除くかどうかを設定する
     *
     * @param {Boolean} enableRemove submit時に削除するかどうか
     * @return {Jeeel.Net.Form} 自身のインスタンス
     */
    setRemoveFormAtSubmit: function (enableRemove) {
        this._submitRemove = !!enableRemove;
        
        return this;
    },

    /**
     * 指定したキーの値のリストを取得する
     *
     * @param {String} key キー(name)
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    get: function (key, defaultValue) {
        var param = this.getAll();
        var names = this._getName('' + key);
        
        // 配列るキーの場合(a[b]やa[]の場合)
        if (names.length !== 1) {
            for (var i = 0, l = names.length - 1; i < l; i++) {
                param = param[names[i]];
            }
            
            key = names[l];
        }
        
        param = param[key];

        return (Jeeel.Type.isSet(param) ? param : defaultValue);
    },

    /**
     * form内の値を全て取得する<br />
     * その際checkedが付いていないradioボタンやcheckboxは無視される
     *
     * @return {Hash} 値のリスト
     */
    getAll: function () {},
    
    /**
     * 指定したキーのデフォルト値のリストを取得する
     *
     * @param {String} key キー(name)
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getDefault: function (key, defaultValue) {
        var param = this.getDefaultAll();
        var names = this._getName('' + key);
        
        // 配列るキーの場合(a[b]やa[]の場合)
        if (names.length !== 1) {
            for (var i = 0, l = names.length - 1; i < l; i++) {
                param = param[names[i]];
            }
            
            key = names[l];
        }
        
        param = param[key];

        return (Jeeel.Type.isSet(param) ? param : defaultValue);
    },
    
    /**
     * form内のデフォルト値を全て取得する<br />
     * その際checkedが付いていないradioボタンやcheckboxは無視される
     *
     * @return {Hash} 値のリスト
     */
    getDefaultAll: function () {},
    
    /**
     * 値をhiddenでセットする<br />
     * 対象の要素が無い場合はhiddenで埋め込み、対象の要素がある場合は以下のような動作になる<br />
     * radio: 指定した値のradioにチェックが付く<br />
     * checkbox: 指定した値と同じだった場合にはチェックが付きそれ以外はチェックが外れる<br />
     * select: 指定した値のオプションをセレクトする<br />
     * それ以外: 値自体が上書きされる<br />
     * また、対象の要素と埋め込もうとした値が一致しなかった場合は要素を削除してhiddenが埋め込まれる<br />
     * 例: <br />
     * name="test"の要素があった場合にJeeel.Net.Form#set('test', [1, 2, 3]);<br />
     * こういう記述の場合要素に対して配列つまり test に対して test[0] などの名前で上書きしようとするので削除の対象となる<br />
     * 同じく name="test[a]" に対して Jeeel.Net.Form#set('test', 44); などの指定も同じく削除の対象となる
     *
     * @param {String} key キー(inputタグのnameと同じ書式)
     * @param {Mixied} val 値
     * @return {Jeeel.Net.Form} 自身のインスタンス
     */
    set: function (key, val) {
        var names = this._getName('' + key);
        
        // 配列るキーの場合(a[b]やa[]の場合)
        if (names.length !== 1) {
            var base = {}, obj = base;
            
            for (var i = 0, l = names.length - 1; i < l; i++) {
                obj[names[i]] = {};
                obj = obj[names[i]];
            }
            
            obj[names[l]] = val;
            
            key = names[0];
            val = base[key];
        }
        
        var input = this.getElementAll(true)[key];
        
        Jeeel.Dom.ElementOperator.create(this.getOverwrittenElements())
                               .filterName(key, true)
                               .remove();

        this._set(key, val, input);

        return this;
    },

    /**
     * 指定したHashをの内容を全てhidden形式で埋め込む<br />
     * keyが被った場合は全て上書きする
     * 
     * @param {Hash} vals 値
     * @return {Jeeel.Net.Form} 自身のインスタンス
     */
    setAll: function (vals) {

        Jeeel.Hash.forEach(vals,
            function (val, key) {
                this.set(key, val);
            }, this
        );

        return this;
    },

    /**
     * 指定キーの値を破棄する(この際指定キーのElementのnameが破棄される)<br />
     * その際checkedが付いていないradioボタンやcheckboxは無視される
     *
     * @param {String} key キー
     * @return {Jeeel.Net.Form} 自インスタンス
     */
    unset: function (key) {
        Jeeel.Dom.ElementOperator.create([this.getElement(key, true), this.getOverwrittenElements()])
                                 .filterName(key, true)
                                 .removeAttr('name');
        
        return this;
    },

    /**
     * 指定キーの値を保持しているかどうかを返す<br />
     * その際checkedが付いていないradioボタンやcheckboxは無視される
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    has: function (key) {
        return Jeeel.Type.isSet(this.get(key));
    },

    /**
     * 指定したキーのinput要素を取得する(指定した名前が複数ある場合はリストになる)
     *
     * @param {String} key キー(name)
     * @return {Element|Hash} inputの要素
     */
    getElement: function (key) {
        var param = this.getElementAll(arguments[1]);
        var names = this._getName('' + key);
        
        // 配列るキーの場合(a[b]やa[]の場合)
        if (names.length !== 1) {
            for (var i = 0, l = names.length - 1; i < l; i++) {
                param = param[names[i]];
            }
            
            key = names[l];
        }
        
        param = param[key];
        
        return param || null;
    },

    /**
     * form内の全てのinput要素を取得する
     * 
     * @return {Hash} input要素のリスト
     */
    getElementAll: function () {},

    /**
     * 検索対象にならなかった無名のinput要素を全て取得する
     *
     * @return {Element[]} input要素の配列
     */
    getUnknownElements: function () {},
    
    /**
     * 検索過程で上書きされてしまうinput要素を全て取得する
     * 
     * @return {Element[]} input要素の配列
     * @example
     * <form>
     *   <input type="" name="hoge" value="1" />
     *   <input type="" name="hoge" value="2" />
     *   <input type="" name="hoge[]" value="3" />
     *   <input type="" name="hoge[]" value="4" />
     * </form>
     * 上記のformの場合最初から2つのhogeの要素が取得される
     */
    getOverwrittenElements: function () {},
    
    /**
     * selectタグのoptionを全て取得する
     * 
     * @param {String} key selectタグのname
     * @return {Element[]} オプションリスト
     */
    getOptions: function (key) {
        var select = this.getElement(key),
            nodeName = select && select.nodeName;
        
        if ( ! nodeName || nodeName.toUpperCase() !== 'SELECT') {
            return [];
        }
        
        return Jeeel.Hash.toArray(select.options);
    },
    
    /**
     * selectタグのoptionの値を全て取得する
     * 
     * @param {String} key selectタグのname
     * @return {String[]} オプションの値のリスト
     */
    getOptionValues: function (key) {
        var options = this.getOptions(key);
        
        for (var i = options.length; i--;) {
            options[i] = options[i].value;
        }
        
        return options;
    },
    
    /**
     * 指定キーのinput要素を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Net.Form} 自インスタンス
     */
    unsetElement: function (key) {
        Jeeel.Dom.ElementOperator.create([this.getElement(key, true), this.getOverwrittenElements()])
                               .filterName(key, true)
                               .remove();
        
        return this;
    },
    
    /**
     * selectタグのoptionを指定した値に全て置き換える
     * 
     * @param {String} key selectタグのname
     * @param {Hash} options オプションの値に使う値と表示値のリスト({value1: text1, value2: text2, ...})
     * @return {Jeeel.Net.Form} 自インスタンス
     */
    replaceOptions: function (key, options) {
        var select = this.getElement(key),
            nodeName = select && select.nodeName;
        
        if ( ! nodeName || nodeName.toUpperCase() !== 'SELECT') {
            return this;
        } else if ( ! Jeeel.Type.isHash(options)) {
            return this;
        }
        
        select = new Jeeel.Dom.Element(select);
        
        var addOptions = [],
            val, option;
        
        for (val in options) {
            option = Jeeel.Document.createElement('option');
            option.value = val;
            option.innerHTML = Jeeel.String.escapeHtml(options[val]);
            
            addOptions[addOptions.length] = option;
        }
        
        select.clearChildNodes()
              .appendChild(addOptions);
        
        return this;
    },
    
    /**
     * 自動的にフィルタ、バリデータを起動させるようにする
     * 
     * @ignore 未完成
     */
    enableAutoChecker: function () {
        var elms = Jeeel.Dom.ElementOperator.create(this._pseudoForm || this._form).$QUERY('input[name]');
        
        for (var i = elms.length; i--;) {
            var vRules = elms.getData('validationRules', i);
            var fRules = elms.getData('filtrationRules', i);
            
            
        }
    },
    
    /**
     * 設定した全てのフィルタ・検証を行う
     * 
     * @return {Jeeel.Net.Form} 自インスタンス
     */
    validate: function () {
        this._params.clear();
        this._params.setAll(this.getAll());
        
        this._super.validate.call(this);
        
        return this;
    },
    
    /**
     * フォームの送信を行う
     *
     * @return {Jeeel.Net.Form} 自身のインスタンス
     */
    submit: function () {
        if (Jeeel.Acl && Jeeel.Acl.isDenied(this.getAction(), '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
        
        if ( ! this.isValid()) {
            throw new Error('There is an error in the contents of the form.');
        }
        
        if (this._pseudoForm) {
            this._setAllForm(this.getAll());
        }
        
        // formがDOM上に居ない場合IE等のブラウザにて送信が出来ないので埋め込んでから送信を行う
        if ( ! this._form.parentNode || this._form.parentNode.nodeType === Jeeel.Dom.Node.DOCUMENT_FRAGMENT_NODE) {
            Jeeel.Document.appendToBody(this._form);
        }
        
        this._form.submit();
        
        if (this._submitRemove) {
            this.removeForm();
        }

        return this;
    },
    
    /**
     * フォームの内容をJeeel.Net.Ajaxインスタンスに変換する
     *
     * @return {Jeeel.Net.Ajax} 変換後のインスタンス
     */
    toAjax: function () {
        var params = this.getAll();
        var fields = this._params.getFields();
        
        var ajax = new Jeeel.Net.Ajax(this.getAction(), this.getMethod());
        
        ajax.setAll(params);
        
        for (var i = fields.length; i--;) {
            var field = fields[i];
            
            ajax.addRule(field.getName(), field.getLabel(), field.getValidateRules(), field.getFilterRules());
        }
        
        return ajax;
    },
    
    /**
     * 必須項目のバリデートを行う(空文字も弾く様に上書き)
     * 
     * @param {Mixed} value バリデート値
     * @return {Boolean} 空じゃなかったかどうか(null, undefined, ''以外が通過)
     * @private
     */
    _validateRequired: function (value) {
        return ! Jeeel.Type.isEmpty(value) && value !== '';
    },
    
    /**
     * 値が無かったら無視する(空文字も値なしとするように上書き)
     * 
     * @param {Mixed} value フィルタ値
     * @return int フィルタ後の値
     * @private
     */
    _filterOption: function (value) {
        return this._validateRequired(value) ? value : Jeeel.Parameter.Filter.IGNORED_VALUE;
    },
    
    /**
     * 値が指定されていなかった場合に代わりに代替値を返す(空文字も値なしとするように上書き)
     * 
     * @param {Mixed} value 対象値
     * @param {Mixed} defaultValue デフォルト値
     * @return {Mixed} 処理後の値
     * @private
     */
    _filterDefault: function (value, defaultValue) {
        return this._validateRequired(value) ? value : defaultValue;
    },
    
    _init: function () {
        var uName = Jeeel.Net.Form.UNKNOWN_NAME;
        var oName = Jeeel.Net.Form.OVERWRITTEN_NAME;
        var fnvf = new Jeeel.Filter.Html.FormValue();
        var fdvf = new Jeeel.Filter.Html.FormValue(true);
        var fnef = new Jeeel.Filter.Html.Form();
        var fuef = new Jeeel.Filter.Html.Form(false, uName);
        var foef = new Jeeel.Filter.Html.Form(false, null, oName);
        var uef  = new Jeeel.Filter.Url.Escape();
        
        /**
         * @ignore
         */
        this.getAll = function () {
            return fnvf.filter(this._pseudoForm || this._form);
        };
        
        /**
         * @ignore
         */
        this.getDefaultAll = function () {
            return fdvf.filter(this._pseudoForm || this._form);
        };
        
        /**
         * @ignore
         */
        this.getElementAll = function (secretPrm) {
            var res = fnef.enableAccurateList(secretPrm).filter(this._pseudoForm || this._form);
            
            return res;
        };
        
        /**
         * @ignore
         */
        this.getUnknownElements = function () {
            var parm = fuef.filter(this._pseudoForm || this._form)[uName];

            return Jeeel.Hash.getValues(parm || []);
        };
        
        /**
         * @ignore
         */
        this.getOverwrittenElements = function () {
            return foef.filter(this._pseudoForm || this._form)[oName];
        };
        
        /**
         * @ignore
         */
        this._setAllForm = function (vals) {
            var inputs = fnef.enableAccurateList(true).filter(this._form);

            Jeeel.Hash.forEach(vals,
                function (val, key) {
                    this._set(key, val, inputs[key], true);
                }, this
            );

            return this;
        };
        
        /**
         * @ignore
         */
        this._set = function (key, val, input, toForm) {
            
            var i;
            
            // inputが配列の場合(ラジオボタン)
            if (Jeeel.Type.isArray(input)) {
                
                // valが単体の場合指定した値と合致するラジオボタンにチェックを付ける
                if ( ! Jeeel.Type.isHash(val)) {
                    val = '' + val;
                    
                    for (i = input.length; i--;) {
                        if (input[i].value === val) {
                            input[i].checked = true;
                            break;
                        }
                    }
                }

                // valが複数の場合inputと形式が一致しないためinputを削除してから値の設定を行う
                else {
                    Jeeel.Dom.ElementOperator.create(input).remove();

                    this._set(key, val, null, toForm);
                }
            }
            // inputがElementの場合
            else if (Jeeel.Type.isElement(input)) {

                // valが単体の場合そのまま代入
                if ( ! Jeeel.Type.isHash(val)) {
                    if (input.tagName.toUpperCase() === 'INPUT' && input.type.toLowerCase() === 'checkbox') {
                        input.checked = input.value === ('' + val);
                    } else {
                        input.value = uef.filter(val);
                    }
                }

                // valが複数の場合inputと形式が一致しないためinputを削除してから値の設定を行う
                else {
                    Jeeel.Dom.ElementOperator.create(input).remove();

                    this._set(key, val, null, toForm);
                }
            }
            // inputがHashの場合
            else if (input) {

                // valが単数の場合inputと形式が一致しないためinputを削除してから値の設定を行う
                if ( ! Jeeel.Type.isHash(val)) {
                    Jeeel.Dom.ElementOperator.create(input).remove();

                    this._set(key, val, null, toForm);

                    return;
                }

                // valが複数の場合それぞれのinputにコピーを再帰的に行っていく
                Jeeel.Hash.forEach(val, 
                    function (val, inputKey) {
                        this._set(key + '[' + inputKey + ']', val, input[inputKey], toForm);
                    }, this
                );

            }
            // inputが存在しない場合
            else {

                // valを基にHiddenインスタンスを作成する
                input = Jeeel.Filter.Html.Hidden.create(key).filter(val);
                
                // Hiddenインスタンスの埋め込み先を決定する
                var owner = ! toForm && this._pseudoForm || this._form;

                // 作成したHiddenインスタンスを対象に埋め込む
                if (Jeeel.Type.isArray(input)) {
                    for (i = 0; i < input.length; i++) {
                        owner.appendChild(input[i]);
                    }
                } else {
                    owner.appendChild(input);
                }
            }
        };
        
        delete this._init;
    }
};

Jeeel.Class.extend(Jeeel.Net.Form, Jeeel.Net.Abstract);

Jeeel.Net.Form.prototype._init();
Jeeel.directory.Jeeel.Net.Ajax = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Net + 'Ajax/';
    }
};

/**
 * コンストラクタ
 * 
 * @class Ajaxの制御を行うクラス
 * @augments Jeeel.Net.Abstract
 * @param {String} url Ajax対象URLの文字列
 * @param {String} [method] HTTPメソッド(getまたはpost、大文字小文字は問わない、初期値はPOST)
 * @throws {Error} urlが指定されていない場合に起こる
 */
Jeeel.Net.Ajax = function (url, method) {

    if ( ! Jeeel.Type.isString(url)) {
        throw new Error('URLを指定してください。');
    }
    
    Jeeel.Net.Abstract.call(this);

    this.setMethod(method);
    
    this._requestQueue = [];
    
    this._url = url;
    this._fields = new Jeeel.Parameter();
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} url Ajax対象URL文字列
 * @param {String} [method] HTTPメソッド(getまたはpost、大文字小文字は問わない、初期値はPOST)
 * @return {Jeeel.Net.Ajax} 作成したインスタンス
 */
Jeeel.Net.Ajax.create = function (url, method) {
    return new this(url, method);
};

/**
 * Ajaxのリクエストを作成する
 * 
 * @return {XMLHttpRequest} 作成したリクエスト(作成出来なかった場合はnullを返す)
 */
Jeeel.Net.Ajax.createXMLHttpRequest = function () {
    var obj = null, activeXIds =[
        'MAXM12.XMLHTTP.3.0',
        'MAXM12.XMLHTTP',
        'Microsoft.XMLHTTP'
    ];
    
    if (typeof XMLHttpRequest !== 'undefined') {
        obj = new XMLHttpRequest();
    } 
    else if (typeof ActiveXObject !== 'undefined') {
      
        // IE7以前の作成
        for (var i = 0, l = activeXIds.length; i < l; i++) {
            try {
                obj = new ActiveXObject(activeXIds[i]);
                break;
            } catch (e) {}
        }
    }
    
    return obj;
};

/**
 * 指定したURLのレスポンスをそのまま返す
 *
 * @param {String} url アクセスURL
 * @param {Hash} [parameter] URLに渡すPostパラメータを示す連想配列
 * @return {String|Object} サーバーからのレスポンス、異常終了時はstatu, statusText, responseのキーをもつオブジェクト
 * @throws {Error} Ajaxがサポートされていないと発生する
 */
Jeeel.Net.Ajax.serverResponse = function (url, parameter) {

    if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
        Jeeel.Acl.throwError('Access Error', 404);
    }

    if ( ! Jeeel.Type.isHash(parameter)) {
        parameter = {};
    }

    var request = this.createXMLHttpRequest();
    var response;

    if (request) {
        var check = function () {
            if (request.readyState == 4 && request.status == 200) {
                response = request.responseText;
            } else if (request.readyState == 4) {
                response = {
                    status: request.status,
                    statusText: request.statusText,
                    response: request.responseText
                };
            }
        };

        request.open('POST', url, false);
        request.onreadystatechange = check;

        request.setRequestHeader('X-Requested-With' , 'XMLHttpRequest');
        request.setRequestHeader('X-Jeeel-Version' , Jeeel.VERSION);
        request.setRequestHeader('Accept' , 'text/javascript, text/html, application/xml, text/xml, */*');
        request.setRequestHeader('Content-Type' , 'application/x-www-form-urlencoded; charset=UTF-8');

        if (request.overrideMimeType &&
            (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
        {
            request.setRequestHeader('Connection' , 'close');
        }

        request.send(Jeeel.Parameter.create(parameter).toQueryString());
    } else {
        throw new Error('Ajaxがサポートされていません。');
    }

    if (response) {
        return response;
    }

    if (request.readyState == 4 && request.status == 200) {
        return request.responseText;
    }

    return {
        status: request.status,
        statusText: request.statusText,
        response: request.responseText
    };
};

Jeeel.Net.Ajax.prototype = {

    /**
     * Ajaxの際にサーバー側に渡さずに戻り値に定義づけるパラメータのハッシュを保持するJeeel.Parameter
     *
     * @type Jeeel.Parameter
     * @private
     */
    _fields: null,
    
    /**
     * リトライ情報
     * 
     * @type 
     * @private
     */
    _retry: null,

    /**
     * Ajax対象のURL
     *
     * @type String
     * @private
     */
    _url: '',

    /**
     * HTTPメソッド
     *
     * @type String
     * @private
     */
    _method: '',

    /**
     * 現在通信中かどうか
     *
     * @type Boolean
     * @private
     */
    _executing: false,

    /**
     * 非同期通信かどうか
     *
     * @type Boolean
     * @private
     */
    _asynchronous: true,
    
    /**
     * タイムアウト時間(ミリ秒)
     * 
     * @type Integer
     * @private
     */
    _timeoutTime: 0,
    
    /**
     * 並列接続時の動作ポリシー
     * 
     * @type Integer
     * @private
     */
    _collisionPolicy: 0,
    
    /**
     * 通信に必要な情報
     * 
     * @type Array
     * @private
     */
    _requestQueue: [],

    /**
     * 作成メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _create: null,

    /**
     * 完了メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _complete: null,

    /**
     * 成功メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _success: null,
    
    /**
     * 中止メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _abort: null,
    
    /**
     * タイムアウトメソッド
     * 
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _timeout: null,

    /**
     * 失敗メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _failure: null,

    /**
     * 部分受信メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _interactive: null,

    /**
     * 送信準備完了メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _loaded: null,

    /**
     * コネクションオープンメソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _loading: null,

    /**
     * XMLHttpRequest生成メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @private
     */
    _uninitialized: null,

    /**
     * 例外メソッド
     *
     * @type Function void callback(Jeeel.Net.Ajax.Request request, Error error)
     * @private
     */
    _exception: null,
    
    /**
     * 内部通信完了メソッド
     * 
     * @type Jeeel.Function.Callback
     * @private
     */
    _innerComplete: null,
    
    /**
     * リクエスト
     *
     * @type Jeeel.Net.Ajax.Request
     * @private
     */
    _request: null,

    /**
     * 戻り値
     *
     * @type Jeeel.Net.Ajax.Response
     * @private
     */
    _response: null,

    /**
     * エラー
     *
     * @type Error
     * @private
     */
    _error: null,
    
    /**
     * Ajax対象のURLを取得する
     * 
     * @return {String} URL
     */
    getUrl: function () {
        return this._url;
    },

    /**
     * Ajax対象URLの設定
     *
     * @param {String} url Ajax対象URL
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     * @throws {Error} urlが文字列でない場合に起こる
     */
    setUrl: function (url) {
        if ( ! Jeeel.Type.isString(url)) {
            throw new Error('URLを指定してください。');
        }
        
        this._url = url;

        return this;
    },
    
    /**
     * HTTPメソッドの取得を行う
     * 
     * @return {String} HTTPメソッド
     */
    getMethod: function () {
        return this._method;
    },

    /**
     * HTTPメソッドの設定
     *
     * @param {String} method HTTPメソッド(getまたはpost、大文字小文字は問わない)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setMethod: function (method) {
        if ( ! Jeeel.Type.isString(method)) {
            method = 'POST';
        }
        
        method = method.toUpperCase();

        if (method !== 'GET' && method !== 'POST') {
            method = 'POST';
        }

        this._method = method;

        return this;
    },
    
    /**
     * 非同期通信化どうかを返す
     *
     * @return {Boolean} 自身のインスタンス
     */
    getAsynchronous: function () {
        return this._asynchronous;
    },

    /**
     * 非同期通信化どうかの設定
     *
     * @param {Boolean} asynchronous 非同期通信かどうか
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setAsynchronous: function (asynchronous) {
        this._asynchronous = !!asynchronous;

        return this;
    },
    
    /**
     * リトライの設定を行う<br />
     * リトライを行った際は本来呼ばれるメソッドは呼ばれなくなる
     * 
     * @param {Integer} limit リトライ回数(0で無制限、-1で無効)
     * @param {Integer} [delayTime] 遅延秒数(ミリ秒、デフォルトでは30000ミリ秒)
     * @param {Function} [callback] リトライ時に呼ばれるメソッド<br />
     *                               コールバックメソッドに渡される引数は存在しない<br />
     *                               void callback()
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setRetry: function (limit, delayTime, callback, thisArg) {
      
        if (limit < 0) {
            this._retry = null;
            
            return this;
        }
        
        this._retry = {
            count: 0,
            limit: +limit,
            delayTime: delayTime || 30000,
            callback: callback && {func: callback, thisArg: thisArg}
        };
        
        return this;
    },
    
    /**
     * 非同期通信時のタイムアウトまでの時間を取得する
     * 
     * @return {Integer} タイムアウト時間、0で無制限(ミリ秒)
     */
    getTimeoutTime: function () {
        return this._timeoutTime;
    },
    
    /**
     * 非同期通信時のタイムアウトまでの時間を設定する
     * 
     * @param {Integer} time タイムアウト時間、0で無制限(ミリ秒)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setTimeoutTime: function (time) {
        this._timeoutTime = +time || 0;
        
        return this;
    },
    
    /**
     * コリジョンポリシーを取得する
     * 
     * @return {String} コリジョンポリシー
     */
    getCollisionPolicy: function () {
        return this._collisionPolicy;
    },
    
    /**
     * 並列リクエストをした場合の動作を設定する
     * 
     * @param {Integer} collisionPolicy コリジョンポリシー
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     * @see Jeeel.Net.Ajax.CollisionPolicy
     */
    setCollisionPolicy: function (collisionPolicy) {
        if (isNaN(collisionPolicy)) {
            collisionPolicy = this.constructor.CollisionPolicy.IGNORE;
        }
        
        switch (collisionPolicy) {
            case this.constructor.CollisionPolicy.IGNORE:
            case this.constructor.CollisionPolicy.CHANGE:
            case this.constructor.CollisionPolicy.ENQUEUE:
                break;
                
            default:
                collisionPolicy = this.constructor.CollisionPolicy.IGNORE;
                break;
        }
        
        this._collisionPolicy = collisionPolicy;
        
        return this;
    },

    /**
     * 作成メソッドの登録
     *
     * @param {Function} callback 作成メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setCreateMethod: function (callback, thisArg) {
        this._create = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 完了メソッドの登録
     *
     * @param {Function} callback 完了メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setCompleteMethod: function (callback, thisArg) {
        this._complete = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 成功メソッドの登録
     *
     * @param {Function} callback 成功メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setSuccessMethod: function (callback, thisArg) {
        this._success = {func: callback, thisArg: thisArg};

        return this;
    },
    
    /**
     * アボートメソッドの登録
     *
     * @param {Function} callback アボートメソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setAbortMethod: function (callback, thisArg) {
        this._abort = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * タイムアウトメソッドの登録(アボートメソッドが最後に呼ばれう)
     *
     * @param {Function} callback タイムアウトメソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setTimeoutMethod: function (callback, thisArg) {
        this._timeout = {func: callback, thisArg: thisArg};

        return this;
    },
    
    /**
     * 失敗メソッドの登録
     *
     * @param {Function} callback 失敗メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setFailureMethod: function (callback, thisArg) {
        this._failure = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 部分受信メソッドの登録
     *
     * @param {Function} callback 部分受信メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setInteractiveMethod: function (callback, thisArg) {
        this._interactive = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 送信準備完了メソッドの登録
     *
     * @param {Function} callback 送信準備完了メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setLoadedMethod: function (callback, thisArg) {
        this._loaded = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * コネクションオープンメソッドの登録
     *
     * @param {Function} callback コネクションオープンメソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setLoadingMethod: function (callback, thisArg) {
        this._loading = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * XMLHttpRequest生成メソッドの登録
     *
     * @param {Function} callback XMLHttpRequest生成メソッド<br />
     *                             コールバックメソッドに渡される引数はレスポンス, X-JSONオブジェクトとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Response response, Object jsonHeader)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setUninitializedMethod: function (callback, thisArg) {
        this._uninitialized = {func: callback, thisArg: thisArg};

        return this;
    },

    /**
     * 例外メソッドの登録
     *
     * @param {Function} callback 例外メソッド<br />
     *                             コールバックメソッドに渡される引数はリクエスト, エラーとなる<br />
     *                             void callback(Jeeel.Net.Ajax.Request request, Error error)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setExceptionMethod: function (callback, thisArg) {
        this._exception = {func: callback, thisArg: thisArg};

        return this;
    },
    
    /**
     * レスポンスフィールドパラメータの全取得
     *
     * @return {Hash} 値リスト
     */
    getFieldAll: function () {
        return this._fields.getAll();
    },

    /**
     * レスポンスフィールドパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getField: function (key, defaultValue) {
        return this._fields.get(key, defaultValue);
    },

    /**
     * レスポンスフィールドパラメータを総入れ替えする
     *
     * @param {Hash} vals 値リスト
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     * @throws {Error} valsが配列式でない場合に起こる
     */
    setFieldAll: function (vals) {
        if ( ! Jeeel.Type.isHash(vals)) {
            throw new Error('valsが配列・連想配列ではありあせん。');
        }

        this._fields.setAll(vals);

        return this;
    },

    /**
     * レスポンスフィールドパラメータの設定
     *
     * @param {String} key キー
     * @param {Mixied} val 値
     * @return {Jeeel.Net.Ajax} 自身のインスタンス
     */
    setField: function (key, val) {
        this._fields.set(key, val);

        return this;
    },

    /**
     * レスポンスフィールドの指定キーの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Net.Ajax} 自インスタンス
     */
    unsetField: function (key) {
        this._fields.unset(key);

        return this;
    },

    /**
     * レスポンスフィールドの指定キーの値を保持しているかどうかを返す
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    hasField: function (key) {
        return this._fields.has(key);
    },
    
    /**
     * 通信中かどうかを取得する
     * 
     * @return {Boolean} 通信中かどうか
     */
    isExecuting: function () {
        return this._executing || !!this._requestQueue.length;
    },
    
    /**
     * 通信に使用したリクエストを取得する
     * 
     * @return {Jeeel.Net.Ajax.Request} リクエスト
     */
    getRequest: function () {
        return this._request;
    },
    
    /**
     * 前回の通信のレスポンスを取得する
     * 
     * @return {Jeeel.Net.Ajax.Response} レスポンス
     */
    getResponse: function () {
        return this._response;
    },
    
    /**
     * 通信中のエラーを取得する
     * 
     * @return {Error} エラー
     */
    getError: function () {
        return this._error;
    },

    /**
     * 実際にAjaxを実行する
     *
     * @return {Jeeel.Net.Ajax} 自インスタンス
     */
    execute: function () {
        
        if (Jeeel.Acl && Jeeel.Acl.isDenied(this._url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
        
        if ( ! this.isValid()) {
            throw new Error('There is an error in the submission.');
        }
        
        // 通信中だった場合コリジョンポリシーに基づき動作を変える
        if (this._executing) {
            
            switch (this._collisionPolicy) {
                case this.constructor.CollisionPolicy.IGNORE:
                    return this;
                    break;
                
                case this.constructor.CollisionPolicy.CHANGE:
                    this.abort();
                    break;
                    
                case this.constructor.CollisionPolicy.ENQUEUE:
                    var ajax = this.clone();
                    this._requestQueue.push(ajax);
                    (this._requestQueue[this._requestQueue.length - 2] || this)._innerComplete = Jeeel.Function.Callback.create('_onRequestComplete', this);
                    return this;
                    break;
            }
        }
        
        if (this._retry && this._retry.retrying) {
            var callback = this._retry.callback;
            
            if (callback) {
                callback.func.call(callback.thisArg || this);
            }
            
            this._retry.retrying = false;
        }
        
        var self = this;
        
        this._request = new this.constructor.Request(this._url, {
            method: this._method,
            parameters: this._params.toQueryString(),
            fields: this._fields.getAll(),
            asynchronous: this._asynchronous,
            timeout: this._timeoutTime,
            onCreate: function (response, jsonHeader) {
                self._callMethod('_create', [response, jsonHeader]);

                self._response  = null;
                self._executing = true;
            },
            onComplete: function (response, jsonHeader) {
                self._callMethod('_complete', [response, jsonHeader]);

                self._response  = response;
                self._executing = false;
                
                if ( ! (self._retry && self._retry.retrying) && self._innerComplete) {
                    self._innerComplete.call();
                }
            },
            onSuccess: function (response, jsonHeader){
                self._callMethod('_success', [response, jsonHeader]);
            },
            onFailure: function (response, jsonHeader){
                if (self._retry && ( ! self._retry.limit || (self._retry.count < self._retry.limit))) {
                    self._retry.retrying = true;
                    self._retry.count++;
                    
                    Jeeel.Deferred.next(self.execute, self, self._retry.delayTime);
                } else {
                    if (self._failure) {
                        self._callMethod('_failure', [response, jsonHeader]);
                    } else {
                        Jeeel.errorHtmlDump('Failure', response.statusText + '(' + response.status + ')', response.responseText);
                    }
                }
            },
            onAbort: function (response, jsonHeader) {
                self._callMethod('_abort', [response, jsonHeader]);
            },
            onTimeout: function (response, jsonHeader) {
                if (self._retry && ( ! self._retry.limit || (self._retry.count < self._retry.limit))) {
                    self._retry.retrying = true;
                    self._retry.count++;
                    
                    Jeeel.Deferred.next(self.execute, self, self._retry.delayTime);
                } else {
                    self._callMethod('_timeout', [response, jsonHeader]);
                }
            },
            onInteractive: function (response, jsonHeader) {
                self._callMethod('_interactive', [response, jsonHeader]);
            },
            onLoaded: function (response, jsonHeader) {
                self._callMethod('_loaded', [response, jsonHeader]);
            },
            onLoading: function (response, jsonHeader) {
                self._callMethod('_loading', [response, jsonHeader]);
            },
            onUninitialized: function (response, jsonHeader) {
                self._callMethod('_uninitialized', [response, jsonHeader]);
            },
            onException: function (request, error) {
                self._error     = error;
                self._executing = false;
                
                if (self._exception) {
                    self._callMethod('_exception', [request, error]);
                } else if ( ! Jeeel.errorHtmlDump('Exception', error.name, error.fileName + '(' + error.lineNumber + ')', error.message, request.transport.responseText)) {
                    throw error;
                }
            }
        });
        
        return this;
    },
    
    /**
     * 通信を中止する
     * 
     * @return {Jeeel.Net.Ajax} 自インスタンス
     */
    abort: function () {
        if (this._request && this._executing) {
            this._request.abort();
            this._executing = false;
        }
        
        return this;
    },
    
    /**
     * インスタンスの複製を作成する
     * 
     * @return {Jeeel.Net.Ajax} 複製インスタンス
     */
    clone: function () {
        var ajax = new this.constructor(this._url, this._method);
        
        for (var key in this) {
            if (this.hasOwnProperty(key)) {
                
                // 状態変数や一時変数は複製すべきではない
                switch (key) {
                    case '_requestQueue':
                    case '_innerComplete':
                    case '_executing':
                    case '_request':
                    case '_response':
                    case '_error':
                        continue;
                        break;
                }
                
                if (Jeeel.Type.isArray(this[key])) {
                    ajax[key] = this[key].concat();
                } else if (this[key] instanceof Jeeel.Parameter) {
                    ajax[key] = this[key].clone();
                } else {
                    ajax[key] = this[key];
                }
            }
        }
        
        return ajax;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {String} url Ajax対象URLの文字列
     * @param {String} [method] HTTPメソッド(getまたはpost、大文字小文字は問わない、初期値はPOST)
     * @constructor
     */
    constructor: Jeeel.Net.Ajax,
    
    /**
     * メソッドを呼び出す
     * 
     * @param {String} name メソッド名
     * @param {Array} [args] メソッドに引き渡す引数の配列
     */
    _callMethod: function (name, args) {
        if ( ! this[name]) {
            return;
        }
        
        this[name].func.apply(this[name].thisArg || this, args || []);
    },
    
    /**
     * _innerCompleteに対して登録するコールバック
     */
    _onRequestComplete: function () {
        
        switch (this._collisionPolicy) {
            case this.constructor.CollisionPolicy.ENQUEUE:
                var ajax = this._requestQueue.shift();
                
                if (ajax) {
                    ajax.execute();
                }
                break;
        }
    }
};

Jeeel.Class.extend(Jeeel.Net.Ajax, Jeeel.Net.Abstract);

Jeeel.file.Jeeel.Net.Ajax = ['Request', 'Response', 'CollisionPolicy'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Net.Ajax, Jeeel.file.Jeeel.Net.Ajax);

/**
 * コンストラクタ
 *
 * @class 実際にAjax通信を行うクラス
 * @param {String} url 対象URL
 * @param {Hash} options オプション
 */
Jeeel.Net.Ajax.Request = function (url, options) {
    var self = this;

    self.options = Jeeel.Hash.merge(self.options, options || {});

    self.options.method = self.options.method.toLowerCase();

    if (Jeeel.Type.isString(self.options.parameters)) {
        self.options.parameters = Jeeel.Filter.Url.QueryParameter.create().filter(self.options.parameters);
    }

    self.transport = Jeeel.Net.Ajax.createXMLHttpRequest();
    self.request(url);
};

/**
 * イベントを表す定数のリスト
 * 
 * @type String[]
 */
Jeeel.Net.Ajax.Request.Events = ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];

/**
 * 現在アクティブなRequestの数
 *
 * @type Integer
 */
Jeeel.Net.Ajax.Request.activeRequestCount = 0;

/**
 * レスポンスを処理するモジュール<br />
 * 追加登録することでデバッグ等を行える
 */
Jeeel.Net.Ajax.Request.responder = {

    /**
     * Requestが作成された場合に呼ばれる
     */
    onCreate: function () {
        Jeeel.Net.Ajax.Request.activeRequestCount++;
    },

    /**
     * Requestが終了した場合に呼ばれる
     */
    onComplete: function () {
        Jeeel.Net.Ajax.Request.activeRequestCount--;
    }
};

/**
 * レスポンスモジュールを呼び出す
 *
 * @param {String} methodName メソッド名
 * @param {Jeeel.Net.Ajax.Request} request アクセス中のRequest
 * @param {XMLHttpRequest} transport 基となるXMLHttpRequestオブジェクト
 * @param {Mixied} json Jsonを解析した後のオブジェクト
 */
Jeeel.Net.Ajax.Request.dispatch = function (methodName, request, transport, json) {
    var obj = Jeeel.Net.Ajax.Request.responder;

    if (Jeeel.Type.isFunction(obj[methodName])) {

        obj[methodName].call(obj, request, transport, json);
    }
};

Jeeel.Net.Ajax.Request.prototype = {

    /**
     * アクセスが終了したかどうか
     * 
     * @type Boolean
     */
    _complete: false,
    
    /**
     * タイムアウトID
     * 
     * @type Integer
     */
    _timeoutId: 0,
    
    /**
     * 作成時刻
     * 
     * @type Date 
     */
    createTimestamp: null,

    /**
     * ベースに使用するXMLHttpRequestオブジェクト
     *
     * @type XMLHttpRequest
     */
    transport: null,

    /**
     * アクセス時に使用するオプション
     *
     * @type Hash
     */
    options: {
        method:       'post',
        asynchronous: true,
        contentType:  'application/x-www-form-urlencoded',
        encoding:     'UTF-8',
        parameters:   '',
        evalJSON:     true,
        evalJS:       true,
        fields:       {},
        timeout:      0
    },

    /**
     * 現在のステータスを取得する
     *
     * @return {Integer} ステータス
     */
    getStatus: function () {
        try {
            return this.transport.status || 0;
        } catch (e) {
            return 0;
        }
    },

    /**
     * ヘッダを取得する
     *
     * @param {String} name ヘッダ名
     * @return {String} ヘッダ情報
     */
    getHeader: function (name) {
        try {
            return this.transport.getResponseHeader(name) || null;
        } catch (e) {
            return null;
        }
    },

    /**
     * レスポンスをJsonと見立ててオブジェクトに変換する
     *
     * @return {Mixied} 変換後のオブジェクト
     */
    evalResponse: function () {
        var json = this.transport.responseText || '';
        json = decodeURIComponent(json);
        try {
            return Jeeel.Json.decode(json);
        } catch (e) {
            this.dispatchException(e);
        }
    },

    /**
     * 実際にサーバーにアクセスを行う
     *
     * @param {String} url アクセスURL
     */
    request: function (url) {
        this.url = url;
        this.method = this.options.method;
        var params = Jeeel.Method.clone(this.options.parameters);

        if ( ! Jeeel.Hash.inHash(this.method, ['get', 'post'])) {
            params['_method'] = this.method;
            this.method = 'post';
        }

        this.parameters = params;

        params = Jeeel.Parameter.create(params).toQueryString();

        if (params) {
            if (this.method == 'get') {
                this.url += (this.url.indexOf('?') > -1 ? '&' : '?') + params;
            } else if (/Konqueror|Safari|KHTML/.test(navigator.userAgent)) {
                params += '&_=';
            }
        }

        try {
            var response = new Jeeel.Net.Ajax.Response(this);

            if (this.options.onCreate){
                this.options.onCreate(response);
            }
            
            this.createTimestamp = new Date();

            Jeeel.Net.Ajax.Request.dispatch('onCreate', this, response);

            if (this.options.user && this.options.password) {
                this.transport.open(this.method.toUpperCase(), this.url, this.options.asynchronous, this.options.user, this.options.password);
            } else {
                this.transport.open(this.method.toUpperCase(), this.url, this.options.asynchronous);
            }

            if (this.options.asynchronous) {
                if (this.options.timeout) {
                    var self = this;
                    
                    this._timeoutId = setTimeout(function () {
                            var response = new Jeeel.Net.Ajax.Response(self);
                            
                            self.options.onTimeout(response, response.headerJSON);
                            self.abort();
                        }, this.options.timeout
                    );
                }
                
                Jeeel.Function.create(this.readyStateChange).bind(this).delay(1)();
            }

            this.transport.onreadystatechange = Jeeel.Function.create(this.onStateChange).bind(this);
            this.setRequestHeaders();

            this.body = (this.method == 'post' ? (this.options.postBody || params) : null);
            this.transport.send(this.body);

            /* Force Firefox to handle ready state 4 for synchronous requests */
            if ( ! this.options.asynchronous && this.transport.overrideMimeType) {
                this.onStateChange();
            }

        }
        catch (e) {
            this.dispatchException(e);
        }
    },
    
    /**
     * アクセスを中止する
     */
    abort: function () {
        
        if (this._complete) {
            return;
        }
        
        this.transport.abort();

        if (this.options.onAbort) {
            var response = new Jeeel.Net.Ajax.Response(this);
            this.options.onAbort(response, response.headerJSON);
        }
        
        clearTimeout(this._timeoutId);
    },

    /**
     * ステータスが変化されるたびに呼ばれるメソッド
     */
    onStateChange: function () {
        var readyState = this.transport.readyState;
        
        if (readyState > 1 && !((readyState == 4) && this._complete)) {
            this.readyStateChange(this.transport.readyState);
        }
    },
    
    /**
     * 通信が成功したかどうかを返す
     *
     * @return {Boolean} 通信が成功したかどうか
     */
    isSuccess: function () {
        var status = this.getStatus();
        return !status || (status >= 200 && status < 300);
    },

    /**
     * ステータスが変化するたびに呼ばれる
     * 
     * @param {String} readyState 現在のステートを表す文字列
     */
    readyStateChange: function (readyState) {
        
        try {
            var state = Jeeel.Net.Ajax.Request.Events[readyState];
            var response = new Jeeel.Net.Ajax.Response(this);

            if (state == 'Complete') {
                this._complete = true;
                (this.options['on' + response.status] ||
                this.options['on' + (this.isSuccess() ? 'Success' : 'Failure')] ||
                Jeeel.Function.Template.EMPTY)(response, response.headerJSON);

                var contentType = response.getHeader('Content-type');

                if (this.options.evalJS == 'force'
                    || (this.options.evalJS && this.isSameOrigin() && contentType
                        && contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
                {
                    this.evalResponse();
                }
            }

            (this.options['on' + state] || Jeeel.Function.Template.EMPTY)(response, response.headerJSON);
            Jeeel.Net.Ajax.Request.dispatch('on' + state, this, response, response.headerJSON);

            if (state == 'Complete') {
                this.transport.onreadystatechange = Jeeel.Function.Template.EMPTY;
                clearTimeout(this._timeoutId);
            }
        } catch (e) {
            this.dispatchException(e);
        }
    },

    /**
     * ヘッダをセットする
     */
    setRequestHeaders: function () {
        var headers = {
            'X-Requested-With': 'XMLHttpRequest',
            'X-Jeeel-Version': Jeeel.VERSION,
            'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
        };

        if (this.method === 'post') {
            headers['Content-type'] = this.options.contentType +
            (this.options.encoding ? '; charset=' + this.options.encoding : '');

            if (this.transport.overrideMimeType &&
                (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
            {
                headers['Connection'] = 'close';
            }
        }

        if (typeof this.options.requestHeaders === 'object') {
            var extras = this.options.requestHeaders;

            if (Jeeel.Type.isFunction(extras.push)) {
                for (var i = 0, length = extras.length; i < length; i += 2) {
                    headers[extras[i]] = extras[i+1];
                }
            }
            else {
                for (var key in extras) {
                    headers[key] = extras[key];
                }
            }
        }

        for (var name in headers) {
            this.transport.setRequestHeader(name, headers[name]);
        }
    },

    /**
     * 現在のアクセスドメインと同等の場所へのアクセスかどうかを返す
     *
     * @return {Boolean} 現ドメインと同じプロトコル・ドメイン・ポートへのアクセスかどうか
     */
    isSameOrigin: function () {
        var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
        return !m || (m[0] == (location.protocol + '//' + Jeeel._doc.domain + (location.port ? ':' + location.port : '')));
    },

    /**
     * エラーが発生した場合に処理するメソッド
     * 
     * @param {Error} error エラーオブジェクト
     */
    dispatchException: function (error) {

        if (this.options.onException) {
            this.options.onException(this, error);
        } else {
            throw error;
        }
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     * @param {String} url 対象URL
     * @param {Hash} options オプション
     */
    constructor: Jeeel.Net.Ajax.Request
};

/**
 * コンストラクタ
 *
 * @class AjaxのResponseを表すクラス
 * @param {Jeeel.Net.Ajax.Request} request リクエスト
 */
Jeeel.Net.Ajax.Response = function (request) {

    var self = this;

    self.request = request;
    self.fields  = request.options.fields;
    var transport = self.transport = request.transport;
    var readyState = self.readyState = transport.readyState;

    if ((readyState > 2 && ! Jeeel.UserAgent.isInternetExplorer()) || readyState == 4) {
        self.status       = self.getStatus();
        self.statusText   = self.getStatusText();
        self.responseText = (transport.responseText ? transport.responseText : '');
        self.headerJSON   = self._getHeaderJSON();
    }

    if (readyState == 4) {
        var xml = transport.responseXML;
        self.responseXML  = Jeeel.Type.isUndefined(xml) ? null : xml;
        self.responseJSON = self._getResponseJSON();
    }
};

Jeeel.Net.Ajax.Response.prototype = {

    /**
     * 現在の状態でのステータス
     *
     * @type Integer
     */
    status: 0,

    /**
     * 現在のステータスを示す文字列
     *
     * @type String
     */
    statusText: '',

    /**
     * テキストの戻り値
     *
     * @type String
     */
    responseText: null,

    /**
     * XMLの戻り値
     * 
     * @type XMLDocument
     */
    responseXML: null,

    /**
     * Jsonの戻り値
     *
     * @type Mixied
     */
    responseJSON: null,

    /**
     * リクエスト時に渡したフィールドパラメータ
     *
     * @type Hash
     */
    fields: null,
    
    /**
     * レスポンスフィールドパラメータの全取得
     *
     * @return {Hash} 値リスト
     */
    getFieldAll: function () {
        return this.fields;
    },

    /**
     * レスポンスフィールドパラメータの取得
     *
     * @param {String} key キー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixied} 値
     */
    getField: function (key, defaultValue) {
        return Jeeel.Type.isSet(this.fields[key]) ? this.fields[key] : defaultValue;
    },

    /**
     * ヘッダを取得する<br />
     * エラーが起こった場合や存在しない場合はnullを返す
     *
     * @param {String} name ヘッダ名
     * @return {String} ヘッダ情報
     */
    getHeader: function (name) {
        try {
            return this.transport.getResponseHeader(name) || null;
        } catch (e) {
            return null;
        }
    },

    /**
     * ヘッダをそのまま取得する
     *
     * @param {String} name ヘッダ名
     * @return {String} ヘッダ情報
     */
    getResponseHeader: function (name) {
        return this.transport.getResponseHeader(name);
    },

    /**
     * ヘッダを全て取得する<br />
     * エラーが起こった場合や存在しない場合はnullを返す
     *
     * @return {String} ヘッダ情報
     */
    getAllHeaders: function () {
        try {
            return this.getAllResponseHeaders();
        } catch (e) {
            return null;
        }
    },

    /**
     * ヘッダを全てをそのまま取得する
     *
     * @return {String} ヘッダ情報
     */
    getAllResponseHeaders: function () {
        return this.transport.getAllResponseHeaders();
    },

    /**
     * 現在のステータスを取得する
     *
     * @return {Integer} ステータス
     */
    getStatus: function () {
        try {
            return this.transport.status || 0;
        } catch (e) {
            return 0;
        }
    },

    /**
     * 現在のステータスを示す文字列を取得する
     *
     * @return {Integer} ステータス文字列
     */
    getStatusText: function () {
        try {
            return this.transport.statusText || '';
        } catch (e) {
            return '';
        }
    },

    /**
     * 戻り値を強制的にJsonに変換して取得する<br />
     * 変換できなかった場合は空の連想配列になる
     *
     * @return {Mixied} 変換後のJsonオブジェクト(連想配列)
     */
    getResponseJSON: function () {
        var res;
        
        var options = this.request.options;
        
        try {
            res = Jeeel.Json.decode(decodeURIComponent(this.responseText), ! options.sanitizeJSON && this.request.isSameOrigin());
        } catch (e) {
            res = {};
        }

        return res;
    },
    
    /**
     * 戻り値を強制的にXMLに変換して取得する<br />
     * 変換できなかった場合はnullになる
     *
     * @return {Jeeel.Dom.Xml} 変換後のXMLインスタンス
     */
    getResponseXML: function () {
        var res;

        try {
            res = new Jeeel.Dom.Xml(this.responseXML || this.responseText);
        } catch (e) {
            res = null;
        }

        return res;
    },
    
    /**
     * headerJsonを取得する
     *
     * @return {Mixied} Jsonを変換した後のオブジェクト
     * @protected
     */
    _getHeaderJSON: function () {
        var json = this.getHeader('X-JSON');
        
        if ( ! json) {
            return null;
        }

        json = decodeURIComponent(json);

        try {
            return Jeeel.Json.decode(json);
        } catch (e) {
            this.request.dispatchException(e);
        }
    },

    /**
     * 戻り値のJsonを取得する<br />
     * ただしヘッダにjson情報が書き込まれている必要がある
     *
     * @return {Mixied} Jsonを変換した後のオブジェクト
     * @protected
     */
    _getResponseJSON: function () {
        var options = this.request.options;

        if (!options.evalJSON || (options.evalJSON != 'force' &&
            (this.getHeader('Content-type') || '').indexOf('application/json') < 0) || this.responseText.match(/^\s*$/)) {
            return null;
        }

        try {
            return Jeeel.Json.decode(decodeURIComponent(this.responseText), ! options.sanitizeJSON && this.request.isSameOrigin());
        } catch (e) {
            this.request.dispatchException(e);
        }
    }
};

/**
 * @namespace 並列リクエストをした時の動作ポリシー列挙体
 */
Jeeel.Net.Ajax.CollisionPolicy = {
  
    /**
     * 新しいリクエストを無視する
     *
     * @type Integer
     * @constant
     */
    IGNORE: 0,
    
    /**
     * 現在通信中のリクエストを破棄し新しいリクエストに置き換える
     *
     * @type Integer
     * @constant
     */
    CHANGE: 1,
    
    /**
     * 現在通信中のリクエストの終了後に次の通信を行う用にキューにリクエストを入れる
     *
     * @type Integer
     * @constant
     */
    ENQUEUE: 2
};

if (Jeeel._auto) {
    Jeeel._tmp();
}
(function () {
    var index = 0;
    
    /**
     * コンストラクタ
     * 
     * @class Jsonp通信の制御を行うクラス
     * @augments Jeeel.Net.Abstract
     * @param {String} url Jsonp通信URL
     * @throws {Error} urlが指定されていない場合に起こる
     */
    Jeeel.Net.Jsonp = function (url) {
        if ( ! Jeeel.Type.isString(url)) {
            throw new Error('URLを指定してください。');
        }
        
        Jeeel.Net.Abstract.call(this);

        this._url = url;
        this._loaded = Jeeel.Function.simpleBind(this._loaded, this);

        this._id = index++;
    };
})();

/**
 * インスタンスの作成を行う
 * 
 * @param {String} url Jsonp通信URL
 * @return {Jeeel.Net.Jsonp} 作成したインスタンス
 * @throws {Error} urlが指定されていない場合に起こる
 */
Jeeel.Net.Jsonp.create = function (url) {
    return new this(url);
};

Jeeel.Net.Jsonp.prototype = {
  
    /**
     * インスタンスの固有ID
     * 
     * @type Integer
     * @private
     */
    _id: null,

    /**
     * Jsonp通信URL
     *
     * @type String
     * @private
     */
    _url: '',
    
    /**
     * サーバー側で呼び出させるためのキャッシュキー
     * 
     * @type String
     * @private
     */
    _callbackKey: null,
    
    /**
     * Jsonp通信終了後のコールバック
     * 
     * @type Hash
     * @private
     */
    _loadCallback: null,
    
    /**
     * スクリプトタグ
     * 
     * @type Element
     * @private
     */
    _script: null,

    /**
     * Jsonp通信URLの設定
     *
     * @param {String} url Jsonp通信URL
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     * @throws {Error} urlが文字列でない場合に起こる
     */
    setUrl: function (url) {
        if ( ! Jeeel.Type.isString(url)) {
            throw new Error('URLを指定してください。');
        }

        this._url = url;

        return this;
    },
    
    /**
     * Jsonp通信時にサーバー側で呼び出すコールバックを設定する<br />
     * このコールバック設定を使用した場合グローバル関数を作成する必要は無くなる<br />
     * ただし、Jsonp通信が終了した時点でこのコールバックは無効になる
     * 
     * @param {String} callbackKey サーバー側でコールバックの名前を取得する際のキー
     * @param {Function} callback 実際に呼び出されるコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     */
    setCallback: function (callbackKey, callback, thisArg) {
        
        this._callbackKey = callbackKey;
        
        Jeeel._jsp['f' + this._id] = function () {
            callback.apply(thisArg, arguments);
        };
        
        this._params.set(callbackKey, 'Jeeel._jsp.f' + this._id);
        
        return this;
    },
    
    /**
     * Jsonp通信終了後に呼び出すメソッドを設定する
     * 
     * @param {Function} callback 通信終了メソッド<br />
     *                             コールバックメソッドに渡される引数はJsonpを行ったスクリプトElementになる<br />
     *                             void callBack(Element script)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     */
    setLoadedMethod: function (callback, thisArg) {
        this._loadCallback = {func: callback, thisArg: thisArg};
        
        return this;
    },

    /**
     * 実際にJsonp通信を実行する
     *
     * @return {Jeeel.Net.Jsonp} 自インスタンス
     */
    execute: function () {
        if (Jeeel.Acl && Jeeel.Acl.isDenied(this._url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
        
        if ( ! this.isValid()) {
            throw new Error('There is an error in the submission.');
        }
      
        var url = this._url + '?' + this._params.toQueryString();
        
        this._script = Jeeel.Loader.loadScript(url, this._loaded);
         
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Net.Jsonp,
    
    /**
     * 読み込み終了後に呼ばれるイベントメソッド
     */
    _loaded: function () {
        Jeeel.Dom.Element.create(this._script).remove();

        if (this._loadCallback) {
            this._loadCallback.func.call(this._loadCallback.thisArg || this, this._script);
        }
        
        if (this._callbackKey) {
            this._params.unset(this._callbackKey);
            
            delete Jeeel._jsp['f' + this._id];
        }

        this._script = null;
    }
};

Jeeel.Class.extend(Jeeel.Net.Jsonp, Jeeel.Net.Abstract);

/**
 * コンストラクタ
 * 
 * @class ビーコンを使用した通信を提供するクラス
 * @augments Jeeel.Net.Abstract
 * @param {String} url データ送信先URL
 * @throws {Error} urlが指定されていない場合に起こる
 */
Jeeel.Net.Beacon = function (url) {

    if ( ! Jeeel.Type.isString(url)) {
        throw new Error('URLを指定してください。');
    }
        
    Jeeel.Net.Abstract.call(this);
    
    this._url = url;
    this._onLoad = Jeeel.Function.simpleBind(this._onLoad, this);
    this._onError = Jeeel.Function.simpleBind(this._onError, this);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} url データ送信先URL
 * @return {Jeeel.Net.Beacon} 作成したインスタンス
 */
Jeeel.Net.Beacon.create = function (url) {
    return new this(url);
};

Jeeel.Net.Beacon.prototype = {
  
    /**
     * ビーコン通信URL
     *
     * @type String
     * @private
     */
    _url: '',
    
    /**
     * ビーコン
     * 
     * @type Element
     * @private
     */
    _beacon: null,
    
    /**
     * ビーコンの通信成功時のコールバック
     * 
     * @type Hash
     * @private
     */
    _loadCallback: null,
    
    /**
     * ビーコンの通信失敗時のコールバック
     * 
     * @type Hash
     * @private
     */
    _errorCallback: null,
    
    /**
     * ビーコン通信終了後に呼び出すメソッドを設定する
     * 
     * @param {Function} callback 通信終了メソッド<br />
     *                             コールバックメソッドに渡される引数はビーコンElementになる<br />
     *                             void callBack(Element script)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Beacon} 自インスタンス
     */
    setLoadedMethod: function (callback, thisArg) {
        this._loadCallback = {func: callback, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * ビーコン通信失敗時に呼び出すメソッドを設定する
     * 
     * @param {Function} callback 通信終了メソッド<br />
     *                             コールバックメソッドに渡される引数はビーコンElementになる<br />
     *                             void callBack(Element script)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Net.Beacon} 自インスタンス
     */
    setErrorMethod: function (callback, thisArg) {
        this._errorCallback = {func: callback, thisArg: thisArg};
        
        return this;
    },

    /**
     * 実際にビーコン通信を実行する
     *
     * @return {Jeeel.Net.Beacon} 自インスタンス
     */
    execute: function () {
        if (Jeeel.Acl && Jeeel.Acl.isDenied(this._url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
        
        if ( ! this.isValid()) {
            throw new Error('There is an error in the submission.');
        }
        
        var url = this._url + '?' + this._params.toQueryString();
        
        var beacon = new Image();
        
        beacon.src = url;
        
        beacon.onload = this._onLoad;
        beacon.onerror = this._onError;
        
        this._beacon = beacon;
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {String} url データ送信先URL
     * @constructor
     */
    constructor: Jeeel.Net.Beacon,
    
    /**
     * 読み込み完了イベント
     */
    _onLoad: function () {
        if (this._loadCallback) {
            this._loadCallback.func.call(this._loadCallback.thisArg || this, this._beacon);
        }
    },
    
    /**
     * 通信エラーイベント
     */
    _onError: function () {
        if (this._errorCallback) {
            this._errorCallback.func.call(this._errorCallback.thisArg || this, this._beacon);
        }
    }
};

Jeeel.Class.extend(Jeeel.Net.Beacon, Jeeel.Net.Abstract);

/**
 * コンストラクタ
 * 
 * @class サーバーを監視する機能を管理するクラス(Server-Sent Events)
 * @param {String} [url] コネクションを張るURL
 * @example
 * サーバー側
 * サーバー側でアクセスするURLに以下のヘッダを設定
 * "Content-type: text/event-stream;"
 * 
 * レスポンスは行区切りでキーとペアで返す
 * data: [dataString] // レスポンスに載せるデータ
 * event: [customEventName] // カスタムイベントに使用するイベント名
 * retry: [nextAccessTimeout] // 次にアクセスするまでの時間(ミリ秒)
 * 
 * クライアント側
 * var c = new Jeeel.Net.Comet();
 * c.addResponseEvent(listener); // レスポンスが帰ってきた際のイベント登録
 * c.addErrorEvent(listener); // エラー時のイベント登録
 * 
 * c.open(URL);
 */
Jeeel.Net.Comet = function (url) {
    this._openEvent = Jeeel.Function.simpleBind(this._openEvent, this);
    this._messageEvent = Jeeel.Function.simpleBind(this._messageEvent, this);
    this._errorEvent = Jeeel.Function.simpleBind(this._errorEvent, this);
    this._customEvent = Jeeel.Function.simpleBind(this._customEvent, this);
        
    this._opens = [];
    this._messages = [];
    this._errors = [];
    this._customs = {};
    
    this.open(url);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} [url] コネクションを張るURL
 * @return {Jeeel.Net.Comet} 作成したインスタンス
 */
Jeeel.Net.Comet.create = function (url) {
    return new this(url);
};

Jeeel.Net.Comet.prototype = {
  
    /**
     * コネクション
     * 
     * @type EventSource
     * @private
     */
    _source: null,
    
    /**
     * オープンイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _opens: [],
    
    /**
     * メッセージイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _messages: [],
    
    /**
     * エラーイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _errors: [],
    
    /**
     * カスタムイベントリスト
     * 
     * @type Hash
     * @private
     */
    _customs: {},
    
    /**
     * オープンイベント
     * 
     * @private
     */
    _openEvent: function (e) {
        var evs = this._opens;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * メッセージイベント
     * 
     * @private
     */
    _messageEvent: function (e) {
        var evs = this._messages;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * エラーイベント
     * 
     * @private
     */
    _errorEvent: function (e) {
        var evs = this._errors;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * カスタムイベント
     * 
     * @private
     */
    _customEvent: function (e) {
        var evs = this._customs[e.type];
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * コネクションを張り終えた際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    addOpenEvent: function (listener) {
        this._opens.push(listener);

        return this;
    },
    
    /**
     * サーバーがレスポンスを返した際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    addResponseEvent: function (listener) {
        this._messages.push(listener);

        return this;
    },

    /**
     * サーバー側でイベント名を指定した場合に呼ばれる独自イベントの追加を行う<br >
     * その際レスポンスイベントは発生しない
     * 
     * @param {String} eventName イベント名
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    addCustomEvent: function (eventName, listener) {
        
        if ( ! (eventName in this._customs)) {
            this._customs[eventName] = [];
            
            if (this._source) {
                this._source.addEventListener(eventName, this._customEvent, false);
            }
        }
        
        this._customs[eventName].push(listener);
        
        return this;
    },
    
    /**
     * タスク内でエラーが発生した場合に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    addErrorEvent: function (listener) {
        this._errors.push(listener);

        return this;
    },
    
    /**
     * 新たにコネクションを張り直す<br />
     * その際前のコネクションは閉じられる
     * 
     * @param {String} url コネクションを張るURL
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    open: function (url) {
        
        if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
        
        if ( ! url) {
            return this;
        } else if (this._source) {
            this.close();
        }
        
        this._source = new EventSource(url);
        
        this._source.onopen = this._openEvent;
        this._source.onmessage = this._messageEvent;
        this._source.onerror = this._errorEvent;
        
        if (Jeeel.Hash.getCount(this._customs)) {
            for (var name in this._customs) {
                this._source.addEventListener(name, this._customEvent, false);
            }
        }
        
        return this;
    },
    
    /**
     * コネクションを閉じる
     * 
     * @return {Jeeel.Net.Comet} 自インスタンス
     */
    close: function () {
        
        if ( ! this._source) {
            return this;
        }
        
        for (var name in this._customs) {
            this._source.removeEventListener(name, this._customEvent, false);
        }
        
        this._source.close();
        
        this._source = null;
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     * @param {String} [url] コネクションを張るURL
     */
    constructor: Jeeel.Net.Comet
};

/**
 * コンストラクタ
 * 
 * @class 双方向通信の機能を管理するクラス
 * @param {String} [url] コネクションを張るURL
 */
Jeeel.Net.Socket = function (url) {
    this._openEvent = Jeeel.Function.simpleBind(this._openEvent, this);
    this._closeEvent = Jeeel.Function.simpleBind(this._closeEvent, this);
    this._messageEvent = Jeeel.Function.simpleBind(this._messageEvent, this);
    this._errorEvent = Jeeel.Function.simpleBind(this._errorEvent, this);
    
    this._opens = [];
    this._closes = [];
    this._messages = [];
    this._errors = [];
    
    this.open(url);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} [url] コネクションを張るURL
 * @return {Jeeel.Net.Socket} 作成したインスタンス
 */
Jeeel.Net.Socket.create = function (url) {
    return new this(url);
};

Jeeel.Net.Socket.prototype = {
  
    /**
     * ソケット
     * 
     * @type WebSocket
     * @private
     */
    _socket: null,
    
    /**
     * オープンイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _opens: [],
    
    /**
     * クローズイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _closes: [],
    
    /**
     * メッセージイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _messages: [],
    
    /**
     * エラーイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _errors: [],
    
    /**
     * オープンイベント
     * 
     * @private
     */
    _openEvent: function (e) {
        var evs = this._opens;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * クローズイベント
     * 
     * @private
     */
    _closeEvent: function (e) {
        var evs = this._closes;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * メッセージイベント
     * 
     * @private
     */
    _messageEvent: function (e) {
        var evs = this._messages;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * エラーイベント
     * 
     * @private
     */
    _errorEvent: function (e) {
        var evs = this._errors;
        
        for (var i = 0, l = evs.length; i < l; i++) {
            evs[i](e);
        }
    },
    
    /**
     * コネクションを張り終えた際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    addOpenEvent: function (listener) {
        this._opens.push(listener);

        return this;
    },
    
    /**
     * コネクションを閉じた際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    addCloseEvent: function (listener) {
        this._closes.push(listener);

        return this;
    },
    
    /**
     * サーバー側からデータを受信した際に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    addReceiveEvent: function (listener) {
        this._messages.push(listener);

        return this;
    },

    /**
     * タスク内でエラーが発生した場合に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    addErrorEvent: function (listener) {
        this._errors.push(listener);

        return this;
    },
    
    /**
     * サーバー側にデータを送信する
     * 
     * @param {String} content サーバー側に送るデータ
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    send: function (content) {
        if (this._socket.readyState === 1) {
            this._socket.send(content);
        }
        
        return this;
    },
    
    /**
     * 新たにコネクションを張り直す<br />
     * その際前のコネクションは閉じられる
     * 
     * @param {String} url コネクションを張るURL
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    open: function (url) {
        
        if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
        
        if ( ! url) {
            return this;
        } else if (this._socket) {
            this.close();
        }
        
        this._socket = new WebSocket(url);
        
        this._socket.onopen = this._openEvent;
        this._socket.onclose = this._closeEvent;
        this._socket.onmessage = this._messageEvent;
        this._socket.onerror = this._errorEvent;
        
        return this;
    },
    
    /**
     * コネクションを閉じる
     * 
     * @return {Jeeel.Net.Socket} 自インスタンス
     */
    close: function () {
        
        if ( ! this._socket) {
            return this;
        }
        
        this._socket.close();
        
        this._socket = null;
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     * @param {String} [url] コネクションを張るURL
     */
    constructor: Jeeel.Net.Socket
};

Jeeel.directory.Jeeel.Code = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Code/';
    }
};

/**
 * @namespace コード関連のネームスペース
 */
Jeeel.Code = {

};

Jeeel.file.Jeeel.Code = ['CharCode', 'CharEncoding', 'HtmlCode'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Code, Jeeel.file.Jeeel.Code);

/**
 * @namespace 文字コードに関する列挙体
 */
Jeeel.Code.CharCode = {

    /**
     * 空文字
     *
     * @type Integer
     * @constant
     */
    Null: 0x00,

    /**
     * ヘッダ開始
     *
     * @type Integer
     * @constant
     */
    StartOfHeading: 0x01,

    /**
     * テキスト開始
     *
     * @type Integer
     * @constant
     */
    StartOfText: 0x02,

    /**
     * テキスト終了
     *
     * @type Integer
     * @constant
     */
    EndOfText: 0x03,

    /**
     * 伝送終了
     *
     * @type Integer
     * @constant
     */
    EndOfTransmission: 0x04,

    /**
     * 問い合わせ
     *
     * @type Integer
     * @constant
     */
    Enquiry: 0x05,
    
    /**
     * 肯定応答
     *
     * @type Integer
     * @constant
     */
    Acknowledge: 0x06,

    /**
     * ベル
     *
     * @type Integer
     * @constant
     */
    Bell: 0x07,

    /**
     * 1文字後退
     *
     * @type Integer
     * @constant
     */
    BackSpace: 0x08,

    /**
     * 水平タブ
     *
     * @type Integer
     * @constant
     */
    HorizontalTabulation: 0x09,
    
    /**
     * 改行
     *
     * @type Integer
     * @constant
     */
    LineFeed: 0x0A,

    /**
     * 垂直タブ
     *
     * @type Integer
     * @constant
     */
    VerticalTabulation: 0x0B,
    
    /**
     * 改ページ
     *
     * @type Integer
     * @constant
     */
    FormFeed: 0x0C,

    /**
     * 復帰
     *
     * @type Integer
     * @constant
     */
    CarriageReturn: 0x0D,
    
    /**
     * シフトアウト
     *
     * @type Integer
     * @constant
     */
    ShiftOut: 0x0E,

    /**
     * シフトイン
     *
     * @type Integer
     * @constant
     */
    ShiftIn: 0x0F,
    
    /**
     * データリンク拡張
     *
     * @type Integer
     * @constant
     */
    DataLinkEscape: 0x10,

    /**
     * 装置制御1(XON)
     *
     * @type Integer
     * @constant
     */
    DeviceControl1: 0x11,

    /**
     * 装置制御2
     *
     * @type Integer
     * @constant
     */
    DeviceControl2: 0x12,

    /**
     * 装置制御3(XOFF)
     *
     * @type Integer
     * @constant
     */
    DeviceControl3: 0x13,
    
    /**
     * 装置制御4
     *
     * @type Integer
     * @constant
     */
    DeviceControl4: 0x14,

    /**
     * 否定応答
     *
     * @type Integer
     * @constant
     */
    NegativeAcKnowledge: 0x15,

    /**
     * 同期信号
     *
     * @type Integer
     * @constant
     */
    SynchronousIdle: 0x16,

    /**
     * ブロック転送終了
     *
     * @type Integer
     * @constant
     */
    EndOfTransmissionBlock: 0x17,

    /**
     * 取り消し
     *
     * @type Integer
     * @constant
     */
    Cancel: 0x18,

    /**
     * メディア終了
     *
     * @type Integer
     * @constant
     */
    EndOfMedium: 0x19,
    
    /**
     * 置換(EOF)
     *
     * @type Integer
     * @constant
     */
    SubstituteCharacter: 0x1A,

    /**
     * エスケープ
     *
     * @type Integer
     * @constant
     */
    Escape: 0x1B,

    /**
     * ファイル区切り
     *
     * @type Integer
     * @constant
     */
    FileSeparator: 0x1C,

    /**
     * グループ区切り
     *
     * @type Integer
     * @constant
     */
    GroupSeparator: 0x1D,

    /**
     * レコード区切り
     *
     * @type Integer
     * @constant
     */
    RecordSeparator: 0x1E,

    /**
     * ユニット区切り
     *
     * @type Integer
     * @constant
     */
    UnitSeparator: 0x1F,

    /**
     * 空白
     *
     * @type Integer
     * @constant
     */
    Space: 0x20,

    /**
     * !
     *
     * @type Integer
     * @constant
     */
    ExclamationMark: 0x21,

    /**
     * "
     *
     * @type Integer
     * @constant
     */
    DoubleQuote: 0x22,

    /**
     * #
     *
     * @type Integer
     * @constant
     */
    Sharp: 0x23,

    /**
     * $
     *
     * @type Integer
     * @constant
     */
    DollarMark: 0x24,

    /**
     * %
     *
     * @type Integer
     * @constant
     */
    PercentSign: 0x25,

    /**
     * &amp;
     *
     * @type Integer
     * @constant
     */
    Ampersand: 0x26,

    /**
     * '
     *
     * @type Integer
     * @constant
     */
    SingleQuote: 0x27,

    /**
     * (
     *
     * @type Integer
     * @constant
     */
    LeftParenthesis: 0x28,

    /**
     * )
     *
     * @type Integer
     * @constant
     */
    RightParenthesis: 0x29,

    /**
     * &lowast;
     *
     * @type Integer
     * @constant
     */
    MultiplicationSign: 0x2A,

    /**
     * +
     *
     * @type Integer
     * @constant
     */
    AdditionSign: 0x2B,

    /**
     * ,
     *
     * @type Integer
     * @constant
     */
    Comma: 0x2C,

    /**
     * -
     *
     * @type Integer
     * @constant
     */
    SubtractionSign: 0x2D,

    /**
     * .
     *
     * @type Integer
     * @constant
     */
    Period: 0x2E,
    
    /**
     * /
     *
     * @type Integer
     * @constant
     */
    DivisionSign: 0x2F,

    /**
     * 0
     *
     * @type Integer
     * @constant
     */
    0: 0x30,

    /**
     * 1
     *
     * @type Integer
     * @constant
     */
    1: 0x31,

    /**
     * 2
     *
     * @type Integer
     * @constant
     */
    2: 0x32,

    /**
     * 3
     *
     * @type Integer
     * @constant
     */
    3: 0x33,

    /**
     * 4
     *
     * @type Integer
     * @constant
     */
    4: 0x34,

    /**
     * 5
     *
     * @type Integer
     * @constant
     */
    5: 0x35,

    /**
     * 6
     *
     * @type Integer
     * @constant
     */
    6: 0x36,

    /**
     * 7
     *
     * @type Integer
     * @constant
     */
    7: 0x37,

    /**
     * 8
     *
     * @type Integer
     * @constant
     */
    8: 0x38,

    /**
     * 9
     *
     * @type Integer
     * @constant
     */
    9: 0x39,

    /**
     * :
     *
     * @type Integer
     * @constant
     */
    Colon: 0x3A,

    /**
     * ;
     *
     * @type Integer
     * @constant
     */
    Semicolon: 0x3B,

    /**
     * &lt;
     *
     * @type Integer
     * @constant
     */
    LessThan: 0x3C,

    /**
     * =
     *
     * @type Integer
     * @constant
     */
    EqualsSign: 0x3D,

    /**
     * &gt;
     *
     * @type Integer
     * @constant
     */
    GreaterThan: 0x3E,

    /**
     * ?
     *
     * @type Integer
     * @constant
     */
    QuestionMark: 0x3F,

    /**
     * &#64;
     *
     * @type Integer
     * @constant
     */
    Atmark: 0x40,

    /**
     * A
     *
     * @type Integer
     * @constant
     */
    A: 0x41,

    /**
     * B
     *
     * @type Integer
     * @constant
     */
    B: 0x42,

    /**
     * C
     *
     * @type Integer
     * @constant
     */
    C: 0x43,

    /**
     * D
     *
     * @type Integer
     * @constant
     */
    D: 0x44,

    /**
     * E
     *
     * @type Integer
     * @constant
     */
    E: 0x45,

    /**
     * F
     *
     * @type Integer
     * @constant
     */
    F: 0x46,

    /**
     * G
     *
     * @type Integer
     * @constant
     */
    G: 0x47,

    /**
     * H
     *
     * @type Integer
     * @constant
     */
    H: 0x48,

    /**
     * I
     *
     * @type Integer
     * @constant
     */
    I: 0x49,

    /**
     * J
     *
     * @type Integer
     * @constant
     */
    J: 0x4A,

    /**
     * K
     *
     * @type Integer
     * @constant
     */
    K: 0x4B,

    /**
     * L
     *
     * @type Integer
     * @constant
     */
    L: 0x4C,

    /**
     * M
     *
     * @type Integer
     * @constant
     */
    M: 0x4D,

    /**
     * N
     *
     * @type Integer
     * @constant
     */
    N: 0x4E,

    /**
     * O
     *
     * @type Integer
     * @constant
     */
    O: 0x4F,

    /**
     * P
     *
     * @type Integer
     * @constant
     */
    P: 0x50,

    /**
     * Q
     *
     * @type Integer
     * @constant
     */
    Q: 0x51,

    /**
     * R
     *
     * @type Integer
     * @constant
     */
    R: 0x52,

    /**
     * S
     *
     * @type Integer
     * @constant
     */
    S: 0x53,

    /**
     * T
     *
     * @type Integer
     * @constant
     */
    T: 0x54,

    /**
     * U
     *
     * @type Integer
     * @constant
     */
    U: 0x55,

    /**
     * V
     *
     * @type Integer
     * @constant
     */
    V: 0x56,

    /**
     * W
     *
     * @type Integer
     * @constant
     */
    W: 0x57,

    /**
     * X
     *
     * @type Integer
     * @constant
     */
    X: 0x58,

    /**
     * Y
     *
     * @type Integer
     * @constant
     */
    Y: 0x59,

    /**
     * Z
     *
     * @type Integer
     * @constant
     */
    Z: 0x5A,

    /**
     * [
     *
     * @type Integer
     * @constant
     */
    LeftBracket: 0x5B,

    /**
     * \
     *
     * @type Integer
     * @constant
     */
    YenMark: 0x5C,

    /**
     * ]
     *
     * @type Integer
     * @constant
     */
    RightBracket: 0x5D,

    /**
     * ^
     *
     * @type Integer
     * @constant
     */
    Caret: 0x5E,

    /**
     * _
     *
     * @type Integer
     * @constant
     */
    Underscore: 0x5F,

    /**
     * `
     *
     * @type Integer
     * @constant
     */
    BackQuote: 0x60,

    /**
     * a
     *
     * @type Integer
     * @constant
     */
    a: 0x61,

    /**
     * b
     *
     * @type Integer
     * @constant
     */
    b: 0x62,

    /**
     * c
     *
     * @type Integer
     * @constant
     */
    c: 0x63,

    /**
     * d
     *
     * @type Integer
     * @constant
     */
    d: 0x64,

    /**
     * e
     *
     * @type Integer
     * @constant
     */
    e: 0x65,

    /**
     * f
     *
     * @type Integer
     * @constant
     */
    f: 0x66,

    /**
     * g
     *
     * @type Integer
     * @constant
     */
    g: 0x67,

    /**
     * h
     *
     * @type Integer
     * @constant
     */
    h: 0x68,

    /**
     * i
     *
     * @type Integer
     * @constant
     */
    i: 0x69,

    /**
     * j
     *
     * @type Integer
     * @constant
     */
    j: 0x6A,

    /**
     * k
     *
     * @type Integer
     * @constant
     */
    k: 0x6B,

    /**
     * l
     *
     * @type Integer
     * @constant
     */
    l: 0x6C,

    /**
     * m
     *
     * @type Integer
     * @constant
     */
    m: 0x6D,

    /**
     * n
     *
     * @type Integer
     * @constant
     */
    n: 0x6E,

    /**
     * o
     *
     * @type Integer
     * @constant
     */
    o: 0x6F,

    /**
     * p
     *
     * @type Integer
     * @constant
     */
    p: 0x70,

    /**
     * q
     *
     * @type Integer
     * @constant
     */
    q: 0x71,

    /**
     * r
     *
     * @type Integer
     * @constant
     */
    r: 0x72,

    /**
     * s
     *
     * @type Integer
     * @constant
     */
    s: 0x73,

    /**
     * t
     *
     * @type Integer
     * @constant
     */
    t: 0x74,

    /**
     * u
     *
     * @type Integer
     * @constant
     */
    u: 0x75,

    /**
     * v
     *
     * @type Integer
     * @constant
     */
    v: 0x76,

    /**
     * w
     *
     * @type Integer
     * @constant
     */
    w: 0x77,

    /**
     * x
     *
     * @type Integer
     * @constant
     */
    x: 0x78,

    /**
     * y
     *
     * @type Integer
     * @constant
     */
    y: 0x79,

    /**
     * z
     *
     * @type Integer
     * @constant
     */
    z: 0x7A,

    /**
     * &#123;
     *
     * @type Integer
     * @constant
     */
    LeftBrace: 0x7B,

    /**
     * |
     *
     * @type Integer
     * @constant
     */
    VerticalBar: 0x7C,

    /**
     * &#125;
     *
     * @type Integer
     * @constant
     */
    RightBrace: 0x7D,

    /**
     * ~
     *
     * @type Integer
     * @constant
     */
    Tilde: 0x7E,

    /**
     * 削除
     *
     * @type Integer
     * @constant
     */
    Delete: 0x7F
};

Jeeel.Code.CharCode.getChar = function (charCode) {
    
    var hash;
    
    if (this.getChar._hash) {
        hash = this.getChar._hash;
    } else {
        hash = new Jeeel.Hash(this);
        
        this.getChar._hash = hash;
    }

    return hash.search(charCode, true);
};

(function () {
    for (var i = 0; i < 128; i++) {
        var chr = String.fromCharCode(i);

        if ( ! (chr in Jeeel.Code.CharCode)) {
            Jeeel.Code.CharCode[chr] = i;
        }
    }
})();

/**
 * @namespace 文字のエンコーディングに関する列挙体
 */
Jeeel.Code.CharEncoding = {

    /**
     * UTF-8
     *
     * @type String
     * @constant
     */
    UTF8: 'UTF-8',

    /**
     * Shift_JIS
     *
     * @type String
     * @constant
     */
    SHIFT_JIS: 'Shift_JIS',

    /**
     * JIS
     *
     * @type String
     * @constant
     */
    JIS: 'ISO-2022-JP',

    /**
     * EUC-JP
     *
     * @type String
     * @constant
     */
    EUC: 'EUC-JP'
};

/**
 * @namespace HTML特殊文字に関する列挙体
 */
Jeeel.Code.HtmlCode = {
  
    /**
     * (&nbsp;)半角空白
     * 
     * @type String
     * @constant
     */
    HalfWidthSpace: '&nbsp;',
    
    /**
     * (&emsp;)全角空白
     * 
     * @type String
     * @constant
     */
    FullWidthSpace: '&emsp;',
    
    /**
     * "
     * 
     * @type String
     * @constant
     */
    DoubleQuote: '&quot;',
    
    /**
     * &amp;
     * 
     * @type String
     * @constant
     */
    Ampersand: '&amp;',
    
    /**
     * &lt;
     * 
     * @type String
     * @constant
     */
    LessThan: '&lt;',
    
    /**
     * &gt;
     * 
     * @type String
     * @constant
     */
    GreaterThan: '&gt;',
    
    /**
     * &crarr;
     * 
     * @type String
     * @constant
     */
    CarriageReturn: '&crarr;',
    
    /**
     * &copy;
     * 
     * @type String
     * @constant
     */
    Copyright: '&copy;',
    TradeMark: '&trade;',
    RegisteredTrademark : '&reg;',
    PlusMinusSign: '&plusmn;',
    MultiplicationSign: '&times;',
    DivisionSign: '&divide;',
    ZipCode: '&#12306;',
    EncircledNumber1: '&#9312;',
    EncircledNumber2: '&#9313;',
    EncircledNumber3: '&#9314;',
    EncircledNumber4: '&#9315;',
    EncircledNumber5: '&#9316;',
    EncircledNumber6: '&#9317;',
    EncircledNumber7: '&#9318;',
    EncircledNumber8: '&#9319;',
    EncircledNumber9: '&#9320;',
    EncircledNumber10: '&#9321;',
    EncircledNumber11: '&#9322;',
    EncircledNumber12: '&#9323;',
    EncircledNumber13: '&#9324;',
    EncircledNumber14: '&#9325;',
    EncircledNumber15: '&#9326;',
    EncircledNumber16: '&#9327;',
    EncircledNumber17: '&#9328;',
    EncircledNumber18: '&#9329;',
    EncircledNumber19: '&#9330;',
    EncircledNumber20: '&#9331;',
    LargeRomanNumeral1: '&#8544;',
    LargeRomanNumeral2: '&#8545;',
    LargeRomanNumeral3: '&#8546;',
    LargeRomanNumeral4: '&#8547;',
    LargeRomanNumeral5: '&#8548;',
    LargeRomanNumeral6: '&#8549;',
    LargeRomanNumeral7: '&#8550;',
    LargeRomanNumeral8: '&#8551;',
    LargeRomanNumeral9: '&#8552;',
    LargeRomanNumeral10: '&#8553;',
    LargeRomanNumeral11: '&#8554;',
    LargeRomanNumeral12: '&#8555;',
    SmallRomanNumeral1: '&#8560;',
    SmallRomanNumeral2: '&#8561;',
    SmallRomanNumeral3: '&#8562;',
    SmallRomanNumeral4: '&#8563;',
    SmallRomanNumeral5: '&#8564;',
    SmallRomanNumeral6: '&#8565;',
    SmallRomanNumeral7: '&#8566;',
    SmallRomanNumeral8: '&#8567;',
    SmallRomanNumeral9: '&#8568;',
    SmallRomanNumeral10: '&#8569;',
    SmallRomanNumeral11: '&#8570;',
    SmallRomanNumeral12: '&#8571;',
    Millimeter: '&#13212;',
    Centimeter: '&#13213;',
    Kilometer: '&#13214;',
    Milligram: '&#13198;',
    Kilogram: '&#13199;',
    BlackSpade: '&spades;',
    BlackClub: '&clubs;',
    BlackHeart: '&hearts;',
    BlackDiamond: '&diams;',
    BlackStar: '&#9733;',
    WhiteSpade: '&#9828;',
    WhiteClub: '&#9831;',
    WhiteHeart: '&#9825;',
    WhiteDiamond: '&#9826;',
    WhiteStar: '&#9734;',
    Feminine: '&#9792;',
    Muscular: '&#9794;',
    CheckBox: '&#9744;',
    CheckBoxChecked: '&#9745;',
    Fine: '&#9728;',
    Rain: '&#9730;',
    Snow: '&#9731;',
    Cloud: '&#9729;',
    BlackPawn: '&#9823;',
    BlackKnight: '&#9822;',
    BlackBishop: '&#9821;',
    BlackRook: '&#9820;',
    BlackQueen: '&#9819;',
    BlackKing: '&#9818;',
    WhitePawn: '&#9817;',
    WhiteKnight: '&#9816;',
    WhiteBishop: '&#9815;',
    WhiteRook: '&#9814;',
    WhiteQueen: '&#9813;',
    WhiteKing: '&#9812;',
    BioHazard: '&#9763;',
    Hexagram: '&#10017;'
};

/**
 * @staticClass 読み込み関連のメソッドを提供するスタティッククラス
 * @example
 * CSS、JSの読み込み、埋め込み機能を主とするクラス
 * CSSやJSを途中から読み込みたい場合や文字列をCSSとして解釈したい場合などに使用する
 * 
 * 例：
 * Jeeel.Loader.loadScript('/st/js/test.js'); // 新しくJSを読み込む
 * Jeeel.Loader.loadStyle('/st/css/test.css'); // 新しくCSSを読み込む
 * Jeeel.Loader.addScript('#test {color: red;}'); // JS文字列を指定してスクリプトを実行させる
 * Jeeel.Loader.addStyle('#test {color: red;}'); // CSS文字列を指定してスタイルを有効にする
 * Jeeel.Loader.preloadFile('/st/img/test.png'); // 今後JSで読み込む予定のファイルを事前読み込みしておき読み込んだ後にすぐ使えるようにする
 */
Jeeel.Loader = {

    /**
     * Prototype.jsが読み込まれているかどうかを返す。
     * 
     * @return {Boolean} 読み込みが完了していたらtrueそれ以外はfalseを返す
     */
    completePrototype: function () {
        if (Jeeel._global.Prototype && ! Jeeel.Type.isEmpty(Prototype.Version)) {
            return true;
        }

        return false;
    },

    /**
     * jQuery.jsが読み込まれているかどうかを返す。
     *
     * @return {Boolean} 読み込みが完了していたらtrueそれ以外はfalseを返す
     */
    completeJQuery: function () {
        if (Jeeel._global.jQuery && Jeeel.Type.isFunction(jQuery) && Jeeel.Type.isString(jQuery.prototype.jquery)) {
            return true;
        }

        return false;
    },

    /**
     * YUI.jsが読み込まれているかどうかを返す。
     *
     * @return {Boolean} 読み込みが完了していたらtrueそれ以外はfalseを返す
     */
    completeYUI: function () {
        if (Jeeel._global.YUI && Jeeel.Type.isFunction(YUI) && Jeeel.Type.isString(YUI.version)) {
            return true;
        }

        return false;
    },

    /**
     * JavaScriptを読み込む
     *
     * @param {String} url JavaScriptのURL
     * @param {Function} [callback] 読み込み完了時のコールバック
     * @param {String} [charCode] 明示的にキャラクターコードを設定する場合に指定(Jeeel.Code.CharEncoding参照)
     * @return {Element} scriptタグのElement
     * @see Jeeel.Code.CharEncoding
     */
    loadScript: function (url, callback, charCode) {
      
        if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
        
        var script  = Jeeel.Document.createElement('script');
        script.type = 'text/javascript';

        if (Jeeel.Type.isString(charCode)) {
            script.charset = charCode;
        }

        if (callback) {
            script.onreadystatechange = function () {
                if (script.readyState === 'loaded' || script.readyState === 'complete') {
                    script.onreadystatechange = null;
                    script.onload = null;
                    callback(script);
                }
            };
            
            script.onload = function () {
                script.onreadystatechange = null;
                script.onload = null;
                callback(script);
            };
        }
        
        script.src  = url;

        Jeeel.Document.appendToHead(script);
        
        return script;
    },

    /**
     * CSSを読み込む
     *
     * @param {String} url CSSのURL
     * @param {String} [charCode] 明示的にキャラクターコードを設定する場合に指定(Jeeel.Code.CharEncoding参照)
     * @return {Element} linkタグのElement
     * @see Jeeel.Code.CharEncoding
     */
    loadStyle: function (url, charCode) {
      
        if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
      
        var style  = Jeeel.Document.createElement('link');
        style.type = 'text/css';
        style.rel  = 'stylesheet';

        if (Jeeel.Type.isString(charCode)) {
            style.charset = charCode;
        }
        
        style.href = url;

        Jeeel.Document.appendToHead(style);
        
        return style;
    },

    /**
     * スクリプトを記述したJavaScript文字列を実行してヘッダに埋め込む
     *
     * @param {String} script JavaScript文字列
     * @return {Element} scriptタグのElement
     */
    addScript: function (script) {
        var scriptTag  = Jeeel.Document.createElement('script');
        scriptTag.type = 'text/javascript';
        scriptTag.innerHTML = script;

        Jeeel.Document.appendToHead(scriptTag);
        
        return scriptTag;
    },

    /**
     * スタイルを記述したCSS文字列を適用してヘッダに埋め込む
     *
     * @param {String} style CSS文字列
     * @return {Element} styleタグのElement
     */
    addStyle: function (style) {
        var styleTag  = Jeeel.Document.createElement('style');
        styleTag.type = 'text/css';
        
        style = '\n' + style + '\n';

        if (styleTag.styleSheet) {
            styleTag.styleSheet.cssText = style;
        } else {
            styleTag.innerHTML = style;
        }

        Jeeel.Document.appendToHead(styleTag);
        
        return styleTag;
    },
    
    /**
     * ファイルの事前読み込みを行う<br />
     * これを行う事により事前にキャッシュを作る事が可能になる
     * 
     * @param {String} url 読み込みファイルのURL
     */
    preloadFile: function (url) {},

    /**
     * 現在読み込み中のJavaScriptのscriptタグを取得する<br />
     * 読み込み中のJavaScript内から呼ばないと意味がない
     *
     * @return {Element} scriptタグのElement
     * @deprecated 今後削除予定
     */
    getCurrentScript: function () {
        return (function (e) {
            return (e.nodeName.toUpperCase() === 'SCRIPT' ? e : arguments.callee(e.lastChild));
        })(Jeeel._doc);
    },

    /**
     * 指定したURLのファイルがあるかどうかを返す
     *
     * @param {String} url ファイルのURL
     * @return {Boolean} ファイルが存在するかどうか
     */
    existsFile: function (url) {
      
        if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
            Jeeel.Acl.throwError('Access Error', 404);
        }
      
        var file = Jeeel.Net.Ajax.serverResponse(url);

        if (Jeeel.Type.isString(file)) {
            return true;
        }

        return false;
    },
    
    /**
     * @ignore
     */
    _init: function () {
      
        if (/*@cc_on!@*/false) {
            /**
             * @ignore
             */
            this.preloadFile = function (url) {
                if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
                    Jeeel.Acl.throwError('Access Error', 404);
                }
                
                new Image().src = url;
            };
        } else {
            /**
             * @ignore
             */
            this.preloadFile = function (url) {
              
                if (Jeeel.Acl && Jeeel.Acl.isDenied(url, '*', 'Url')) {
                    Jeeel.Acl.throwError('Access Error', 404);
                }
                
                var obj = Jeeel.Document.createElement('object');
                
                obj.width  = 0;
                obj.height = 0;
                obj.data = url;
                Jeeel.Document.appendToBody(obj);
            };
        }
      
        delete this._init;
    }
};

Jeeel.Loader._init();
/**
 * @staticClass Json関連のモジュール
 * @example
 * JSONのエンコードとデコードを提供するクラス
 * クロスブラウザのためにもJSONよりこのクラスを使うのが望ましい
 * 
 * 例：
 * Jeeel.Json.encode({a: [1, 2, 3], b: 'テスト'}); // '{"a": [1, 2, 3], "b": "テスト"}' が返ってくる
 * Jeeel.Json.decode('[1,2,3,4,5]'); // [1, 2, 3, 4, 5] が返ってくる
 * 
 * このクラスは通常のJSONよりも複雑な記述を使用する事が出来るが常にノンセキュアでデコードを行うことになるので信頼出来るか分からない外部とのやり取りなどでは使用しない方が良い
 * 
 * var json = Jeeel.Json.encode({date: new Date('2012/11/22'), reg: /^test-.*$/}, true); // 2つ目の引数をtrueにすることで既存のオブジェクトのコンストラクタ等を使用するようになり、
 *                                                                                       // '{"date":new Date(1353510000000),"reg":/^test-.*$/}' が返ってくる
 * Jeeel.Json.decode(json, true); // 2つ目の引数をtrueにすることで関数やnew, 正規表現等を含んだJSONを復元できる。
 *                                // ただしセキュアであること前提で動くのでjsonに悪意のあるコードが含まれていても実行する
 *                                // 左の戻り値は{date: new Date('2012/11/22'), reg: /^test-.*$/}となり復元されていることが確認できるはず
 */
Jeeel.Json = {
    
    /**
     * 指定した値をJsonにエンコードする<br/>
     * なお参照も全て展開するので、<br />
     * 参照先がDomの様な階層が深い場合やサイズオーバーが起こる<br />
     * またプライベートプロパティ・メソッドまでは修正変換されないので、<br />
     * デコード後にまったく同じように使えるとは限らない
     *
     * @param {Mixied} obj Jsonに変換するオブジェクト
     * @param {Boolean} [serializeScript] エンコード時にJavaScriptの型について厳密に変換するかどうか
     * @return {String} Jsonに変換後の文字列
     * @throws {RangeError} 無限ループに入った場合またはオブジェクトのサイズが限界を超えた場合に発生する
     * @throws {TypeError} 循環参照がある場合に発生する
     */
    encode: function (obj, serializeScript) {
        
        // 厳密変換でない場合高速化のため既存のJSONを使用する
        if ( ! serializeScript && Jeeel._global.JSON) {
            return JSON.stringify(obj);
        }
        
        var res;

        if (Jeeel.Type.isPrimitive(obj)) {
            if (Jeeel.Type.isString(obj)) {
                res = '"' + obj.replace('\\', '\\\\')
                              .replace(/(\r\n|\n)/ig, '\\n')
                              .replace(/\t/ig, '\\t')
                              .replace('"', '\\"')
                              .replace("'", "\\'") + '"';
            } else {
                res = '' + obj;
            }
        } else if (Jeeel.Type.isFunction(obj)) {

            if (serializeScript) {
                switch (obj) {
                    case Object:
                        res = 'Object';
                        break;
                        
                    case Array:
                        res = 'Array';
                        break;
                        
                    case String:
                        res = 'String';
                        break;
                        
                    case Boolean:
                        res = 'Boolean';
                        break;
                        
                    case Date:
                        res = 'Date';
                        break;
                        
                    case RegExp:
                        res = 'RegExp';
                        break;
                        
                    default:
                        if (Jeeel._debugMode && Jeeel.Debug && obj[Jeeel.Debug.Debugger.INFORMATION_NAME]) {
                            res = obj[Jeeel.Debug.Debugger.INFORMATION_NAME].name;
                        }
                        break;
                }
            }

            if ( ! res) {
                res = obj.toString().replace(/\/\/[^\r\n]*(\r\n|\n)/ig, '')
                                    .replace(/((\r\n|\n) +|\t|\r\n|\n){1,}/ig, ' ');
            }
        } else if (serializeScript) {
            if (Jeeel.Type.isDate(obj)) {
                res = 'new Date(' + obj.getTime() + ')';
            } else if (Jeeel.Type.isMath(obj)) {
                res = 'Math';
            } else if (Jeeel.Type.isJSON(obj)) {
                res = 'JSON';
            } else if (Jeeel.Type.isRegularExpression(obj)) {
                res = obj.toString();
            }
        }
        
        if ( ! res) {
            if (Jeeel.Type.isArray(obj)) {
                res  = [];

                for (var i = 0, l = obj.length; i < l; i++) {
                    res[i] = this.encode(obj[i], serializeScript);
                }

                res = '[' + res.join(',') + ']';
            } else {
                res = [];

                for (var key in obj) {
                    if (Jeeel._debugMode && Jeeel.Debug && key === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                        continue;
                    }

                    res[res.length] = '"' + key + '":' + this.encode(obj[key], serializeScript);
                }

                res = '{' + res.join(',') + '}';
            }
        }
        
        return res;
    },
    
    /**
     * 作成したJsonをデコードする<br />
     * 検証を行い、evalして返す
     *
     * @param {String} json Json形式の文字列
     * @param {Boolean} [isSecure] JSONの中身の安全性が確実な場合にtrueにすると検証なしで動作するため速くなる(また、完全なJSON形式でなくても動作するようになる)
     * @return {Mixied} 変換後の値(空文字の場合はundefinedが返る)
     * @throws {TypeError} jsonが文字列ではないときに発生
     * @throws {SyntaxError} jsonがJson形式でないときに発生
     */
    decode: function (json, isSecure) {

        // jsonの中身が空の場合nullではなくundefinedを返す("null"をデコードした時と区別するため)
        if ( ! json) {
            return void 0;
        }

        if ( ! Jeeel.Type.isString(json)) {
            throw new TypeError('jsonが文字列ではありません。');
        } else if ( ! isSecure) {
            if (Jeeel._global.JSON) {
                return JSON.parse(json);
            } else if ( ! this.isJson(json)) {
                throw new SyntaxError('jsonがJson形式になっていません。');
            }
        }

        return eval('(' + json + ')');
    },
    
    /**
     * 完全なJson形式であるかどうかを返す(メソッド等が入っていた場合は不可)
     *
     * @param {String} json 検査対象の文字列
     * @return {Boolean} Json形式であるかどうか
     */
    isJson: function (json) {

        if ( ! Jeeel.Type.isString(json)) {
            throw new TypeError('jsonが文字列ではありません。');
        }

        if (json.match(/^\s*$/)) {
            return false;
        }

        return !(/[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/.test(json.replace(/"(\\.|[^"\\])*"/g, ' ')));
    }
};
Jeeel.directory.Jeeel.Session = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Session/';
    }
};

/**
 * @namespace Session関連のネームスペース
 * @example
 * Sessionネームスペース以下はセッション、擬似セッションを管理する機能を保持する
 * 以下にようなクラスが存在する
 * Jeeel.Session.Cookie
 * Jeeel.Session.Name
 * Jeeel.Session.WebStorage
 * 
 * Jeeel.Session.Cookie
 * クッキーを扱うクラス
 * 制御可能なのは読み込み、書き込み、クッキーの寿命、有効パス、有効ドメインとなる
 * 
 * 
 * 例：
 * document.cookieの中身を以下とする
 * "sid=aabbggsshhyy; aa=555"
 * 
 * var cookie = Jeeel.Session.Cookie.create(); // new Jeeel.Session.Cookie()だとクッキーの読み込みを行わない
 * cookie.load(); // 現在の値を破棄して新しくクッキーを読み込み解析する
 * cookie.getAll(); // 現在のクッキーの値を連想配列にして返す、{sid: 'aabbggsshhyy', aa: 555}
 * cookie.set('b', [12, 55, {a: 'y', v: true}]); // 現在の保持値に値を設定する
 * cookie.save(); // 実際にクッキーに値を書き込む、変更された箇所のみ書き込まれる
 *                // 実際のクッキーの値は以下のようになる
 *                // "sid=aabbggsshhyy; aa=555; b=%5B12%2C55%2C%7B%22a%22%3A%22y%22%2C%22v%22%3Atrue%7D%5D"
 *                // bの値は複雑な値になるのでこのクラスか類似した機能下でしか復元できない
 *                // 実際に保存されている値はJSON化した後encodeURIComponentでエスケープした状態である
 * cookie.setExpires(360); // 今から保存するクッキーの有効期限を6分間とする(インスタンスを作成した時点ではブラウザを閉じるまで)
 * cookie.set('c', 55).save(); // ここで保存したcに対して有効期限が設定される
 * 
 * 
 * Jeeel.Session.Name
 * window.nameを使用して擬似的にセッションを作り出すクラス
 * 使用するためにはグローバル変数にnameが無いこと、window.nameを使用したスクリプトが動いていないことが条件になる
 * また別画面、別ドメインに遷移しても値が消えないため重要なデータを保存するとデータ漏えいが起こる可能性もある
 * 
 * 例：
 * window.nameは空とする
 * 基本的な操作はJeeel.Session.Cookieと同じである
 * 違うのはデフォルトの有効期限と保存時の形式くらいである
 * 
 * var winName = Jeeel.Session.Name.create();
 * winName.setExpires(360); // 今から保存する値の有効期限を6分間とする(インスタンスを作成した時点では1日)
 * winName.getDomain('test.co.jp'); // 今から保存する値の有効ドメインを指定する(インスタンス作成時は現在のドメイン)
 * winName.set('test', 888);
 * winName.save();
 * 
 * Jeeel.Session.WebStorage
 * localStorage, sessionStorageを使用して擬似的にセッションを作り出すクラス
 * storageを使用するので他のクラスよりも大容量のデータを保存出来セキュリティも高い
 * また永続保存する媒体として適している
 * 
 * 例：
 * var storage = Jeeel.Session.WebStorage.create(true, 'test'); // このクラスはlocalStorage, sessionStorageの使い分けをするため1つめの引数で永続保存(localStorageを使用するかどうか)をするかどうかを指定する
 *                                                              // また2つめの引数では任意にstorageに保存する際の名前を指定できる
 * 
 * storage.setExpires(1800); // 今から保存する値の有効期限を1時間とする(インスタンスを作成した時点では1日)
 * storage.setPath('/test/index/'); // 今から保存する値の有効パスを指定する(インスタンスを作成した時点ではルートパス: "/")
 * storage.set('test', 888);
 * storage.save();
 */
Jeeel.Session = {

    /**
     * Sessionの保存期間の初期値を取得する
     *
     * @return {Integer} 保存期間(秒)
     */
    getExpires: function () {
        return Jeeel.Session.Core.expires;
    },

    /**
     * Sessionの保存期間の初期値を設定する<br />
     * マイナスを指定すると無制限になる
     *
     * @param {Integer} expires 保存期間(秒)
     * @return {Jeeel.Session} 自オブジェクト
     */
    setExpires: function (expires) {

        if ( ! Jeeel.Type.isInteger(expires)) {
            throw new Error('expiresが整数ではありません。');
        }

        Jeeel.Session.Core.expires = expires;

        return this;
    },

    /**
     * Sessionの読み込み許可をするドメインの初期値を取得する
     *
     * @return {String} 読み込み可能ドメイン
     */
    getDomain: function () {
        return Jeeel.Session.Core.domain;
    },

    /**
     * Sessionの読み込み許可をするドメインの初期値を設定する
     *
     * @param {String} domain 読み込み可能ドメイン
     * @return {Jeeel.Session} 自オブジェクト
     */
    setDomain: function (domain) {

        if ( ! Jeeel.Type.isString(domain)) {
            throw new Error('domainが文字列ではありません。');
        }

        Jeeel.Session.Core.domain = domain;

        return this;
    },

    /**
     * Sessionの読み込み可能パスの初期値を取得する
     *
     * @return {String} 読み込み可能パス
     */
    getPath: function () {
        return Jeeel.Session.Core.path;
    },

    /**
     * Sessionの読み込み可能パスの初期値を設定する
     *
     * @param {String} path 読み込み可能パス
     * @return {Jeeel.Session} 自オブジェクト
     */
    setPath: function (path) {

        if ( ! Jeeel.Type.isString(path)) {
            throw new Error('pathが文字列ではありません。');
        }

        Jeeel.Session.Core.path = path;

        return this;
    }
};

Jeeel.file.Jeeel.Session = ['Core', 'Abstract', 'Cookie', 'Name'];

if (Jeeel._extendMode.WebStorage && Jeeel._global && Jeeel._global.sessionStorage && Jeeel._global.localStorage) {
    Jeeel.file.Jeeel.Session[Jeeel.file.Jeeel.Session.length] = 'WebStorage';
}

Jeeel._autoImports(Jeeel.directory.Jeeel.Session, Jeeel.file.Jeeel.Session);

/**
 * コンストラクタ
 * 
 * @class セッション内のデータのやり取りを提供するコアクラス
 * @param {Hash} params リスト化したい値を保持するキー
 * @param {Integer} [expires] Sessionの保存期限(秒)<br />
 *                             マイナスを指定すると無制限になる
 * @param {String} [domain] 許可ドメイン
 * @param {String} [path] 許可パス
 */
Jeeel.Session.Core = function (params, expires, domain, path, id) {
    if ( ! Jeeel.Type.isHash(params)) {
        throw new Error('paramsがHashではありません。');
    }

    this.params  = params;
    this.created = (arguments[5] ? new Date(arguments[5]) : new Date());
    this.expires = (Jeeel.Type.isInteger(expires) ? expires : 0);
    this.path    = (Jeeel.Type.isString(path) ? path : '/');
    this.domain  = (Jeeel.Type.isString(domain) ? domain : Jeeel.UserAgent.getHostname());
    
    if (id) {
        this.id = id;
    }
};

/**
 * インスタンスの作成を行う
 *
 * @param {Hash} params リスト化したい値を保持するキー
 * @return {Jeeel.Session.Core} 作成したインスタンス
 */
Jeeel.Session.Core.create = function (params) {
    return new this(params, this.expires, this.domain, this.path);
};

/**
 * Sessionオブジェクトかどうかを返す
 *
 * @param {Mixied} val 判定値
 * @return {Boolean} 判定結果
 */
Jeeel.Session.Core.isSessionObject = function (val) {
    if ( ! Jeeel.Type.isObject(val)) {
        return false;
    }
    else if ( ! Jeeel.Type.isHash(val.params)) {
        return false;
    }
    else if ( ! Jeeel.Type.isString(val.created)) {
        return false;
    }
    else if ( ! Jeeel.Type.isInteger(val.expires)) {
        return false;
    }
    else if ( ! Jeeel.Type.isString(val.domain)) {
        return false;
    }
    else if ( ! Jeeel.Type.isString(val.path)) {
        return false;
    }
    else if ( ! Jeeel.Type.isString(val.id)) {
        return false;
    }

    return true;
};

/**
 * 現在のドメインが許可されているのかどうかを調べる
 *
 * @param {String} target 対象のドメイン
 * @return {Boolean} 許可されたドメインならばtrueそれ以外はfalseを返す
 */
Jeeel.Session.Core.isAllowDomain = function (target) {
    var domain = Jeeel.UserAgent.getHostname();

    var reg = new RegExp('^'+target.replace('.', '\\.'));

    if (domain.match(reg)) {
        return true;
    }

    return false;
};

/**
 * 現在アクセスしているパスが許可されているのかどうか調べる
 *
 * @param {String} target 対象のパス
 * @return {Boolean} 許可されたパスならばtrueそれ以外はfalseを返す
 */
Jeeel.Session.Core.isAllowPath = function (target) {
    var path = Jeeel.UserAgent.getPath();

    var reg = new RegExp('^'+target+(target.charAt(target.length-1) == '/' ? '' : '(/|$)'));

    if (path.match(reg)) {
        return true;
    }

    return false;
};

/**
 * シリアライズされてオブジェクトの復元を行う
 *
 * @param {String} serializeObj シリアライズされているオブジェクト
 * @return {Jeeel.Session.Core} 復元したインスタンス
 */
Jeeel.Session.Core.unserialize = function (serializeObj) {
    var session;

    try {
        session = Jeeel.Json.decode(decodeURIComponent(serializeObj));
    } catch(e) {
        session = {};
    }
    
    if ( ! Jeeel.Type.isHash(session)) {
        return this.create({});
    }

    var res = {};

    for (var domain in session) {

        if ( ! this.isAllowDomain(domain)) {
            continue;
        }

        for (var path in session[domain]) {

            if ( ! this.isAllowPath(path)) {
                continue;
            }

            var val = session[domain][path];

            if ( ! this.isSessionObject(val)) {
                val = this.create({});
            } else {
                val = new this(val.params, val.expires, val.domain, val.path, val.id, val.created);
            }

            if (val.isTimeOver()) {
                val = this.create({});
            }

            res = Jeeel.Hash.merge(res, val.params);
        }

        break;
    }

    session = this.create(res);

    return session;
};

/**
 * クッキーの内容をロードする
 *
 * @param {String} cookieObj document.cookie内部の値
 * @return {Jeeel.Session.Core} 作成したインスタンス
 */
Jeeel.Session.Core.loadCookie = function (cookieObj) {
    var objs = cookieObj.split('; ');

    var params = {};

    for (var i = 0, l = objs.length; i < l; i++) {
        var pair = objs[i].split('=');

        var session = decodeURIComponent(pair[1]);

        try {
            session = Jeeel.Json.decode(session);
        } catch (e) {}

        params[pair[0]] = session;
    }

    return this.create(params);
};

/**
 * Sessionの保存期限の初期値(秒)<br />
 * 0を指定でブラウザを閉じるまでで(cookieのみ)、<br />
 * マイナスを指定すると無制限になる
 *
 * @type Integer
 */
Jeeel.Session.Core.expires = 0;

/**
 * Sessionの読み込み可能ドメインの初期値
 *
 * @type String
 */
Jeeel.Session.Core.domain = Jeeel.UserAgent.getHostname();

if (Jeeel.Session.Core.domain === 'localhost') {
    Jeeel.Session.Core.domain = '';
}

/**
 * Sessionの読み込み可能パスの初期値
 *
 * @type String
 */
Jeeel.Session.Core.path = Jeeel.UserAgent.getPath();

Jeeel.Session.Core.prototype = {
    
    /**
     * Sessionに保存するパラメータ
     *
     * @type Hash
     */
    params: {},

    /**
     * Sessionを作成した時刻
     *
     * @type Date
     */
    created: null,

    /**
     * Sessionの保存期限(秒)<br />
     * 0を指定でブラウザを閉じるまでで(cookieのみ)、<br />
     * マイナスを指定すると無制限になる
     *
     * @type Integer
     */
    expires: 0,

    /**
     * Sessionの読み込み可能パス
     *
     * @type String
     */
    path: '',

    /**
     * Sessionの読み込み可能ドメイン
     *
     * @type String
     */
    domain: '',
    
    /**
     * Sessionが作成されたID
     * 
     * @type String
     */
    id: Jeeel.UNIQUE_ID,
    
    /**
     * シリアライズが可能なオブジェクトを返す
     *
     * @return {Object} シリアライズ可能オブジェクト
     */
    getSerializeableObject: function () {
        return {
            params:  this.params,
            created: this.created.toGMTString(),
            expires: this.expires,
            domain:  this.domain,
            path:    this.path,
            id:      Jeeel.UNIQUE_ID
        };
    },

    /**
     * Sessionオブジェクトをシリアライズする
     *
     * @param {String} windowName window.nameの値
     * @return {String} シリアライズされたSessionオブジェクト
     */
    serialize: function (windowName) {
        var sessionOwner;

        try {
            sessionOwner = Jeeel.Json.decode(decodeURIComponent(windowName));
        } catch(e) {
            sessionOwner = {};
        }

        if ( ! Jeeel.Type.isObject(sessionOwner)) {
            sessionOwner = {};
        }

        if ( ! (this.domain in sessionOwner)) {
            sessionOwner[this.domain] = {};
        }

        if ( ! this.constructor.isSessionObject(sessionOwner[this.domain][this.path])) {
            sessionOwner[this.domain][this.path] = this.getSerializeableObject();
        } else {

            var selfObj = this.getSerializeableObject();

            delete selfObj.params;

            sessionOwner[this.domain][this.path] = Jeeel.Hash.merge(sessionOwner[this.domain][this.path], selfObj);

            for (var key in this.params) {
                sessionOwner[this.domain][this.path].params[key] = this.params[key];

                if ( ! Jeeel.Type.isSet(sessionOwner[this.domain][this.path].params[key])) {
                    delete sessionOwner[this.domain][this.path].params[key];
                }
            }
        }

        return encodeURIComponent(Jeeel.Json.encode(sessionOwner));
    },

    /**
     * Session情報をクッキーに保存できる形式に変換して返す
     *
     * @return {String[]} クッキー保存形式の文字列
     */
    getCookies: function () {
        var expires = new Date(this.created.toString());

        expires.setSeconds(expires.getSeconds() + (this.expires < 0 ? Math.pow(2, 32) : this.expires));
        expires = expires.toGMTString();

        var res = [];
        var ext = (this.expires === 0 ? '' : ';expires=' + expires) + (this.domain == '' ? '' : ';domain=' + this.domain) + ';path=' + this.path + ';';
        var rmExt = new Date();
        
        rmExt.setDate(rmExt.getDate() - 1);
        rmExt = ';expires=' + rmExt.toGMTString() + (this.domain == '' ? '' : ';domain=' + this.domain) + ';path=' + this.path + ';';

        for (var key in this.params) {
            if (Jeeel.Type.isUndefined(this.params[key])) {
                res[res.length] = key + '=null' + rmExt;
            } else if (Jeeel.Type.isString(this.params[key])) {
                res[res.length] = key + '=' + encodeURIComponent(this.params[key]) + ext;
            } else {
                res[res.length] = key + '=' + encodeURIComponent(Jeeel.Json.encode(this.params[key])) + ext;
            }
        }

        return res;
    },

    /**
     * このSessionオブジェクトの期限が切れていないかどうかを調べる
     *
     * @return {Boolean} 期限切れならばtrueそれ以外はfalseを返す
     */
    isTimeOver: function () {

        if (this.expires < 0) {
            return false;
        } else if (this.expires === 0) {
            this.expires = 86400;
        }

        var expires = new Date(this.created.toString());

        expires.setSeconds(expires.getSeconds() + this.expires);

        var now = new Date();

        if (now.getTime() > expires.getTime()) {
            return true;
        }

        return false;
    },

    /**
     * 現在のドメインが許可されているのかどうかを調べる
     *
     * @return {Boolean} 許可されたドメインならばtrueそれ以外はfalseを返す
     */
    isAllowDomain: function () {
        var domain = Jeeel.UserAgent.getHostname();

        var reg = new RegExp('^' + this.domain.replace('.', '\\.'));

        if (domain.match(reg)) {
            return true;
        }

        return false;
    },

    /**
     * 現在アクセスしているパスが許可されているのかどうか調べる
     *
     * @return {Boolean} 許可されたパスならばtrueそれ以外はfalseを返す
     */
    isAllowPath: function () {
        var path = Jeeel.UserAgent.getPath();

        var reg = new RegExp('^' + this.path+(this.path.charAt(this.path.length-1) == '/' ? '' : '(/|$)'));

        if (path.match(reg)) {
            return true;
        }

        return false;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Hash} params リスト化したい値を保持するキー
     * @param {Integer} [expires] Sessionの保存期限(秒)<br />
     *                             マイナスを指定すると無制限になる
     * @param {String} [domain] 許可ドメイン
     * @param {String} [path] 許可パス
     * @constructor
     */
    constructor: Jeeel.Session.Core
};

/**
 * コンストラクタ
 *
 * @abstractClass セッションクラスを作る際の抽象クラス
 */
Jeeel.Session.Abstract = function () {
    this._session = Jeeel.Session.Core.create({});
    this._changedValues = {};
};

Jeeel.Session.Abstract.prototype = {

    /**
     * セッションの必要値の保存領域
     * 
     * @type Jeeel.Session.Core
     * @protected
     */
    _session: null,
    
    /**
     * 変更された値
     * 
     * @type Hash
     * @private
     */
    _changedValues: {},

    /**
     * パラメータを取得する
     *
     * @param {String} key 保存する値を示すキー
     * @param {Mixied} [defaultValue] デフォルト値
     * @return {Mixed} 保存されていた値
     */
    get: function (key, defaultValue) {
        return (key in this._session.params ? this._session.params[key] : defaultValue);
    },

    /**
     * パラメータを全て取得する
     *
     * @return {Hash} 保存されていた値の連想配列
     */
    getAll: function () {
        return this._session.params;
    },

    /**
     * パラメータを設定する
     *
     * @param {String} key 保存する値を示すキー
     * @param {Mixed} value 保存する値
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    set: function (key, value) {
        this._session.params[key] = value;
        this._changedValues[key] = value;

        return this;
    },

    /**
     * パラメータを設定する
     *
     * @param {Hash} values 保存する値の連想配列
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    setAll: function (values) {

        if ( ! Jeeel.Type.isHash(values)) {
            throw new Error('valuesがHashではありません。');
        }

        Jeeel.Hash.forEach(values, function (val, key) {
            this._session.params[key] = val;
            this._changedValues[key] = val;
        }, this);

        return this;
    },

    /**
     * 指定したキーの値を破棄する
     *
     * @param {String} key キー
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    unset: function (key) {
        this._session.params[key] = undefined;
        this._changedValues[key] = undefined;

        return this;
    },
    
    /**
     * パラメータを全て破棄する
     *
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    clear: function () {
        for (var key in this._session.params) {
            this._session.params[key] = undefined;
            this._changedValues[key] = undefined;
        }
        
        return this;
    },

    /**
     * 指定したキーの値を保持しているかどうかを返す
     *
     * @param {String} key キー
     * @return {Boolean} 値を保持していたらtrueそれ以外はfalseを返す
     */
    has: function (key) {
        return key in this._session.params && this._session.params[key] !== undefined;
    },

    /**
     * Sessionの保存期間を取得する
     *
     * @return {Integer} 保存期間(秒)
     */
    getExpires: function () {
        return this._session.expires;
    },

    /**
     * Sessionの保存期間を設定する<br />
     * 0を指定でブラウザを閉じるまでで(cookieのみ)、<br />
     * マイナスを指定すると無制限になる
     *
     * @param {Integer} expires 保存期間(秒)
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    setExpires: function (expires) {

        if ( ! Jeeel.Type.isInteger(expires)) {
            throw new Error('expiresが整数ではありません。');
        }

        this._session.expires = expires;

        return this;
    },

    /**
     * Sessionの読み込み許可をするドメインを取得する
     *
     * @return {String} 読み込み可能ドメイン
     */
    getDomain: function () {
        return this._session.domain;
    },

    /**
     * Sessionの読み込み許可をするドメインを設定する
     *
     * @param {String} domain 読み込み可能ドメイン
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    setDomain: function (domain) {

        if ( ! Jeeel.Type.isString(domain)) {
            throw new Error('domainが文字列ではありません。');
        }

        this._session.domain = domain;

        return this;
    },

    /**
     * Sessionの読み込み可能パスを取得する
     *
     * @return {String} 読み込み可能パス
     */
    getPath: function () {
        return this._session.path;
    },

    /**
     * Sessionの読み込み可能パスを設定する
     *
     * @param {String} path 読み込み可能パス
     * @return {Jeeel.Session.Abstract} 自インスタンス
     */
    setPath: function (path) {

        if ( ! Jeeel.Type.isString(path)) {
            throw new Error('pathが文字列ではありません。');
        }

        this._session.path = path;

        return this;
    }
};
/**
 * コンストラクタ<br />
 * コンストラクタを直接使用した場合はロードは行われない
 *
 * @class Cookieを使用してセッションを扱うクラス(クッキーが使用できるのを前提に動作する)
 * @augments Jeeel.Session.Abstract
 * @example
 * // 通常通りに使用する場合は以下のような形になる
 * var cookie = Jeeel.Session.Cookie.create(); //インスタンスを作成し、同時にクッキーの読み込みも行う(#loadも同時に行っている)
 * cookie.getAll(); //値を全て取得する
 * cookie.set('test', [1, 2, 34, 5, 7]); //値を設定する(設定する値はなんでも良い: 複雑なインスタンスは除く)
 * cookie.setAll({test2: 111, test3: 'str'}); //連想配列の値を個別に保存する
 * cookie.unset('test4'); //test4の値を破棄する(saveを呼ぶとその時設定中のドメイン・パスの値を消去する)
 * cookie.save(); //現在のインスタンス内部の値をクッキーに保存する(変更がなされた箇所のみなのでtest, test2, test3, test4(元々の値があれば)のみとなる)
 * 
 * // saveを行った後のクッキーのイメージは以下のような感じになる
 * // document.cookie == "test=[1, 2, 34, 5, 7]; test2=111; test3='str'"
 * 
 * // ドメインやパス、保存期間などを設定する場合は以下の設定を行ってから#saveメソッドを呼ぶ必要がある
 * // 但し既に保存されているものとパス等がが違った場合上書きではなく新規になるので注意
 * // 更に詳しく知る場合はJeeel.Session.Abstractのメソッド一覧を参照
 * cookie.setDomain('www.test.com'); //デフォルトで現在のドメインになる(localhostは除く)
 * cookie.setPath('/test/index/'); //デフォルトでは現在のパスになる
 * cookie.setExpires(172800); //デフォルトではブラウザを閉じるまで
 */
Jeeel.Session.Cookie = function () {
    Jeeel.Session.Abstract.call(this);
};

/**
 * インスタンスの作成を行う<br />
 * さらにロードも同時に行う
 *
 * @return {Jeeel.Session.Cookie} 作成したインスタンス
 */
Jeeel.Session.Cookie.create = function () {
    return (new this()).load();
};

Jeeel.Session.Cookie.prototype = {
    
    /**
     * 設定した値をセッションに保存する<br >
     * 実際にクッキーに保存するのは変更が加えられた要素のみである
     *
     * @return {Jeeel.Session.Cookie} 自インスタンス
     */
    save: function () {
        var tmp = this._session.params;
        
        this._session.params = this._changedValues;
        
        var cookies = this._session.getCookies();
        
        this._session.params = tmp;
        this._changedValues = {};
        
        for (var i = cookies.length; i--;) {
            Jeeel._doc.cookie = cookies[i];
        }

        return this;
    },
    
    /**
     * セッションに保存されていた値を読み込む<br/>
     * なお、現在保持している値は全て削除される
     *
     * @return {Jeeel.Session.Cookie} 自インスタンス
     */
    load: function () {
        this._session = Jeeel.Session.Core.loadCookie(Jeeel._doc.cookie);
        this._changedValues = {};

        return this;
    }
};

Jeeel.Class.extend(Jeeel.Session.Cookie, Jeeel.Session.Abstract);

/**
 * コンストラクタ<br />
 * コンストラクタを直接使用した場合はロードは行われない
 *
 * @class Cookieを使用しないセッションを扱うクラス(但しサーバー側には干渉しない、またドメインが変わっても参照できるため重要な情報保持には向かない)<br />
 *         なおこのクラスはwindow.nameを使用している(グローバル変数nameが存在する場合やwindow.nameを他の用途に使用している場合は使用できない)
 * @augments Jeeel.Session.Abstract
 * @example
 * // 基本的にな使い方はJeeel.Session.Cookieと殆ど変らない
 * // 但し、window.nameを使用しているためグローバルにnameの名前の変数名を定義すると動作出来なくなる
 * // また保存もwindowが閉じられると無効になったり、サーバー側には送信しなかったり、どのページに遷移しても読み込むことが出来たりなどセキュリティが低く制限も多い
 * var sname = Jeeel.Session.Name.create(); //インスタンスを作成し、同時にwindow.nameの読み込みも行う(#loadも同時に行っている)
 * sname.getAll(); //値を全て取得する
 * sname.set('test', [1, 2, 34, 5, 7]); //値を設定する(設定する値はなんでも良い: 複雑なインスタンスは除く)
 * sname.setAll({test2: 111, test3: 'str'})
 * sname.save(); //現在のインスタンス内部の値をwindow.nameに保存する
 * 
 * // saveを行った後のwindow.nameのイメージは以下のような感じになる
 * // window.name == "{test:[1, 2, 34, 5, 7], test2:111; test3:'str'}"
 * 
 * // ドメインやパス、保存期間などを設定する場合は以下の設定を行ってから#saveメソッドを呼ぶ必要がある
 * // 但し既に保存されているものとパス等がが違った場合上書きではなく新規になるので注意
 * // 更に詳しく知る場合はJeeel.Session.Abstractのメソッド一覧を参照
 * sname.setDomain('www.test.com'); //デフォルトで現在のドメインになる(localhostは除く)
 * sname.setPath('/test/index/'); //デフォルトでは現在のパスになる
 * sname.setExpires(172800); //デフォルトではブラウザを閉じるまで(擬似)
 */
Jeeel.Session.Name = function () {
    Jeeel.Session.Abstract.call(this);
};

/**
 * インスタンスの作成を行う<br />
 * さらにロードも同時に行う
 *
 * @return {Jeeel.Session.Name} 作成したインスタンス
 */
Jeeel.Session.Name.create = function () {
    return (new this()).load();
};

Jeeel.Session.Name.prototype = {
  
    /**
     * 設定した値をセッションに保存する<br />
     * なおセーブ時は前に保持していた値は削除された後保存されるので、<br />
     * 注意して行う必要がある。
     *
     * @return {Jeeel.Session.Name} 自インスタンス
     */
    save: function () {
        var tmp = this._session.params;
        this._session.params = this._changedValues;
        
        Jeeel._global.name = this._session.serialize(Jeeel._global.name);
        
        this._session.params = tmp;
        this._changedValues = {};

        return this;
    },
    
    /**
     * セッションに保存されていた値を読み込む<br/>
     * なお、現在保持している値は全て削除される
     *
     * @return {Jeeel.Session.Name} 自インスタンス
     */
    load: function () {
        this._session = Jeeel.Session.Core.unserialize(Jeeel._global.name);
        this._changedValues = {};

        return this;
    }
};

Jeeel.Class.extend(Jeeel.Session.Name, Jeeel.Session.Abstract);

/**
 * コンストラクタ<br />
 * コンストラクタを直接使用した場合はロードは行われない
 *
 * @class Cookieを使用しないセッションを扱うクラス(但しサーバー側には干渉しない、またドメイン・プロトコル・ポート番号で制御されるため異なるドメイン間等ではデータのやりとりは出来ない)<br />なおこのクラスはwindow.localStorage, sessionStorageを使用している
 * @augments Jeeel.Session.Abstract
 * @param {Boolean} [isPersistent] データの永続化をするかどうか(ブラウザを閉じてもアクセス出来るか)
 * @param {String} [name] 保存名を明示的に指定する場合に指定
 * @example
 * // 基本的にな使い方はJeeel.Session.Cookieと殆ど変らない
 * // 但し、window.nameを使用しているためグローバルにnameの名前の変数名を定義すると動作出来なくなる
 * var storage = Jeeel.Session.WebStorage.create(true); //インスタンスを作成し、同時にwindow.localStorageの読み込みも行う(#loadも同時に行っている)
 * storage.getAll(); //値を全て取得する
 * storage.set('test', [1, 2, 34, 5, 7]); //値を設定する(設定する値はなんでも良い: 複雑なインスタンスは除く)
 * storage.setAll({test2: 111, test3: 'str'})
 * storage.save(); //現在のインスタンス内部の値をwindow.localStorageに保存する
 * 
 * // saveを行った後のwindow.nameのイメージは以下のような感じになる
 * // window.localStorage == "{test:[1, 2, 34, 5, 7], test2:111; test3:'str'}"
 * 
 * // パス、保存期間などを設定する場合は以下の設定を行ってから#saveメソッドを呼ぶ必要がある
 * // 但し既に保存されているものとパス等がが違った場合上書きではなく新規になるので注意
 * // 更に詳しく知る場合はJeeel.Session.Abstractのメソッド一覧を参照
 * storage.setDomain('www.test.com'); //この設定はこのクラスにおいて無意味である(window.localStorageがそもそもクロスドメインを許可していないため)
 * storage.setPath('/test/index/'); //デフォルトでは現在のパスになる
 * storage.setExpires(172800); //デフォルトではブラウザを閉じるまで(擬似)
 */
Jeeel.Session.WebStorage = function (isPersistent, name) {
  
    Jeeel.Session.Abstract.call(this);

    /**
     * 保存データを永続化するかどうか
     * 
     * @type Boolean
     * @private
     */
    this._isPersistent = !!isPersistent;
    
    /**
     * 保存する際に使用するキー
     *
     * @type String
     * @private
     */
    this._sessionName = name || Jeeel.Session.WebStorage.STORAGE_NAME;
};

/**
 * インスタンスの作成を行う<br />
 * さらにロードも同時に行う
 *
 * @param {Boolean} [isPersistent] データの永続化をするかどうか(ブラウザを閉じてもアクセス出来るか)
 * @param {String} [name] 保存名を明示的に指定する場合に指定
 * @return {Jeeel.Session.WebStorage} 作成したインスタンス
 */
Jeeel.Session.WebStorage.create = function (isPersistent, name) {
    return (new this(isPersistent, name)).load();
};

/**
 * localStorageに保存する際のキー
 * 
 * @type String
 * @constant
 */
Jeeel.Session.WebStorage.STORAGE_NAME = 'Jeeel-Session-WebStorage-Name';

Jeeel.Session.WebStorage.prototype = {
    
    /**
     * 設定した値をセッションに保存する<br />
     * なおセーブ時は前に保持していた値は削除された後保存されるので、<br />
     * 注意して行う必要がある。
     *
     * @return {Jeeel.Session.WebStorage} 自インスタンス
     */
    save: function () {
        var tmp = this._session.params;
        this._session.params = this._changedValues;
        
        (this._isPersistent ? Jeeel._global.localStorage : Jeeel._global.sessionStorage).setItem(this._sessionName, this._session.serialize((this._isPersistent ? Jeeel._global.localStorage : Jeeel._global.sessionStorage).getItem(this._sessionName)));

        this._session.params = tmp;
        this._changedValues = {};

        return this;
    },
    
    /**
     * セッションに保存されていた値を読み込む<br/>
     * なお、現在保持している値は全て削除される
     *
     * @return {Jeeel.Session.WebStorage} 自インスタンス
     */
    load: function () {
        this._session = Jeeel.Session.Core.unserialize((this._isPersistent ? Jeeel._global.localStorage : Jeeel._global.sessionStorage).getItem(this._sessionName));
        this._changedValues = {};

        return this;
    }
};

Jeeel.Class.extend(Jeeel.Session.WebStorage, Jeeel.Session.Abstract);
/**
 * コンストラクタ
 * 
 * @class テンプレートを解析して文字列の置換やスクリプトの実行を行うクラス(所謂JSのテンプレートエンジン)<br />
 *         実行時にevalを使用するのでセキュアコード以外は実行するべきではない<br />
 *         また正規表現を多用しているのでIE等の貧弱なブラウザでは実行に時間が掛る可能性も高い
 *         <ul>
 *           <li> {+JS+}: JS実行して戻り値を表示する</li>
 *           <li> {!JS!}: JSを実行する{++}との違いは表示が行われない事と複数行の実行も可能なこと</li>
 *           <li> {?fetch ATTRIBUTES?}: 他のテンプレートを読み込み出力を行う。この際テンプレート変数を属性に付けて引き渡せる。file='test.tpl'[, var='tpl']などの形式でファイルURLを渡す。その際にvarを渡すと代わりに変数に代入する。</li>
 *           <li> {?if JS?}, {?elseif JS?}, {?else?}, {?if?}: JSを評価して条件に応じて分岐させる</li>
 *           <li> {?for JS;JS;JS?}, {?for JS in JS?}, {?/for?}: JSを実行しながらfor繰り返しを行う</li>
 *           <li> {?while JS?}, {?/while?}: JSを実行しながらwhile繰り返しを行う</li>
 *           <li> {?capture NAME?}, {?/capture?}: タグで囲まれたテンプレートの出力を出力せずにNAMEで指定した変数に格納する</li>
 *           <li> {?function NAME?}TEMPLATE{?/function?}: タグで囲まれたテンプレート部分を解析せずに保持し、NAME(Hash args)で呼び出した際に動的に解析を行う argsは内部で使用する変数のリスト</li>
 *           <li> {?strip?}, {?/strip?}: タグで囲まれたテンプレートの出力の空白・タブ・改行を全て取り除いて表示する</li>
 *           <li> {?escape?}, {?/escape?}: タグで囲まれたテンプレートの出力のHTMLタグ等を全てエスケープして表示する</li>
 *           <li> {#COMMENT#}: 表示も実行もされないコメント</li>
 *         </ul>
 * @example
 * Smartyの様なテンプレートエンジンとして使用することが出来るクラス
 * 
 * 例：
 * ------------------------------------------------------------------------------------------
 * {#キャプチャを行う#}
 * {?capture 'hoge'?}
 *   Pop Up
 * {?/capture?}
 * {#通常出力#}
 * <h1>{+Jeeel.VERSION+}</h1>
 * {?function 'title'?}{?strip?}
 *   <li>タイトル-{+i+}</li>
 *   {?if Math.random() < 0.5?}
 *     {#再帰呼び出し#}
 *     Recall {+title({i: Math.random()})+}
 *   {?/if?}
 * {?/strip?}{?/function?}
 * <footer>
 *   {#JSの実行#}
 *   {!
 *     var tpl = '';
 *     tpl += '<h2>';
 *     tpl += 'hoge';
 *     tpl += Math.random();
 *     tpl += '</h2>';
 *     
 *     var j = 10;
 *   !}
 *   {#whileループ#}
 *   {?while j--?}
 *     {#if分岐#}
 *     {?if parseInt(Math.random() * 2) % 2?}
 *       <div>
 *         {#HTMLのエスケープ#}
 *         {?escape?}
 *           {+tpl+}
 *         {?/escape?}
 *       </div>
 *     {?else?}
 *       失敗
 *     {?/if?}
 *   {?/while?}
 *   {+pot+}{+foot+}
 * </footer>
 * ------------------------------------------------------------------------------------------
 * 
 * 以上のようなファイルが/test/js-templateに存在した場合に以下の文を実行する事が出来る
 * 
 * var template = Jeeel.Template.create();
 * template.assign('foot', '777'); // footの名前のテンプレート変数を定義する
 * template.fetchFile('/test/js-template'); // 先のファイルを読み込んでコンパイルし実行する
 * 
 * 上記をサンプルにするとHTMLタグ以外にSmartyに似たタグが混じっているのが分かる
 * {#と#}に挟まれた箇所はコメントとなる 例、{#ここはコメント#}
 * {+と+}に挟まれた箇所は実行＋表示になる 例、{+Math.random()+}
 * {!と!}に挟まれた箇所は複数行の実行になる 例、{! var a = 10; a += 50; a -= 30 !}
 * {?と?}に挟まれた箇所は制御構文にある 例、{?if a > 50?}<div>テスト</div>{?/if?}
 * これらを組み合わせることでテンプレート変数を動的に割り当てHTML文字列を作成することを主とする
 * 
 * シンプルな例
 * ----------------------------------------------
 * <table>
 *   <tr>
 *     <th>名前</th>
 *     <th>コメント</th>
 *   </tr>
 *   {?for var i = 0; i < list.length; i++?}
 *     <tr>
 *       <td>{+list[i].name+}</td>
 *       <td>{+list[i].comment+}</td>
 *     </tr>
 *   {?/for?}
 * </table>
 * ----------------------------------------------
 * 上記のような文字列が変数strに入っているとする
 * 
 * var tpl = Jeeel.Template.create();
 * tpl.assign('list', [{name: 'a', 'Aです'}, {name: 'b', 'Bです'}]);
 * var res = tpl.fetchTemplate(str);
 * 
 * 上記を実行した場合は結果resは以下になる
 * ----------------------------------------------
 * <table>
 *   <tr>
 *     <th>名前</th>
 *     <th>コメント</th>
 *   </tr>
 *     <tr>
 *       <td>a</td>
 *       <td>Aです</td>
 *     </tr>
 *     <tr>
 *       <td>b</td>
 *       <td>Bです</td>
 *     </tr>
 * </table>
 * ----------------------------------------------
 * 
 * ファイルと通信するとあまり効率が良くないので、予めテンプレート文字列をJS側に定義しておくか引き渡しておくと効率が良い
 */
Jeeel.Template = function () {
    this._params = {};
    this._caches = {};
};

/**
 * インスタンスの作成を行う
 *
 * @return {Jeeel.Template} 作成したインスタンス
 */
Jeeel.Template.create = function () {
    return new this();
};

/**
 * @namespace テンプレート解析のためのパターンリスト
 */
Jeeel.Template.PATTERNS = {
    
    /**
     * 属性として扱うパターン
     * 
     * @type RegExp
     * @constant
     */
    ATTRIBUTE: /([a-zA-Z_\-\$]+)\s*=\s*(?:([a-zA-Z_\-\$]+)|(("|')[\s\S]+?[^\\]\4))/g,
    
    /**
     * コメントとして扱うパターン{#COMMENT#}
     * 
     * @type RegExp
     * @constant
     */
    COMMENT: /\{#[\s\S]+?#\}/g,
    
    /**
     * 出力として扱うパターン{+OUTPUT_CODE+}
     * 
     * @type RegExp
     * @constant
     */
    OUTPUT: /\{\+\s*([\s\S]+?)\s*\+\}/g,
    
    /**
     * コード実行として扱うパターン{!SCRIPT!}
     * 
     * @type RegExp
     * @constant
     */
    SCRIPT: /\{!\s*([\s\S]+?)\s*!\}/g,
    
    /**
     * 別ファイルをインライン展開するパターン{?fetch ATTRIBUTES?}<br />
     * 必須属性: file='ファイル名'
     * 任意属性: var='変数名'
     * 
     * @type RegExp
     * @constant
     */
    FETCH: /\{\?fetch\s+([\s\S]+?)\?\}/g,
    
    /**
     * if分岐として扱うパターン{?if BOOLEAN?}
     * 
     * @type RegExp
     * @constant
     */
    IF: /\{\?if\s+([\s\S]+?)\?\}/g,
    
    /**
     * elseif分岐として扱うパターン{?elseif BOOLEAN?}
     * 
     * @type RegExp
     * @constant
     */
    ELSE_IF: /\{\?elseif\s+([\s\S]+?)\?\}/g,
    
    /**
     * else分岐として扱うパターン{?else?}
     * 
     * @type RegExp
     * @constant
     */
    ELSE: /\{\?else\?\}/g,
    
    /**
     * if分岐の終了タグとして扱うパターン{?/if?}
     * 
     * @type RegExp
     * @constant
     */
    END_IF: /\{\?\/if\?\}/g,
    
    /**
     * forループとして扱うパターン{?for A;B;C?}
     * 
     * @type RegExp
     * @constant
     */
    FOR: /\{\?for\s+([^;]*);([^;]*);([\s\S]*?)\?\}/g,
    
    /**
     * for-inループとして扱うパターン{?for A in B?}
     * 
     * @type RegExp
     * @constant
     */
    FOREACH: /\{\?for\s+([\s\S]*?)\s+in\s+([\s\S]*?)\?\}/g,
    
    /**
     * forループの終了タグとして扱うパターン{?/for?}
     * 
     * @type RegExp
     * @constant
     */
    END_FOR: /\{\?\/for\?\}/g,
    
    /**
     * whileループとして扱うパターン{?while BOOLEAN?}
     * 
     * @type RegExp
     * @constant
     */
    WHILE: /\{\?while\s+([\s\S]+?)\?\}/g,
    
    /**
     * whileループの終了タグとして扱うパターン{?/while?}
     * 
     * @type RegExp
     * @constant
     */
    END_WHILE: /\{\?\/while\?\}/g,
    
    /**
     * テンプレート内容を変数に格納するcaptureとして扱うパターン{?capture NAME?}
     * 
     * @type RegExp
     * @constant
     */
    CAPTURE: /\{\?capture\s+("|')([\s\S]+)\1\?\}/g,
    
    /**
     * captureの終了タグとして扱うパターン{?/capture?}
     * 
     * @type RegExp
     * @constant
     */
    END_CAPTURE: /\{\?\/capture\?\}/g,
    
    /**
     * テンプレート内容を動的に解析するfunctionのタグとして扱うパターン{?function?}{?/function?}
     * 
     * @type RegExp
     * @constant
     */
    FUNCTION: /\{\?function\s+("|')([\s\S]+)\1\?\}([\s\S]*?)\{\?\/function\?\}/g,
    
    /**
     * 空白や改行を取り除くstripタグとして扱うパターン{?strip?}
     * 
     * @type RegExp
     * @constant
     */
    STRIP: /\{\?strip\?\}/g,
    
    /**
     * stripの終了タグとして扱うパターン{?/strip?}
     * 
     * @type RegExp
     * @constant
     */
    END_STRIP: /\{\?\/strip\?\}/g,
    
    /**
     * HTMLタグのエスケープを行うescapeとして扱うパターン{?escape?}
     * 
     * @type RegExp
     * @constant
     */
    ESCAPE: /\{\?escape\?\}/g,
    
    /**
     * escapeの終了タグとして扱うパターン{?/escape?}
     * 
     * @type RegExp
     * @constant
     */
    END_ESCAPE: /\{\?\/escape\?\}/g
};

Jeeel.Template.prototype = {
    
    /**
     * 現在テンプレートを解析中かどうか
     * 
     * @type Boolean
     * @private
     */
    _fetching: false,
    
    /**
     * 現在解析中のテンプレートのキャッシュキー
     * 
     * @type String
     * @private
     */
    _cacheKey: null,
    
    /**
     * 実行する際に必要な変数名と値のペアリスト
     * 
     * @type Hash
     * @private
     */
    _params: {},
    
    /**
     * functionタグのキャッシュを格納する変数
     * 
     * @type Hash
     * @private
     */
    _functions: {},
    
    /**
     * テンプレートファイルのキャッシュ
     * 
     * @type Hash
     * @private
     */
    _caches: {},
    
    /**
     * include等を行う際に使用する内部インスタンス
     * 
     * @type Jeeel.Template
     * @private
     */
    _fetcher: null,

    /**
     * 実行する際に使用する変数をセットする
     *
     * @param {String} key 変数名
     * @param {Mixed} value 変数の値
     * @return {Jeeel.Template} 自インスタンス
     */
    assign: function (key, value) {
        this._params[key] = value;

        return this;
    },

    /**
     * 指定した連想配列のキーを変数名として全てassignする
     *
     * @param {Hash} values 変数名と変数値のペアリスト
     * @return {Jeeel.Template} 自インスタンス
     */
    assignAll: function (values) {
        if ( ! Jeeel.Type.isHash(values)) {
            throw new Error('valuesは必ず配列式でなければなりません。');
        }

        for (var key in values) {
            this.assign(key, values[key]);
        }

        return this;
    },

    /**
     * セットされた変数の値を破棄する
     *
     * @param {String} key 変数名
     * @return {Jeeel.Template} 自インスタンス
     */
    unassign: function (key) {
        delete this._params[key];

        return this;
    },

    /**
     * セットされた変数の値をすべて破棄する
     *
     * @return {Jeeel.Template} 自インスタンス
     */
    unassignAll: function () {
        this._params = {};

        return this;
    },
    
    /**
     * 指定したキャッシュを消去する
     * 
     * @param {String} cacheKey キャッシュキー
     * @return {Jeeel.Template} 自インスタンス
     */
    clearCache: function (cacheKey) {
        delete this._caches[cacheKey];
        
        return this;
    },
    
    /**
     * キャッシュを全て消去する
     * 
     * @return {Jeeel.Template} 自インスタンス
     */
    clearCacheAll: function () {
        this._caches = {};
        
        return this;
    },
    
    /**
     * 指定したファイル内容を解析し、文字列置換して返す
     *
     * @param {String} url ファイルを示すURL
     * @param {String} [cacheKey] キャッシュするキーを明示的に指定したい場合に使用する<br />
     *                             また明示的にnullを渡すとキャッシュなしで動作する
     * @return {String} 解析後の文字列
     * @throws {Error} ファイルが見当たらないかサーバーエラー時に発生する
     */
    fetchFile: function (url, cacheKey) {
        this._fetching = true;
        
        if (cacheKey === null) {
            this._cacheKey = null;
        } else {
            this._cacheKey = cacheKey || url;
        }
        
        var res;
        
        if ( ! this._caches[this._cacheKey]) {
            res = Jeeel.Net.Ajax.serverResponse(url);

            if ( ! Jeeel.Type.isString(res)) {
                this._fetching = false;
                this._cacheKey = null;

                throw new Error('ファイルが見当たらないかサーバーエラーを返しました。');
            }
        }

        try {
            res = this._replaceTemplate(res);
        } catch (e) {
            throw e;
        } finally {
            this._fetching = false;
            this._cacheKey = null;
        }

        return res;
    },
    
    /**
     * 指定したファイル内容を非同期で解析しコールバックに引き渡す
     *
     * @param {String} url ファイルを示すURL
     * @param {Function} callback コールバック
     * @param {String} [cacheKey] キャッシュするキーを明示的に指定したい場合に使用する<br />
     *                             また明示的にnullを渡すとキャッシュなしで動作する
     * @return {Jeeel.Template} 自インスタンス
     * @throws {Error} callbackを指定しなかった場合に発生する
     * @throws {Error} 現在他のテンプレートを解析中だった場合に発生する
     * @throws {Error} ファイルが見当たらないかサーバーエラー時に発生する
     */
    fetchFileAsync: function (url, callback, cacheKey) {
        
        if ( ! Jeeel.Type.isFunction(callback)) {
            throw new Error('callbackは必ず指定しなければなりません。');
        } else if (this._fetching) {
            throw new Error('同時に複数のテンプレートの解析はできません。');
        }
        
        this._fetching = true;
        
        if (cacheKey === null) {
            this._cacheKey = null;
        } else {
            this._cacheKey = cacheKey || url;
        }
        
        if ( ! this._caches[this._cacheKey]) {
            var ajax = new Jeeel.Net.Ajax(url);

            ajax.setSuccessMethod(function (response) {
                var res;

                try {
                    res = this._replaceTemplate(response.responseText);
                } catch (e) {
                    throw e;
                } finally {
                    this._fetching = false;
                    this._cacheKey = null;
                }

                callback(res);
            }, this).setFailureMethod(function (response) {
                this._fetching = false;
                this._cacheKey = null;

                throw new Error('ファイルが見当たらないかサーバーエラーを返しました。');
            }, this).setExceptionMethod(function (r, e) {
                throw e;
            }, this).execute();
        } else {
            try {
                callback(this._replaceTemplate());
            } catch (e) {
                throw e;
            } finally {
                this._fetching = false;
                this._cacheKey = null;
            }
        }
        
        return this;
    },

    /**
     * 指定した文字列をテンプレートして扱い文字列置換を行う
     *
     * @param {String} template テンプレート文字列
     * @param {String} [cacheKey] キャッシュする際に指定する
     * @return {String} 解析後の文字列
     */
    fetchTemplate: function (template, cacheKey) {
        this._fetching = true;
        
        this._cacheKey = cacheKey || null;
        
        try {
            var res = this._replaceTemplate(template);
        } catch (e) {
            throw e;
        } finally {
            this._fetching = false;
        }

        return res;
    },
    
    /**
     * 指定したキャッシュをテンプレートして扱い文字列置換を行う
     *
     * @param {String} cacheKey 取得したいキャッシュ名
     * @return {String} 解析後の文字列
     */
    fetchCache: function (cacheKey) {
        this._fetching = true;
        
        this._cacheKey = cacheKey;
        
        try {
            var res = this._replaceTemplate('');
        } catch (e) {
            throw e;
        } finally {
            this._fetching = false;
        }

        return res;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Template,
    
    /**
     * テンプレートを実際に解析する
     * 
     * @param {String} $__template__$ テンプレート
     * @return {String} 解析後のテンプレート
     * @private
     */
    _replaceTemplate: function ($__template__$) {
        
        if ( ! this._fetcher) {
            this._fetcher = Jeeel.Template.create();
        } 
        
        var $__out__$, $__code__$, $__striptmp__$, $__escapetmp__$, $__this__$ = this, $__creator__$ = this._fetcher;
        
        this._functions = {};
        
        var $__compile__$ = function ($__template__$, args) {
            var $__out__$, $__code__$, $__striptmp__$, $__escapetmp__$;
            
            args = args || {};
            
            for (var $__key__$ in args) {
                eval("var " + $__key__$ + " = args[$__key__$];");
            }
            
            $__code__$ = $__template__$.replace($__this__$.constructor.PATTERNS.COMMENT, '');

            $__code__$ = $__this__$._replaceFunction($__code__$);
            $__code__$ = $__this__$._replaceOutput($__code__$);
            $__code__$ = $__this__$._replaceScript($__code__$);
            $__code__$ = $__this__$.replaceRequest($__code__$);
            $__code__$ = $__this__$._replaceBranch($__code__$);
            $__code__$ = $__this__$._replaceLoop($__code__$);
            $__code__$ = $__this__$._replaceCapture($__code__$);
            $__code__$ = $__this__$._replaceStrip($__code__$);
            $__code__$ = $__this__$._replaceEscape($__code__$);
            
            $__code__$ = "$__out__$ = \u001e" + $__code__$ + "\u001e";

            $__code__$ = $__code__$.replace(/\r?\n/g, '\\n')
                                   .replace(/\r/g, '')
                                   .replace(/"/g, '\\"')
                                   .replace(/\u001e/g, '"');
            
            (function () {
                eval($__code__$);
            })();

            return $__out__$;
        };
        
        if (this._cacheKey && this._caches[this._cacheKey]) {
            $__code__$ = this._caches[this._cacheKey].code;
            this._functions = this._caches[this._cacheKey].func;
        } else {
            $__code__$ = $__template__$.replace(this.constructor.PATTERNS.COMMENT, '');

            $__code__$ = this._replaceFunction($__code__$);
            $__code__$ = this._replaceOutput($__code__$);
            $__code__$ = this._replaceScript($__code__$);
            $__code__$ = this.replaceRequest($__code__$);
            $__code__$ = this._replaceBranch($__code__$);
            $__code__$ = this._replaceLoop($__code__$);
            $__code__$ = this._replaceCapture($__code__$);
            $__code__$ = this._replaceStrip($__code__$);
            $__code__$ = this._replaceEscape($__code__$);

            $__code__$ = "$__out__$ = \u001e" + $__code__$ + "\u001e";

            $__code__$ = $__code__$.replace(/\r?\n/g, '\\n')
                                   .replace(/\r/g, '')
                                   .replace(/"/g, '\\"')
                                   .replace(/\u001e/g, '"');

            if (this._cacheKey) {
                this._caches[this._cacheKey] = {
                    tpl: $__template__$,
                    code: $__code__$,
                    func: this._functions
                };
            }
        }
        
        var $__key__$;

        // 使用変数の動的定義
        for ($__key__$ in this._params) {
            eval('var ' + $__key__$ + ' = this._params[$__key__$];');
        }
        
        for ($__key__$ in this._functions) {
            eval('var ' + $__key__$ + ' = function (args) { return $__compile__$("' + this._functions[$__key__$] + '", args);};');
        }

        (function () {
            eval($__code__$);
        })();
        
        return $__out__$;
    },
    
    /**
     * テンプレートの出力パターンの置き換えを行う
     * 
     * @param {String} template テンプレート
     * @return {String} 置換後のテンプレート
     * @private
     */
    _replaceOutput: function (template) {
        return template.replace(this.constructor.PATTERNS.OUTPUT, function (match, output) {
            output = output.replace(/"/g, "\u001e")
                           .replace(/(\r?\n)/g, " ");

            return "\u001e + (" + output + ") +\u001e";
        });
    },
    
    /**
     * テンプレートの実行スクリプトパターンの置き換えを行う
     * 
     * @param {String} template テンプレート
     * @return {String} 置換後のテンプレート
     * @private
     */
    _replaceScript: function (template) {
        return template.replace(this.constructor.PATTERNS.SCRIPT, function (match, script) {
            script = script.replace(/"/g, "\u001e")
                           .replace(/(\r?\n)/g, " ");

            return "\u001e; " + script + "; $__out__$ += \u001e";
        });
    },
    
    /**
     * テンプレートの外部読み込みパターンの置き換えを行う
     * 
     * @param {String} template テンプレート
     * @return {String} 置換後のテンプレート
     * @private
     */
    replaceRequest: function (template) {
        var self = this;
        
        return template.replace(this.constructor.PATTERNS.FETCH, function (match, values) {
            
            var prms = {};
            
            values.replace(self.constructor.PATTERNS.ATTRIBUTE, function (match, key, variable, str) {
                prms[key] = variable || str;
            });
            
            var variable, file = prms.file;
            var isInclude = true;
            
            delete prms.file;
            
            if (prms['var']) {
                variable = ('' + prms['var']).replace(/^("|')([\s\S]+)\1$/g, '$2');
                
                isInclude = false;
                
                delete prms['var'];
            }
            
            var tpl = '(function () {$__creator__$.unassignAll();';
            
            for (var key in prms) {
                tpl += '$__creator__$.assign(\u001e' + key + '\u001e, ' + prms[key] + ');';
            }
            
            tpl += 'return $__creator__$.fetchFile(' + file + ');})()';
            
            if (isInclude) {
                return "\u001e + " + tpl + " + \u001e";
            }
            
            return "\u001e; var  " + variable + ' = ' + tpl + "; $__out__$ += \u001e";
        });
    },
    
    /**
     * テンプレートの条件分岐パターンの置き換えを行う
     * 
     * @param {String} template テンプレート
     * @return {String} 置換後のテンプレート
     * @private
     */
    _replaceBranch: function (template) {
        return template.replace(this.constructor.PATTERNS.IF, "\u001e; if ($1) { $$__out__$$ += \u001e")
                       .replace(this.constructor.PATTERNS.ELSE_IF, "\u001e;} else if ($1) { $$__out__$$ += \u001e")
                       .replace(this.constructor.PATTERNS.ELSE, "\u001e;} else { $$__out__$$ += \u001e")
                       .replace(this.constructor.PATTERNS.END_IF, "\u001e;} $$__out__$$ += \u001e");
    },
    
    /**
     * テンプレートの繰り返しパターンの置き換えを行う
     * 
     * @param {String} template テンプレート
     * @return {String} 置換後のテンプレート
     * @private
     */
    _replaceLoop: function (template) {
        return template.replace(this.constructor.PATTERNS.FOR, "\u001e; for ($1;$2;$3) { $$__out__$$ += \u001e")
                       .replace(this.constructor.PATTERNS.FOREACH, "\u001e; for ($1 in $2) { $$__out__$$ += \u001e")
                       .replace(this.constructor.PATTERNS.END_FOR, "\u001e;} $$__out__$$ += \u001e")
                       .replace(this.constructor.PATTERNS.WHILE, "\u001e; while ($1) { $$__out__$$ += \u001e")
                       .replace(this.constructor.PATTERNS.END_WHILE, "\u001e;} $$__out__$$ += \u001e");
    },
    
    /**
     * テンプレートのcaptureパターンの置き換えを行う
     * 
     * @param {String} template テンプレート
     * @return {String} 置換後のテンプレート
     * @private
     */
    _replaceCapture: function (template) {
        return template.replace(this.constructor.PATTERNS.CAPTURE, "\u001e; var $2 = \u001e")
                       .replace(this.constructor.PATTERNS.END_CAPTURE, "\u001e; $$__out__$$ += \u001e");
    },
    
    /**
     * テンプレートのfunctionパターンの置き換えを行う
     * 
     * @param {String} template テンプレート
     * @return {String} 置換後のテンプレート
     * @private
     */
    _replaceFunction: function (template) {
        var self = this;
        
        return template.replace(this.constructor.PATTERNS.FUNCTION, function (match, quotation, name, value) {
            value = value.replace(/"/g, '\\"')
                         .replace(/(\r?\n)/g, "\\n");
            
            self._functions[name] = value;

            return "";
        });
    },
    
    /**
     * テンプレートのstripパターンの置き換えを行う
     * 
     * @param {String} template テンプレート
     * @return {String} 置換後のテンプレート
     * @private
     */
    _replaceStrip: function (template) {
        return template.replace(this.constructor.PATTERNS.STRIP, "\u001e; if ( ! $$__striptmp__$$) { $$__striptmp__$$ = $$__out__$$; $$__out__$$ = \u001e")
                       .replace(this.constructor.PATTERNS.END_STRIP, "\u001e; $$__out__$$ = $$__striptmp__$$ + $$__out__$$.replace(/\\s+/g, \u001e\u001e); $$__striptmp__$$ = null;} $$__out__$$ += \u001e");
    },
    
    /**
     * テンプレートのescapeパターンの置き換えを行う
     * 
     * @param {String} template テンプレート
     * @return {String} 置換後のテンプレート
     * @private
     */
    _replaceEscape: function (template) {
        return template.replace(this.constructor.PATTERNS.ESCAPE, "\u001e; if ( ! $$__escapetmp__$$) { $$__escapetmp__$$ = $$__out__$$; $$__out__$$ = \u001e")
                       .replace(this.constructor.PATTERNS.END_ESCAPE, "\u001e; $$__out__$$ = $$__escapetmp__$$ + Jeeel.String.escapeHtml($$__out__$$); $$__escapetmp__$$ = null;} $$__out__$$ += \u001e");
    }
};

/**
 * コンストラクタ
 *
 * @class タイマーを管理するクラス
 * @param {Function} func 一定時間毎に呼び出されるコールバック(関数内のthisはここで作成するインスタンスになる)
 * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数
 * @example
 * setIntervalやsetTimeoutのタイマーを管理するクラス
 * intervalを途中で一時停止したり、呼びだされるコールバックに引数を渡す機能を使いたい場合に使用する(引数はブラウザのバグや未実装の影響でsetIntervalやsetTimeoutを直接使うとクロスブラウザでなくなる)
 * またタイマーが呼び出された回数や最後のタイマーの戻り値なども取得できる
 * 
 * 例：
 * function test (a, b) {
 *     return (a + b) * Math.random();
 * }
 * 
 * var timer = Jeeel.Timer.create(test, 3000, 12, 45);
 * 
 * // 3秒経過
 * 
 * timer.getLastResult(); // 0 ～ 57の間の数が返ってくる
 * timer.stop(); // タイマーを一時停止する
 * 
 * // 3秒経過
 * 
 * timer.start(); // タイマーを再開する
 * 
 * // 6秒経過
 * 
 * timer.getCount(); // 3が返ってくる(3回コールバックが実行された意味になる)
 */
Jeeel.Timer = function (func, interval, var_args) {

    var limit = -1;

    if (func && Jeeel.Type.isInteger(func.limit)) {
        limit = func.limit;
    }

    var args = Array.prototype.slice.call(arguments, 2, arguments.length);

    if (arguments[0]) {
        var self = this;
        var baseFunc = func;
        arguments[0] = function () {

            if (self._limit >= 0 && self._limit <= self._count) {
                self.end();
                return;
            }

            self._lastResult = baseFunc.apply(self, args);
            
            self._count++;
        };
    }

    this._count = 0;
    this._limit = limit;
    this._args  = Array.prototype.slice.call(arguments);
    this._timer = this._setInterval.apply(null, arguments);
    this._enabled = true;
    this._lastResult = null;
};

/**
 * インスタンスの作成を行う
 *
 * @param {Function} func 一定時間毎に呼び出されるコールバック(関数内のthisはここで作成するインスタンスになる)
 * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数
 * @return {Jeeel.Timer} 作成したインスタンス
 */
Jeeel.Timer.create = function (func, interval, var_args) {
    return Jeeel.Function.toNative(Jeeel, 'Timer', true).apply(null, arguments);
};

/**
 * 指定した回数だけタイマーを回す
 *
 * @param {Function} func 一定時間毎に呼び出されるコールバック(関数内のthisはJeeel.Timerのインスタンスになる)
 * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
 * @param {Integer} limit タイマーを回す回数(マイナスを指定すると無制限になる)
 * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数には0から始まるタイマーが回った回数が渡される)
 * @return {Jeeel.Timer} 作成したインスタンス
 */
Jeeel.Timer.setLimitInterval = function (func, interval, limit, var_args) {
    var baseFunc = func;
    
    /**
     * @ignore
     */
    func = function () {
        if (arguments[0]) {
            arguments[0] = this._count;
        }

        return baseFunc.apply(this, arguments);
    };

    func.limit = limit;

    if (arguments[0]) {
        arguments[0] = func;
    }

    return Jeeel.Function.toNative(Jeeel, 'Timer', true).apply(null, arguments);
};

/**
 * 指定時間後にメソッドを実行する
 *
 * @param {Function|Jeeel.Function.Callback} func コールバックメソッド
 * @param {Integer} delayTime コールバックを呼び出す遅延時間(ミリ秒)
 * @param {Mixied} var_args コールバックに渡す引数を可変的に渡す
 * @return {Integer} タイムアウトID
 */
Jeeel.Timer.setTimeout = function (func, delayTime, var_args) {
    var args = Array.prototype.slice.call(arguments, 2, arguments.length);

    /**
     * @ignore
     */
    var _func = (func instanceof Jeeel.Function.Callback) ? function () {
        return func.apply(args);
    } : function () {
        return func.apply(this, args);
    };

    return setTimeout(_func, delayTime);
};

/**
 * 指定時間後にセットしたメソッドの設定を解除する
 *
 * @param {Integer} timeoutId タイムアウトID
 */
Jeeel.Timer.clearTimeout = function (timeoutId) {
    clearTimeout(timeoutId);
};

Jeeel.Timer.prototype = {
    
    /**
     * タイマーが回った回数
     *
     * @type Integer
     * @private
     */
    _count: 0,

    /**
     * タイマーを回す回数(マイナスで無制限)
     *
     * @type Integer
     * @private
     */
    _limit: 0,
    
    /**
     * コンストラクタに引き渡された引数
     *
     * @type Arguments
     * @private
     */
    _args: null,
    
    /**
     * タイマーID
     *
     * @type Integer
     * @private
     */
    _timer: 0,

    /**
     * タイマーが有効かどうかを示す真偽値
     *
     * @type Boolean
     * @private
     */
    _enabled: true,

    /**
     * タイマーで実行されたコールバックの最後の戻り値
     *
     * @type Mixied
     * @private
     */
    _lastResult: null,

    /**
     * setIntervalを呼ぶ
     *
     * @return {Integer} タイマーID
     * @private
     */
    _setInterval: function (func, interval) {
        return Jeeel.Window.setInterval(func, interval);
    },

    /**
     * タイマーをスタートする
     *
     * @return {Jeeel.Timer} 自インスタンス
     */
    start: function () {
        if ( ! this._enabled) {
            this._timer   = this._setInterval.apply(null, this._args);
            this._enabled = true;
        }

        return this;
    },

    /**
     * タイマーをストップする
     *
     * @return {Jeeel.Timer} 自インスタンス
     */
    stop: function () {
        if (this._enabled) {
            Jeeel.Window.clearInterval(this._timer);
            this._enabled = false;
        }

        return this;
    },

    /**
     * タイマーを終了する<br />
     * このメソッドを呼んだ後のインスタンスに対して何をしても意味が無い
     */
    end: function () {
        this.stop();

        for (var key in this) {
            delete this[key];
        }
    },

    /**
     * タイマーで実行されたコールバックの最後の戻り値を取得する
     *
     * @return {Mixied} タイマーで実行されたコールバックの最後の戻り値
     */
    getLastResult: function () {
        return this._lastResult;
    },

    /**
     * タイマーが回った回数を取得する
     *
     * @return {Integer} タイマーが回った回数
     */
    getCount: function () {
        return this._count;
    },

    /**
     * タイマーが回っているかどうかを返す
     *
     * @return {Boolean} タイマーが回っているかどうか
     */
    isEnabled: function () {
        return this._enabled;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Function} func 一定時間毎に呼び出されるコールバック(関数内のthisはここで作成するインスタンスになる)
     * @param {Integer} interval コールバックを呼び出す間隔(ミリ秒)
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数
     * @constructor
     */
    constructor: Jeeel.Timer
};
Jeeel.directory.Jeeel.DataStructure = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'DataStructure/';
    }
};

/**
 * @namespace データ構造関するネームスペース
 */
Jeeel.DataStructure = {
    
};

Jeeel.file.Jeeel.DataStructure = ['Stack', 'Queue', 'Deque', 'List', 'Tree'];

Jeeel._autoImports(Jeeel.directory.Jeeel.DataStructure, Jeeel.file.Jeeel.DataStructure);
/**
 * コンストラクタ
 * 
 * @class スタックを扱うクラス
 */
Jeeel.DataStructure.Stack = function () {
    this._stack = [];
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Stack} 作成したインスタンス
 */
Jeeel.DataStructure.Stack.create = function () {
    return new this();
};

Jeeel.DataStructure.Stack.prototype = {
    
    /**
     * 内部スタック
     * 
     * @type Array
     * @private
     */
    _stack: [],
    
    /**
     * スタックに値を入れる
     * 
     * @param {Mixied} data 入れる値
     * @return {Jeeel.DataStructure.Stack} 自インスタンス
     */
    push: function (data) {
        this._stack.push(data);
        
        return this;
    },
    
    /**
     * スタックから値を取りだす
     * 
     * @return {Mixied} 取りだした値
     */
    pop: function () {
        return (+this._stack.length ? this._stack.pop() : null);
    },
    
    /**
     * スタックに入っている値を全て削除する
     * 
     * @return {Jeeel.DataStructure.Stack} 自インスタンス
     */
    clear: function () {
        this._stack = [];
        
        return this;
    },
    
    /**
     * スタックのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._stack.length;
    }
};

/**
 * コンストラクタ
 * 
 * @class キューを扱うクラス
 */
Jeeel.DataStructure.Queue = function () {
    this._queue = [];
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Queue} 作成したインスタンス
 */
Jeeel.DataStructure.Queue.create = function () {
    return new this();
};

Jeeel.DataStructure.Queue.prototype = {
    
    /**
     * 内部キュー
     * 
     * @type Array
     * @private
     */
    _queue: [],
    
    /**
     * キューに値を入れる
     * 
     * @param {Mixied} data 入れる値
     * @return {Jeeel.DataStructure.Queue} 自インスタンス
     */
    enqueue: function (data) {
        this._queue.push(data);
        
        return this;
    },
    
    /**
     * キューから値を取りだす
     * 
     * @return {Mixied} 取りだした値
     */
    dequeue: function () {
        return (+this._queue.length ? this._queue.shift() : null);
    },
    
    /**
     * キューに入っている値を全て削除する
     * 
     * @return {Jeeel.DataStructure.Queue} 自インスタンス
     */
    clear: function () {
        this._queue = [];
        
        return this;
    },
    
    /**
     * キューのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._queue.length;
    }
};

/**
 * コンストラクタ
 * 
 * @class デックを扱うクラス
 */
Jeeel.DataStructure.Deque = function () {
    this._deque = [];
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Deque} 作成したインスタンス
 */
Jeeel.DataStructure.Deque.create = function () {
    return new this();
};

Jeeel.DataStructure.Deque.prototype = {
    
    /**
     * 内部デック
     * 
     * @type Array
     * @private
     */
    _deque: [],
    
    /**
     * デックの前方に値を入れる
     *
     * @param {Mixied} data 入れる値
     * @return {Jeeel.DataStructure.Deque} 自インスタンス
     */
    pushFront: function (data) {
        this._deque.unshift(data);

        return this;
    },
    
    /**
     * デックの後方に値を入れる
     *
     * @param {Mixied} data 入れる値
     * @return {Jeeel.DataStructure.Deque} 自インスタンス
     */
    pushBack: function (data) {
        this._deque.push(data);

        return this;
    },

    /**
     * デックの前方から値を取りだす
     *
     * @return {Mixied} 取りだした値
     */
    popFront: function () {
        if (this._deque.length === 0) {
            return null;
        }
        
        return this._deque.shift();
    },

    /**
     * デックの後方から値を取りだす
     *
     * @return {Mixied} 取りだした値
     */
    popBack: function () {
        if (this._deque.length === 0) {
            return null;
        }
        
        return this._deque.pop();
    },
    
    /**
     * デックに入っている値を全て削除する
     * 
     * @return {Jeeel.DataStructure.Deque} 自インスタンス
     */
    clear: function () {
        this._deque = [];
        
        return this;
    },
    
    /**
     * デックのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._deque.length;
    }
};
Jeeel.directory.Jeeel.DataStructure.List = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.DataStructure + 'List/';
    }
};

/**
 * コンストラクタ
 * 
 * @class リストを扱うクラス
 */
Jeeel.DataStructure.List = function () {
    this._dummyNode = new this.constructor.Node(null);
    
    this._dummyNode._prev = this._dummyNode;
    this._dummyNode._next = this._dummyNode;
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.List} 作成したインスタンス
 */
Jeeel.DataStructure.List.create = function () {
    return new this();
};

Jeeel.DataStructure.List.prototype = {
    
    /**
     * 番兵ノード
     * 
     * @type Jeeel.DataStructure.List.Node
     * @private
     */
    _dummyNode: null,
    
    /**
     * データサイズ
     * 
     * @type Integer
     * @private
     */
    _size: 0,
    
    /**
     * 先頭ノードを取得する
     * 
     * @return {Jeeel.DataStructure.List.Node} 先頭ノード
     */
    getFirst: function () {
        return this._size && this._dummyNode._next || null;
    },

    /**
     * 後方ノードを取得する
     * 
     * @return {Jeeel.DataStructure.List.Node} 後方ノード
     */
    getLast: function () {
        return this._size && this._dummyNode._prev || null;
    },
    
    /**
     * 指定ノードの後に新しいノードを挿入する
     * 
     * @param {Jeeel.DataStructure.List.Node} node 起点ノード
     * @param {Jeeel.DataStructure.List.Node} newNode 追加ノード
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    insertAfter: function (node, newNode) {
        if ( ! node) {
            node = this._dummyNode;
        }
        
        newNode._next = node._next;
        newNode._prev = node;
        newNode._next._prev = newNode;
        node._next = newNode;
        
        this._size++;
        
        return this;
    },
    
    /**
     * 指定ノードの前に新しいノードを挿入する
     * 
     * @param {Jeeel.DataStructure.List.Node} node 起点ノード
     * @param {Jeeel.DataStructure.List.Node} newNode 追加ノード
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    insertBefore: function (node, newNode) {
        if ( ! node) {
            node = this._dummyNode;
        }
        
        newNode._next = node;
        newNode._prev = node._prev;
        newNode._prev._next = newNode;
        node._prev = newNode;
        
        this._size++;
        
        return this;
    },
    
    /**
     * ノードを追加する
     * 
     * @param {Jeeel.DataStructure.List.Node} node 追加ノード
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    appendNode: function (node) {
        return this.insertBefore(null, node);
    },
    
    /**
     * ノードを削除する
     * 
     * @param {Jeeel.DataStructure.List.Node} node 削除ノード
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    removeNode: function (node) {
        var prev = node._prev;
        var next = node._next;
        
        prev._next = next;
        next._prev = prev;
        
        delete node;
        
        this._size--;
        
        return this;
    },
    
    /**
     * データを追加する
     * 
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    appendData: function (data) {
        return this.insertBefore(null, new this.constructor.Node(data));
    },
    
    /**
     * 指定された関数を各要素に一度ずつ実行する
     *
     * @param {Function} callback void callback(Mixied data, Jeeel.DataStructure.List.Node node, Jeeel.DataStructure.List list)
     * @param {Mixied} [thisArg] callback内でthisに相当する値
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    forEach: function (callback, thisArg) {
        var node = this._dummyNode._next;
        
        if ( ! Jeeel.Type.isSet(thisArg)) {
            thisArg = this;
        }
        
        while(node !== this._dummyNode) {
            callback.call(thisArg, node.getData(), node, this);
            
            node = node._next;
        }

        return this;
    },
    
    /**
     * インスタンスを配列に変換する
     * 
     * @return {Array} 変換後の配列
     */
    toArray: function () {
        var node = this._dummyNode._next;
        var arr  = [];
        
        while (node !== this._dummyNode) {
            arr[arr.length] = node.getData();
            
            node = node._next;
        }
        
        return arr;
    },
    
    /**
     * インスタンスを反転配列に変換する
     * 
     * @return {Array} 変換後の配列
     */
    toReverseArray: function () {
        var node = this._dummyNode._prev;
        var arr  = [];
        
        while (node !== this._dummyNode) {
            arr[arr.length] = node.getData();
            
            node = node._prev;
        }
        
        return arr;
    },
    
    /**
     * リストに入っている値を全て削除する
     * 
     * @return {Jeeel.DataStructure.List} 自インスタンス
     */
    clear: function () {
        var node = this._dummyNode._next;
        
        // GCに必ず回収されるように全ての参照を切る
        while (node !== this._dummyNode) {
            delete node._prev;
            node = node._next;
        }
        
        this._dummyNode._prev = this._dummyNode;
        this._dummyNode._next = this._dummyNode;
        this._size = 0;
        
        return this;
    },
    
    /**
     * リストのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._size;
    },
   
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.DataStructure.List
};

Jeeel.file.Jeeel.DataStructure.List = ['Node'];

Jeeel._autoImports(Jeeel.directory.Jeeel.DataStructure.List, Jeeel.file.Jeeel.DataStructure.List);
/**
 * コンストラクタ
 * 
 * @class リスト内のノードを扱うクラス
 * @param {Mixied} data ノードが扱うデータ
 * @param {Jeeel.DataStructure.List.Node} [prev] 前方のノード
 * @param {Jeeel.DataStructure.List.Node} [next] 後方のノード
 */
Jeeel.DataStructure.List.Node = function (data, prev, next) {
    this._data = data;
    this._prev = prev || null;
    this._next = next || null;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Mixied} data ノードが扱うデータ
 * @param {Jeeel.DataStructure.List.Node} [prev] 前方のノード
 * @param {Jeeel.DataStructure.List.Node} [next] 後方のノード
 * @return {Jeeel.DataStructure.List.Node} 作成したインスタンス
 */
Jeeel.DataStructure.List.Node.create = function (data, prev, next) {
    return new this(data, prev, next);
};

Jeeel.DataStructure.List.Node.prototype = {
  
    /**
     * 前方ノード
     * 
     * @type Jeeel.DataStructure.List.Node
     * @private
     */
    _prev: null,
    
    /**
     * 後方ノード
     * 
     * @type Jeeel.DataStructure.List.Node
     * @private
     */
    _next: null,
    
    /**
     * データ
     * 
     * @type Mixied
     * @private
     */
    _data: null,
    
    /**
     * データを取得する
     * 
     * @return {Mixied} データ
     */
    getData: function () {
        return this._data;
    },
    
    /**
     * 前方ノードを取得する
     * 
     * @return {Jeeel.DataStructure.List.Node} 前方ノード
     */
    getPrevious: function () {
        return this._prev;
    },
    
    /**
     * 後方ノードを取得する
     * 
     * @return {Jeeel.DataStructure.List.Node} 後方ノード
     */
    getNext: function () {
        return this._next;
    },
      
    /**
     * コンストラクタ
     * 
     * @param {Mixied} data ノードが扱うデータ
     * @param {Jeeel.DataStructure.List.Node} [prev] このノードの前のノード
     * @param {Jeeel.DataStructure.List.Node} [next] このノードの次のノード
     * @constructor
     */
    constructor: Jeeel.DataStructure.List.Node,
    
    /**
     * ノード内のデータを返す
     * 
     * @return {Mixied} データ
     */
    valueOf: function () {
        return this._data;
    },
    
    /**
     * ノード内のデータを文字列変換して返す
     * 
     * @return {String} データ文字列
     */
    toString: function () {
        return (this._data || '' + this._data).toString();
    }
};Jeeel.directory.Jeeel.DataStructure.Tree = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.DataStructure + 'Tree/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 木構造を扱うクラス
 */
Jeeel.DataStructure.Tree = function () {
    
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Tree} 作成したインスタンス
 */
Jeeel.DataStructure.Tree.create = function () {
    return new this();
};

Jeeel.DataStructure.Tree.prototype = {
  
    /**
     * ルートノード
     * 
     * @type Jeeel.DataStructure.Tree.Node
     * @private
     */
    _root: null,
    
    /**
     * ルートノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node} ルートノード
     */
    getRoot: function () {
        return this._root;
    },
    
    /**
     * データを追加する
     * 
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.Tree} 自インスタンス
     */
    appendData: function (data) {
        if ( ! this._root) {
            this._root = new this.constructor.Node(data);
            
            return this;
        }
        
        this._root.appendData(data);
        
        return this;
    },
    
    /**
     * ツリーのサイズを取得する
     * 
     * @return {Integer} サイズ
     */
    getSize: function () {
        return this._root.getSize();
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.DataStructure.Tree
};

Jeeel.file.Jeeel.DataStructure.Tree = ['Node', 'Binary'];

Jeeel._autoImports(Jeeel.directory.Jeeel.DataStructure.Tree, Jeeel.file.Jeeel.DataStructure.Tree);
/**
 * コンストラクタ
 * 
 * @class ツリー内のノードを扱うクラス
 * @param {Mixied} data ノードデータ
 * @param {Jeeel.DataStructure.Tree.Node} [parent] 親ノード
 */
Jeeel.DataStructure.Tree.Node = function (data, parent) {
    this._data = data;
    this._children = [];
    this._parent = parent || null;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Mixied} data ノードデータ
 * @param {Jeeel.DataStructure.Tree.Node} [parent] 親ノード
 * @return {Jeeel.DataStructure.Tree.Node} 作成したインスタンス
 */
Jeeel.DataStructure.Tree.Node.create = function (data, parent) {
    return new this(data, parent);
};

Jeeel.DataStructure.Tree.Node.prototype = {
  
    /**
     * 親ノード
     * 
     * @type Jeeel.DataStructure.Tree.Node
     * @private
     */
    _parent: null,
    
    /**
     * 子ノードリスト
     * 
     * @type Jeeel.DataStructure.Tree.Node[]
     * @private
     */
    _children: [],
    
    /**
     * データ
     * 
     * @type Mixied
     * @private
     */
    _data: null,
    
    /**
     * データを取得する
     * 
     * @return {Mixied} データ
     */
    getData: function () {
        return this._data;
    },
    
    /**
     * 親ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node} 親ノード
     */
    getParent: function () {
        return this._parent;
    },
    
    /**
     * 子ノードリストを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node[]} 子ノードリスト
     */
    getChildren: function () {
        return this._children;
    },
    
    /**
     * 最初に追加した子ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node} 最初の子ノード
     */
    getFirstChild: function () {
        return this._children[0] || null;
    },
    
    /**
     * 最後に追加した1子ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Node} 最後の子ノード
     */
    getLastChild: function () {
        return this._children[this._children.length - 1] || null;
    },
    
    /**
     * データを追加する
     * 
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.Tree.Node} 自インスタンス
     */
    appendData: function (data) {
        this._children[this._children.length] = new this.constructor(data, this);
        
        return this;
    },
    
    /**
     * 子ノードの数を取得する
     * 
     * @return {Integer} 子ノードの数
     */
    getDegree: function () {
        return this._children.length;
    },
    
    /**
     * このノードに紐づく全てのデータ数を取得する
     * 
     * @return {Integer} データ数
     */
    getSize: function () {
        var size = 1;
        
        for (var i = this._children.length; i--;) {
            size += this._children[i].getSize();
        }
        
        return size;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Mixied} data ノードデータ
     * @param {Jeeel.DataStructure.Tree.Node} [parent] 親ノード
     * @constructor
     */
    constructor: Jeeel.DataStructure.Tree.Node,
    
    /**
     * ノード内のデータを返す
     * 
     * @return {Mixied} データ
     */
    valueOf: function () {
        return this._data;
    },
    
    /**
     * ノード内のデータを文字列変換して返す
     * 
     * @return {String} データ文字列
     */
    toString: function () {
        return (this._data || '' + this._data).toString();
    }
};Jeeel.directory.Jeeel.DataStructure.Tree.Binary = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.DataStructure.Tree + 'Binary/';
    }
};

/**
 * コンストラクタ
 * 
 * @class 二分木を扱うクラス
 * @augments Jeeel.DataStructure.Tree
 */
Jeeel.DataStructure.Tree.Binary = function () {
    Jeeel.DataStructure.Tree.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.DataStructure.Tree.Binary} 作成したインスタンス
 */
Jeeel.DataStructure.Tree.Binary.create = function () {
    return new this();
};

Jeeel.DataStructure.Tree.Binary.prototype = {
    
    /**
     * データを追加する
     * 
     * @param {Integer} order オーダー
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.Tree.Binary} 自インスタンス
     */
    appendData: function (order, data) {
        if ( ! this._root) {
            this._root = new this.constructor.Node(order, data);
            
            return this;
        }
        
        this._root.appendData(order, data);
        
        return this;
    },
    
    /**
     * オーダーからノードを検索する
     * 
     * @param {Integer} order オーダー
     * @return {Jeeel.DataStructure.Tree.Node} 取得ノード
     */
    search: function (order) {
        return this._root && this._root.search(order);
    },
    
    /**
     * オーダーからデータを検索する
     * 
     * @param {Integer} order オーダー
     * @return {Mixied} 取得データ
     */
    searchData: function (order) {
        return this._root && this._root.searchData(order);
    }
};

Jeeel.Class.extend(Jeeel.DataStructure.Tree.Binary, Jeeel.DataStructure.Tree);

Jeeel.file.Jeeel.DataStructure.Tree.Binary = ['Node', 'Order'];

Jeeel._autoImports(Jeeel.directory.Jeeel.DataStructure.Tree.Binary, Jeeel.file.Jeeel.DataStructure.Tree.Binary);

/**
 * コンストラクタ
 * 
 * @class ツリー内のノードを扱うクラス
 * @param {Integer} order オーダー
 * @param {Mixied} data ノードデータ
 * @param {Jeeel.DataStructure.Tree.Binary.Node} [parent] 親ノード
 */
Jeeel.DataStructure.Tree.Binary.Node = function (order, data, parent) {
    Jeeel.DataStructure.Tree.Node.call(this, data, parent);
    
    this._order = order;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Integer} order オーダー
 * @param {Mixied} data ノードデータ
 * @param {Jeeel.DataStructure.Tree.Binary.Node} [parent] 親ノード
 * @return {Jeeel.DataStructure.Tree.Binary.Node} 作成したインスタンス
 */
Jeeel.DataStructure.Tree.Binary.Node.create = function (order, data, parent) {
    return new this(order, data, parent);
};

Jeeel.DataStructure.Tree.Binary.Node.prototype = {
    
    /**
     * 検索及びデータ追加に使用するオーダー
     * 
     * @type Integer
     * @private
     */
    _order: 0,
    
    /**
     * 右の子ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Binary.Node} 右の子ノード
     */
    getRightChild: function () {
        return this._children[1] || null;
    },
    
    /**
     * 左の子ノードを取得する
     * 
     * @return {Jeeel.DataStructure.Tree.Binary.Node} 左の子ノード
     */
    getLeftChild: function () {
        return this._children[0] || null;
    },
    
    /**
     * データを追加する
     * 
     * @param {Integer} order オーダー
     * @param {Mixied} data 追加データ
     * @return {Jeeel.DataStructure.Tree.Node} 自インスタンス
     */
    appendData: function (order, data) {

        if (order < this._order) {
            if (this._children[0]) {
                this._children[0].appendData(order, data);
            } else {
                this._children[0] = new this.constructor(order, data, this);
            }
        } else {
            if (this._children[1]) {
                this._children[1].appendData(order, data);
            } else {
                this._children[1] = new this.constructor(order, data, this);
            }
        }

        return this;
    },
    
    /**
     * オーダーからノードを検索する
     * 
     * @param {Integer} order オーダー
     * @return {Jeeel.DataStructure.Tree.Node} 取得ノード
     */
    search: function (order) {
        if (this._order === order) {
            return this;
        } else if (this._order < order) {
            return this._children[0] && this._children[0].search(order) || null;
        } else {
            return this._children[1] && this._children[1].search(order) || null;
        }
    },
    
    /**
     * オーダーからデータを検索する
     * 
     * @param {Integer} order オーダー
     * @return {Mixied} 取得データ
     */
    searchData: function (order) {
        var node = this.search(order);
        
        return node && node.getData();
    }
};

Jeeel.Class.extend(Jeeel.DataStructure.Tree.Binary.Node, Jeeel.DataStructure.Tree.Node);

/**
 * 二分木の内部の並び順の列挙体
 */
Jeeel.DataStructure.Tree.Binary.Order = {
    LEFT_LESS: 0
};Jeeel.directory.Jeeel.Object = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Object/';
    }
};

/**
 * @namespace 汎用オブジェクト関連のネームスペース
 */
Jeeel.Object = {

};

Jeeel.file.Jeeel.Object = ['Item', 'Point', 'Size', 'Rect', 'Color', 'Date', 'Font', 'Technical'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Object, Jeeel.file.Jeeel.Object);

/**
 * コンストラクタ
 *
 * @class キーと値のペアを保持するクラス
 * @param {String} key キー
 * @param {Mixied} value 値
 */
Jeeel.Object.Item = function (key, value) {

    /**
     * キー
     *
     * @type String
     */
    this.key = key;

    /**
     * 値
     * 
     * @type Mixied
     */
    this.value = value;
};

Jeeel.Object.Item.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Item} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Item(this.key, this.value);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Item} item 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (item) {
        return this.key === item.key
            && this.value === item.value;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return this.key + '=' + this.value;
    }
};

/**
 * コンストラクタ
 *
 * @class 座標を扱うクラス
 * @param {Integer} x X座標
 * @param {Integer} y Y座標
 */
Jeeel.Object.Point = function (x, y) {

    /**
     * X座標
     *
     * @type Integer
     */
    this.x = x;

    /**
     * Y座標
     *
     * @type Integer
     */
    this.y = y;
};

Jeeel.Object.Point.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Point} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Point(this.x, this.y);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Point} point 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (point) {
        return this.x === point.x
            && this.y === point.y;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return '(' + this.x + ', ' + this.y + ')';
    }
};

/**
 * コンストラクタ
 *
 * @class サイズを扱うクラス
 * @param {Integer} width 幅
 * @param {Integer} height 高さ
 */
Jeeel.Object.Size = function (width, height) {

    /**
     * 幅
     *
     * @type Integer
     */
    this.width = width;

    /**
     * 高さ
     *
     * @type Integer
     */
    this.height = height;
};

Jeeel.Object.Size.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Size} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Size(this.width, this.height);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Size} size 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (size) {
        return this.width === size.width
            && this.height === size.height;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return this.width + ' × ' + this.height;
    }
};

/**
 * コンストラクタ
 *
 * @class 四角形扱うクラス
 * @param {Integer} x 左辺のX座標
 * @param {Integer} y 上辺のY座標
 * @param {Integer} width 幅
 * @param {Integer} height 高さ
 */
Jeeel.Object.Rect = function (x, y, width, height) {};

/**
 * コンストラクタ
 *
 * @class 四角形扱うクラス
 * @param {Jeeel.Object.Point} startPoint 四角形の左上端の座標
 * @param {Jeeel.Object.Point} endPoint 四角形の右下端の座標
 */
Jeeel.Object.Rect = function (startPoint, endPoint) {};

/**
 * コンストラクタ
 *
 * @class 四角形扱うクラス
 * @param {Jeeel.Object.Point} point 四角形の左上端の座標
 * @param {Jeeel.Object.Size} size 四角形の幅と高さ
 */
Jeeel.Object.Rect = function (point, size) {
    
    var rect = [];

    switch (arguments.length) {
        case 2:
            if (arguments[1] instanceof Jeeel.Object.Point) {
                rect[0] = Math.min(arguments[0].x, arguments[1].x);
                rect[1] = Math.min(arguments[0].y, arguments[1].y);
                rect[2] = Math.abs(arguments[1].x - arguments[0].x);
                rect[3] = Math.abs(arguments[1].y - arguments[0].y);
                point = new Jeeel.Object.Point(rect[0], rect[1]);
                size  = new Jeeel.Object.Size(rect[2], rect[3]);
            } else {
                rect[0] = point.x;
                rect[1] = point.y;
                rect[2] = size.width;
                rect[3] = size.height;
                point = new Jeeel.Object.Point(rect[0], rect[1]);
                size  = new Jeeel.Object.Size(rect[2], rect[3]);
            }
            break;

        case 4:
            rect[0] = arguments[0];
            rect[1] = arguments[1];
            rect[2] = arguments[2];
            rect[3] = arguments[3];
            point = new Jeeel.Object.Point(rect[0], rect[1]);
            size  = new Jeeel.Object.Size(rect[2], rect[3]);
            break;

        default:
            throw new Error('引数の数が違います。');
            break;
    }

    /**
     * X座標
     *
     * @type Integer
     */
    this.x = rect[0];

    /**
     * Y座標
     *
     * @type Integer
     */
    this.y = rect[1];

    /**
     * 幅
     *
     * @type Integer
     */
    this.width = rect[2];

    /**
     * 高さ
     *
     * @type Integer
     */
    this.height = rect[3];

    /**
     * 左上端の座標
     *
     * @type Jeeel.Object.Point
     */
    this.point = point;

    /**
     * 四角形の幅と高さ
     *
     * @type Jeeel.Object.Size
     */
    this.size = size;
    
    /**
     * 始点(左上端の座標)
     * 
     * @type Jeeel.Object.Point
     */
    this.startPoint = point;
    
    /**
     * 終点(右下端の座標)
     * 
     * @type Jeeel.Object.Point
     */
    this.endPoint = new Jeeel.Object.Point(this.x + this.width, this.y + this.height);
};

Jeeel.Object.Rect.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Rect} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Rect(this.x, this.y, this.width, this.height);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Rect} rect 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (rect) {
        return this.x === rect.x
            && this.y === rect.y
            && this.width === rect.width
            && this.height === rect.height;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return '(' + this.x + ', ' + this.y + ', ' + this.width + ', ' + this.height + ')';
    }
};


Jeeel.directory.Jeeel.Object.Color = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Object + 'Color/';
    }
};

/**
 * コンストラクタ
 *
 * @class 色を扱うクラス
 * @param {String|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 色を表す値
 */
Jeeel.Object.Color = function (color) {
    var rgb, hsl;
    
    if (color instanceof this.constructor.Rgb) {
        rgb = color;
        hsl = this.constructor.rgbToHsl(rgb);
    } else if (color instanceof this.constructor.Hsl) {
        hsl = color;
        rgb = this.constructor.hslToRgb(hsl);
    } else if (Jeeel.Type.isString(color)) {
        if (color.match(/^hsla?\(/i)) {
            color = new this.constructor.Hsl(color);
        } else {
            color = new this.constructor.Rgb(color);
        }
        
        this.constructor.call(this, color);
        
        return;
    } else {
        throw new Error('color is unknown type.');
    }
    
    this._rgb = rgb;
    this._hsl = hsl;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 色を表す値
 * @return {Jeeel.Object.Color} 作成したインスタンス
 */
Jeeel.Object.Color.create = function (color) {
    return new this(color);
};

/**
 * RGBから色を作成する
 *
 * @param {String} rgbString RGBを示す文字列(先頭に#や0xが付いていても良い)<br />
 *                            1色につき1桁もしくは2桁
 * @return {Jeeel.Object.Color} 作成したインスタンス
 */
Jeeel.Object.Color.createRgbString = function (rgbString) {
    return new this(new this.Rgb(rgbString));
};

/**
 * RGBから色を作成する
 *
 * @param {Integer} red 赤
 * @param {Integer} green 緑
 * @param {Integer} blue 青
 * @param {Number} [alpha] アルファ
 * @return {Jeeel.Object.Color} 作成したインスタンス
 */
Jeeel.Object.Color.createRgb = function (red, green, blue, alpha) {
    if ( ! alpha && alpha !== 0) {
        alpha = 1;
    }
    
    return new this(new this.Rgb(red, green, blue, alpha));
};

/**
 * HSLから色を作成する
 *
 * @param {Integer} hue 色相
 * @param {Number} saturation 彩度
 * @param {Number} luminance 輝度
 * @param {Number} [alpha] アルファ
 * @return {Jeeel.Object.Color} 作成したインスタンス
 */
Jeeel.Object.Color.createHsl = function (hue, saturation, luminance, alpha) {
    if ( ! alpha && alpha !== 0) {
        alpha = 1;
    }
    
    return new this(new this.Hsl(hue, saturation, luminance, alpha));
};

/**
 * RGBからHSLを計算する
 * 
 * @param {Integer} red 赤
 * @param {Integer} green 緑
 * @param {Integer} blue 青
 * @return {Hash} hue: 色相, saturation: 彩度, luminance: 輝度
 */
Jeeel.Object.Color.calculateHsl = function (red, green, blue) {
    var r = Jeeel.Number.limit(Math.round(red, 0, 255)) / 255;
    var g = Jeeel.Number.limit(Math.round(green, 0, 255)) / 255;
    var b = Jeeel.Number.limit(Math.round(blue, 0, 255)) / 255;

    var max, min,
        h, l, s;
    
    max = Math.max(Math.max(r, g), b);
    min = Math.min(Math.min(r, g), b);
    
    l = (max + min) / 2;

    if (max === min) {
        s = 0;
        h = 0;
    } else {
        var sub = max - min;
        
        if (l <= 0.5) {
            s = sub / (max + min);
        } else {
            s = sub / (2 - (max + min));
        }

        var cr = (max - r) / sub;
        var cg = (max - g) / sub;
        var cb = (max - b) / sub;

        switch (max) {
            case r:
                h = cb - cg;
                break;

            case g:
                h = 2 + cr - cb;
                break;

            case b:
                h = 4 + cg - cr;
                break;
                
            default:
                break;
        }

        h = 60 * h;

        if (h < 0) {
            h += 360;
        }
    }
    
    return {hue: h, saturation: s, luminance: l};
};

/**
 * RGBインスタンスをHSLインスタンスに変換する
 * 
 * @param {Jeeel.Object.Color.Rgb} rgb RGBインスタンス
 * @return {Jeeel.Object.Color.Hsl} 変換後のインスタンス
 */
Jeeel.Object.Color.rgbToHsl = function (rgb) {
    var hsl = this.calculateHsl(rgb.red, rgb.green, rgb.blue);

    return new Jeeel.Object.Color.Hsl(hsl.hue, hsl.saturation, hsl.luminance);
};

/**
 * HSLからRGBを計算する
 * 
 * @param {Integer} hue 色相
 * @param {Number} saturation 彩度
 * @param {Number} luminance 輝度
 * @return {Hash} red: 赤, green: 緑, blue: 青
 */
Jeeel.Object.Color.calculateRgb = function (hue, saturation, luminance) {
    var h = Jeeel.Number.limit(hue, 0, 360);
    var s = Jeeel.Number.limit(saturation, 0, 1);
    var l = Jeeel.Number.limit(luminance, 0, 1);
    
    var max, min;
    var list = [];

    if (l <= 0.5) {
        max = l * (1 + s);
    } else {
        max = l * (1 - s) + s;
    }

    min = 2 * l - max;

    if (s === 0) {
        list[0] = list[1] = list[2] = l;
    } else {
        var hVal = h + 120;
        var sub = max - min;
        
        if (hVal >= 360) {
            hVal = hVal - 360;
        }

        for (var i = 0; i < 3; i++) {

            if (hVal < 60) {
                list[i] = min + sub * hVal / 60;
            } else if (hVal < 180) {
                list[i] = max;
            } else if (hVal < 240) {
                list[i] = min + sub * (240 - hVal) / 60;
            } else {
                list[i] = min;
            }

            if (i === 0) {
                hVal = h;
            } else if (i === 1) {
                hVal = h - 120;

                if (hVal < 0) {
                    hVal = hVal + 360;
                }
            }
        }
    }

    return {red: list[0] * 255, green: list[1] * 255, blue: list[2] * 255};
};

/**
 * HSLインスタンスをRGBインスタンスに変換する
 * 
 * @param {Jeeel.Object.Color.Hsl} hsl HSLインスタンス
 * @return {Jeeel.Object.Color.Rgb} 変換後のインスタンス
 */
Jeeel.Object.Color.hslToRgb = function (hsl) {
    var rgb = this.calculateRgb(hsl.hue, hsl.saturation, hsl.luminance);

    return new Jeeel.Object.Color.Rgb(rgb.red, rgb.green, rgb.blue);
};

Jeeel.Object.Color.prototype = {
  
    /**
     * RGB形式の色を扱うオブジェクト
     * 
     * @type Jeeel.Object.Color.Rgb
     * @private
     */
    _rgb: null,
    
    /**
     * HSL形式の色を扱うオブジェクト
     * 
     * @type Jeeel.Object.Color.Hsl
     * @private
     */
    _hsl: null,
    
    /**
     * RGBインスタンスに変換する
     * 
     * @return {Jeeel.Object.Color.Rgb} RGBインスタンス
     */
    toRgb: function () {
        return this._rgb;
    },
    
    /**
     * HSLインスタンスに変換する
     * 
     * @return {Jeeel.Object.Color.Hsl} RGBインスタンス
     */
    toHsl: function () {
        return this._hsl;
    },
    
    /**
     * アルファブレンドを行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color ブレンドする色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    alphaBlend: function (color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }

        var destColor   = this._rgb;
        var sourceColor = color.toRgb();

        var res;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);

        if (alpha === 0) {
            res = new this.constructor(destColor.clone());
        }
        else if (alpha === 0xFF || dstA === 0) {
            res = new this.constructor(sourceColor.clone());
        }
        else if (dstA === 0xFF) {
            res = this.constructor.createRgb(
                ((sourceColor.red - dstR) * alpha >> 8) + dstR, 
                ((sourceColor.green - dstG) * alpha >> 8) + dstG, 
                ((sourceColor.blue - dstB) * alpha >> 8) + dstB, 
                1
            );
        }
        else {
            dstA = ((0xFF - alpha) * dstA >> 8) & 0xFF;

            res = (alpha + dstA) & 0xFF;

            res = this.constructor.createRgb(
                (sourceColor.red   * alpha + dstR * dstA) / res, 
                (sourceColor.green * alpha + dstG * dstA) / res, 
                (sourceColor.blue  * alpha + dstB * dstA) / res, 
                res / 0xFF
            );
        }
        
        alpha = parseInt(res._rgb.alpha * 0xFF);

        if (alpha === 0) {
            res = this.constructor.createRgb(0, 0, 0, 0);
        }
        else if (alpha !== 0xFF) {
            res = this.constructor.createRgb(
                res._rgb.red * alpha >> 8, 
                res._rgb.green * alpha >> 8, 
                res._rgb.blue * alpha >> 8, 
                alpha / 0xFF
            );
        }

        return res;
    },
    
    /**
     * 加算合成を行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 加算する色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    addBlend: function (color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }
        
        var destColor   = this._rgb;
        var sourceColor = color.toRgb();
        
        var res;
        var srcR = sourceColor.red;
        var srcG = sourceColor.green;
        var srcB = sourceColor.blue;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        var tmp;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);
        
        if (alpha === 0) {
            res = destColor.clone();
        }
        else if (alpha === 0xFF && dstA === 0xFF) {
            res = this.constructor.createRgb(
                ((tmp = srcR + dstR) > 0xFF ? 0xFF : tmp), 
                ((tmp = srcG + dstG) > 0xFF ? 0xFF : tmp), 
                ((tmp = srcB + dstB) > 0xFF ? 0xFF : tmp), 
                1
            );
        }
        else {
            res = this.constructor.createRgb(
                (((tmp = (srcR * alpha + dstR * dstA) >> 8)) > 0xFF ? 0xFF : tmp), 
                (((tmp = (srcG * alpha + dstG * dstA) >> 8)) > 0xFF ? 0xFF : tmp), 
                (((tmp = (srcB * alpha + dstB * dstA) >> 8)) > 0xFF ? 0xFF : tmp), 
                dstA / 0xFF
            );
        }

        return res;
    },
    
    /**
     * 減算合成を行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 減算する色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    subBlend: function(color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }
        
        var destColor   = this._rgb;
        var sourceColor = color.toRgb();
        
        var res;
        var srcR = sourceColor.red;
        var srcG = sourceColor.green;
        var srcB = sourceColor.blue;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        var tmp;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);

        if (alpha === 0) {
            res = destColor.clone();
        }
        else if (alpha === 0xFF && dstA === 0xFF) {
            res = this.constructor.createRgb(
                ((tmp = dstR - srcR) < 0 ? 0 : tmp),
                ((tmp = dstG - srcG) < 0 ? 0 : tmp),
                ((tmp = dstB - srcB) < 0 ? 0 : tmp),
                1
            );
        }
        else {
            res = this.constructor.createRgb(
                ((tmp = (dstR * dstA - srcR * alpha) >> 8) < 0 ? 0 : tmp),
                ((tmp = (dstG * dstA - srcG * alpha) >> 8) < 0 ? 0 : tmp),
                ((tmp = (dstB * dstA - srcB * alpha) >> 8) < 0 ? 0 : tmp),
                dstA / 0xFF
            );
        }

        return res;
    },
    
    /**
     * 乗算合成を行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 乗算する色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    mulBlend: function (color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }
        
        var destColor   = this._rgb;
        var sourceColor = color.toRgb();
        
        var res;
        var srcR = sourceColor.red;
        var srcG = sourceColor.green;
        var srcB = sourceColor.blue;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);

        if (alpha === 0) {
            res = destColor.clone();
        }
        else if (alpha === 0xFF && dstA === 0xFF) {
            res = this.constructor.createRgb(
                (srcR * dstR >> 8),
                (srcG * dstG >> 8),
                (srcB * dstB >> 8),
                1
            );
        }
        else {
            res = this.constructor.createRgb(
                ((dstR * dstA >> 8) * (0xFF + ((srcR - 0xFF) * alpha >> 8)) >> 8),
                ((dstG * dstA >> 8) * (0xFF + ((srcG - 0xFF) * alpha >> 8)) >> 8),
                ((dstB * dstA >> 8) * (0xFF + ((srcB - 0xFF) * alpha >> 8)) >> 8),
                dstA / 0xFF
            );
        }

        return res;
    },
    
    /**
     * 除算合成を行い新しいインスタンスを返す
     * 
     * @param {Jeeel.Object.Color|Jeeel.Object.Color.Rgb|Jeeel.Object.Color.Hsl} color 除算する色
     * @param {Number} [alpha] ブレンドする側アルファ値(省略時はブレンド色のアルファ値を参照する)
     * @return {Jeeel.Object.Color} ブレンド後のインスタンス
     */
    divBlend: function (color, alpha) {
        if (color instanceof this.constructor.Rgb) {
            color = new this.constructor(color);
        } else if (color instanceof this.constructor.Hsl) {
            color = new this.constructor(color);
        } else if ( ! (color instanceof this.constructor)) {
            throw new Error('colorが不明な型です。');
        }
        
        var destColor   = this._rgb;
        var sourceColor = color.toRgb();
        
        var res;
        var srcR = sourceColor.red;
        var srcG = sourceColor.green;
        var srcB = sourceColor.blue;
        var dstA = parseInt(destColor.alpha * 0xFF);
        var dstR = destColor.red;
        var dstG = destColor.green;
        var dstB = destColor.blue;
        
        if ( ! alpha && alpha !== 0) {
            alpha = sourceColor.alpha;
        }
        
        alpha = parseInt(alpha * 0xFF);

        if (alpha === 0) {
            res = destColor.clone();
        }
        else if (alpha === 0xFF && dstA === 0xFF) {
            res = this.constructor.createRgb(
                ((dstR << 8) / (srcR + 1)),
                ((dstG << 8) / (srcG + 1)),
                ((dstB << 8) / (srcB + 1)),
                1
            );
        }
        else {
            res = this.constructor.createRgb(
                ((dstR * dstA) / ((0xFF + ((srcR - 0xFF) * alpha >> 8)) + 1)),
                ((dstG * dstA) / ((0xFF + ((srcG - 0xFF) * alpha >> 8)) + 1)),
                ((dstB * dstA) / ((0xFF + ((srcB - 0xFF) * alpha >> 8)) + 1)),
                dstA / 0xFF
            );
        }

        return res;
    },
    
    /**
     * コンストラクタ
     *
     * @param {Mixied} color 色を表す値
     * @constructor
     */
    constructor: Jeeel.Object.Color
};

Jeeel.file.Jeeel.Object.Color = ['Rgb', 'Hsl', 'Code'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Object.Color, Jeeel.file.Jeeel.Object.Color);

/**
 * コンストラクタ
 *
 * @class RGB形式の色を扱うクラス
 * @param {String} rgbString RGBを示す文字列(先頭に#や0xが付いていても良い)<br />
 *                            1色につき1桁もしくは2桁
 */
Jeeel.Object.Color.Rgb = function (rgbString) {};

/**
 * コンストラクタ
 *
 * @class RGB形式の色を扱うクラス
 * @param {Integer} red 赤
 * @param {Integer} green 緑
 * @param {Integer} blue 青
 */
Jeeel.Object.Color.Rgb = function (red, green, blue) {};

/**
 * コンストラクタ
 *
 * @class RGB形式の色を扱うクラス
 * @param {Integer} red 赤
 * @param {Integer} green 緑
 * @param {Integer} blue 青
 * @param {Number} alpha アルファ
 */
Jeeel.Object.Color.Rgb = function (red, green, blue, alpha) {
  
    switch (arguments.length) {
        case 1:
            var rgbString = ('' + arguments[0]).toUpperCase();

            if (Jeeel.Object.Color.Code[rgbString]) {
                rgbString = Jeeel.Object.Color.Code[rgbString];
            }
            
            rgbString = rgbString.replace(/^(#|0x)/i, '');
            
            if (rgbString.match(/^rgba?\(/i)) {
                rgbString = rgbString.replace(/^rgba?\(/i, '').replace(')', '').replace(/ /g, '');
                
                var rgb = rgbString.split(',');
                
                red   = +rgb[0];
                green = +rgb[1];
                blue  = +rgb[2];
                alpha = rgb[3] ? +rgb[3] : 1;
            } else {
                if (rgbString.length !== 3 && rgbString.length !== 6) {
                    throw new Error('rgb文字列の長さが不自然です。');
                } else if ( ! Jeeel.Type.isHexadecimalNumber(rgbString)) {
                    throw new Error('rgb文字列の形式が正しくありません。');
                }

                if (rgbString.length === 3) {
                    red   = ('0x' + rgbString.charAt(0)) * 17;
                    green = ('0x' + rgbString.charAt(1)) * 17;
                    blue  = ('0x' + rgbString.charAt(2)) * 17;
                } else {
                    red   = +('0x' + rgbString.substr(0, 2));
                    green = +('0x' + rgbString.substr(2, 2));
                    blue  = +('0x' + rgbString.substr(4, 2));
                }
                
                alpha = 1;
            }
            break;

        case 3:
            red   = +red;
            green = +green;
            blue  = +blue;
            alpha = 1;
            break;
            
        case 4:
            red   = +red;
            green = +green;
            blue  = +blue;
            alpha = +alpha;
            break;

        default:
            throw new Error('引数の数が違います。');
            break;
    }

    /**
     * 赤
     *
     * @type Integer
     */
    this.red = Jeeel.Number.limit(Math.round(red), 0, 255);

    /**
     * 緑
     *
     * @type Integer
     */
    this.green = Jeeel.Number.limit(Math.round(green), 0, 255);
    
    /**
     * 青
     *
     * @type Integer
     */
    this.blue = Jeeel.Number.limit(Math.round(blue), 0, 255);
    
    /**
     * アルファ
     *
     * @type Number
     */
    this.alpha = Jeeel.Number.limit(alpha, 0, 1);
};

Jeeel.Object.Color.Rgb.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Color.Rgb} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Color.Rgb(this.red, this.green, this.blue);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Color.Rgb} item 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (item) {
        return this.red === item.red
            && this.green === item.green
            && this.blue === item.blue;
    },
    
    /**
     * RGBの並びでビット演算したRGB数値を返す
     * 
     * @return {Integer} RGB数値
     */
    valueOf: function () {
        return this.red << 16
             | this.green << 8
             | this.blue;
    },
    
    /**
     * RGB文字列に変換する
     * 
     * @param {String} [prefix] 接頭辞
     * @return {String} 小文字の16進数を接続した6桁+接頭辞の文字列
     */
    toRgbString: function (prefix) {
        var i, rgb =[this.red.toString(16), this.green.toString(16), this.blue.toString(16)];
        
        for (i = 3; i--;) {
            if (rgb[i].length < 2) {
                rgb[i] = '0' + rgb[i];
            }
        }
        
        return (prefix || '') + rgb.join('');
    },
    
    /**
     * RGBA文字列に変換する
     * 
     * @return {String} RGBA形式に変換した文字列
     */
    toRgbaString: function () {
        return 'rgba('
             + this.red
             + ', '
             + this.green
             + ', '
             + this.blue
             + ', '
             + this.alpha
             + ')';
    },

    /**
     * 文字列に変換する
     *
     * @param {Boolean} [toFunction] 関数表記に変換する時に指定
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function (toFunction) {
        if (toFunction) {
            return 'rgb('
                 + this.red
                 + ', '
                 + this.green
                 + ', '
                 + this.blue
                 + ')';
        }

        return this.toRgbString('#');
    }
};

/**
 * コンストラクタ
 *
 * @class HSL形式の色を扱うクラス
 * @param {String} hslString HSLを示す文字列(先頭に#や0xが付いていても良い)<br />
 *                            1色につき1桁もしくは2桁
 */
Jeeel.Object.Color.Hsl = function (hslString) {};

/**
 * コンストラクタ
 *
 * @class HSL形式の色を扱うクラス
 * @param {Integer} hue 色相
 * @param {Number} saturation 彩度
 * @param {Number} luminance 輝度
 */
Jeeel.Object.Color.Hsl = function (hue, saturation, luminance) {};

/**
 * コンストラクタ
 *
 * @class HSL形式の色を扱うクラス
 * @param {Integer} hue 色相
 * @param {Number} saturation 彩度
 * @param {Number} luminance 輝度
 * @param {Number} alpha アルファ
 */
Jeeel.Object.Color.Hsl = function (hue, saturation, luminance, alpha) {
  
    switch (arguments.length) {
        case 1:
            var hslString = '' + arguments[0];
            
            if (hslString.match(/^hsla?\(/i)) {
                hslString = hslString.replace(/^hsla?\(/i, '').replace(')', '').replace(/ /g, '');
                
                var hsl = hslString.split(',');
                
                hue        = +hsl[0];
                saturation = parseInt(hsl[1]) / 100;
                luminance  = parseInt(hsl[2]) / 100;
                alpha      = hsl[3] ? +hsl[3] : 1;
            } else {
                throw new Error('hsl文字列の形式が不自然です。');
            }
            break;
            
        case 3:
            hue        = +hue;
            saturation = +saturation;
            luminance  = +luminance;
            alpha      = 1;
            break;
            
        case 4:
            hue        = +hue;
            saturation = +saturation;
            luminance  = +luminance;
            alpha      = +alpha;
            break;

        default:
            throw new Error('引数の数が違います。');
            break;
    }
    
    /**
     * 色相(0～360)
     *
     * @type Integer
     */
    this.hue = Math.round(hue > 360 && (hue % 360) || hue);

    /**
     * 彩度(0.0～1.0)
     *
     * @type Number
     */
    this.saturation = Jeeel.Number.limit(saturation, 0, 1);
    
    /**
     * 輝度(0.0～1.0)
     *
     * @type Number
     */
    this.luminance = Jeeel.Number.limit(luminance, 0, 1);
    
    /**
     * アルファ(0.0～1.0)
     *
     * @type Number
     */
    this.alpha = Jeeel.Number.limit(alpha, 0, 1);
};

Jeeel.Object.Color.Hsl.prototype = {

    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Color.Hsl} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Color.Hsl(this.hue, this.saturation, this.luminance);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Color.Hsl} item 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (item) {
        return this.hue === item.hue
            && this.saturation === item.saturation
            && this.luminance === item.luminance;
    },

    /**
     * 文字列に変換する
     *
     * @param {Boolean} [toHSLA] アルファ値を加えた値に変換する時に指定
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function (toHSLA) {
        var s = Math.round(this.saturation * 100);
        var l = Math.round(this.luminance * 100);
        
        if (toHSLA) {
            return 'hsla('
                 + this.hue
                 + ', '
                 + s + '%'
                 + ', '
                 + l + '%'
                 + ', '
                 + this.alpha
                 + ')';
        }
        
        return 'hsl('
             + this.hue
             + ', '
             + s + '%'
             + ', '
             + l + '%'
             + ')';
    }
};

/**
 * @namespace カラーコードの列挙体
 */
Jeeel.Object.Color.Code = {
  
    /**
     * 赤
     * 
     * @type String
     * @constant
     */
    RED: '#FF0000',
    
    /**
     * 緑
     * 
     * @type String
     * @constant
     */
    GREEN: '#008000',
    
    /**
     * ライム
     * 
     * @type String
     * @constant
     */
    LIME: '#00FF00',
    
    /**
     * 青
     * 
     * @type String
     * @constant
     */
    BLUE: '#0000FF',
    
    /**
     * シアン
     * 
     * @type String
     * @constant
     */
    CYAN: '#00FFFF',
    
    /**
     * アジュール
     * 
     * @type String
     * @constant
     */
    AZURE: '#F0FFFF',
    
    /**
     * マゼンタ
     * 
     * @type String
     * @constant
     */
    MAGENTA: '#FF00FF',
    
    /**
     * イエロー
     * 
     * @type String
     * @constant
     */
    YELLOW: '#FFFF00',
    
    /**
     * 紫
     * 
     * @type String
     * @constant
     */
    VIOLET: '#EE82EE',
    
    /**
     * ブルーバイオレット
     * 
     * @type String
     * @constant
     */
    BLUEVIOLET: '#8A2BE2',
    
    /**
     * 茶
     * 
     * @type String
     * @constant
     */
    BROWN: '#A52A2A',
    
    /**
     * 白
     * 
     * @type String
     * @constant
     */
    WHITE: '#FFFFFF',
    
    /**
     * 灰
     * 
     * @type String
     * @constant
     */
    GRAY: '#808080',
    
    /**
     * 黒
     * 
     * @type String
     * @constant
     */
    BLACK: '#000000',
    
    /**
     * 透明
     * 
     * @type String
     * @constant
     */
    TRANSPARENT: 'rgba(0, 0, 0, 0)'
};

/**
 * コンストラクタ
 *
 * @class 日付関係に関する操作を手助けするクラス
 * @param {Date|String|Integer|Jeeel.Object.Date} [date] 基となるDateオブジェクトやDateString(省略は現時刻)
 * @param {Integer} [offset] 指定した日付を示すタイムゾーンのオフセット(日本なら+540)
 */
Jeeel.Object.Date = function (date, offset) {
    
    var dateOffset;
    
    if (Jeeel.Type.isString(date)) {
        date = new Date(date.replace(/-/g, '/'));
        
        if (offset || offset === 0) {
            dateOffset = (offset + date.getTimezoneOffset()) * 60000;
            date = new Date(date.getTime() + dateOffset);
        }
    } else if (Jeeel.Type.isInteger(date)) {
        date = new Date(date);
    } else if (date instanceof Jeeel.Object.Date) {
        date = new Date(date.getTime());
    }

    if ( ! Jeeel.Type.isDate(date)) {
        date = new Date();
    }

    this._date = date;
    
    // ローカルを基準とした表示なのでグリニッジを標準とする
    this._offset = (offset || offset === 0 ? offset : -date.getTimezoneOffset());
    
    this._refreshProperty();
    
    this._timestamp = new Date();
    
    if ( ! Jeeel.Object.Date._lock && ! Jeeel.Language.hasLanguage('Object.Date')) {
        Jeeel.Object.Date._lock = true;
        
        Jeeel.Language.loadLanguage('Object.Date', function () {
            Jeeel.Object.Date._lock = false;
        });
    }
};

/**
 * インスタンスの作成を行う
 *
 * @param {Date|String|Integer|Jeeel.Object.Date} [date] 基となるDateオブジェクトやDateString(省略は現時刻)
 * @param {Integer} [offset] 指定した日付を示すタイムゾーンのオフセット(日本なら+540)
 * @return {Jeeel.Object.Date} 作成したインスタンス
 */
Jeeel.Object.Date.create = function (date, offset) {
    return new this(date, offset);
};

/**
 * 指定した日付からインスタンスの作成を行う(全省略は現時刻)
 *
 * @param {Integer} [year] 年
 * @param {Integer} [month] 月
 * @param {Integer} [day] 日
 * @param {Integer} [hour] 時
 * @param {Integer} [minute] 分
 * @param {Integer} [second] 秒
 * @param {Integer} [millisecond] ミリ秒
 * @param {Integer} [offset] 指定した日付を示すタイムゾーンのオフセット(日本なら+540)
 * @return {Jeeel.Object.Date} 作成したインスタンス
 */
Jeeel.Object.Date.createDate = function (year, month, day, hour, minute, second, millisecond, offset) {
    var i, l = arguments.length;
    
    for (i = 0; i < l; i++) {
        if (Jeeel.Type.isEmpty(arguments[i])) {
            arguments[i] = null;
        }
    }

    if (Jeeel.Type.isSet(month)) {
        arguments[1]--;
    } else if (Jeeel.Type.isSet(year)) {
        arguments[1] = 0;
        l++;
    }
    
    return new this(Jeeel.Function.toNative(Jeeel._global, 'Date', true).apply(null, arguments).toGMTString(), offset);
};

/**
 * 指定した日付が存在するかどうかチェックする
 *
 * @param {Digit} year 年
 * @param {Digit} [month] 月
 * @param {Digit} [day] 日
 * @param {Digit} [hour] 時
 * @param {Digit} [minute] 分
 * @param {Digit} [second] 秒
 * @param {Digit} [millisecond] ミリ秒
 * @return {Boolean} 日付が存在するかどうか
 */
Jeeel.Object.Date.checkDate = function (year, month, day, hour, minute, second, millisecond) {
    var date = this.createDate.apply(this, arguments);

    return date.year === +year
        && date.month === (+month || 1)
        && date.date === (+day || 1)
        && date.hour === (+hour || 0)
        && date.minute === (+minute || 0)
        && date.second === (+second || 0)
        && date.millisecond === (+millisecond || 0);
};

if (Jeeel._global && Jeeel._global.Date && Jeeel._global.Date.now) {
  
    /**
     * 1970年1月1日0時0分0秒(UTC)からの経過ミリ秒を取得する(オフセットを考慮)
     * 
     * @return {Integer} 経過ミリ秒
     */
    Jeeel.Object.Date.now = function () {
        return Date.now();
    };
} else {
  
    /**
     * @ignore
     */
    Jeeel.Object.Date.now = function () {
        return (new Date()).getTime();
    };
}

/**
 * 指定した日付文字列を1970年1月1日0時0分0秒(UTC)からの経過ミリ秒に変換する
 * 
 * @param {String} dateString 日付文字列
 * @return {Integer} 経過ミリ秒
 */
Jeeel.Object.Date.parse = function (dateString) {
    return Date.parse((dateString || '').replace(/-/g, '/'));
};

/**
 * ミリ秒を日に換算し変換する
 * 
 * @param {Integer} time ミリ秒
 * @return {Number} 日
 */
Jeeel.Object.Date.timeToDate = function (time) {
    return time / 86400000;
};

/**
 * ミリ秒を時に換算し変換する
 * 
 * @param {Integer} time ミリ秒
 * @return {Number} 時
 */
Jeeel.Object.Date.timeToHour = function (time) {
    return time / 3600000;
};

/**
 * ミリ秒を分に換算し変換する
 * 
 * @param {Integer} time ミリ秒
 * @return {Number} 分
 */
Jeeel.Object.Date.timeToMinute = function (time) {
    return time / 60000;
};

/**
 * ミリ秒を秒に換算し変換する
 * 
 * @param {Integer} time ミリ秒
 * @return {Number} 分
 */
Jeeel.Object.Date.timeToSecond = function (time) {
    return time / 1000;
};

/**
 * 曜日のリストを取得する
 * 
 * @return {String[]} 曜日のリスト
 */
Jeeel.Object.Date.getDays = function () {
    var lang = Jeeel.Language.getLanguage('Object.Date');
    
    var res = [];
    
    for (var i = 7; i--;) {
        res[i] = lang['d' + i]['short'];
    }
    
    return res;
};

Jeeel.Object.Date.prototype = {

    /**
     * 基となるDateオブジェクト
     *
     * @type Date
     */
    _date: null,
    
    /**
     * タイムゾーンによるオフセット
     * 
     * 
     * @type Integer
     */
    _offset: null,

    /**
     * このインスタンスを作成した日付
     *
     * @type Date
     */
    _timestamp: null,
    
    /**
     * 年
     * 
     * @type Integer
     */
    year: 0,
    
    /**
     * 月(1～12)
     * 
     * @type Integer
     */
    month: 0,
    
    /**
     * 日
     * 
     * @type Integer
     */
    date: 0,
    
    /**
     * 時
     * 
     * @type Integer
     */
    hour: 0,
    
    /**
     * 分
     * 
     * @type Integer
     */
    minute: 0,
    
    /**
     * 秒
     * 
     * @type Integer
     */
    second: 0,
    
    /**
     * ミリ秒
     * 
     * @type Integer
     */
    millisecond: 0,
    
    /**
     * 曜日
     * 
     * @type Integer
     */
    day: 0,
    
    /**
     * 1970年1月1日0時0分0秒(UTC)からの経過ミリ秒
     * 
     * @type Integer
     */
    time: 0,
    
    /**
     * Dateオブジェクトを取得する
     * 
     * @return {Date} 取得したDateオブジェクト
     */
    getDateObject: function () {
        return this._date;
    },
    
    /**
     * 年を取得する
     * 
     * @return {Integer} 年
     */
    getYear: function () {
        return this.year;
    },
    
    /**
     * 月を取得する
     * 
     * @return {Integer} 月(1～12)
     */
    getMonth: function () {
        return this.month;
    },
    
    /**
     * 日を取得する
     * 
     * @return {Integer} 日
     */
    getDate: function () {
        return this.date;
    },
    
    /**
     * 時を取得する
     * 
     * @return {Integer} 時
     */
    getHour: function () {
        return this.hour;
    },
    
    /**
     * 分を取得する
     * 
     * @return {Integer} 分
     */
    getMinute: function () {
        return this.minute;
    },
    
    /**
     * 秒を取得する
     * 
     * @return {Integer} 秒
     */
    getSecond: function () {
        return this.second;
    },
    
    /**
     * ミリ秒を取得する
     * 
     * @return {Integer} ミリ秒
     */
    getMillisecond: function () {
        return this.millisecond;
    },
    
    /**
     * 1970年1月1日0時0分0秒(UTC)からの経過ミリ秒を取得する(オフセットを考慮)
     * 
     * @return {Integer} 経過ミリ秒
     */
    getTime: function () {
        return this.time;
    },
    
    /**
     * 1970年1月1日0時0分0秒(UTC)からの経過ミリ秒を取得する(オフセットを無視)
     * 
     * @return {Integer} 経過ミリ秒
     */
    getUtcTime: function () {
        return Date.UTC(this.year, this.month - 1, this.date, this.hour, this.minute, this.second, this.millisecond);
    },
    
    /**
     * 曜日を示す数を取得する
     * 
     * @return {Integer} 曜日を示す数(0～6)
     */
    getDay: function () {
        return this.day;
    },
    
    /**
     * 曜日名を取得する
     *
     * @return {String} 曜日の短縮名(Sun,Mon,日,月,...等)
     */
    getDayName: function () {
        var lang = Jeeel.Language.getLanguage('Object.Date');
        
        return lang['d' + this.day]['short'];
    },
    
    /**
     * このインスタンスのタイムゾーンオフセットを返す
     * 
     * @return {Integer} タイムゾーンオフセット(分数で、GMTからの差分: 日本なら+540)
     */
    getOffset: function () {
        return this._offset;
    },
    
    /**
     * このインスタンスのタイムゾーンオフセットを設定する<br />
     * 変更した際に自動的にプロパティの値がそのタイムゾーンでの値に書き換わる
     * 
     * @param {Integer} offset タイムゾーンオフセット
     * @return {Jeeel.Object.Date} 自インスタンス
     */
    setOffset: function (offset) {
        offset = +offset;
        
        if (offset) {
            var tmp = this._offset;
            this._offset = offset;
            
            this._refreshProperty(tmp);
        }
        
        return this;
    },

    /**
     * 作成時からの経過時間を返す
     *
     * @return {Integer} 作成時からの経過時間(ミリ秒)
     */
    getElapsedTime: function () {
        var now  = new Date();
        return now.getTime() - this._timestamp.getTime();
    },
    
    /**
     * 作成時からの経過時間を設定する
     *
     * @param {Integer} time 作成時からの経過時間(ミリ秒)
     * @return {Jeeel.Object.Date} 自インスタンス
     */
    setElapsedTime: function (time) {
        var now  = new Date();

        this._timestamp.setTime(now.getTime() - time);
        
        return this;
    },

    /**
     * 作成時からの経過時間を加味して新しくインスタンスを作成する
     *
     * @return {Jeeel.Object.Date} 新しく作成したインスタンス
     */
    getInstanceAddElapsedTime: function () {
        var time = this.getElapsedTime();

        return Jeeel.Object.Date.create(this.time + time);
    },
    
    /**
     * この週の日のリストを取得する<br />
     * 週は日曜から土曜となるように返す<br />
     * なお週なので前の月や次の月の日付が紛れる事がある
     * 
     * @return {Integer[]} 日リスト
     */
    getDatesOfWeek: function () {
        var date = new Date(this.year, this.month - 1, this.date - this.day);
        var res  = [];

        do {
            res[res.length] = date.getDate();

            date.setDate(date.getDate() + 1);
        } while(date.getDay() !== 0);

        return res;
    },

    /**
     * この月の日のリストを取得する
     *
     * @return {Integer[]} 日リスト
     */
    getDatesOfMonth: function () {
        var month = this.month - 1;
        var date  = new Date(this.year, month, 1);
        var res   = [];

        while(date.getMonth() === month) {
            res[res.length] = date.getDate();

            date.setDate(date.getDate() + 1);
        }

        return res;
    },

    /**
     * Unix関連で良く使用されるUnixTimeを取得する
     *
     * @return {Integer} UnixTime(秒)
     */
    getUnixTime: function () {
        return Math.floor(this.time / 1000);
    },
    
    /**
     * 日付を加算する
     * 
     * @param {Integer} [year] 年
     * @param {Integer} [month] 月
     * @param {Integer} [day] 日
     * @param {Integer} [hour] 時
     * @param {Integer} [minute] 分
     * @param {Integer} [second] 秒
     * @param {Integer} [millisecond] ミリ秒
     * @return {Jeeel.Object.Date} 自インスタンス
     */
    add: function (year, month, day, hour, minute, second, millisecond) {
        var list = ['FullYear', 'Month', 'Date', 'Hours', 'Minutes', 'Seconds', 'Milliseconds'];
        
        for (var i = 0, l = Math.min(arguments.length, list.length); i < l; i++) {
            var setter = 'set' + list[i];
            var getter = 'get' + list[i];
            
            this._date[setter](this._date[getter]() + (+arguments[i]));
        }
        
        return this._refreshProperty();
    },
    
    /**
     * 日付を減算する
     * 
     * @param {Integer} [year] 年
     * @param {Integer} [month] 月
     * @param {Integer} [day] 日
     * @param {Integer} [hour] 時
     * @param {Integer} [minute] 分
     * @param {Integer} [second] 秒
     * @param {Integer} [millisecond] ミリ秒
     * @return {Jeeel.Object.Date} 自インスタンス
     */
    sub: function (year, month, day, hour, minute, second, millisecond) {
        var list = ['FullYear', 'Month', 'Date', 'Hours', 'Minutes', 'Seconds', 'Milliseconds'];
        
        for (var i = 0, l = Math.min(arguments.length, list.length); i < l; i++) {
            var setter = 'set' + list[i];
            var getter = 'get' + list[i];
            
            this._date[setter](this._date[getter]() - (+arguments[i]));
        }
        
        return this._refreshProperty();
    },
    
    /**
     * この日付から指定した日付に時間経過した場合に発生するイベントの追加を行う<br />
     * この日付より後の実行日付でなければ登録は無効化される
     * 
     * @param {Function} listener 登録メソッド(引数には自インスタンス、実行日付インスタンス、任意の引数)
     * @param {Jeeel.Object.Date} date 実行日付を示すオブジェクト
     * @param {Mixied} var_args 登録メソッドに引き渡す引数
     * @return {Jeeel.Object.Date} 自インスタンス
     * @example 
     * var date1 = Jeeel.Object.Date.createDate(2010, 5, 6, 22, 10);
     * var date2 = Jeeel.Object.Date.createDate(2010, 5, 7, 22, 10);
     * 
     * date1.addTimeoutEvent(
     *     function (baseDate, execDate, name) {
     *         alert(name + 'さん ' + baseDate.toString('Y-m-d H:i:s') + 'から、' + execDate.toString('Y-m-d H:i:s') + 'へ時間経過しました。');
     *     }, 
     *     date2,
     *     'Ken'
     * );
     * 
     * // date1が作成されてから丸一日経った時間にイベントが実行される
     * // Kenさん 2011-05-06 22:10:00から、2011-05-07 22:10:00に時間経過しました。
     */
    addTriggerDateEvent: function (listener, date, var_args) {
        if ( ! (date instanceof Jeeel.Object.Date) || this >= date) {
            return this;
        }
        
        var _listener = function () {
            listener.apply(null, arguments);
        };
        
        var args = Array.prototype.slice.call(arguments, 2, arguments.length);
        
        args.unshift(
            _listener,
            date - (this + this.getElapsedTime()),
            this,
            date
        );
        
        if (args[1] <= 0) {
            args[1] = 1;
        }
        
        Jeeel.Timer.setTimeout.apply(null, args);
        
        return this;
    },

    /**
     * SQL等でよく使用されるDate形式の文字列に変換する
     *
     * @return {String} Date形式の文字列
     */
    toSqlDate: function () {
        return this.year + '-'
             + this._getNum(this.month) + '-'
             + this._getNum(this.date);
    },

    /**
     * SQL等でよく使用されるDateTime形式の文字列に変換する
     *
     * @return {String} DateTime形式の文字列
     */
    toSqlDateTime: function () {
        return this.year + '-'
             + this._getNum(this.month) + '-'
             + this._getNum(this.date) + ' '
             + this._getNum(this.hour) + ':'
             + this._getNum(this.minute) + ':'
             + this._getNum(this.second);
    },
    
    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Date} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Date(this);
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Date|String|Integer|Jeeel.Object.Date} [date] 基となるDateオブジェクトやDateString(省略は現時刻)
     * @constructor
     */
    constructor: Jeeel.Object.Date,

    /**
     * 指定したフォーマットに従って文字列変換する<br />
     * フォーマットはphpのdateフォーマットと同等である<br />
     * 曜日名は現在設定されているロケールによって変化する
     *
     * @param {String} [format] フォーマット(省略時はDateTime形式になる)
     * @return {String} 変換後の文字列
     * @see Jeeel.Language
     */
    toString: function (format) {

        if ( ! Jeeel.Type.isString(format)) {
            format = 'Y-m-d H:i:s';
        }

        var year     = this.year;
        var month    = this.month;
        var date     = this.date;
        var hour     = this.hour;
        var minute   = this.minute;
        var second   = this.second;
        var unixTime = this.getUnixTime();
        var day      = this.day;

        var lastDate = (new Date(year, month, 0)).getDate();

        var halfHour = hour % 12;
        var amString = (hour < 12 ? 'am' : 'pm');

        if (halfHour == 0) {
            halfHour = 12;
        }
        
        var lang = Jeeel.Language.getLanguage('Object.Date');

        /**
         * @ignore
         */
        var formatList = {
            d: this._getNum(date),
            j: date,
            N: (day == 0 ? 7 : day),
            w: day,
            m: this._getNum(month),
            n: month,
            t: lastDate,
            Y: year,
            y: year.toString().substr(2, 4),
            a: amString,
            A: amString.toUpperCase(),
            g: halfHour,
            G: hour,
            h: this._getNum(halfHour),
            H: this._getNum(hour),
            i: this._getNum(minute),
            s: this._getNum(second),
            U: unixTime,
            D: lang['d' + day]['short'],
            l: lang['d' + day]['full']
        };

        for (var key in formatList) {
            var reg = new RegExp(key, 'g');
            
            format = format.replace(reg, formatList[key]);
        }

        return format;
    },

    /**
     * 現在の時刻を表すミリ秒を返す<br />
     * 1970年1月1日0時0分0秒(UTC)からの経過ミリ秒
     *
     * @return {Integer} 取得した経過ミリ秒
     */
    valueOf: function () {
        return this.time;
    },
    
    /**
     * 数値を二桁にフォーマットする
     * 
     * @param {Integer} num 数値
     * @return {String} フォーマット後の値
     * @private
     */
    _getNum: function (num) {
        return Jeeel.String.padLeft(num, 2, '0');
    },
    
    /**
     * プロパティを更新する
     * 
     * @return {Jeeel.Object.Date} 自インスタンス
     * @private
     */
    _refreshProperty: function () {
        
        var date = this._date;
        
        date = new Date(date.getTime() - (this._offset + date.getTimezoneOffset()) * 60000);
        
        this.year  = date.getFullYear();
        this.month = date.getMonth() + 1;
        this.date  = date.getDate();
        this.hour  = date.getHours();
        this.minute = date.getMinutes();
        this.second = date.getSeconds();
        this.millisecond = date.getMilliseconds();
        this.day = date.getDay();
        this.time = this._date.getTime();
        
        return this;
    }
};

// 言語設定ファイルの初期ロード
if ( ! Jeeel.Object.Date._lock && ! Jeeel.Language.hasLanguage('Object.Date')) {
    Jeeel.Object.Date._lock = true;

    Jeeel.Language.loadLanguage('Object.Date', function () {
        Jeeel.Object.Date._lock = false;
    });
}

/**
 * コンストラクタ
 * 
 * @class フォントを扱うクラス
 * @param {String[]} family フォントの種類
 * @param {String} [size] フォントのサイズ
 * @param {String} [weight] フォントの太さ
 * @param {String} [style] フォントスタイル
 * @param {String} [height] フォントの高さ
 * @param {String} [variant] スモールキャピタル
 */
Jeeel.Object.Font = function (family, size, weight, style, height, variant) {
    
    if (Jeeel.Type.isString(family)) {
        family = [family];
    }
    
    if ( ! Jeeel.Type.isArray(family)) {
        throw new Error('引数の型が違います。');
    }
    
    for (var i = family.length; i--;) {
        if ( ! Jeeel.Type.isString(family[i])) {
            throw new Error('引数の型が違います。');
        } else if (family[i].match(/^'.*'$/)) {
            continue;
        }
        
        family[i] = "'" + family[i] + "'";
    }
    
    /**
     * フォント名
     * 
     * @type String[]
     */
    this.family = family;
  
    /**
     * フォントサイズ
     * 
     * @type String
     */
    this.size = size || 'medium';
    
    /**
     * フォントの太さ
     * 
     * @type String
     */
    this.weight = weight || 'normal';
    
    /**
     * フォントスタイル
     * 
     * @type String
     */
    this.style = style || 'normal';
    
    /**
     * フォントの高さ
     * 
     * @type String
     */
    this.height = height || 'normal';
    
    /**
     * スモールキャピタル
     * 
     * @type String
     */
    this.variant = variant || 'normal';
};

Jeeel.Object.Font.prototype = {
    /**
     * 複製を行う
     *
     * @return {Jeeel.Object.Font} 複製したインスタンス
     */
    clone: function () {
        return new Jeeel.Object.Font(this.family, this.size, this.weight, this.style, this.height, this.variant);
    },

    /**
     * 内部比較を行い結果を返す
     *
     * @param {Jeeel.Object.Font} font 比較オブジェクト
     * @return {Boolean} 判定結果
     */
    equals: function (font) {
        return this.family.join('') === font.family.join('')
            && this.size === font.size
            && this.weight === font.weight
            && this.style === font.style
            && this.height === font.height
            && this.variant === font.variant;
    },

    /**
     * 文字列に変換する
     *
     * @return {String} 文字列に変換した自インスタンス
     */
    toString: function () {
        return this.style + ' '
             + this.variant + ' '
             + this.weight + ' '
             + this.size + '/'
             + this.height + ' '
             + this.family.join(',');
    }
};
Jeeel.directory.Jeeel.Object.Technical = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Object + 'Technical/';
    }
};

/**
 * @namespace Jeeel内部で使用している特殊クラスを保持するネームスペース
 */
Jeeel.Object.Technical = {

};

Jeeel.file.Jeeel.Object.Technical = ['LineIndex'];

if (Jeeel._debugMode) {
    Jeeel.file.Jeeel.Object.Technical[Jeeel.file.Jeeel.Object.Technical.length] = 'Trace';
    Jeeel.file.Jeeel.Object.Technical[Jeeel.file.Jeeel.Object.Technical.length] = 'Information';
}

Jeeel._autoImports(Jeeel.directory.Jeeel.Object.Technical, Jeeel.file.Jeeel.Object.Technical);

/**
 * コンストラクタ
 *
 * @class Jeeel.Stringで行数とインデックスを表す構造体
 * @param {Hash} lineIndex
 * @param {Integer} lineIndex.line
 * @param {Integer} lineIndex.index
 */
Jeeel.Object.Technical.LineIndex = function (lineIndex) {
    var self = this;

    self.line  = lineIndex.line;
    self.index = lineIndex.index;
};

Jeeel.Object.Technical.LineIndex.prototype = {
  
    /**
     * 行番号
     *
     * @type Integer
     */
    line : false,

    /**
     * 行文字列のインデックス
     *
     * @type Integer
     */
    index : false
};

/**
 * コンストラクタ
 *
 * @class メソッドのトレースを保持する構造体
 * @param {Function} func 対象の関数
 */
Jeeel.Object.Technical.Trace = function (func) {
    var self = this;
    self.args = func.arguments && Array.prototype.slice.call(func.arguments, 0, func.arguments.length) || [];
    self.name = (func[Jeeel.Debug.Debugger.INFORMATION_NAME] || {}).name || func.name;
    self.func = func;
};

Jeeel.Object.Technical.Trace.prototype = {

    /**
     * 引数配列
     *
     * @type Array
     */
    args: [],

    /**
     * 関数名
     *
     * @type String
     */
    name: '',

    /**
     * 関数詳細
     *
     * @type Function
     */
    func: null,
    
    /**
     * 文字列に変換する
     * 
     * @return {String} 文字列
     */
    toString: function () {
        return this.name;
    }
};

/**
 * コンストラクタ
 *
 * @class オブジェクトの情報を保持する構造体
 * @param {String} name オブジェクト名
 * @param {Mixied} parent 親オブジェクト
 */
Jeeel.Object.Technical.Information = function (name, parent) {
    var self = this;
    self.name = name;
    self.parent = parent;
};

Jeeel.Object.Technical.Information.prototype = {

    /**
     * オブジェクト名
     *
     * @type String
     */
    name: '',

    /**
     * オブジェクトの親
     *
     * @type Mixied
     */
    parent: ''
};
Jeeel.directory.Jeeel.Validator = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Validator/';
    }
};

/**
 * @namespace バリデータに関するネームスペース
 */
Jeeel.Validator = {

    /**
     * コンストラクタ
     *
     * @abstractClass バリデータクラスを作る際の抽象クラス
     */
    Abstract: function () {}
};

Jeeel.Validator.Abstract.prototype = {

    /**
     * ヘルパーを作成して返す
     * 
     * @param {Mixied} val バリデートを掛ける対象値
     * @return {Jeeel.Validator.Helper} 作成したヘルパー
     * @protected
     */
    _createHelper: function (val) {
        return Jeeel.Validator.Helper.create(val);
    },

    /**
     * 指定した値に対してバリデートを掛ける
     *
     * @param {Mixied} val バリデートを掛ける値
     * @return {Hash} エラーを保持した連想配列リスト
     */
    validate: function (val) {
        var errors;
        
        if (Jeeel.Type.isHash(val)) {
            errors = this._validateEach(val);
        } else {
            errors = this._validate(val);
        }

        return errors;
    },

    /**
     * バリデートの内部メソッド<br />
     * 必ずオーバーライドしなければならない
     *
     * @param {Mixied} val バリデートを掛ける値
     * @return {Hash} エラーを保持した連想配列リスト
     * @protected
     * @abstract
     */
    _validate: function (val) {
        throw new Error('_validateメソッドが実装されていません。');
    },
    
    /**
     * 配列式の場合のメソッド
     *
     * @param {Hash} arr バリデートを掛ける値のリスト
     * @return {Hash} エラーを保持した連想配列リスト
     * @protected
     */
    _validateEach: function (arr) {
        var result = {};

        Jeeel.Hash.forEach(arr,
            function (val, key) {
                result[key] = this.validate(val);
            }, this
        );

        return result;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Validator.Abstract
};

Jeeel.file.Jeeel.Validator = ['Helper'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Validator, Jeeel.file.Jeeel.Validator);

/**
 * コンストラクタ
 *
 * @class バリデートの助けを行うクラス
 * @param {Mixied} val バリデートを掛ける対象値
 * @param {Function|Function[]} [plugins] メソッドリスト
 */
Jeeel.Validator.Helper = function (val, plugins) {

    if ( ! Jeeel.Type.isObject(plugins)) {
        plugins = {};
    }

    this._value = val;
    this._errors = [];

    var notValidator = ['isValid', 'hasErrors', 'hasError', 'getErrors', 'getFirstError'];
    
    for (var name in plugins) {
        
        if (Jeeel.Hash.inHash(name, notValidator)) {
            continue;
        }

        this[name] = plugins[name];
    }

    var self = this;

    for (var property in this) {

        if (property[0] === '_' || Jeeel.Hash.inHash(property, notValidator)) {
            continue;
        } else if (Jeeel.Hash.keyExists(property, plugins)) {
            this[property] = (function (_property, method) {
                return function () {
                    var args = [self._value];
                    
                    for (var i = 0, l = arguments.length; i < l; i++) {
                        args.push(arguments[i]);
                    }

                    var res  = method.apply(self, args);

                    if (res === false) {
                        self._errors[self._errors.length] = _property;
                    }

                    return self;
                };
            })(property, this[property]);
        } else {
            this[property] = (function (_property, method) {
                return function () {
                    var res = method.apply(self, arguments);

                    if (res === false) {
                        self._errors[self._errors.length] = _property;
                    }

                    return self;
                };
            })(property, this[property]);
        }
    }
};

/**
 * インスタンスの作成を行う
 *
 * @param {Mixied} val バリデートを掛ける対象値
 * @return {Jeeel.Validator.Helper} 作成したインスタンス
 */
Jeeel.Validator.Helper.create = function (val) {
    return new this(val, this.getPlugins());
};

/**
 * プラグインの追加
 *
 * @param {String} name メソッド名
 * @param {Function} method メソッド(メソッドは最初の引数にバリデートする値その後は任意の引数となる)<br />
 *                           Boolean method(Mixied value, ...)
 * @throws {Error} methodがメソッドではない場合に発生
 */
Jeeel.Validator.Helper.setPlugin = function (name, method) {
    if ( ! Jeeel.Type.isFunction(method)) {
        throw new Error('指定した引数がメソッドではありません。');
    }

    if (Jeeel.Type.isEmpty(this._plugins)) {
        this._plugins = {};
    }

    this._plugins[name] = method;
};

/**
 * プラグインの設定
 *
 * @param {Function[]} methods メソッドの連想配列(メソッドは最初の引数にバリデートする値その後は任意の引数となる)<br />
 *                              Boolean method(Mixied value, ...)
 * @throws {Error} methodsがメソッドまたはメソッドリストではない場合に発生
 */
Jeeel.Validator.Helper.setPlugins = function (methods) {

    if ( ! Jeeel.Type.isObject(methods)) {
        throw new Error('指定した引数がメソッドリストではありません。');
    }

    for (var name in methods) {
        if (Jeeel.Type.isFunction(methods[name])) {
            throw new Error('指定した引数にメソッド以外のものが含まれています。');
        }
    }

    /**
     * プラグイン
     *
     * @type Function[]
     * @private
     */
    this._plugins = methods;
};

/**
 * プラグインを取得
 *
 * @return {Function[]} メソッド連想配列
 */
Jeeel.Validator.Helper.getPlugins = function () {
    if (Jeeel.Type.isEmpty(this._plugins)) {
        return {};
    }

    return this._plugins;
};

Jeeel.Validator.Helper.prototype = {

    /**
     * バリデートを掛ける値
     * 
     * @type Mixied
     * @private
     */
    _value: null,

    /**
     * エラー保持配列
     *
     * @type String[]
     * @private
     */
    _errors: [],

    /**
     * バリデートを通過したかどうかを返す
     *
     * @return {Boolean} バリデータが通過したならばtrueそれ以外はfalseを返す
     */
    isValid: function () {
        return ! this.hasErrors();
    },

    /**
     * エラーが存在するかどうかを返す
     *
     * @return {Boolean} エラーがあったらtrueそれ以外はfalseを返す
     */
    hasErrors: function () {
        return !!this._errors.length;
    },

    /**
     * 指定したメソッドのエラーがあるかどうかを返す
     *
     * @param {String} name エラーがあったかどうかを調べるメソッド名
     * @return {Boolean} エラーがあったらtrueそれ以外はfalseを返す
     */
    hasError: function (name) {
        return Jeeel.Hash.inHash(name, this._errors);
    },
    
    /**
     * エラーリストを取得する
     * 
     * @return {String[]} エラーの出たメソッド名のリスト
     */
    getErrors: function () {
        return this._errors;
    },

    /**
     * 最初のエラーを返す
     *
     * @return {String} エラーが起こったメソッド名
     * @throws {Error} エラーがそもそも存在しない場合に発生する
     */
    getFirstError: function () {
        if ( ! this.hasErrors()) {
            throw new Error('エラーが存在しません。');
        }

        return this._errors[0];
    },

    /**
     * 値が文字列で英数字のみで構成されているかどうかを調べる
     * 
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    alnum: function () {
        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        return (this._value.match(/^[0-9a-zA-Z]*$/) ? true : false);
    },

    /**
     * 値が文字列でアルファベットのみで構成されているかどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    alpha: function () {
        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        return (this._value.match(/^[a-zA-Z]*$/) ? true : false);
    },

    /**
     * 値がminからmaxまでの整数値(文字列整数値でも可)であるかどうかを調べる
     *
     * @param {Integer} min 最小値
     * @param {Integer} max 最大値
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    between: function (min, max) {
        if ( ! Jeeel.Type.isDigit(this._value)) {
            return false;
        }

        var digit = +this._value;

        return (min <= digit && digit <= max);
    },

    /**
     * 値が整数値か整数文字列かどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    digits: function () {
        return Jeeel.Type.isDigit(this._value);
    },

    /**
     * 値が文字列でメール形式であるかどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    email: function () {
        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        return (this._value.match(/^[_a-zA-Z0-9-]+([\.\+_a-zA-Z0-9-]+)*@[a-zA-Z0-9]([_a-zA-Z0-9-])*(\.[_a-zA-Z0-9-]+)*(\.[_a-zA-Z0-9-]{2,})+$/i) ? true : false);
    },

    /**
     * 値が文字列で郵便番号形式であるかどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    zipcode: function () {
        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        return (this._value.match(/^[0-9]{3}-?[0-9]{4}$/) ? true : false);
    },

    /**
     * 値が空(null, undefined, 空文字)でないかどうかを調べる
     *
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    notEmpty: function () {
        return !(Jeeel.Type.isEmpty(this._value) || this._value === '');
    },

    /**
     * 値がmin文字からmax文字までの文字数であるかどうかを調べる
     *
     * @param {Integer} min 最小値
     * @param {Integer} max 最大値
     * @return {Jeeel.Validator.Helper} 自身のインスタンス
     */
    length: function (min, max) {

        if ( ! Jeeel.Type.isString(this._value)) {
            return false;
        }

        var length = this._value.length;

        return (min <= length && length <= max);
    }
};
Jeeel.directory.Jeeel.Storage = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Storage/';
    }
};

/**
 * @namespace ストレージ関連のネームスペース
 */
Jeeel.Storage = {

    /**
     * コンストラクタ
     *
     * @class ストレージクラスを作る際の抽象クラス
     */
    Abstract: function () {}
};

Jeeel.Storage.Abstract.prototype = {

    /**
     * ストレージにパラメータの保存を行う
     *
     * @param {Mixed} params 保存値
     * @return {Jeeel.Storage.Abstract} 自インスタンス
     * @throws {Error} メソッドが実装されていない場合に発生
     * @abstract
     */
    save: function (params) {
        throw new Error('saveメソッドが実装されていません。');
    },

    /**
     * ストレージからパラメータの読み込みを行う
     *
     * @return {Mixed} 読み込み値
     * @return {Jeeel.Storage.Abstract} 自インスタンス
     * @throws {Error} メソッドが実装されていない場合に発生
     * @abstract
     */
    load: function () {
        throw new Error('loadメソッドが実装されていません。');
    }
};

Jeeel.file.Jeeel.Storage = ['Session', 'Object'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Storage, Jeeel.file.Jeeel.Storage);
Jeeel.directory.Jeeel.Storage.Session = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Storage + 'Session/';
    }
};

/**
 * @namespace Session関連を扱うストレージのネームスペース
 */
Jeeel.Storage.Session = {

};

Jeeel.file.Jeeel.Storage.Session = ['Abstract', 'Cookie', 'Name'];

if (Jeeel._extendMode.WebStorage && Jeeel._global && Jeeel._global.sessionStorage && Jeeel._global.localStorage) {
    Jeeel.file.Jeeel.Storage.Session[Jeeel.file.Jeeel.Storage.Session.length] = 'WebStorage';
}

Jeeel._autoImports(Jeeel.directory.Jeeel.Storage.Session, Jeeel.file.Jeeel.Storage.Session);

/**
 * コンストラクタ
 *
 * @abstractClass ストレージセッションクラスを作る際の抽象クラス
 * @augments Jeeel.Storage.Abstract
 */
Jeeel.Storage.Session.Abstract = function () {
    Jeeel.Storage.Abstract.call(this);
};

Jeeel.Storage.Session.Abstract.prototype = {
    
    /**
     * セッションインスタンス
     * 
     * @type Jeeel.Session.Abstract
     * @private
     */
    _session: null,
    
    /**
     * セッション名
     * 
     * @type String
     * @private
     */
    _name: null,

    /**
     * Sessionの保存期間を取得する
     *
     * @return {Integer} 保存期間(秒)
     */
    getExpires: function () {
        return this._session.getExpires();
    },

    /**
     * Sessionの保存期間を設定する<br />
     * マイナスを指定すると無制限になる
     *
     * @param {Integer} expires 保存期間(秒)
     * @return {Jeeel.Storage.Session.Abstract} 自インスタンス
     */
    setExpires: function (expires) {

        this._session.setExpires(expires);

        return this;
    },

    /**
     * Sessionの読み込み許可をするドメインを取得する
     *
     * @return {String} 読み込み可能ドメイン
     */
    getDomain: function () {
        return this._session.getDomain();
    },

    /**
     * Sessionの読み込み許可をするドメインを設定する
     *
     * @param {String} domain 読み込み可能ドメイン
     * @return {Jeeel.Storage.Session.Abstract} 自インスタンス
     */
    setDomain: function (domain) {

        this._session.setDomain(domain);

        return this;
    },

    /**
     * Sessionの読み込み可能パスを取得する
     *
     * @return {String} 読み込み可能パス
     */
    getPath: function () {
        return this._session.getPath();
    },

    /**
     * Sessionの読み込み可能パスを設定する
     *
     * @param {String} path 読み込み可能パス
     * @return {Jeeel.Storage.Session.Abstract} 自インスタンス
     */
    setPath: function (path) {
        this._session.setPath(path);

        return this;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Session.Abstract, Jeeel.Storage.Abstract);
/**
 * コンストラクタ
 *
 * @class クッキーのセッションを扱ってストレージを模すクラス
 * @augments Jeeel.Storage.Session.Abstract
 * @param {String} name 読み込み・保存時の名前
 * @throws {Error} nameを文字列で指定しなかった場合に発生
 * @see Jeeel.Session.Cookie
 */
Jeeel.Storage.Session.Cookie = function (name) {

    if ( ! Jeeel.Type.isString(name)) {
        throw new Error('nameは必ず指定しなければなりません。');
    }
    
    Jeeel.Storage.Session.Abstract.call(this);
    
    this._name = name;
    this._session = Jeeel.Session.Cookie.create();
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name 読み込み・保存時の名前
 * @return {Jeeel.Storage.Session.Cookie} 作成したインスタンス
 */
Jeeel.Storage.Session.Cookie.create = function (name) {
    return new this(name);
};

Jeeel.Storage.Session.Cookie.prototype = {
    
    /**
     * クッキーに値を保存する
     *
     * @param {Hash} params 保存する値のリスト
     */
    save: function (params) {

        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        this._session.set(this._name, params).save();
    },
    
    /**
     * クッキーの値を読み込む
     *
     * @return {Hash} 読み込んだ結果値
     */
    load: function () {
        var params = this._session.load().get(this._name);

        if ( ! Jeeel.Type.isSet(params)) {
            params = {};
        }

        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        return params;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Session.Cookie, Jeeel.Storage.Session.Abstract);

/**
 * コンストラクタ
 *
 * @class ネームのセッションを扱ってストレージを模すクラス(但しサーバー側には干渉しない、またドメインが変わっても参照できるため重要な情報保持には向かない)<br />なおこのクラスはwindow.nameを使用している
 * @augments Jeeel.Storage.Session.Abstract
 * @param {String} name 読み込み・保存時の名前
 * @throws {Error} nameを文字列で指定しなかった場合に発生
 * @see Jeeel.Session.Name
 */
Jeeel.Storage.Session.Name = function (name) {

    if ( ! Jeeel.Type.isString(name)) {
        throw new Error('nameは必ず指定しなければなりません。');
    }
    
    Jeeel.Storage.Session.Abstract.call(this);

    this._name = name;
    this._session = Jeeel.Session.Name.create();
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name 読み込み・保存時の名前
 * @return {Jeeel.Storage.Session.Name} 作成したインスタンス
 */
Jeeel.Storage.Session.Name.create = function (name) {
    return new this(name);
};

Jeeel.Storage.Session.Name.prototype = {
    
    /**
     * 値を保存する
     *
     * @param {Hash} params 保存する値のリスト
     */
    save: function (params) {
        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        this._session.set(this._name, params).save();
    },
    
    /**
     * 保存した値を読み込む
     *
     * @return {Hash} 読み込んだ結果値
     */
    load: function () {
        var params = this._session.get(this._name);

        if ( ! Jeeel.Type.isSet(params)) {
            params = {};
        }

        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        return params;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Session.Name, Jeeel.Storage.Session.Abstract);

/**
 * コンストラクタ
 *
 * @class ウェブストレージのセッションを扱ってストレージを模すクラス(但しサーバー側には干渉しない、またドメイン・プロトコル・ポート番号で制御されるため異なるドメイン間等ではデータのやりとりは出来ない)<br />なおこのクラスはwindow.localStorageを使用している
 * @augments Jeeel.Storage.Session.Abstract
 * @param {String} name 読み込み・保存時の名前
 * @param {Boolean} [isPersistent] データの永続化をするかどうか(ブラウザを閉じてもアクセス出来るか)
 * @throws {Error} nameを文字列で指定しなかった場合に発生
 * @see Jeeel.Storage.Session.Abstract
 */
Jeeel.Storage.Session.WebStorage = function (name, isPersistent) {

    if ( ! Jeeel.Type.isString(name)) {
        throw new Error('nameは必ず指定しなければなりません。');
    }
    
    Jeeel.Storage.Session.Abstract.call(this);
    
    this._session = Jeeel.Session.WebStorage.create(isPersistent, Jeeel.Storage.Session.WebStorage.STORAGE_NAME);
    this._name = name;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name 読み込み・保存時の名前
 * @param {Boolean} [isPersistent] データの永続化をするかどうか(ブラウザを閉じてもアクセス出来るか)
 * @return {Jeeel.Storage.Session.WebStorage} 作成したインスタンス
 */
Jeeel.Storage.Session.WebStorage.create = function (name, isPersistent) {
    return new this(name, isPersistent);
};

/**
 * localStorageに保存する際のキー
 *
 * @type String
 * @constant
 */
Jeeel.Storage.Session.WebStorage.STORAGE_NAME = 'Jeeel-Storage-Session-WebStorage-Name';

Jeeel.Storage.Session.WebStorage.prototype = {
  
    /**
     * 値を保存する
     *
     * @param {Hash} params 保存する値のリスト
     */
    save: function (params) {
        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        this._session.set(this._name, params).save();
    },
    
    /**
     * 保存した値を読み込む
     *
     * @return {Hash} 読み込んだ結果値
     */
    load: function () {
        var params = this._session.get(this._name);

        if ( ! Jeeel.Type.isSet(params)) {
            params = {};
        }

        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }

        return params;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Session.WebStorage, Jeeel.Storage.Session.Abstract);

(function () {
    var defaultName = '@JEEEL@';
    var index = 1;
    var instances = {};
    
    /**
     * コンストラクタ(newなしで呼んでも動作する)
     * 
     * @class Objectストレージ、Objectに対して疑似的に保存を行うクラス(Jeeel.Parameterと合わせても使えるが基本単独で使う)
     * @augments Jeeel.Storage.Abstract
     * @param {Object} object 疑似保存対象のObject(IEでElement指定の場合は何も無いが、その他の場合はプロパティが拡張させるので注意、その際のキーはJeeel.UNIQUE_IDが使用される)
     * @param {String} [name] ネームスペースを指定する場合に指定
     * @see Jeeel.UNIQUE_ID
     */
    Jeeel.Storage.Object = function (object, name) {
        
        var uniqueId = object.uniqueID || object[Jeeel.UNIQUE_ID];
        
        if ( ! uniqueId) {
            object[Jeeel.UNIQUE_ID] = uniqueId = index++;
        }
        
        if ( ! name) {
            name = defaultName;
        }
        
        if (instances[name] && instances[name][uniqueId]) {
            return instances[name][uniqueId];
        } else if ( ! (this instanceof Jeeel.Storage.Object)) {
            return new Jeeel.Storage.Object(object, name);
        }
        
        Jeeel.Storage.Abstract.call(this);
        
        if ( ! instances[name]) {
            instances[name] = {};
        }
        
        instances[name][uniqueId] = this;
        this._params = {};
    };
    
    /**
     * インスタンスが既に作成されているかどうかを返す
     * 
     * @param {Object} object 疑似保存対象のObject
     * @param {String} [name] ネームスペースを指定する場合に指定
     * @return {Boolean} 既に作成されているかどうか
     */
    Jeeel.Storage.Object.exists = function (object, name) {
        var uniqueId = object.uniqueID || object[Jeeel.UNIQUE_ID];
        
        if ( ! uniqueId) {
            return false;
        }
        
        if ( ! name) {
            name = defaultName;
        }
        
        return !!(instances[name] && instances[name][uniqueId]);
    };
})();

/**
 * インスタンスの作成を行う
 * 
 * @param {Object} object 疑似保存対象のObject(IEでElement指定の場合は何も無いが、その他の場合はプロパティが拡張させるので注意、その際のキーはJeeel.UNIQUE_IDが使用される)
 * @param {String} [name] ネームスペースを指定する場合に指定
 * @return {Jeeel.Storage.Object} 作成したインスタンス
 * @see Jeeel.UNIQUE_ID
 */
Jeeel.Storage.Object.create = function (object, name) {
    return new this(object, name);
};

/**
 * 議事保存対象のObjectが既にユニークIDを保持しているかどうかを取得する<br />
 * この確認作業を行う事で不要な拡張を防ぐことが出来る
 * 
 * @param {Object} object 疑似保存対象のObject
 * @return {Boolean} ユニークIDを持っているかどうか
 */
Jeeel.Storage.Object.hasUniqueId = function (object) {
    return !!(object.uniqueID || object[Jeeel.UNIQUE_ID]);
};

Jeeel.Storage.Object.prototype = {

    /**
     * Domの疑似保存先ストレージ
     * 
     * @type Hash
     * @private
     */
    _params: {},
    
    /**
     * データの保存を行う
     * 
     * @param {Hash} params 保存データ
     * @return {Jeeel.Storage.Object} 自インスタンス
     */
    save: function (params) {
        if ( ! Jeeel.Type.isHash(params)) {
            params = [params];
        }
        
        for (var key in params) {
            this._params[key] = params[key];
        }
        
        return this;
    },

    /**
     * データの読み込みを行う
     * 
     * @return {Hash} 読み込んだデータ
     */
    load: function () {
        var key, res = {};
        
        for (key in this._params) {
            res[key] = this._params[key];
        }
        
        return res;
    },
    
    /**
     * データを一つだけ保存する
     * 
     * @param {String} key 保存キー
     * @param {Mixed} value 保存値
     * @return {Jeeel.Storage.Object} 自インスタンス
     */
    set: function (key, value) {
        this._params[key] = value;
        
        return this;
    },
    
    /**
     * データを一つだけ読み込む
     * 
     * @param {String} key 読み込みキー
     * @return {Mixed} 読み込んだデータ
     */
    get: function (key) {
        return this._params[key];
    },
    
    /**
     * データを全て破棄する
     * 
     * @return {Jeeel.Storage.Object} 自インスタンス
     */
    clear: function () {
        this._params = {};
        
        return this;
    }
};

Jeeel.Class.extend(Jeeel.Storage.Object, Jeeel.Storage.Abstract);
/**
 * @staticClass 外部との連携に関するネームスペース
 */
Jeeel.External = {
    
    /**
     * Flash内のActionScript関数を呼び出す
     *
     * @param {String} flashName embedタグのname
     * @param {String} methodName 呼び出す関数名
     * @param {Mixied} var_args 呼び出す際に渡す引数の可変引数
     * @return {Mixied} ActionScript側からの戻り値
     */
    callActionScript: function (flashName, methodName, var_args) {
        var flash = Jeeel._doc[flashName];

        if ( ! flash || ! flash[methodName]) {
            Jeeel.errorDump('ActionScript Call Error');
            return null;
        }

        var method = flash[methodName];
        var args = Array.prototype.slice.call(arguments, 2, arguments.length);

        if (method.apply) {
            return method.apply(flash, args);
        }

        return Jeeel.Function.toNative(flash, methodName).apply(null, args);
    }
};

(function () {
  
    // 遅延実行待ちのメソッド
    var deferredQueue = [];
    
    /**
     * コンストラクタ
     * 
     * @class 遅延実行を管理するクラス
     */
    Jeeel.Deferred = function () {
        this.reset();
    };
    
    /**
     * インスタンスの作成を行う
     * 
     * @return {Jeeel.Deferred} 作成したインスタンス
     */
    Jeeel.Deferred.create = function () {
        return new this();
    };
    
    /**
     * デフォルトのメソッド成功時の挙動
     * 
     * @param {Mixied} [x] 引数
     */
    Jeeel.Deferred.success = {func: Jeeel.Function.Template.RETURN_ARGUMENT};

    /**
     * デフォルトのメソッド失敗時の挙動
     * 
     * @param {Mixied} [x] 引数
     */
    Jeeel.Deferred.error = {func: Jeeel.Function.Template.THROW_ARGUMENT};

    /**
     * 指定したメソッドを遅延実行する
     * 
     * @param {Function} callback 遅延実行対象のメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトは作成したインスタンスになる)
     * @param {Integer} [delayTime] 遅延時間(デフォルトは0)
     * @return {Jeeel.Deferred} 作成したインスタンス
     */
    Jeeel.Deferred.next = function (callback, thisArg, delayTime) {
        var df = new this();
        
        if ( ! deferredQueue[0]) {
            var id = setTimeout(function () {
              
                var dq = deferredQueue.shift();

                if (deferredQueue[0]) {
                    id = setTimeout(arguments.callee, dq._delayTime);
                    
                    /**
                     * @ignore
                     */
                    deferredQueue[0]._canceller = function () {
                        clearTimeout(id);
                    };
                }
                
                dq.call();
            }, +delayTime || 0);

            /**
             * @ignore
             */
            df._canceller = function () {
                clearTimeout(id);
            };
        }
        
        deferredQueue[deferredQueue.length] = function () {
            df.call();
        };
        
        deferredQueue[deferredQueue.length - 1]._delayTime = +delayTime || 0;

        if (callback) {
            df.next(callback, thisArg);
        }

        return df;
    };
    
    /**
     * 待ちキューのサイズを取得する
     * 
     * @return {Integer} 待ちキューのサイズ
     */
    Jeeel.Deferred.getQueueSize = function () {
        return deferredQueue.length;
    };
})();

Jeeel.Deferred.prototype = {
    
    /**
     * 成功・失敗の時に呼ばれるコールバック
     * 
     * @type Hash
     * @private
     */
    _callback: null,
    
    /**
     * キャンセル時に呼ばれるメソッド
     * 
     * @type Function
     * @private
     */
    _canceller: null,
    
    /**
     * 次に実行されるメソッドのキュー
     * 
     * @type Function[]
     */
    _next: [],
    
    /**
     * 初期状態に戻す
     * 
     * @return {Jeeel.Deferred} 自インスタンス
     */
    reset: function () {
        this._next = [];

        this._callback = {
            success: this.constructor.success,
            error: this.constructor.error
        };
        
        return this;
    },
    
    /**
     * 遅延実行を執行する
     * 
     * @param {Mixied} [val] 引数
     * @return {Jeeel.Deferred} 自インスタンス
     */
	  call: function (val) {
        return this._call(val);
    },
    
    /**
     * 遅延実行を途中キャンセルする
     * 
     * @return {Jeeel.Deferred} 自インスタンス
     */
    cancel: function () {
        (this._canceller || Jeeel.Function.Template.EMPTY)();
        
        return this.reset();
    },
    
    /**
     * 次のメソッドを登録する
     * 
     * @param {Function} nextCallback 次のメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Deferred} 新規インスタンス
     */
    next: function (nextCallback, thisArg) {
        this._next.push({func: nextCallback, thisArg: thisArg});
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Deferred,
    
    _call: function (val) {
      
        if ( ! this._next.length) {
            return this;
        }
        
        var next = this._next.shift();
        var type = 'success', callback;
        
        try {
            val = next.func.call(next.thisArg || this, val);
            
            callback = this._callback[type];
            val = callback.func.call(callback.thisArg || this, val);
        } catch (e) {
            type = "error";
            val = e;
            
            callback = this._callback[type];
            callback.func.call(callback.thisArg || this, val);
            
            return this;
        }
        
        if (this._next.length) {
            this._call(val);
        }
        
        return this;
    }
};

Jeeel.directory.Jeeel.Config = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Config/';
    }
};

(function () {
    
    var cash = {};
    var creating = false;
    
    /**
     * コンストラクタ
     * 
     * @class 簡易設定ファイルを管理するクラス(for-inでループも可能)
     * @param {Jeeel.Dom.Xml} xml 軽量ファイルを読み込んだXMLインスタンス
     * @example
     * コンフィグファイルの書式例
     * -----------------------------------------------------
     * <?xml version="1.0" encoding="UTF-8"?>
     * <config>
     *   <url>http://Jeeel.co.jp/test.js</url>
     *   <enable>1</enable>
     * </config>
     * -----------------------------------------------------
     * 
     * // 上記のファイルを読み込む
     * var conf = Jeeel.Config.load(url);
     * 
     * //conf.url => http://Jeeel.co.jp/test.js
     * //conf.enable => 1
     * 
     * var vals = [];
     * 
     * for (var key in conf) {
     *     vals[vals.length] = {name: key, value: conf[key]};
     * }
     * 
     * vals => [{name: 'url', value: 'http://Jeeel.co.jp/test.js'}, {name: 'enable', value: '1'}]
     */
    Jeeel.Config = function (xml) {
        
        if (creating) {
            this._init(xml);
        } else {
          
            if ( ! (xml instanceof Jeeel.Dom.Xml)) {
                throw new Error('xmlがJeeel.Dom.Xmlインスタンスではありません。');
            }
            
            creating = true;
            
            this._init(xml.config);
            
            creating = false;
        }
    };
    
    /**
     * コンフィグファイルの読み込みを同期的に行う<br />
     * キャッシングも行い同じコンフィグへのアクセスは早くなる
     * 
     * @param {String} url コンフィグへのURL
     * @return {Jeeel.Config} コンフィグ
     */
    Jeeel.Config.load = function(url) {
        if (cash[url]) {
            return cash[url];
        }

        return cash[url] = new this(Jeeel.Dom.Xml.load(url));
    };
    
    /**
     * コンフィグファイルの読み込みを非同期行う<br />
     * キャッシングも行い同じコンフィグへのアクセスは早くなる
     * 
     * @param {String} url コンフィグへのURL
     * @param {Function} callback 指定すると非同期読み込みになり引数にコンフィグが渡される<br />
     *                               void callback(Jeeel.Config config)
     */
    Jeeel.Config.loadAsync = function (url, callback) {
        if ( ! callback) {
            return;
        }
        
        if (cash[url]) {
            callback(cash[url]);
        } else {
            var self = this;
            
            Jeeel.Dom.Xml.loadAsync(url, function (xml) {
                cash[url] = new self(xml);
                
                callback(cash[url]);
                
                self = null;
            });
        }
    };
})();

Jeeel.Config.prototype = {
    
    /**
     * 初期化
     * 
     * @param {Jeeel.Dom.Xml.Node[]|Jeeel.Dom.Xml.Node} node ノード
     * @private
     */
    _init: function (node) {
        delete this._init;
        
        if ( ! (node instanceof Jeeel.Dom.Xml.Node)) {
            
            if (node.length !== 1) {
                throw new Error('コンフィグの同階層に同じ名前の要素が存在します。');
            }
            
            node = node[0];
        }
        
        if (node.getNamespace()) {
            throw new Error('コンフィグに名前空間が使用されています。');
        }
        
        var setProperty = false;
        
        for (var key in node) {
            var property = node[key];
            
            if ( ! (key in Jeeel.Dom.Xml.Node.prototype) && property) {
                this[key] = new Jeeel.Config(property);
                setProperty = true;
            }
        }
        
        if ( ! setProperty) {
            var value = node.getValue() || '';
            
            this.valueOf = function () {
                return value;
            };
        }
    }
};
/**
 * コンストラクタ
 * 
 * @class 独自エラークラス(デバッグモードが有効の場合はスタックトレースも取得する)
 * @param {String} [message] エラーメッセージ
 * @param {Integer} [code] エラーコード
 * @param {Integer} [nestCount] このエラーメッセージを本来投げるべき箇所以外で作成した場合に指定
 */
Jeeel.Error = function (message, code, nestCount) {
  
    if (Jeeel._global.Error && Error.call) {
        var err = Error.call(this, message);
        var pairs = Jeeel.Hash.getPairs(err, false);

        for (var i = pairs.length; i--;) {
            if (pairs[i].key === '__proto__') {
                continue;
            } else if (pairs[i].key === 'name') {
                continue;
            }

            this[pairs[i].key] = pairs[i].value;
        }
    }
    
    this.message = '' + message;
    this.code = +code || 0;
    
    if (Jeeel._debugMode && Jeeel.Debug) {
        
        if ( ! (nestCount > 0)) {
            nestCount = 1;
        } else {
            nestCount++;
        }
        
        this.stackTrace = Jeeel.Debug.Debugger.getTrace(nestCount);
    }
};

Jeeel.Error.prototype = {
    
    /**
     * Error名
     * 
     * @type String
     */
    name: 'JeeelError',

    /**
     * エラーメッセージ
     * 
     * @type String
     */
    message: '',
    
    /**
     * エラーコード
     * 
     * @type Integer
     */
    code: 0,
    
    /**
     * スタックトレース
     * 
     * @type Jeeel.Object.Technical.Trace[]
     */
    stackTrace: [],
    
    /**
     * コンストラクタ
     * 
     * @param {String} [message] エラーメッセージ
     * @param {Integer} [nestCount] このエラーメッセージを本来投げるべき箇所以外で作成した場合に指定
     * @constructor
     */
    constructor: Jeeel.Error
};

Jeeel.Class.extend(Jeeel.Error, Error);
Jeeel.directory.Jeeel.Util = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Util/';
    }
};

/**
 * @namespace ユーティル関連のネームスペース
 * @deprecated 今後削除される可能性あり
 */
Jeeel.Util = {

};

Jeeel.file.Jeeel.Util = ['Prefecture'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Util, Jeeel.file.Jeeel.Util);
/**
 * @staticClass 都道府県に関するモジュール
 * 
 * @deprecated 今後削除される可能性あり
 */
Jeeel.Util.Prefecture = {
    /**
     * 都道府県のIDと都道府県名のペアリスト
     *
     * @type Hash
     * @private
     * @constant
     */
    _assoc : {
        1 : '北海道',
        2 : '青森県',
        3 : '岩手県',
        4 : '宮城県',
        5 : '秋田県',
        6 : '山形県',
        7 : '福島県',
        8 : '茨城県',
        9 : '栃木県',
        10 : '群馬県',
        11 : '埼玉県',
        12 : '千葉県',
        13 : '東京都',
        14 : '神奈川県',
        15 : '新潟県',
        16 : '富山県',
        17 : '石川県',
        18 : '福井県',
        19 : '山梨県',
        20 : '長野県',
        21 : '岐阜県',
        22 : '静岡県',
        23 : '愛知県',
        24 : '三重県',
        25 : '滋賀県',
        26 : '京都府',
        27 : '大阪府',
        28 : '兵庫県',
        29 : '奈良県',
        30 : '和歌山県',
        31 : '鳥取県',
        32 : '島根県',
        33 : '岡山県',
        34 : '広島県',
        35 : '山口県',
        36 : '徳島県',
        37 : '香川県',
        38 : '愛媛県',
        39 : '高知県',
        40 : '福岡県',
        41 : '佐賀県',
        42 : '長崎県',
        43 : '熊本県',
        44 : '大分県',
        45 : '宮崎県',
        46 : '鹿児島県',
        47 : '沖縄県'
    },

    /**
     * 都道府県のIDと都道府県名のペアリストを返す
     *
     * @return {Hash} 都道府県のIDと都道府県名のペアリスト
     */
    getAssoc : function () {
        return this._assoc;
    },

    /**
     * 都道府県IDから都道府県名を得る
     *
     * @param {Integer} prefectureId 都道府県ID
     * @return {String} 都道府県名
     */
    getName : function (prefectureId) {
        if ( ! (prefectureId in this._assoc)) {
            throw new Error('存在しない都道府県IDです。');
        }

        return this._assoc[prefectureId];
    }
};
Jeeel.directory.Jeeel.Gui = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Gui/';
    }
};

/**
 * @namespace GUI関連のネームスペース
 * @see Jeeel.Gui.ColorPicker
 * @see Jeeel.Gui.Scrollbar.Vertical
 * @example
 * Guiのネームスペース以下は独自で生成したGUIパーツを保持する拡張機能の一つ
 * カラーピッカーやスクロールバー、カレンダーなどがある
 * この機能は拡張なので、まだ十分と言えるだけパーツを保持していないがあるパーツにおいては十分に使えるものとなっている
 * 
 * Jeeel.Gui.ColorPicker
 * カラーピッカーを扱うクラス
 * 指定したテキストボックスなどに色選択をさせてデータを入力させる補助ツールとして使用する
 * 
 * 例：
 * var picker = Jeeel.Gui.ColorPicker.create();
 * picker.addTarget($ID('text')); // このカラーピッカーが起動する要素を追加する(クリックイベント)
 * 
 * Jeeel.Gui.Scrollbar.Vertical
 * 垂直方向にスクロールバー
 * 通常のスクロールバーと違いdivで生成した擬似スクロールバーである
 * このクラスを使用するとある要素のスクロールを離れた位置のスクロールバーで操作したり、
 * 複数の要素のスクロールを1つのスクロールバーで操作したりできる
 * 
 * 例：
 * var vscroll = Jeeel.Gui.Scrollbar.Vertical.create();
 * vscroll.getScrollbar(); // このクラスは要素を勝手にbodyなどに埋め込まないため取得してから手動で埋め込む必要がる
 * vscroll.addScrollEvent(Test.onscroll, Test); // スクロールバーがスクロールした際に発生するイベントをハンドルする
 * vscroll.setContainerHeight(788); // このスクロールバーが対応するコンテナの高さを設定する
 */
Jeeel.Gui = {
    
};

Jeeel.file.Jeeel.Gui = ['Abstract', 'Tooltip', 'ColorPicker', 'Scrollbar', 'Calendar', 'Mouse'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Gui, Jeeel.file.Jeeel.Gui);

/**
 * コンストラクタ
 * 
 * @abstractClass GUIクラスを作る際の抽象クラス
 */
Jeeel.Gui.Abstract = function () {
    
};

Jeeel.Gui.Abstract.prototype = {
    /**
     * デフォルトのスタイルを記述した文字列
     * 
     * @type String
     */
    _defaultStyle: '',
    
    /**
     * 現在の読み込みスタイルのタグ
     * 
     * @type Element
     */
    _styleTag: null,
    
    /**
     * ユーザースタイルの読み込みを行う
     * 
     * @param {String} url CSSのURL
     * @return {Jeeel.Gui.Abstract} 自インスタンス
     */
    loadStyle: function (url) {
        Jeeel.Dom.Element.create(this._styleTag).remove();
        
        this._styleTag = Jeeel.Loader.loadStyle(url);
        
        return this;
    },
    
    /**
     * デフォルトのスタイルに戻す
     * 
     * @return {Jeeel.Gui.Abstract} 自インスタンス
     */
    resetStyle: function () {
        Jeeel.Dom.Element.create(this._styleTag).remove();
        
        this._styleTag = Jeeel.Loader.addStyle(this._defaultStyle);
        
        return this;
    }
};

/**
 * コンストラクタ
 * 
 * @class ツールチップを管理するクラス
 * @augments Jeeel.Gui.Abstract
 * @param {Element} [target] ツールチップ表示対象のElement
 * @param {String} [text] 設定するテキスト
 */
Jeeel.Gui.Tooltip = function (target, text) {
    Jeeel.Gui.Abstract.call(this);
    
    this._init(target, text);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Element} [target] ツールチップ表示対象のElement
 * @param {String} [text] 設定するテキスト
 * @return {Jeeel.Gui.Tooltip} 作成したインスタンス
 */
Jeeel.Gui.Tooltip.create = function (target, text) {
    return new this(target, text);
};

/**
 * ツールチップ全インスタンス共通のスタイルを定義する
 */
Jeeel.Gui.Tooltip.initStyle = function () {
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    var style = 'div.' + this.CLASS.TOOLTIP + ' {\n'
              + '  position: absolute;\n'
              + '  width: auto;\n'
              + '  height: auto;\n'
              + '  box-shadow: 5px 5px 3px #444;\n'
              + '  -moz-box-shadow: 5px 5px 3px #444;\n'
              + '  -webkit-box-shadow: 5px 5px 3px #444;\n'
              + '}\n'
              + 'div.' + this.CLASS.TOOLTIP + ' div.' + this.CLASS.TEXT_CONTENT + ' {\n'
              + '  padding: 2px;\n'
              + '  font-size: 12px;\n'
              + '  font-weight: normal;\n'
              + '  color: #000;\n'
              + '  border: 1px solid #000000;\n'
              + '  background-color: #FFFFE1;\n'
              + '}\n';
            
    if (Jeeel.UserAgent.isInternetExplorer()) {
        style += 'div.' + this.CLASS.TOOLTIP + ' {\n'
               + '  z-index: 3;\n'
               + '}\n'
               + 'div.' + this.CLASS.TOOLTIP + ' div.' + this.CLASS.TEXT_CONTENT + ' {\n'
               + '  position: relative;\n'
               + '  z-index: 4;\n'
               + '}\n'
               + 'div.' + this.CLASS.TOOLTIP + ' div.' + this.CLASS.IE_SHADOW_BOX + ' {\n'
               + '  display: block;\n'
               + '  position: absolute;\n'
               + '  z-index: 2;\n'
               + '  top: 2px;\n'
               + '  left: 2px;\n'
               + '  right: -2px;\n'
               + '  bottom: -2px;\n'
               + '  filter: progid:DXImageTransform.Microsoft.Blur(pixelradius=3);\n'
               + '  -ms-filter: "progid:DXImageTransform.Microsoft.Blur(pixelradius=3)";\n'
               + '  background-color: #444;\n'
               + '}\n';
    } else {
        style += 'div.' + this.CLASS.TOOLTIP + ' div.' + this.CLASS.IE_SHADOW_BOX + ' {\n'
               + '  display: none;\n'
               + '}\n';
    }

    this._styleTag = Jeeel.Loader.addStyle(style);
};

/**
 * ツールチップのクラス名
 */
Jeeel.Gui.Tooltip.CLASS = {
    TOOLTIP: 'jeeel-gui-tooltip',
    IE_SHADOW_BOX: 'jeeel-gui-tooltip-ie-shadow-box',
    TEXT_CONTENT: 'jeeel-gui-tooltip-text-content'
};

/**
 * ツールチップの作成個数
 * 
 * @type Integer
 */
Jeeel.Gui.Tooltip.createLength = 0;

Jeeel.Gui.Tooltip.prototype = {
  
    /**
     * ツールチップ
     * 
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _tooltip: null,
    
    /**
     * ツールチップ文字列コンテント
     * 
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _textContent: null,
    
    /**
     * ツールチップの表示対象
     * 
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _target: null,
    
    /**
     * タイムアウトID
     * 
     * @type Integer
     * @private
     */
    _timeOutId: null,
    
    /**
     * ツールチップにテキストを設定する
     * 
     * @param {String} text 設定するテキスト
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    setText: function (text) {
        this._textContent.setText(text);
        
        return this;
    },
    
    /**
     * ツールチップにHTMLを設定する
     * 
     * @param {String} html 設定するHTML
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    setHtml: function (html) {
        this._textContent.setHtml(html);
        
        return this;
    },
    
    /**
     * ツールチップが表示される対象を設定する
     * 
     * @param {Element} target 対象のElement
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    setTarget: function (target) {
        if (this._target) {
            this._target.removeOut(this.hide)
                        .removeMouseMove(this._show);
        }
        
        this._target = Jeeel.Dom.ElementOperator.create(target);
        
        this._target.addOut(this.hide, this)
                    .addMouseMove(this._show, this);
        
        return this;
    },
    
    /**
     * ツールチップを表示する
     * 
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    show: function () {
        this._tooltip.show();
        
        return this;
    },
    
    /**
     * ツールチップを隠す
     * 
     * @return {Jeeel.Gui.Tooltip} 自インスタンス
     */
    hide: function () {
        Jeeel.Timer.clearTimeout(this._timeOutId);
        
        this._tooltip.hide();
        
        return this;
    },
    
    /**
     * ツールチップを削除する
     */
    remove: function () {
        if (this._target) {
            this._target.removeOut(this.hide)
                        .removeMouseMove(this._show);
        }
        
        this.hide();
        this._tooltip.remove();
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Element} [target] ツールチップ表示対象のElement
     * @param {String} [text] 設定するテキスト
     */
    constructor: Jeeel.Gui.Tooltip,
    
    /**
     * ツールチップを対象の要素上に表示する
     * 
     * @param {Jeeel.Dom.Event} e イベントオブジェクト
     */
    _show: function (e) {
        this.hide();
        
        var pos = e.mousePoint;
        var self = this;
        
        this._timeOutId = Jeeel.Timer.setTimeout(
            function () {
                self._tooltip.shiftTo(pos.x, pos.y + 20);
                self.show();
            }, 800
        );
    },
    
    /**
     * ツールチップの初期化を行う
     */
    _init: function (target, text) {
        var index = this.constructor.createLength;
        
        this.constructor.initStyle();
        
        var tip = Jeeel.Document.createElement('div');
        var textContent = Jeeel.Document.createElement('div');
        var ieShadowBox = Jeeel.Document.createElement('div');

        tip.id = this.constructor.CLASS.TOOLTIP + '-' + index;
        tip.className = this.constructor.CLASS.TOOLTIP;
        
        textContent.className = this.constructor.CLASS.TEXT_CONTENT;
        ieShadowBox.className = this.constructor.CLASS.IE_SHADOW_BOX;
        
        tip.appendChild(textContent);
        tip.appendChild(ieShadowBox);

        this._textContent = new Jeeel.Dom.ElementOperator(textContent);
        this._tooltip = new Jeeel.Dom.ElementOperator(tip);
        this._tooltip.hide();
        
        if (target) {
            this.setTarget(target);
        }
        
        if (text) {
            this.setText(text);
        }
        
        Jeeel.Document.appendToBody(tip);
        
        this.constructor.createLength++;
        
        this._styleTag = this.constructor._styleTag;
    }
};

Jeeel.Class.extend(Jeeel.Gui.Tooltip, Jeeel.Gui.Abstract);
Jeeel.directory.Jeeel.Gui.ColorPicker = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Gui + 'ColorPicker/';
    }
};

/**
 * コンストラクタ
 * 
 * @class カラーピッカーを扱うクラス
 * @augments Jeeel.Gui.Abstract
 * @param {Element} [appendTarget] 追加場所(デフォルトはbody)
 */
Jeeel.Gui.ColorPicker = function (appendTarget) {
    Jeeel.Gui.Abstract.call(this);
    
    this._targets = [];
//    this._pickerSize = {};
    this._init(appendTarget);
};

/**
 * インスタンスを作成する
 * 
 * @param {Element} [appendTarget] 追加場所(デフォルトはbody)
 * @return {Jeeel.Gui.ColorPicker} 作成したインスタンス
 */
Jeeel.Gui.ColorPicker.create = function (appendTarget) {
    return new this(appendTarget);
};

/**
 * カラーピッカー全インスタンス共通のスタイルを定義する
 */
Jeeel.Gui.ColorPicker.initStyle = function () {
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    Jeeel.Loader.preloadFile(Jeeel.directory.Jeeel.Gui.ColorPicker + 'hue.png');
    Jeeel.Loader.preloadFile(Jeeel.directory.Jeeel.Gui.ColorPicker + 'luminance.png');
    
    var className = this.CLASS.COLOR_PICKER;
    var style = 'div.' + className + ' {\n'
              + '  position: absolute;\n'
              + '  z-index: 10;\n'
              + '  width: auto;\n'
              + '  height: auto;\n'
              + '  border: 1px solid #B6BAC0;\n'
              + '  background-color: #F9FAFC;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.COLOR_PALLET + ' {\n'
              + '  position: absolute;\n'
              + '  border-left: 1px solid black;\n'
              + '  border-top: 1px solid black;\n'
              + '  border-right: 1px solid white;\n'
              + '  border-bottom: 1px solid white;\n'
              + '  padding: 0;\n'
              + '  margin: 0;\n'
              + '  cursor: pointer;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.COLOR_PALLET + ' div.' + this.CLASS.COLOR_INDICATOR + ' {\n'
              + '  background-color: transparent;\n'
              + '  border: 1px solid white;\n'
              + '  border-radius: 50%;\n'
              + '  -moz-border-border-radius: 50%;\n'
              + '  -webkit-border-radius: 50%;\n'
              + '  -o-border-radius: 50%;\n'
              + '  -ms-border-radius: 50%;\n'
              + '  position: absolute;\n'
              + '  left: 0px;\n'
              + '  top: 0px;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.LUMINANCE_BAR + ' {\n'
              + '  border-left: 1px solid black;\n'
              + '  border-top: 1px solid black;\n'
              + '  border-right: 1px solid white;\n'
              + '  border-bottom: 1px solid white;\n'
              + '  padding: 0;\n'
              + '  margin: 0;\n'
              + '  position: absolute;\n'
              + '  cursor: pointer;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.LUMINANCE_BAR + ' div.' + this.CLASS.LUMINANCE_BAR_BACKGROUND + ' {\n'
              + '  position: absolute;\n'
              + '  z-index: -1;\n'
              + '  left: 0px;\n'
              + '  top: 0px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.LUMINANCE_BAR + ' div.' + this.CLASS.LUMINANCE_INDICATOR + ' {\n'
              + '  background-color: transparent;\n'
              + '  border-top: 1px solid #888888;\n'
              + '  border-bottom: 1px solid #ffffff;\n'
              + '  position: absolute;\n'
              + '  height: 5px;\n'
              + '  left: 0px;\n'
              + '  top: 0px;\n'
              + '  overflow: hidden;\n'
              + '  z-index: 1;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.LUMINANCE_BAR + ' div.' + this.CLASS.LUMINANCE_INDICATOR + ' div {\n'
              + '  background-color: transparent;\n'
              + '  border-top: 1px solid #ffffff;\n'
              + '  border-bottom: 1px solid #888888;\n'
              + '  height: 3px;\n'
              + '  width: 100%;\n'
              + '  overflow: hidden;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.HEADER + ' {\n'
              + '  overflow: hidden;\n'
              + '  width: 100%;\n'
              + '  height: ' + this.STYLE.HEADER_HEIGHT + 'px;\n'
              + '  background-color: #DDDDDD;\n'
              + '  border-bottom: 1px solid #B6BAC0;\n'
              + '  font-family: Arial, sans-serif;\n'
              + '  white-space: nowrap;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.HEADER + ' span.' + this.CLASS.TITLE + ' {\n'
              + '  padding: 0;\n'
              + '  margin: 0;\n'
              + '  padding-top: 2px;\n'
              + '  height: ' + this.STYLE.HEADER_HEIGHT + 'px;\n'
              + '  width: 90%;\n'
              + '  display: inline-block;\n'
              + '  text-align: center;\n'
              + '  font-size: 10px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.HEADER + ' button.' + this.CLASS.CLOSE_BUTTON + ' {\n'
              + '  padding: 0;\n'
              + '  margin: 0;\n'
              + '  padding-left: 2px;\n'
              + '  padding-right: 2px;\n'
              + '  font-size: 10px;\n'
              + '  vertical-align: top;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' {\n'
              + '  position: absolute;\n'
              + '  overflow: hidden;\n'
              + '  height: ' + this.STYLE.FOOTER_HEIGHT + 'px;\n'
              + '  font-size: 0px;\n'
              + '  font-family: Arial, sans-serif;\n'
              + '  white-space: nowrap;\n'
              + '  padding: 4px 0 2px 2px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input {\n'
              + '  font-size: 11px;\n'
              + '  vertical-align: middle;\n'
              + '  padding: 0;\n'
              + '  margin: 0;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input.' + this.CLASS.COLOR_DISPLAY + ' {\n'
              + '  width: 30px;\n'
              + '  margin-right: 3px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input.' + this.CLASS.COLOR_TEXT_DISPLAY + ' {\n'
              + '  width: 50px;\n'
              + '  margin-right: 3px;\n'
              + '  padding-left: 3px;\n'
              + '  border-top-width: 1px;\n'
              + '  border-right-width: 1px;\n'
              + '  border-bottom-width: 1px;\n'
              + '  border-left-width: 1px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input.' + this.CLASS.OK_BUTTON + ' {\n'
              + '  margin: 0 3px 0 2px;\n'
              + '  padding-left: 2px;\n'
              + '  padding-right: 2px;\n'
              + '  font-size: 10px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.FOOTER + ' input.' + this.CLASS.CLOSE_BUTTON + ' {\n'
              + '  padding-left: 2px;\n'
              + '  padding-right: 2px;\n'
              + '  font-size: 10px;\n'
              + '}';

    this._styleTag = Jeeel.Loader.addStyle(style);
};

/**
 * @namespace スタイル定義に使う定数
 */
Jeeel.Gui.ColorPicker.STYLE = {
    COLOR_PICKER_PADDING: 5,
    BORDER_WIDTH: 1,
    LUMINANCE_BAR_WIDTH: 15,
    LUMINANCE_BAR_LEFT_MARGIN: 10,
    HEADER_HEIGHT: 18,
    FOOTER_HEIGHT: 24
};

/**
 * @namespace カラーピッカーのクラス名
 */
Jeeel.Gui.ColorPicker.CLASS = {
    COLOR_PICKER: 'jeeel-gui-color-picker',
    TABLE: 'jeeel-gui-color-picker-table',
    COLOR_PALLET: 'jeeel-gui-color-picker-color-pallet',
    LUMINANCE_BAR: 'jeeel-gui-color-picker-luminance-bar',
    LUMINANCE_BAR_BACKGROUND: 'jeeel-gui-color-picker-luminance-bar-background',
    LUMINANCE_BAR_FOREGROUND: 'jeeel-gui-color-picker-luminance-bar-foreground',
    COLOR_INDICATOR: 'jeeel-gui-color-picker-color-indicator',
    LUMINANCE_INDICATOR: 'jeeel-gui-color-picker-luminance-indicator',
    HEADER: 'jeeel-gui-color-picker-header',
    FOOTER: 'jeeel-gui-color-picker-footer',
    TITLE: 'jeeel-gui-color-picker-title',
    COLOR_DISPLAY: 'jeeel-gui-color-picker-color-display',
    COLOR_TEXT_DISPLAY: 'jeeel-gui-color-picker-color-text-display',
    OK_BUTTON: 'jeeel-gui-color-picker-ok-button',
    CLOSE_BUTTON: 'jeeel-gui-color-picker-close-button'
};

/**
 * カラーピッカーの作成個数
 * 
 * @type Integer
 */
Jeeel.Gui.ColorPicker.createLength = 0;

Jeeel.Gui.ColorPicker.prototype = {
    _targets: [],
    _currentTarget: null,
    _callback: null,
    _color: null,
    _size: {
        width: 150, 
        height: 150,
        grid: 1,
        gridie: 2
    },
    
    _pickerSize: {
        width: 189,
        height: 209
    },
    
    _colorPicker: null,
    
    _resizing: false,
    
    _items: null,
    
    /**
     * OKボタンを押した際に呼び出されるメソッドをセットする
     * 
     * @param {Function} callback void callback(Jeeel.Object.Color color, String colorText)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    setCallback: function (callback, thisArg) {
        this._resetTarget();
        
        this._callback = {func: callback, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * このインスタンスを紐付けるターゲットを追加する(コールバックの設定はキャンセルされる)
     * 
     * @param {Element} commonTarget 対象のElement(他の引数を指定しない場合このElementが他の引数と共通になる)
     * @param {Element} [textTarget] Textの値を受け取り専用のElement<br />
     *                                nullを渡すと省略と同じ意味になり、<br />
     *                                falseを渡せばTextの値の受け取りが無くなる
     * @param {Element} [bgTarget] BGカラー受け取り専用のElement<br />
     *                              nullを渡すと省略と同じ意味になり、<br />
     *                              falseを渡せばBGカラーの値の受け取りが無くなる
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    addTarget: function (commonTarget, textTarget, bgTarget) {
        
        var idx = this._targets.length;
        
        this._targets[idx] = {
            click: commonTarget,
            text: Jeeel.Type.isEmpty(textTarget) && commonTarget || textTarget,
            bg: Jeeel.Type.isEmpty(bgTarget) && commonTarget || bgTarget
        };
        
        Jeeel.Dom.Event.addEventListener(commonTarget, Jeeel.Dom.Event.Type.CLICK, this._toggle, this);
        
        this._callback = {
            func: this._targetCallback,            
            thisArg: this
        };
        
        return this;
    },
    
    /**
     * このインスタンスを紐付けるターゲットを削除する
     * 
     * @param {Element} commonTarget 対象のElement
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    removeTarget: function (commonTarget) {
        
        for (var i = this._targets.length; i--;) {
            if (this._targets[i].click === commonTarget) {
                Jeeel.Dom.Event.removeEventListener(commonTarget, Jeeel.Dom.Event.Type.CLICK, this._toggle);
                this._targets.splice(i, 1);
                break;
            }
        }
        
        return this;
    },
    
    /**
     * このインスタンスを紐付けるターゲットをセットする(コールバックの設定はキャンセルされる)
     * 
     * @param {Element} commonTarget 対象のElement(他の引数を指定しない場合このElementが他の引数と共通になる)
     * @param {Element} [textTarget] Textの値を受け取り専用のElement<br />
     *                                nullを渡すと省略と同じ意味になり、<br />
     *                                falseを渡せばTextの値の受け取りが無くなる
     * @param {Element} [bgTarget] BGカラー受け取り専用のElement<br />
     *                              nullを渡すと省略と同じ意味になり、<br />
     *                              falseを渡せばBGカラーの値の受け取りが無くなる
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     * @deprecated じきに無くなります
     */
    setTarget: function (commonTarget, textTarget, bgTarget) {
      
        this._resetTarget();
      
        this._currentTarget = {
            click: commonTarget,
            text: Jeeel.Type.isEmpty(textTarget) && commonTarget || textTarget,
            bg: Jeeel.Type.isEmpty(bgTarget) && commonTarget || bgTarget
        };
        
        Jeeel.Dom.ElementOperator.create(commonTarget).addClick(this._toggle, this);
        
        this._callback = {
            func: this._targetCallback,            
            thisArg: this
        };
        
        return this;
    },
    
    /**
     * カラーテキストの編集を許可するかどうかを設定する(カラーテキストの編集を可能にすると選択した色ではない文字列が帰ってくる可能性がある)
     * 
     * @param {Boolean} editable
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    editableColorText: function (editable) {
        this._items.colorTextDisplay.readOnly = !editable;
        
        return this;
    },
    
    /**
     * カラーピッカーを表示する
     * 
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    show: function () {
        if (this._resizing) {
            return this;
        }
        
        this._showElement(this._colorPicker, 10);
        
        return this;
    },

    /**
     * カラーピッカーを非表示にする
     * 
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    hide: function () {
        if (this._resizing) {
            return this;
        }
      
        this._hideElement(this._colorPicker, 10);
        
        return this;
    },
    
    /**
     * 指定の位置にカラーピッカーを移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    move: function (x, y) {
        var sty = this._colorPicker.style;
        
        sty.top = y + 'px';
        sty.left = x + 'px';
        
        return this;
    },
    
    /**
     * カラーピッカーの表示非表示を切り替える
     * 
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    toggle: function () {
        return this._colorPicker.style.display === 'none' ? this.show() : this.hide();
    },
    
    /**
     * 指定したカラーに設定する
     *
     * @param {Jeeel.Object.Color} color カラー
     * @return {Jeeel.Gui.ColorPicker} 自インスタンス
     */
    setColor: function (color) {
        this._color = color;
        
        this._drawLuminanceBar();
        this._updateSelectedColorInfo();
        this._updateIndicator();
        
        return this;
    },

    /**
     * 選択したカラーを取得する
     *
     * @return {Jeeel.Object.Color} カラー
     */
    getColor: function () {
        return this._color;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Gui.ColorPicker,
    
    /**
     * 内部的に表示を切り替える
     * 
     * @param {Jeeel.Dom.Event} e イベントオブジェクト
     */
    _toggle: function (e) {
        
        var target = e.currentTarget;
        var isUnMatch = true;
        
        for (var i = this._targets.length; i--;) {
            if (this._targets[i].click === target) {
                if (this._currentTarget === this._targets[i]) {
                    isUnMatch = false;
                }
                
                this._currentTarget = this._targets[i];
                break;
            }
        }
        
        var rect = Jeeel.Dom.Element.create(target).getRect();
        
        this.move(rect.endPoint.x + 10, rect.y);
        
        // 前のターゲットと違うターゲットで表示状態のままであった場合移動だけで終了する
        if (isUnMatch && this._colorPicker.style.display !== 'none') {
            return;
        }
        
        this.toggle();
    },
    
    /**
     * ターゲットを初期化する
     */
    _resetTarget: function () {
        if ( ! this._currentTarget) {
            return;
        }
        
        Jeeel.Dom.ElementOperator.create(this._currentTarget.click).removeClick(this._toggle);
        
        this._currentTarget = null;
    },
    
    _targetCallback: function (color, colorText) {
        var rgb = color.toRgb();
        var hsl = color.toHsl();

        if (this._currentTarget.bg) {
            this._currentTarget.bg.style.backgroundColor = rgb.toString();
        }

        if (this._currentTarget.text && 'value' in this._currentTarget.text) {
            this._currentTarget.text.value = colorText;

            if (this._currentTarget.bg === this._currentTarget.text) {
                var fontColor;

                if (hsl.luminance < 0.6) {
                    fontColor = '#ffffff';
                } else {
                    fontColor = '#000000';
                }

                this._currentTarget.text.style.color = fontColor;
            }
        }
    },
    
    _showElement: function (elm, rate) {
        elm = $ELM(elm);
        
        var size = this._pickerSize;
        var scalingSpeed = {w: size.width * rate / 100, h: size.height * rate / 100};
        var s = {w: 0, h: 0};
        
        elm.setStyleList({
            width: '0px',
            height: '0px',
            display: ''
        });
        
        var self = this;
        
        this._resizing = true;

        (function () {
            
            s.w += scalingSpeed.w;
            s.h += scalingSpeed.h;
            
            if (s.w > size.width) {
                s.w = size.width;
            }
            
            if (s.h > size.height) {
                s.h = size.height;
            }
            
            elm.setStyleList({
                width: s.w + 'px',
                height: s.h + 'px'
            });
            
            if (s.w < size.width || s.h < size.height) {
                setTimeout(arguments.callee, 16);
            } else {
                self._resizing = false;
            }
        })();
    },
    
    _hideElement: function (elm, rate) {
        elm = $ELM(elm);
        
        var size = elm.getSize();
        var scalingSpeed = {w: size.width * rate / 100, h: size.height * rate / 100};
        var s = {w: size.width, h: size.height};
        
        var self = this;
        
        this._resizing = true;

        (function () {
            
            s.w -= scalingSpeed.w;
            s.h -= scalingSpeed.h;
            
            if (s.w < 0) {
                s.w = 0;
            }
            
            if (s.h < 0) {
                s.h = 0;
            }
            
            elm.setStyleList({
                width: s.w + 'px',
                height: s.h + 'px'
            });
            
            if (s.w > 0 || s.h > 0) {
                setTimeout(arguments.callee, 16);
            } else {
                elm.setStyleList({
                    display: 'none',
                    width: size.width + 'px',
                    height: size.height + 'px'
                });
                
                self._resizing = false;
            }
        })();
    },

    _selectColor: function (ev, elm) {
        this.hide();
        
        if (this._callback) {
            this._callback.func.call(this._callback.thisArg || this, this._color, this._items.colorTextDisplay.value);
        }
    },
    
    _selectButtonSwitch: function (e, elm) {
        if (elm === this._items.okButton) {
            this._selectColor(e, elm);
        } else  {
            this.hide();
        }
    },
    
    _mouseDownSwitch: function (e, elm) {
        if (elm === this._items.colorPallet) {
            this._palletMouseDown(e, elm);
        } else  {
            this._luminanceMouseDown(e, elm);
        }
    },
    
    _mouseMoveSwitch: function (e, elm) {
        if (elm === this._items.colorPallet) {
            this._palletMouseMove(e, elm);
        } else  {
            this._luminanceMouseMove(e, elm);
        }
    },
    
    _mouseUpSwitch: function (e, elm) {
        if (elm === this._items.colorPallet) {
            this._palletMouseCancel(e, elm);
        } else  {
            this._luminanceMouseCancel(e, elm);
        }
    },
    
    _palletMouseDown: function (ev, elm) {
        if (this._items.colorIndicatorEnableMove) {
            return;
        }
        
        this._items.colorIndicatorEnableMove = true;
        
        this._palletMouseMove(ev, elm);
    },
    
    _palletMouseMove: function (ev, elm) {
        ev.stop();
        
        if ( ! this._items.colorIndicatorEnableMove) {
            return;
        }
        
        var cindStyle = this._items.colorIndicator.style;
        var size = this._size;
        var p = ev.getRelativeMousePoint(this._items.colorPallet);
        var x = p.x - 2;
        var y = p.y - 2;
        
        if (x < 0) {
            x = 0;
        } else if (x > size.width) {
            x = size.width;
        }
        
        if (y < 0) {
            y = 0;
        } else if (y > size.height) {
            y = size.height;
        }
        
        cindStyle.left = x + 'px';
        cindStyle.top = y + 'px';
        
        var hsl = this._color.toHsl();
        var h = x * 359 / size.width;
        var s = 1 - y / size.height;
        
        this._color = Jeeel.Object.Color.createHsl(h, s, hsl.luminance);
        
        this._drawLuminanceBar();
        
        this._updateSelectedColorInfo();
    },
    
    _palletMouseCancel: function (ev, elm) {
        if (this._items.colorIndicatorEnableMove) {
            this._palletMouseMove(ev, elm);
            this._items.colorIndicatorEnableMove = false;
        }
    },
    
    _luminanceMouseDown: function (ev, elm) {
        if (this._items.luminanceIndicatorEnableMove) {
            return;
        }
        
        this._items.luminanceIndicatorEnableMove = true;
        
        this._luminanceMouseMove(ev, elm);
    },
    
    _luminanceMouseMove: function (ev, elm) {
        ev.stop();
        
        if ( ! this._items.luminanceIndicatorEnableMove) {
            return;
        }
        
        var lind = this._items.luminanceIndicator;
        var size = this._size;
        var p = ev.getRelativeMousePoint(this._items.luminanceBar);
        var y = p.y - 2;
        
        if (y < 0) {
            y = 0;
        } else if (y > size.height) {
            y = size.height;
        }
        
        lind.style.top = y + 'px';
        
        var hsl = this._color.toHsl();
        var l = 1 - y / size.height;
        
        this._color = Jeeel.Object.Color.createHsl(hsl.hue, hsl.saturation, l);
        
        this._updateSelectedColorInfo();
    },
    
    _luminanceMouseCancel: function (ev, elm) {
        this._items.luminanceIndicatorEnableMove = false;
    },
    
    _mouseCancel: function (ev, elm) {
      
        // カラーテキスト上でのイベントを許可
        if (ev.target.className === this.constructor.CLASS.COLOR_TEXT_DISPLAY) {
            return;
        }
        
        this._palletMouseCancel(ev, elm);
        this._luminanceMouseCancel(ev, elm);
        
        ev.stop();
    },
    
    _changeColorText: function (ev) {
        
        // 貼り付けイベントだった場合は遅延実行させる
        if (ev && ev.type === Jeeel.Dom.Event.Type.PASTE) {
            Jeeel.Deferred.next(this._changeColorText, this);
            return;
        }
        
        var key = ev && ev.getKeyCode();
        
        switch (key) {
            case Jeeel.Dom.Event.KeyCode.Up:
            case Jeeel.Dom.Event.KeyCode.Down:
            case Jeeel.Dom.Event.KeyCode.Left:
            case Jeeel.Dom.Event.KeyCode.Right:
            case Jeeel.Dom.Event.KeyCode.Home:
            case Jeeel.Dom.Event.KeyCode.End:
            case Jeeel.Dom.Event.KeyCode.Ctrl:
                return;
                break;
            
            default:
                break;
        }
        
        if (ev && ev.ctrlKey) {
            return;
        }
        
        var ctdText = this._items.colorTextDisplay.value;
        
        if ( ! ctdText.match(/^#[0-9A-F]{6}$/i)) {
            return;
        }
        
        var color = Jeeel.Object.Color.create(ctdText);
        
        this.setColor(color);
    },
    
    _updateSelectedColorInfo: function () {
        var cd = this._items.colorDisplay;
        var ctd = this._items.colorTextDisplay;
        var ctxt = this._color.toRgb().toString();
        
        cd.style.backgroundColor = ctxt;
        ctd.value = ctxt;
    },
    
    _hslToRgbCss: function (hsl) {
        var rgb = Jeeel.Object.Color.calculateRgb(hsl.h, hsl.s, hsl.l);
        
        rgb = [
            Jeeel.Number.limit(Math.round(rgb.red), 0, 255).toString(16),
            Jeeel.Number.limit(Math.round(rgb.green), 0, 255).toString(16),
            Jeeel.Number.limit(Math.round(rgb.blue), 0, 255).toString(16)
        ];

        for (var i = 3; i--;) {
            if (rgb[i].length < 2) {
                rgb[i] = '0' + rgb[i];
            }
        }
        
        return '#' + rgb.join('');
    },
    
    _updateIndicator: function () {
        var hsl = this._color.toHsl();

        var cindStyle = this._items.colorIndicator.style;
        var lindStyle = this._items.luminanceIndicator.style;
        var lumiStyle = this._items.luminanceBar.style;
        
        lindStyle.top = (parseInt(lumiStyle.height) * (1 - hsl.luminance)) + "px";
        
        cindStyle.left = (this._size.width * hsl.hue / 360) + "px";
        cindStyle.top  = (this._size.height * (1 - hsl.saturation)) + "px";
    },
    
    _drawPallet: function () {
        var el = this._items.colorPallet;
        var img = Jeeel.Document.createElement('img');
        
        img.src = Jeeel.directory.Jeeel.Gui.ColorPicker + 'hue.png';
        img.width = this._size.width;
        img.height = this._size.height;
        img.style.margin = "0px";
        img.style.padding = "0px";
        
        el.appendChild(img);
    },
    
    /**
     * 明度のバーを描画する
     */
    _drawLuminanceBar: function () {
        var el = this._items.luminanceBarBg;

        var hsl = this._color.toHsl();
        var col = {h: hsl.hue, s: 1, l: 0.5};
        
        // BG色を変える
        el.style.backgroundColor = this._hslToRgbCss(col);
    },
    
    _eventStop: function (e) {
        e.stop();
    },
    
    /**
     * 初期化を行う
     */
    _init: function (appendTarget) {
        var index = this.constructor.createLength;
        
        this.constructor.initStyle();

        var p = this._size;

        var colorPicker = Jeeel.Document.createElement('div');
        colorPicker.className = this.constructor.CLASS.COLOR_PICKER;
        colorPicker.id = this.constructor.CLASS.COLOR_PICKER + '-' + index;

        this._colorPicker = colorPicker;
        
        var colorPallet = Jeeel.Document.createElement('div');
        var luminanceBar = Jeeel.Document.createElement('div');
        var header = Jeeel.Document.createElement('div');
        var footer = Jeeel.Document.createElement('div');

        colorPallet.className = this.constructor.CLASS.COLOR_PALLET;
        luminanceBar.className = this.constructor.CLASS.LUMINANCE_BAR;
        header.className = this.constructor.CLASS.HEADER;
        footer.className = this.constructor.CLASS.FOOTER;
        
        this._color = Jeeel.Object.Color.createHsl(180, 0.5, 0.5);
        var borderBothWidth = this.constructor.STYLE.BORDER_WIDTH * 2;
        
        Jeeel.Dom.Element.create(colorPallet).setStyleList({
            width: p.width + 'px',
            height: p.height + 'px',
            top: '0px',
            left: '0px'
        });
        
        Jeeel.Dom.Element.create(luminanceBar).setStyleList({
            width: this.constructor.STYLE.LUMINANCE_BAR_WIDTH + 'px',
            height: p.height + 'px',
            top: '0px',
            left: p.width + this.constructor.STYLE.LUMINANCE_BAR_LEFT_MARGIN + 'px'
        });
        
        var footerWidth = p.width
                        + borderBothWidth
                        + this.constructor.STYLE.LUMINANCE_BAR_LEFT_MARGIN
                        + this.constructor.STYLE.LUMINANCE_BAR_WIDTH
                        + borderBothWidth;
        
        Jeeel.Dom.Element.create(footer).setStyleList({
            width: footerWidth + 'px',
            left: this.constructor.STYLE.COLOR_PICKER_PADDING + 'px',
            top: p.height + this.constructor.STYLE.COLOR_PICKER_PADDING * 2 + borderBothWidth + this.constructor.STYLE.HEADER_HEIGHT + 'px'
        });
        
        var pickerWidth = footerWidth
                        + this.constructor.STYLE.COLOR_PICKER_PADDING
                        + this.constructor.STYLE.COLOR_PICKER_PADDING;
        
        var pickerHeight = p.height
                         + borderBothWidth
                         + this.constructor.STYLE.HEADER_HEIGHT
                         + this.constructor.STYLE.FOOTER_HEIGHT
                         + this.constructor.STYLE.COLOR_PICKER_PADDING * 3;
                      
        Jeeel.Dom.Element.create(colorPicker).setStyleList({
            width: pickerWidth + 'px',
            height: pickerHeight + 'px'
        });
        
        this._items = {
            colorPallet: colorPallet,
            luminanceBar: luminanceBar,
            luminanceBarWrapper: new Jeeel.Dom.Element(luminanceBar)
        };
        
        var title = Jeeel.Document.createElement('span');
        var close = Jeeel.Document.createElement('button');
        
        title.innerHTML = 'Color Picker';
        title.className = this.constructor.CLASS.TITLE;
        close.innerHTML = '&#215;';
        close.className = this.constructor.CLASS.CLOSE_BUTTON;

        header.appendChild(title);
        header.appendChild(close);
        
        var colorDisplay = Jeeel.Document.createElement('input');
        var colorTextDisplay = Jeeel.Document.createElement('input');
        var okButton = Jeeel.Document.createElement('input');
        var closeButton = Jeeel.Document.createElement('input');
        
        colorDisplay.className = this.constructor.CLASS.COLOR_DISPLAY;
        colorTextDisplay.className = this.constructor.CLASS.COLOR_TEXT_DISPLAY;
        okButton.className = this.constructor.CLASS.OK_BUTTON;
        closeButton.className = this.constructor.CLASS.CLOSE_BUTTON;
        
        colorDisplay.type = colorTextDisplay.type = 'text';
        okButton.type = closeButton.type = 'button';
        
        colorDisplay.disabled = true;
        
        colorTextDisplay.maxLength = 7;
        
        var ctxt = this._color.toRgb().toString();
        colorDisplay.style.backgroundColor = ctxt;
        colorTextDisplay.value = ctxt;
        
        okButton.value = ' O K ';
        closeButton.value = 'Close';
        
        footer.appendChild(colorDisplay);
        footer.appendChild(colorTextDisplay);
        footer.appendChild(okButton);
        footer.appendChild(closeButton);
        
        this._items.okButton = okButton;
        this._items.colorDisplay = colorDisplay;
        this._items.colorTextDisplay = colorTextDisplay;
        
        var colorIndicator = Jeeel.Document.createElement('div');
        var luminanceIndicator = Jeeel.Document.createElement('div');
        var luminanceInnerIndicator = Jeeel.Document.createElement('div');
        var luminanceBarImg = Jeeel.Document.createElement('img');
        var luminanceBarBg = Jeeel.Document.createElement('div');
        
        colorIndicator.className = this.constructor.CLASS.COLOR_INDICATOR;
        luminanceIndicator.className = this.constructor.CLASS.LUMINANCE_INDICATOR;
        luminanceBarImg.className = this.constructor.CLASS.LUMINANCE_BAR_FOREGROUND;
        luminanceBarBg.className = this.constructor.CLASS.LUMINANCE_BAR_BACKGROUND;
        
        luminanceIndicator.appendChild(luminanceInnerIndicator);
        
        luminanceBarImg.src = Jeeel.directory.Jeeel.Gui.ColorPicker + 'luminance.png';
        luminanceBarImg.width = this.constructor.STYLE.LUMINANCE_BAR_WIDTH;
        luminanceBarImg.height = this._size.height;
        luminanceBarImg.style.margin = "0px";
        luminanceBarImg.style.padding = "0px";
        
        luminanceBar.appendChild(luminanceIndicator);
        luminanceBar.appendChild(luminanceBarImg);
        luminanceBar.appendChild(luminanceBarBg);
        
        Jeeel.Dom.Element.create(luminanceBarBg).setStyleList({
            width: this.constructor.STYLE.LUMINANCE_BAR_WIDTH + 'px',
            height: p.height + 'px'
        });
        
        var isIEQuirks = !!(Jeeel._doc.uniqueID && Jeeel._doc.compatMode === "BackCompat");
        
        Jeeel.Dom.Element.create(colorIndicator).setStyleList({
            width: isIEQuirks ? "5px" : "3px",
            height: isIEQuirks ? "5px" : "3px"
        });
        
        Jeeel.Dom.Element.create(luminanceIndicator).setStyleList({
            width: this.constructor.STYLE.LUMINANCE_BAR_WIDTH + 'px'
        });
        
        this._items.colorIndicator = colorIndicator;
        this._items.luminanceIndicator = luminanceIndicator;
        this._items.luminanceBarBg = luminanceBarBg;
        
        this._items.colorIndicatorEnableMove = false;
        this._items.luminanceIndicatorEnableMove = false;
        
        Jeeel.Dom.ElementOperator.create(colorTextDisplay)
             .addEvent(Jeeel.Dom.Event.Type.PASTE, this._changeColorText, this)
             .addEvent(Jeeel.Dom.Event.Type.KEY_UP, this._changeColorText, this);
        
        Jeeel.Dom.ElementOperator.create(colorPicker)
             .addEvent(Jeeel.Dom.Event.Type.CLICK, this._eventStop, this)
             .addEvent(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._mouseCancel, this);

        var body = Jeeel.Document.createElement('div');
        
        Jeeel.Dom.Element.create(body).setStyleList({
            width: p.width + borderBothWidth + this.constructor.STYLE.LUMINANCE_BAR_LEFT_MARGIN + this.constructor.STYLE.LUMINANCE_BAR_WIDTH + 'px',
            height: p.height + 'px',
            left: this.constructor.STYLE.COLOR_PICKER_PADDING + this.constructor.STYLE.BORDER_WIDTH + 'px',
            top: this.constructor.STYLE.COLOR_PICKER_PADDING + this.constructor.STYLE.BORDER_WIDTH + this.constructor.STYLE.HEADER_HEIGHT + 'px',
            position: 'absolute',
            overflow: 'hidden',
            padding: '0',
            margin: '0'
        });

        body.appendChild(colorPallet);
        body.appendChild(luminanceBar);
        
        colorPicker.appendChild(header);
        colorPicker.appendChild(body);
        colorPicker.appendChild(footer);
        
        Jeeel.Dom.ElementOperator.create([colorPallet, luminanceBar])
             .delegate(Jeeel.Dom.Event.Type.MOUSE_DOWN, this._mouseDownSwitch, this)
             .delegate(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._mouseMoveSwitch, this)
             .delegate(Jeeel.Dom.Event.Type.MOUSE_UP, this._mouseUpSwitch, this);
        
        Jeeel.Dom.ElementOperator.create([okButton, closeButton, close])
             .delegate(Jeeel.Dom.Event.Type.CLICK, this._selectButtonSwitch, this);
        
        Jeeel.Function.create(this._initFinish).bind(this).delay(15)(appendTarget);

        this.constructor.createLength++;
    },
    
    _initFinish: function (appendTarget) {
        Jeeel.Dom.Element.create(this._colorPicker).hide().setShim();

        this._drawPallet();
        this._drawLuminanceBar();
        this._updateIndicator();

        if (appendTarget) {
            Jeeel.Dom.Element.create(appendTarget).appendChild(this._colorPicker);
        } else {
            Jeeel.Document.appendToBody(this._colorPicker);
        }

        this._items.colorPallet.appendChild(this._items.colorIndicator);
        
        this._styleTag = this.constructor._styleTag;
    }
};

Jeeel.Class.extend(Jeeel.Gui.ColorPicker, Jeeel.Gui.Abstract);
Jeeel.directory.Jeeel.Gui.Scrollbar = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Gui + 'Scrollbar/';
    }
};

/**
 * @namespace スクロールバー関連のネームスペース
 */
Jeeel.Gui.Scrollbar = {
    
};

Jeeel.file.Jeeel.Gui.Scrollbar = ['Vertical', 'Horizontal'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Gui.Scrollbar, Jeeel.file.Jeeel.Gui.Scrollbar);

/**
 * コンストラクタ
 * 
 * @class 垂直スクロールバーを単体で扱うクラス
 * @augments Jeeel.Gui.Abstract
 */
Jeeel.Gui.Scrollbar.Vertical = function () {
    this._init();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Gui.Scrollbar.Vertical} 作成したインスタンス
 */
Jeeel.Gui.Scrollbar.Vertical.create = function () {
    return new this();
};

Jeeel.Gui.Scrollbar.Vertical.MIN_HEIGHT = 30;

Jeeel.Gui.Scrollbar.Vertical.CLASS = {
    SCROLLBAR: 'jeeel-gui-scrollbar-vertical',
    INNER: 'jeeel-gui-scrollbar-vertical-inner'
};

/**
 * 垂直スクロールバー全インスタンス共通のスタイルを定義する
 */
Jeeel.Gui.Scrollbar.Vertical.initStyle = function () {
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    var className = this.CLASS.SCROLLBAR;
    var style = 'div.' + className + ' {\n'
              + '  position: relative;\n'
              + '  width: 18px;\n'
              + '  height: 100px;\n'
              + '  cursor: pointer;\n'
              + '  margin-top: -1px;\n'
              + '  border: 1px #EEEDE5 solid;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.INNER + ' {\n'
              + '  position: absolute;\n'
              + '  width: 16px;\n'
              + '  height: 60px;\n'
              + '  background-color: #C2D5FC;\n'
              + '  text-align: center;\n'
              + '  line-height: 60px;\n'
              + '  color: #666;\n'
              + '  overflow: hidden;\n'
              + '  border: 1px #FFFFFF solid;\n'
              + '  cursor: pointer;\n'
              + '  font-size: 16px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.INNER + ':hover {\n'
              + '  background-color: #D6E7FF;\n'
              + '}';

    this._styleTag = Jeeel.Loader.addStyle(style);
};

Jeeel.Gui.Scrollbar.Vertical.prototype = {
    _scrollbarHeight: 100,
    _innerHeight: 200,
    _barHeight: 60,
    _barTopMax: 38,
    _scrollDy: 1,
    _scrollTop: 0,
    _scrollTopMax: 100,
    _scrollDelta: 20,
    
    _scrollbar: null,
    _innerBar: null,
    
    _scrollHandlers: [],
    _scrollable: false,
    _startPoint: null,
    
    /**
     * スクロールバーHTML要素を返す
     * 
     * @return {Element} スクロールバー
     */
    getScrollbar: function () {
        return this._scrollbar;
    },
    
    /**
     * スクロールイベントを登録する
     * 
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Eventで固定)
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    addScrollEvent: function (listener, thisArg, var_args) {
        var args = Array.prototype.slice.call(arguments, 2, arguments.length);
        
        args.unshift(null);
        
        this._scrollHandlers[this._scrollHandlers.length] = {
            listener: listener,
            thisArg: thisArg || this,
            args: args
        };
        
        return this;
    },
    
    /**
     * このスクロールバーに対応するコンテナの高さを設定する
     * 
     * @param {Integer} height 高さ
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    setContainerHeight: function (height) {
        this._innerHeight = +height;
        
        this._innerBar.style.height = this._innerHeight + 'px';
        
        return this._resize();
    },
    
    /**
     * このスクロールバーに対応するコンテナの高さを取得する
     * 
     * @return {Integer} 高さ
     */
    getContainerHeight: function () {
        return this._innerHeight;
    },
    
    /**
     * スクロールバー自体の高さを設定する
     * 
     * @param {Integer} height 高さ
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    setScrollHeight: function (height) {
        this._scrollbarHeight = +height;
        
        this._scrollbar.style.height = (this._scrollbarHeight + 1) + 'px';
        
        return this._resize();
    },
    
    /**
     * スクロールバー自体の高さを取得する
     * 
     * @return {Integer} 高さ
     */
    getScrollHeight: function () {
        return this._scrollbarHeight;
    },
    
    /**
     * スクロールのトップ座標を設定する
     * 
     * @param {Number} top トップ座標
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    setScrollTop: function (top) {
        top = Jeeel.Number.limit(+top, 0, this._scrollTopMax);

        var barTop = top / this._scrollDy;
        
        this._scrollTop = top;
        this._innerBar.style.top = barTop + 'px';
        
        return this;
    },
    
    /**
     * スクロールのトップ座標を取得する
     * 
     * @return {Number} トップ座標
     */
    getScrollTop: function () {
        return this._scrollTop;
    },
    
    /**
     * スクロールバーをスクロールする
     * 
     * @param {Number} [delta] スクロール量(1に対して1ホイール分に相当する, +で上に、-で下に進む)
     * @param {Boolean} [doDispatch] スクロールイベントを発生させるかどうか
     * @return {Jeeel.Gui.Scrollbar.Vertical} 自インスタンス
     */
    scroll: function (delta, doDispatch) {
        this.setScrollTop(this._scrollTop + (this._scrollDelta * -delta) || 0);
        
        doDispatch && this._callHandlers(null);
        
        return this;
    },
    
    /**
     * スクロール可能かどうかを返す
     * 
     * @param {Boolean} [isUp] 方向が上かどうか
     * @return {Boolean} スクロール可能かどうか
     */
    canScroll: function (isUp) {
        return isUp ? this.canScrollUp() : this.canScrollDown();
    },
    
    /**
     * 上にスクロールが可能かどうかを返す
     * 
     * @return {Boolean} 上にスクロール可能かどうか
     */
    canScrollUp: function () {
        return this._scrollTop > 0;
    },
    
    /**
     * 下にスクロールが可能かどうかを返す
     * 
     * @return {Boolean} 下にスクロール可能かどうか
     */
    canScrollDown: function () {
        return this._scrollTop < this._scrollTopMax;
    },
    
    _resize: function () {
        var barHeight = this._scrollbarHeight / this._innerHeight * this._scrollbarHeight;

        if (barHeight < this.constructor.MIN_HEIGHT) {
            barHeight = this.constructor.MIN_HEIGHT;
        }
        
        this._barTopMax = this._scrollbarHeight - barHeight;
        this._scrollTopMax = this._innerHeight - this._scrollbarHeight;
        this._scrollDy = this._scrollTopMax / this._barTopMax;
        this._scrollDelta = barHeight * this._scrollDy / 3;
        
        this._barHeight = barHeight;
        this._innerBar.style.height = barHeight + 'px';
        this._innerBar.style.lineHeight = barHeight + 'px';
        
        return this;
    },
    
    _onClick: function (event) {
        event.stop();
        
        if (this._scrollable || event.target !== this._scrollbar) {
            return;
        }
        
        var op = (event.getRelativeMousePoint(this._innerBar).y < 0 ? -1 : 1);
        
        this.setScrollTop(this._scrollTop + op * this._barHeight * this._scrollDy);
        
        this._callHandlers(event);
    },
    
    _onScroll: function (event) {
        if (this._scrollable) {
            return;
        }
        
        var op = (event.mouseWheel > 0 ? -1 : 1);
        var up = op < 0;
        
        if (this.canScroll(up)) {
            event.stop();
            
            this.setScrollTop(this._scrollTop + op * this._scrollDelta);

            this._callHandlers(event);
        }
    },
    
    _onMouseDown: function (event) {
        event.stop();
        
        this._scrollable = true;
        
        this._startPoint = event.getRelativeMousePoint(this._innerBar);
    },
    
    _onMouseMove: function (event) {
        if ( ! this._scrollable) {
            return;
        }
        
        event.stop();
        
        var top = event.getRelativeMousePoint(this._scrollbar).y
                - this._startPoint.y;
              
        top = Jeeel.Number.limit(top, 0, this._barTopMax);
        
        this._innerBar.style.top = top + 'px';
        this.setScrollTop(top * this._scrollDy);
        
        this._callHandlers(event);
    },
    
    _onMouseUp: function (event) {
        if (this._scrollable) {
            event.stop();

            this._scrollable = false;
        }
    },
    
    _callHandlers: function (event) {
        for (var i = 0, l = this._scrollHandlers.length; i < l; i++) {
            var listener = this._scrollHandlers[i].listener;
            var thisArg  = this._scrollHandlers[i].thisArg;
            var args     = this._scrollHandlers[i].args;
            
            args[0] = event;
            
            listener.apply(thisArg, args);
            
            args[0] = null;
        }
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Gui.Scrollbar.Vertical,
    
    _init: function () {
        this.constructor.initStyle();
        var scrollbar = Jeeel.Document.createElement('div');
        var inner = Jeeel.Document.createElement('div');
        
        this._scrollHandlers = [];
        
        scrollbar.className = this.constructor.CLASS.SCROLLBAR;
        inner.className = this.constructor.CLASS.INNER;
        
        inner.innerHTML = '▒';
        
        this._scrollbar = scrollbar;
        this._innerBar = inner;
        
        this._scrollbar.appendChild(this._innerBar);
        
        Jeeel.Dom.Event.addEventListener(this._scrollbar, Jeeel.Dom.Event.Type.CLICK, this._onClick, this);
        Jeeel.Dom.Event.addEventListener(this._scrollbar, Jeeel.Dom.Event.Type.MOUSE_WHEEL, this._onScroll, this);
        Jeeel.Dom.Event.addEventListener(this._innerBar, Jeeel.Dom.Event.Type.MOUSE_DOWN, this._onMouseDown, this);
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._onMouseMove, this);
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, this._onMouseUp, this);
    }
};

Jeeel.Class.extend(Jeeel.Gui.Scrollbar.Vertical, Jeeel.Gui.Abstract);

/**
 * コンストラクタ
 * 
 * @class 水平スクロールバーを単体で扱うクラス
 * @augments Jeeel.Gui.Abstract
 */
Jeeel.Gui.Scrollbar.Horizontal = function () {
    this._init();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Gui.Scrollbar.Horizontal} 作成したインスタンス
 */
Jeeel.Gui.Scrollbar.Horizontal.create = function () {
    return new this();
};

Jeeel.Gui.Scrollbar.Horizontal.MIN_WIDTH = 30;

Jeeel.Gui.Scrollbar.Horizontal.CLASS = {
    SCROLLBAR: 'jeeel-gui-scrollbar-horizontal',
    INNER: 'jeeel-gui-scrollbar-horizontal-inner'
};

/**
 * 水平スクロールバー全インスタンス共通のスタイルを定義する
 */
Jeeel.Gui.Scrollbar.Horizontal.initStyle = function () {
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    var className = this.CLASS.SCROLLBAR;
    var style = 'div.' + className + ' {\n'
              + '  position: relative;\n'
              + '  width: 100px;\n'
              + '  height: 18px;\n'
              + '  cursor: pointer;\n'
              + '  margin-left: -1px;\n'
              + '  border: 1px #EEEDE5 solid;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.INNER + ' {\n'
              + '  position: absolute;\n'
              + '  width: 60px;\n'
              + '  height: 16px;\n'
              + '  background-color: #C2D5FC;\n'
              + '  text-align: center;\n'
              + '  color: #666;\n'
              + '  overflow: hidden;\n'
              + '  border: 1px #FFFFFF solid;\n'
              + '  cursor: pointer;\n'
              + '  font-size: 16px;\n'
              + '}\n'
              + 'div.' + className + ' div.' + this.CLASS.INNER + ':hover {\n'
              + '  background-color: #D6E7FF;\n'
              + '}';

    this._styleTag = Jeeel.Loader.addStyle(style);
};

Jeeel.Gui.Scrollbar.Horizontal.prototype = {
    _scrollbarWidth: 100,
    _innerWidth: 200,
    _barWidth: 60,
    _barLeftMax: 38,
    _scrollDx: 1,
    _scrollLeft: 0,
    _scrollLeftMax: 100,
    _scrollDelta: 20,
    
    _scrollbar: null,
    _innerBar: null,
    
    _scrollHandlers: [],
    _scrollable: false,
    _startPoint: null,
    
    /**
     * スクロールバーHTML要素を返す
     * 
     * @return {Element} スクロールバー
     */
    getScrollbar: function () {
        return this._scrollbar;
    },
    
    /**
     * スクロールイベントを登録する
     * 
     * @param {Function} listener 登録イベントメソッド
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Eventで固定)
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    addScrollEvent: function (listener, thisArg, var_args) {
        var args = Array.prototype.slice.call(arguments, 2, arguments.length);
        
        args.unshift(null);
        
        this._scrollHandlers[this._scrollHandlers.length] = {
            listener: listener,
            thisArg: thisArg || this,
            args: args
        };
        
        return this;
    },
    
    /**
     * このスクロールバーに対応するコンテナの幅を設定する
     * 
     * @param {Integer} width 幅
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    setContainerWidth: function (width) {
        this._innerWidth = +width;
        
        this._innerBar.style.width = this._innerWidth + 'px';
        
        return this._resize();
    },
    
    /**
     * このスクロールバーに対応するコンテナの幅を取得する
     * 
     * @return {Integer} 幅
     */
    getContainerWidth: function () {
        return this._innerWidth;
    },
    
    /**
     * スクロールバー自体の幅を設定する
     * 
     * @param {Integer} width 幅
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    setScrollWidth: function (width) {
        this._scrollbarWidth = +width;
        
        this._scrollbar.style.width = (this._scrollbarWidth + 1) + 'px';
        
        return this._resize();
    },
    
    /**
     * スクロールバー自体の幅を取得する
     * 
     * @return {Integer} 幅
     */
    getScrollWidth: function () {
        return this._scrollbarWidth;
    },
    
    /**
     * スクロールのレフト座標を設定する
     * 
     * @param {Number} left レフト座標
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    setScrollLeft: function (left) {
        left = Jeeel.Number.limit(+left, 0, this._scrollLeftMax);

        var barLeft = left / this._scrollDx;
        
        this._scrollLeft = left;
        this._innerBar.style.left = barLeft + 'px';
        
        return this;
    },
    
    /**
     * スクロールのレフト座標を取得する
     * 
     * @return {Number} レフト座標
     */
    getScrollLeft: function () {
        return this._scrollLeft;
    },
    
    /**
     * スクロールバーをスクロールする
     * 
     * @param {Number} [delta] スクロール量(1に対して1ホイール分に相当する, +で左に、-で右に進む)
     * @param {Boolean} [doDispatch] スクロールイベントを発生させるかどうか
     * @return {Jeeel.Gui.Scrollbar.Horizontal} 自インスタンス
     */
    scroll: function (delta, doDispatch) {
        this.setScrollLeft(this._scrollLeft + (this._scrollDelta * -delta) || 0);
        
        doDispatch && this._callHandlers(null);
        
        return this;
    },
    
    /**
     * スクロール可能かどうかを返す
     * 
     * @param {Boolean} [isLeft] 方向が左かどうか
     * @return {Boolean} スクロール可能かどうか
     */
    canScroll: function (isLeft) {
        return isLeft ? this.canScrollLeft() : this.canScrollRight();
    },
    
    /**
     * 左にスクロールが可能かどうかを返す
     * 
     * @return {Boolean} 左にスクロール可能かどうか
     */
    canScrollLeft: function () {
        return this._scrollLeft > 0;
    },
    
    /**
     * 右にスクロールが可能かどうかを返す
     * 
     * @return {Boolean} 右にスクロール可能かどうか
     */
    canScrollRight: function () {
        return this._scrollLeft < this._scrollLeftMax;
    },
    
    _resize: function () {
        var barWidth = this._scrollbarWidth / this._innerWidth * this._scrollbarWidth - 2;

        if (barWidth < this.constructor.MIN_WIDTH) {
            barWidth = this.constructor.MIN_WIDTH;
        }
        
        this._barLeftMax = this._scrollbarWidth - barWidth - 2;
        this._scrollLeftMax = this._innerWidth - this._scrollbarWidth;
        this._scrollDx = this._scrollLeftMax / this._barLeftMax;
        this._scrollDelta = barWidth * this._scrollDx / 3;
        
        this._barWidth = barWidth;
        this._innerBar.style.width = barWidth + 'px';
        
        return this;
    },
    
    _onClick: function (event) {
        event.stop();
        
        if (this._scrollable || event.target !== this._scrollbar) {
            return;
        }
        
        var op = (event.getRelativeMousePoint(this._innerBar).x < 0 ? -1 : 1);
        
        this.setScrollLeft(this._scrollLeft + op * this._barWidth * this._scrollDx);
        
        this._callHandlers(event);
    },
    
    _onScroll: function (event) {
        if (this._scrollable) {
            return;
        }
        
        var op = (event.mouseWheel > 0 ? -1 : 1);
        var lf = op < 0;
          
        if (this.canScroll(lf)) {
            event.stop();
            
            this.setScrollLeft(this._scrollLeft + op * this._scrollDelta);

            this._callHandlers(event);
        }
    },
    
    _onMouseDown: function (event) {
        event.stop();
        
        this._scrollable = true;
        
        this._startPoint = event.getRelativeMousePoint(this._innerBar);
    },
    
    _onMouseMove: function (event) {
        if ( ! this._scrollable) {
            return;
        }
        
        event.stop();
        
        var left = event.getRelativeMousePoint(this._scrollbar).x
                - this._startPoint.x;
              
        left = Jeeel.Number.limit(left, 0, this._barLeftMax);
        
        this._innerBar.style.left = left + 'px';
        this.setScrollLeft(left * this._scrollDx);
        
        this._callHandlers(event);
    },
    
    _onMouseUp: function (event) {
        if (this._scrollable) {
            event.stop();

            this._scrollable = false;
        }
    },
    
    _callHandlers: function (event) {
        for (var i = 0, l = this._scrollHandlers.length; i < l; i++) {
            var listener = this._scrollHandlers[i].listener;
            var thisArg  = this._scrollHandlers[i].thisArg;
            var args     = this._scrollHandlers[i].args;
            
            args[0] = event;
            
            listener.apply(thisArg, args);
            
            args[0] = null;
        }
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Gui.Scrollbar.Horizontal,
    
    _init: function () {
        this.constructor.initStyle();
        var scrollbar = Jeeel.Document.createElement('div');
        var inner = Jeeel.Document.createElement('div');
        
        this._scrollHandlers = [];
        
        scrollbar.className = this.constructor.CLASS.SCROLLBAR;
        inner.className = this.constructor.CLASS.INNER;
        
        inner.innerHTML = '▒';
        
        this._scrollbar = scrollbar;
        this._innerBar = inner;
        
        this._scrollbar.appendChild(this._innerBar);
        
        Jeeel.Dom.Event.addEventListener(this._scrollbar, Jeeel.Dom.Event.Type.CLICK, this._onClick, this);
        Jeeel.Dom.Event.addEventListener(this._scrollbar, Jeeel.Dom.Event.Type.MOUSE_WHEEL, this._onScroll, this);
        Jeeel.Dom.Event.addEventListener(this._innerBar, Jeeel.Dom.Event.Type.MOUSE_DOWN, this._onMouseDown, this);
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._onMouseMove, this);
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, this._onMouseUp, this);
    }
};

Jeeel.Class.extend(Jeeel.Gui.Scrollbar.Horizontal, Jeeel.Gui.Abstract);

/**
 * コンストラクタ
 * @class カレンダーを扱うクラス
 * @param {Boolean} [multiSelect] 日付複数選択するかどうか
 */
Jeeel.Gui.Calendar = function (multiSelect) { 
    Jeeel.Gui.Abstract.call(this);
    
    this._init(multiSelect);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Boolean} [multiSelect] 日付複数選択するかどうか
 * @return {Jeeel.Gui.Calendar} 作成したインスタンス
 */
Jeeel.Gui.Calendar.create = function (multiSelect) {
    return new this(multiSelect);
};

Jeeel.Gui.Calendar.CLASS = {
    CALENDAR: 'jeeel-gui-calendar',
    HEADER: 'jeeel-gui-header',
    BODY: 'jeeel-gui-body',
    FOOTER: 'jeeel-gui-footer',
    BUTTON: 'jeeel-gui-button',
    POPUPABLE: 'jeeel-gui-popupable',
    DRAG: 'jeeel-gui-drag',
    HELP: 'jeeel-gui-help',
    CLOSE: 'jeeel-gui-close',
    DECISION: 'jeeel-gui-decision',
    TITLE: 'jeeel-gui-title',
    MESSAGE: 'jeeel-gui-message',
    HIGHLIGHT: 'jeeel-gui-highlight',
    ACTIVE: 'jeeel-gui-active',
    TABLE: 'jeeel-gui-table',
    TABLE_HEADER: 'jeeel-gui-table-header',
    TABLE_HEADER_TITLE: 'jeeel-gui-table-header-title',
    TABLE_HEADER_WEEK: 'jeeel-gui-table-header-week',
    TABLE_DATA: 'jeeel-gui-table-data',
    
    DAYS: [
        'jeeel-gui-calendar-day-sunday',
        'jeeel-gui-calendar-day-monday',
        'jeeel-gui-calendar-day-tuesday',
        'jeeel-gui-calendar-day-wednesday',
        'jeeel-gui-calendar-day-thursday',
        'jeeel-gui-calendar-day-friday',
        'jeeel-gui-calendar-day-saturday'
    ],
    
    TODAY: 'jeeel-gui-calendar-today',
    WEEK: 'jeeel-gui-calendar-week',
    DATE: 'jeeel-gui-calendar-date',
    SELECT: 'jeeel-gui-calendar-date-select',
    
    DATE_OPERATOR: 'jeeel-gui-date-operator',
    DATE_OPERATOR_PREV: 'jeeel-gui-date-operator-prev',
    DATE_OPERATOR_NEXT: 'jeeel-gui-date-operator-next',
    DATE_OPERATOR_TODAY: 'jeeel-gui-date-operator-today'
};

Jeeel.Gui.Calendar._initStyle = function () {
        
    if (arguments.callee.ignore) {
        return;
    }
    
    arguments.callee.ignore = true;
    
    var classNames = Jeeel.Gui.Calendar.CLASS;

    var css = '.' + classNames.CALENDAR + ' {\n'
            + '  width: 200px;\n'
            + '  height: auto;\n'
            + '  background-color: white;\n'
            + '  border: black 1px solid;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' {\n'
            + '  border-spacing: 0;\n'
            + '  width: 100%;\n'
            + '  height: 100%;\n'
            + '  font-size: 16px;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' .' + classNames.TABLE_HEADER_WEEK + ' {\n'
            + '  background-color: #BBDDFF;\n'
            + '  border-right: black 1px solid;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' * {\n'
            + '  border: 0;\n'
            + '  color: black;\n'
            + '  margin: 0;\n'
            + '  padding: 0;\n'
            + '  text-align: center;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BUTTON + ' {\n'
            + '  text-align: center;\n'
            + '  cursor: pointer;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + '.' + classNames.POPUPABLE + ' .' + classNames.DRAG + ' {\n'
            + '  cursor: move;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' {\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' tr {\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' th {\n'
            + '  width: 17px;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' .' + classNames.DATE_OPERATOR + ' td {\n'
            + '  background-color: #467AA7;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' .' + classNames.DATE_OPERATOR + ' td:hover {\n'
            + '  background-color: #80B0DA;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' .' + classNames.TABLE_HEADER + ' {\n'
            + '  background-color: #BBDDFF;\n'
            + '  font-weight: bold;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.HEADER + ' .' + classNames.TABLE_HEADER + ' th {\n'
            + '  border-bottom: black 1px solid;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' .' + classNames.DAYS[0] + ' {\n'
            + '  color: #E33;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' .' + classNames.DAYS[6] + ' {\n'
            + '  color: #33E;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.TABLE + ' .' + classNames.TODAY + ' {\n'
            + '  border: 1px solid black;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' {\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' tr {\n'
            + '  height: 18px;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.TABLE_HEADER + ' {\n'
            + '  font-weight: bold;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.TABLE_DATA + ' {\n'
            + '  text-align: center;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + '.' + classNames.HIGHLIGHT + ' td.' + classNames.ACTIVE + ' {\n'
            + '  background-color: #DEF;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + '.' + classNames.HIGHLIGHT + ' td.' + classNames.ACTIVE + '.' + classNames.SELECT + ' {\n'
            + '  background-color: #EBCBD3;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + '.' + classNames.HIGHLIGHT + ' td.' + classNames.TABLE_HEADER_WEEK + ' {\n'
            + '  background-color: #80B0DA;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + ' .' + classNames.TABLE_DATA + '.' + classNames.ACTIVE + '.' + classNames.HIGHLIGHT + ' {\n'
            + '  background-color: #80B0DA;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + ' .' + classNames.TABLE_DATA + '.' + classNames.ACTIVE + '.' + classNames.SELECT + ' {\n'
            + '  background-color: #F9A7A7;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.BODY + ' .' + classNames.WEEK + ' .' + classNames.TABLE_DATA + '.' + classNames.ACTIVE + '.' + classNames.SELECT + '.' + classNames.HIGHLIGHT + ' {\n'
            + '  background-color: #BDACC1;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.FOOTER + ' {\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.FOOTER + ' tr td {\n'
            + '  border-top: black 1px solid;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.FOOTER + ' .' + classNames.MESSAGE + ' {\n'
            + '  vertical-align: middle;\n'
            + '  font-size: 13px;\n'
            + '}\n'
            + '.' + classNames.CALENDAR + ' .' + classNames.FOOTER + ' .' + classNames.DECISION + ' {\n'
            + '  vertical-align: middle;\n'
            + '  font-size: 15px;\n'
            + '}\n';

    this._defaultStyle = css;
    this._styleTag = Jeeel.Loader.addStyle(css);
};

Jeeel.Gui.Calendar.prototype = {
    
    /**
     * ポップアップ可能かどうか
     * 
     * @type Boolean
     * @private
     */
    _popupable: false,
    
    /**
     * 日付複数選択するかどうか
     * 
     * @type Boolean
     * @private
     */
    _multiSelect: false,
    
    /**
     * 日付の選択が決定した場合のコールバック
     * 
     * @type Function
     * @private
     */
    _okCallback: null,
    
    /**
     * カレンダーの要素
     * 
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _calendar: null,
   
    /**
     * 現在表示の日付
     * 
     * @type Jeeel.Object.Date
     * @private
     */
    _date: null,
    
    /**
     * 現在選択中の日付リスト
     * 
     * @type Jeeel.Object.Date[]
     * @private
     */
    _selectDates: [],
    
    _dragData: {
        enable: false
    },
    
    /**
     * 現在の選択済みの日付を取得する
     * 
     * @return {Jeeel.Object.Date} 日付
     */
    getSelectedDate: function () {
        return this._selectDates[0] || null;
    },
    
    /**
     * 現在の選択済みの日付リストを取得する
     * 
     * @return {Jeeel.Object.Date[]} 日付リスト
     */
    getSelectedDates: function () {
        return this._selectDates;
    },
    
    /**
     * 指定した日付を選択する
     * 
     * @param {Jeeel.Object.Date|Date|String|Integer} date 日付を示す値
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    selectDate: function (date) {
        var tmp = new Jeeel.Object.Date(date);
        
        this._selectDates[this._selectDates.length] = Jeeel.Object.Date.createDate(tmp.year, tmp.month, tmp.date);
        
        return this._refreshSelected();
    },
    
    /**
     * 指定した年月日を選択する
     * 
     * @param {Integer} year 年
     * @param {Integer} month 月
     * @param {Integer} day 日
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    selectYmd: function (year, month, day) {
        this._selectDates[this._selectDates.length] = Jeeel.Object.Date.createDate(year, month, day);

        return this._refreshSelected();
    },
    
    /**
     * 表示中の日付を指定した日付に変更する
     * 
     * @param {Jeeel.Object.Date|Date|String|Integer} date 日付を示す値
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeDate: function (date) {
        var prev = this._date;
        
        var tmp = new Jeeel.Object.Date(date);
        
        this._date = Jeeel.Object.Date.createDate(tmp.year, tmp.month, tmp.date);
        
        return this._redraw(prev);
    },
    
    /**
     * 表示中の日付を指定した年月日に変更する
     * 
     * @param {Integer} year 年
     * @param {Integer} month 月
     * @param {Integer} day 日
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeYmd: function (year, month, day) {
         var prev = this._date;
         
        this._date = Jeeel.Object.Date.createDate(year, month, day);
        
        return this._redraw(prev);
    },
    
    /**
     * 表示中の日付を今日に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeToday: function () {
        return this.changeDate();
    },
    
    /**
     * 表示中の日付を前月に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changePrevMonth: function () {
        return this.changeYmd(this._date.year, this._date.month - 1, 1);
    },
    
    /**
     * 表示中の日付を翌月に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeNextMonth: function () {
        return this.changeYmd(this._date.year, this._date.month + 1, 1);
    },
    
    /**
     * 表示中の日付を前年に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changePrevYear: function () {
        return this.changeYmd(this._date.year - 1, this._date.month, 1);
    },
    
    /**
     * 表示中の日付を翌年に変更する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    changeNextYear: function () {
        return this.changeYmd(this._date.year + 1, this._date.month, 1);
    },
    
    /**
     * カレンダーを表示する
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    show: function () {
        
        this._calendar.show();
        
        return this;
    },
    
    /**
     * カレンダーを非表示にする
     * 
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    hide: function () {
        
        this._calendar.hide();
        
        return this;
    },
    
    /**
     * 日付選択を決定した際に呼ばれるコールバックを設定する
     * 
     * @param {Function} callback コールバック
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    setDecisionCallback: function (callback) {
        
        if ( ! Jeeel.Type.isFunction(callback)) {
            throw new Error('callbackが関数ではありません。');
        }
        
        this._okCallback = callback;
        
        return this;
    },
    
    /**
     * カレンダーの要素を取得する
     * 
     * @return {Element} カレンダー要素
     */
    getCalendarElement: function () {
        return this._calendar.get(0);
    },
    
    /**
     * ポップアップの有効・無効を設定する
     * 
     * @param {Boolean} enable ポップアップ化を有効にするかどうか
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    enablePopup: function (enable) {
        var pos = (enable ? 'absolute' : '');
        var zi  = (enable ? '100' : '');
        
        this._calendar.setCss('position', pos)
                      .setCss('z-index', zi);
        
        if (enable) {
            this._calendar.addClass(this.constructor.CLASS.POPUPABLE)
                          .$CLASS(this.constructor.CLASS.CLOSE)
                          .setCss('visibility', 'visible');
        } else {
            this._calendar.removeClass(this.constructor.CLASS.POPUPABLE)
                          .$CLASS(this.constructor.CLASS.CLOSE)
                          .setCss('visibility', 'hidden');
        }
        
        this._popupable = !!enable;

        return this;
    },
    
    /**
     * このElementを指定座標に移動する
     * 
     * @param {Integer} x X座標
     * @param {Integer} y Y座標
     * @return {Jeeel.Gui.Calendar} 自インスタンス
     */
    shiftTo: function (x, y) {
        this._calendar.shiftTo(x, y);
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Boolean} [multiSelect] 日付複数選択するかどうか
     * @constructor
     */
    constructor: Jeeel.Gui.Calendar,
    
    _refreshSelected: function () {
        
        if ( ! this._multiSelect) {
            this._selectDates = [this._selectDates[this._selectDates.length - 1]];
            this._ok();
            this._redraw(this._date);
            
            return this;
        }
        
        var len = this._selectDates.length,
            res = [];
        
        outerLoop: for (var i = 0; i < len; i++) {
            
            var resLen = res.length;
            
            for (var j = 0; j < resLen; j++) {
                if (res[j].year === this._selectDates[i].year && res[j].month === this._selectDates[i].month && res[j].date === this._selectDates[i].date) {
                    res.splice(j, 1);
                    break outerLoop;
                }
            }
            
            res[resLen] = this._selectDates[i];
        }
        
        this._selectDates = res;
        
        return this._redraw(this._date);
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _selectDate: function (ev) {
        var target = Jeeel.Dom.Element.create(ev.target);
        
        if (target.hasClassName(this.constructor.CLASS.DATE)) {
            var date = +target.getText();
            
            if (date) {
                this.selectYmd(this._date.year, this._date.month, date);
            }
        }
    },
    
    _resetState: function () {
        this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('日付を選択してください');
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _changeState: function (ev) {
        var target = Jeeel.Dom.Element.create(ev.target);
        var txt, highlightTarget;
        
        if (target.hasClassName(this.constructor.CLASS.DRAG)) {
            
            txt = this._popupable ? 'ドラッグ可能' : '日付を選択してください';
            
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText(txt);
        }
        else if (target.hasClassName(this.constructor.CLASS.HELP)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('ヘルプ');
        }
        else if (target.hasClassName(this.constructor.CLASS.CLOSE)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('キャンセル');
        }
        else if (target.hasClassName(this.constructor.CLASS.DATE)) {
            
            var date = +target.getText();
            
            if (date) {
                highlightTarget = target;
                
                date = Jeeel.Object.Date.createDate(this._date.year, this._date.month, date);
                
                txt = date.toString('m月d日(D)');
                
                if (target.hasClassName(this.constructor.CLASS.TODAY)) {
                    txt += '(今日)';
                }
                
                this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText(txt);
            } else {
                this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('日付を選択してください');
            }
        } 
        else if (target.hasClassName(this.constructor.CLASS.DATE_OPERATOR_TODAY)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('今日');
        }
        else if (target.hasClassName(this.constructor.CLASS.DATE_OPERATOR_NEXT)) {
            var nt = target.getText();
            
            txt = '翌' + ((nt === '>') ? '月' : '年');
            
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText(txt);
        }
        else if (target.hasClassName(this.constructor.CLASS.DATE_OPERATOR_PREV)) {
            var pt = target.getText();
            
            txt = '前' + ((pt === '<') ? '月' : '年');
          
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText(txt);
        } 
        else if (target.hasClassName(this.constructor.CLASS.TABLE_HEADER_WEEK)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('日付を選択してください');
        } 
        else if (target.hasClassName(this.constructor.CLASS.TABLE_HEADER_TITLE)) {
            this._calendar.$CLASS(this.constructor.CLASS.MESSAGE).setText('日付を選択してください');
        }
        
        this._highlight(highlightTarget);
    },
    
    _highlight: function (date) {
        this._calendar.$CLASS(this.constructor.CLASS.HIGHLIGHT).removeClass(this.constructor.CLASS.HIGHLIGHT);
        
        if (date) {
            Jeeel.Dom.Element.create(date.addClassName(this.constructor.CLASS.HIGHLIGHT).getParentNode())
                             .addClassName(this.constructor.CLASS.HIGHLIGHT);
        }
    },
    
    _cancel: function () {
        this._selectDates = [];
        
        this.hide();
        this._redraw(this._date);
    },
    
    _ok: function () {
        if (this._popupable) {
            this.hide();
        }
        
        if (this._okCallback) {
            this._okCallback(this);
        }
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _drag: function (ev) {
        if ( ! this._dragData.enable) {
            return;
        }
        
        ev.stop();
        
        var bpoint = this._dragData.point;
        var apoint = ev.mousePoint;
        
        var top  = apoint.y - bpoint.y;
        var left = apoint.x - bpoint.x;
        
        this._calendar.setCss('top', top + 'px')
                      .setCss('left', left + 'px');
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _dragOn: function (ev) {
        this._dragData.enable = true;
        this._dragData.point = ev.getRelativeMousePoint(this._calendar.get(0));
        
        Jeeel.Document.addEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._drag, this)
                      .addEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, this._dragOff, this);
    },
    
    /**
     * @param {Jeeel.Dom.Event} ev
     */
    _dragOff: function (ev) {
        this._dragData.enable = false;
        
        Jeeel.Document.removeEventListener(Jeeel.Dom.Event.Type.MOUSE_MOVE, this._drag)
                      .removeEventListener(Jeeel.Dom.Event.Type.MOUSE_UP, this._dragOff);
    },
    
    _isSelected: function (year, month, day) {
        for (var i = 0, l = this._selectDates.length; i < l; i++) {
            
            var date = this._selectDates[i];
            
            if (date.year == year && date.month == month && date.date == day) {
                return true;
            }
        }
        
        return false;
    },
    
    _redraw: function (prevDate) {
        var today   = Jeeel.Object.Date.createDate();
        var toMonth = Jeeel.Object.Date.createDate(this._date.year, this._date.month, 1);
        
        if (toMonth.year !== today.year || toMonth.month !== today.month) {
            today = null;
        }
        
        var dates = toMonth.getDatesOfMonth();
        var l = Jeeel.Object.Date.getDays().length;
        var title = this._calendar.$CLASS(this.constructor.CLASS.TITLE);
        var body = this._calendar.$CLASS(this.constructor.CLASS.WEEK);
        
        title.setText(toMonth.toString('Y年m月'));
        
        var mi = -toMonth.getDay();
        
        for (var i = 0; i < 6; i++) {
            var weekTr = body.$GET(i);
            var week = weekTr.$CLASS(this.constructor.CLASS.DATE);
            
            var hide = true;
            
            for (var w = 0; w < l; w++) {
                var date = week.$GET(w);
                var txt  = dates[mi] || '';
                
                date.setText(txt);
                
                if (today && today.date == txt) {
                    date.addClass(this.constructor.CLASS.TODAY);
                } else {
                    date.removeClass(this.constructor.CLASS.TODAY);
                }
                
                if (this._isSelected(toMonth.year, toMonth.month, txt)) {
                    date.addClass(this.constructor.CLASS.SELECT);
                } else {
                    date.removeClass(this.constructor.CLASS.SELECT);
                }
                
                if (txt) {
                    hide = false;
                    date.addClass(this.constructor.CLASS.ACTIVE);
                } else {
                    date.removeClass(this.constructor.CLASS.ACTIVE);
                }
                
                mi++;
            }
            
            if (hide) {
                weekTr.hide();
            } else {
                weekTr.show();
            }
        }
        
        return this;
    },
    
    /**
     * Elementの作成を行う
     * 
     * @param {String} tagName 作成タグ名
     * @return {Jeeel.Dom.ElementOperator} 作成タグのラッパー
     */
    _createElm: function (tagName) {
        var tag = Jeeel.Document.createElement(tagName);
        
        return Jeeel.Dom.ElementOperator.create(tag);
    },
    
    _init: function (multiSelect) {
        
        if (multiSelect) {
            this._multiSelect = true;
        }
      
        var calendar = this._createElm('table');
        var header   = this._createElm('thead');
        var body     = this._createElm('tbody');
        var footer   = this._createElm('tfoot');
        
        calendar.addClass(this.constructor.CLASS.TABLE)
                .appendChild(header)
                .appendChild(body)
                .appendChild(footer);
                
        header.addClass(this.constructor.CLASS.HEADER);
        body.addClass(this.constructor.CLASS.BODY);
        footer.addClass(this.constructor.CLASS.FOOTER);
        
        var topBar = this._createElm('tr');
        var title = this._createElm('td');
        var help   = this._createElm('td');
        var close  = this._createElm('td');

        title.addClass([this.constructor.CLASS.DRAG, this.constructor.CLASS.TITLE])
             .setProp('colSpan', 6);
             
        help.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.HELP])
            .setCss('visibility', 'hidden');
            
        close.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.CLOSE])
             .addClick(this._cancel, this);
        
        help.setText('?');
        close.setText('×');
        
        topBar.appendChild([help, title, close]);
        
        var opBar  = this._createElm('tr');
        var pYear  = this._createElm('td');
        var pMonth = this._createElm('td');
        var today  = this._createElm('td');
        var nMonth = this._createElm('td');
        var nYear  = this._createElm('td');
        
        opBar.addClass(this.constructor.CLASS.DATE_OPERATOR);
        pYear.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_PREV])
              .addClick(this.changePrevYear, this);
        
        pMonth.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_PREV])
             .addClick(this.changePrevMonth, this);
        
        nYear.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_NEXT])
              .addClick(this.changeNextYear, this);
        
        nMonth.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_NEXT])
             .addClick(this.changeNextMonth, this);
        
        today.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DATE_OPERATOR_TODAY])
             .addClick(this.changeToday, this)
             .setProp('colSpan', 4);
        
        pYear.setText('<<');
        pMonth.setText('<');
        today.setText('今日');
        nMonth.setText('>');
        nYear.setText('>>');
        
        opBar.appendChild([pYear, pMonth, today, nMonth, nYear]);
        
        var tr, th, td, w, l = Jeeel.Object.Date.getDays().length;
        var dayClasses = this.constructor.CLASS.DAYS;
        var weekTitle = this._createElm('tr')
                            .addClass(this.constructor.CLASS.TABLE_HEADER);
        
        th = this._createElm('th');
        th.addClass([this.constructor.CLASS.TABLE_HEADER_TITLE, this.constructor.CLASS.TABLE_HEADER_WEEK])
          .setText('週');
        
        weekTitle.appendChild(th);
        
        for (w = 0; w < l; w++) {
            th = this._createElm('th');
            th.addClass([this.constructor.CLASS.TABLE_HEADER_TITLE, dayClasses[w]])
              .setText(Jeeel.Object.Date.getDays()[w].substr(0, 1));
            
            weekTitle.appendChild(th);
        }
        
        header.appendChild([topBar, opBar, weekTitle]);
        
        body.addClass(this.constructor.CLASS.DATE_TABLE)
            .addClick(this._selectDate, this);

        var date = Jeeel.Object.Date.create();
        today = date;
        
        this._date = date;
        
        title.setText(date.toString('Y年m月'));
        date = Jeeel.Object.Date.create(date.toString('Y-m-1'));
        
        var dates = date.getDatesOfMonth();
        var mi = - date.getDay();
        
        for (var i = 0; i < 6; i++) {
            tr = this._createElm('tr').addClass(this.constructor.CLASS.WEEK);
            td = this._createElm('td');
            td.addClass([this.constructor.CLASS.TABLE_DATA, this.constructor.CLASS.TABLE_HEADER_WEEK])
              .setText(i + 1);
                  
            tr.appendChild(td);
            
            var hide = true;
            
            for (w = 0; w < l; w++) {
                var txt = dates[mi] || '';
                
                td = this._createElm('td');
                td.addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.TABLE_DATA, this.constructor.CLASS.DATE, dayClasses[w]])
                  .setText(txt);
                  
                if (today.date == txt) {
                    td.addClass(this.constructor.CLASS.TODAY);
                }
                
                if (txt) {
                    hide = false;
                    td.addClass(this.constructor.CLASS.ACTIVE);
                } else {
                    td.removeClass(this.constructor.CLASS.ACTIVE);
                }

                tr.appendChild(td);
                
                mi++;
            }
            
            if (hide) {
                tr.hide();
            }
            
            body.appendChild(tr);
        }
        
        tr = this._createElm('tr');
        td = this._createElm('td');
        
        td.setProp('colSpan', 8)
          .addClass([this.constructor.CLASS.DRAG, this.constructor.CLASS.MESSAGE])
          .setText('日付を選択して下さい');
          
        tr.appendChild(td);
        
        footer.appendChild(tr);
        
        tr = this._createElm('tr');
        td = this._createElm('td');

        td.setProp('colSpan', 8)
          .addClass([this.constructor.CLASS.BUTTON, this.constructor.CLASS.DECISION])
          .addClick(this._ok, this)
          .setText('決定');
          
        tr.appendChild(td);
        
        if ( ! this._multiSelect) {
            tr.hide();
        }
        
        footer.appendChild(tr);
        
        var parent = this._createElm('div');
        
        this._calendar = parent.addMouseMove(this._changeState, this)
                               .addOut(this._resetState, this)
                               .addClass(this.constructor.CLASS.CALENDAR)
                               .appendChild(calendar);
                               
        this._calendar.$CLASS(this.constructor.CLASS.DRAG)
                      .addMouseDown(this._dragOn, this);
        
        this.enablePopup(false);
        Jeeel.Document.appendToBody(this._calendar.get(0));
                      
        this.constructor._initStyle();
        
        this._defaultStyle = this.constructor._defaultStyle;
        this._styleTag = this.constructor._styleTag;
    }
};

Jeeel.Class.extend(Jeeel.Gui.Calendar, Jeeel.Gui.Abstract);
Jeeel.directory.Jeeel.Gui.Mouse = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Gui + 'Mouse/';
    }
};

/**
 * @namespace マウス関連のGUIネームスペース
 */
Jeeel.Gui.Mouse = {

    /**
     * リスナ対象となるオブジェクト
     *
     * @type Element|Document|Window
     * @private
     */
    _currentTarget: Jeeel._doc,

    /**
     * 初期化を終えたかどうか
     *
     * @type Boolean
     * @private
     */
    _inited: false,

    /**
     * マウスの現在位置
     *
     * @type Jeeel.Object.Point
     * @private
     */
    _point: new Jeeel.Object.Point(0, 0),

    /**
     * マウスボタンの押されている判別子
     *
     * @type Object
     * @private
     */
    _button: {
        left: false,
        right: false,
        middle: false
    },

    /**
     * マウス情報の取得のためのリスナー
     * 
     * @private
     */
    _listener: function () {
        var ev = Jeeel.Dom.Event.getEventObject();
        Jeeel.Gui.Mouse._point = ev.mousePoint.clone();

        this._button.left   = ev.isLeftDown;
        this._button.right  = ev.isRightDown;
        this._button.middle = ev.isMiddleDown;
    },

    /**
     * マウス情報を取得するための初期化を行う<br />
     * 常にマウスを追いかけるためやや重い<br />
     * このメソッドを呼んでいないと、他のメソッドが意味をなさない
     */
    init: function () {
        if (this._inited) {
            return;
        }

        Jeeel.Dom.Event.addEventListener(this._currentTarget, Jeeel.Dom.Event.Type.MOUSE_MOVE, this._listener);
        this._inited = true;
    },

    /**
     * マウス情報を取得するための初期化処理を無効化する
     */
    clear: function () {
        if ( ! this._inited) {
            return;
        }

        Jeeel.Dom.Event.removeEventListener(this._currentTarget, Jeeel.Dom.Event.Type.MOUSE_MOVE, this._listener);
        this._inited = false;
    },

    /**
     * マウスの左ボタンが押されているかどうか
     *
     * @return {Boolean}
     */
    isLeftDown: function () {
        return this._button.left;
    },

    /**
     * マウスの右ボタンが押されているかどうか
     *
     * @return {Boolean}
     */
    isRightDown: function () {
        return this._button.right;
    },

    /**
     * マウスの中央ボタンが押されているかどうか
     * 
     * @return {Boolean}
     */
    isMiddleDown: function () {
        return this._button.middle;
    },

    /**
     * マウスの現在位置を取得する
     * 
     * @return {Jeeel.Object.Point} マウス位置
     */
    getPoint: function () {
        return Jeeel.Gui.Mouse.point;
    },

    /**
     * マウスの現在位置のX座標を取得する
     *
     * @return {Integer}
     */
    getX: function () {
        return Jeeel.Gui.Mouse.point.x;
    },

    /**
     * マウスの現在位置のY座標を取得する
     *
     * @return {Integer}
     */
    getY: function () {
        return Jeeel.Gui.Mouse.point.y;
    }
};

Jeeel.file.Jeeel.Gui.Mouse = ['Gesture'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Gui.Mouse, Jeeel.file.Jeeel.Gui.Mouse);

/**
 * コンストラクタ
 *
 * @class マウスジェスチャーを管理するクラス
 * @param {Element|Document|Window} [target] ジェスチャーの対象になるオブジェクト
 * @param {Integer} [sensitivityPlay] マウスの感度の遊び
 */
Jeeel.Gui.Mouse.Gesture = function (target, sensitivityPlay) {
    if ( ! target) {
        target = Jeeel.Gui.Mouse._currentTarget;
    }

    if (Jeeel.Type.isInteger(sensitivityPlay)) {
        this._sensitivityPlay = sensitivityPlay;
    }

    this._target = target;
    this._onMouseDown.bind(this);
    this._onMouseUp.bind(this);
    this._onMouseMove.bind(this);
};

/**
 * インスタンスの作成を行う
 *
 * @param {Element|Document|Window} [target] ジェスチャーの対象になるオブジェクト
 * @param {Integer} [sensitivityPlay] マウスの感度の遊び
 * @return {Jeeel.Gui.Mouse.Gesture} 作成したインスタンス
 */
Jeeel.Gui.Mouse.Gesture.create = function (target, sensitivityPlay) {
    return new this(target, sensitivityPlay);
};

Jeeel.Gui.Mouse.Gesture.prototype = {

    /**
     * マウス感度の遊び
     *
     * @type Integer
     * @protected
     */
    _sensitivityPlay: 10,

    /**
     * ジェスチャー対象となるオブジェクト
     *
     * @type Element|Document|Window
     * @protected
     */
    _target: null,

    /**
     * マウスジェスチャーが始動しているかどうか
     *
     * @type Boolean
     * @protected
     */
    _started: false,

    /**
     * 現在実行されているかどうか
     *
     * @type Boolean
     * @protected
     */
    _active: false,

    /**
     * アクティブになった時のコールバック
     *
     * @type Function
     * @protected
     */
    _activeCallback: null,

    /**
     * アクティブが解除された時のコールバック
     * 
     * @type Function
     * @protected
     */
    _inactiveCallback: null,

    /**
     * ジェスチャーした地点のリスト
     *
     * @type Jeeel.Object.Point[]
     * @protected
     */
    _pointList: [],

    /**
     * ジェスチャーした方向のリスト
     *
     * @type Integer[]
     * @protected
     */
    _gestureList: [],

    /**
     * ジェスチャーのマウスボタンを右クリックで行うかどうか(通常はfalse)
     *
     * @type Boolean
     * @protected
     */
    _isRight: false,

    /**
     * マウスが押し込まれた時の動作
     *
     * @type Jeeel.Function
     * @protected
     */
    _onMouseDown: Jeeel.Function.create(function () {

        if (this._active) {
            return;
        }

        var ev = Jeeel.Dom.Event.getEventObject();

        if ((this._isRight && ! ev.isRightDown) ||
            ( ! this._isRight && ! ev.isLeftDown))
        {
            return;
        }

        this._gestureList = [];
        this._pointList   = [];
        
        this._active = true;
        this._pointList.push(ev.mousePoint.clone());

        if (this._activeCallback) {
            this._activeCallback.call(this);
        }

    }),

    /**
     * マウスのボタンを上げた時の動作
     *
     * @type Jeeel.Function
     * @protected
     */
    _onMouseUp: Jeeel.Function.create(function () {

        if ( ! this._active) {
            return;
        }

        var ev = Jeeel.Dom.Event.getEventObject();

        if ((this._isRight && ev.isRightDown) ||
            ( ! this._isRight && ! ev.isLeftDown))
        {
            return;
        }
        
        this._active = false;

        if (this._inactiveCallback) {
            this._inactiveCallback.call(this, this.getGestureList());
        }

    }),

    /**
     * マウスが移動したときのイベント
     *
     * @type Jeeel.Function
     * @protected
     */
    _onMouseMove: Jeeel.Function.create(function () {

        if ( ! this._active) {
            return;
        }
        
        var ev = Jeeel.Dom.Event.getEventObject();

        if ((this._isRight && ! ev.isRightDown) ||
            ( ! this._isRight && ! ev.isLeftDown)){
            this._active = false;

            if (this._inactiveCallback) {
                this._inactiveCallback.call(this, this.getGestureList());
            }
            
            return;
        }

        var oldGesture = this._gestureList[this._pointList.length - 2];
        var newGesture;

        var oldPoint = this._pointList[this._pointList.length - 1];
        var newPoint = ev.mousePoint;
        var hLength  = newPoint.x - oldPoint.x;
        var vLength  = newPoint.y - oldPoint.y;

        if (Math.abs(hLength) > Math.abs(vLength) + this._sensitivityPlay) {
            newGesture = (hLength < 0 ? Jeeel.Dom.Event.KeyCode.Left : Jeeel.Dom.Event.KeyCode.Right);
        } else if (this._sensitivityPlay + Math.abs(hLength) < Math.abs(vLength)) {
            newGesture = (vLength < 0 ? Jeeel.Dom.Event.KeyCode.Up : Jeeel.Dom.Event.KeyCode.Down);
        } else {
            return;
        }

        if (oldGesture && oldGesture === newGesture) {
            this._pointList[this._pointList.length - 1] = newPoint.clone();
            return;
        }

        this._gestureList.push(newGesture);
        this._pointList.push(newPoint.clone());
        
    }),

    /**
     * マウスジェスチャーを開始する
     *
     * @return {Jeeel.Gui.Mouse.Gesture} 自インスタンス
     */
    start: function () {

        if (this._started) {
            return this;
        }

        Jeeel.Dom.Event.addEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_DOWN, this._onMouseDown);
        Jeeel.Dom.Event.addEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_UP,   this._onMouseUp);
        Jeeel.Dom.Event.addEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_MOVE, this._onMouseMove);
        this._started = true;

        return this;
    },

    /**
     * マウスジェスチャーを終了する
     *
     * @return {Jeeel.Gui.Mouse.Gesture} 自インスタンス
     */
    end: function () {

        if ( ! this._started) {
            return this;
        }

        Jeeel.Dom.Event.removeEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_DOWN, this._onMouseDown);
        Jeeel.Dom.Event.removeEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_UP,   this._onMouseUp);
        Jeeel.Dom.Event.removeEventListener(this._target, Jeeel.Dom.Event.Type.MOUSE_MOVE, this._onMouseMove);
        this._started = false;
        this._active  = false;

        return this;
    },

    /**
     * 使用するマウスのボタンを右ボタンにするかどうかを設定する<br />
     * なおこの設定を呼ぶと強制的にマウスジェスチャーが終了させられる
     *
     * @param {Boolean} isRight 右かどうか
     */
    setMouseButtonRight: function (isRight) {
        this.end();
        this._isRight = isRight;

        return this;
    },

    /**
     * ジェスチャーがアクティブになった時のコールバックを設定する
     *
     * @param {Function} callback 設定コールバック(引数はなしで、thisはこのインスタンスになる)
     * @return {Jeeel.Gui.Mouse.Gesture} 自インスタンス
     */
    setActiveCallback: function (callback) {
        this._activeCallback = callback;

        return this;
    },

    /**
     * ジェスチャーがアクティブになった時のコールバックを設定する
     *
     * @param {Function} callback 設定コールバック(引数はこのジェスチャーのリストで、thisはこのインスタンスになる)
     * @return {Jeeel.Gui.Mouse.Gesture} 自インスタンス
     */
    setInactiveCallback: function (callback) {
        this._inactiveCallback = callback;

        return this;
    },

    /**
     * 現在までのジェスチャーを取得する<br />
     * なおリスト内に入っている数値は、<br />
     * Jeeel.Code.KeyCode内のLeft, Right, Up, Downのいずれかである
     *
     * @return {Integer[]} 取得したジェスチャーのリスト
     */
    getGestureList: function () {
        return this._gestureList;
    },

    /**
     * 現在までのジェスチャーを文字列として取得する
     *
     * @return {String}
     */
    getGestureListToString: function () {
        var res = '';

        for (var i = 0; i < this._gestureList.length; i++) {

            if (i > 0) {
                res += ' ';
            }

            switch (this._gestureList[i]) {
                case Jeeel.Dom.Event.KeyCode.Left:
                    res += '←';
                    break;

                case Jeeel.Dom.Event.KeyCode.Right:
                    res += '→';
                    break;

                case Jeeel.Dom.Event.KeyCode.Up:
                    res += '↑';
                    break;

                case Jeeel.Dom.Event.KeyCode.Down:
                    res += '↓';
                    break;

                default:
                    res += '？';
                    break;
            }
        }

        return res;
    },

    /**
     * 指定したジェスチャーと現在の結果が一致するかどうかを返す
     * 
     * @param {Integer[]} gesture 比較対象のジェスチャーのリスト
     * @return {Boolean} ジェスチャーが一致するかどうか
     */
    matchGesture:function (gesture) {
        if (gesture.length !== this._gestureList.length) {
            return false;
        }

        for (var i = 0; i < gesture.length; i++) {
            if (gesture[i] !== this._gestureList[i]) {
                return false;
            }
        }

        return true;
    },

    /**
     * 現在までのマウス座標を取得する
     *
     * @type Jeeel.Object.Point[]
     */
    getPointList: function () {
        return this._pointList;
    }
};
Jeeel.directory.Jeeel.Worker = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Worker/';
    }
};

/**
 * コンストラクタ
 * 
 * @class マルチスレッドを提供するクラス(1インスタンスにつき1スレッド)
 */
Jeeel.Worker = function () {
    var script = Jeeel.directory.Jeeel.Worker + 'Thread.js?lang=' + Jeeel.Language.getLocale();
    
    if (Jeeel.QUERY) {
        script += '&' + Jeeel.QUERY.replace(/lang=[a-z]+&?/g, '');
    }
    
    this._worker = new Worker(script);
    this._errors = [];
    this._messages = {};
    
    this._init();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Worker} 作成したインスタンス
 */
Jeeel.Worker.create = function () {
    return new this();
};

Jeeel.Worker.prototype = {
  
    /**
     * 内部スレッドWorker
     * 
     * @type Worker
     * @private
     */
    _worker: null,
    
    /**
     * 内部スレッドの動作数(待ちキュー)
     * 
     * @type Integer
     * @private
     */
    _workCount: 0,
    
    /**
     * メッセージイベントリスト
     * 
     * @type Hash
     * @private
     */
    _messages: {},
    
    /**
     * エラーイベントリスト
     * 
     * @type Function[]
     * @private
     */
    _errors: [],
    
    /**
     * メッセージイベント
     * 
     * @private
     */
    _messageEvent: function () {
        var event = Jeeel.Dom.Event.getEventObject();
        var data = event.data;
        
        if (Jeeel.Hash.inHash(data.type, [Jeeel.Worker.Type.EXECUTE_SCRIPT])) {
            return;
        }
        
        var actionEvents = this._messages[data.type];
        
        if ( ! actionEvents) {
            this._workCount--;
            return;
        }
        
        for (var i = 0, l = actionEvents.length; i < l; i++) {
            actionEvents[i](data.msg, data.type);
        }
        
        this._workCount--;
    },
    
    /**
     * エラーイベント
     * 
     * @private
     */
    _errorEvent: function () {
        var event = Jeeel.Dom.Event.getEventObject().getEvent();

        for (var i = 0, l = this._errors.length; i < l; i++) {
            this._errors[i](event);
        }
        
        if (l === 0) {
            var error = event.message + '\n'
                      + event.filename + '('
                      + event.lineno + ')';

            Jeeel.errorDump(error);
        }
        
        this._workCount--;
    },
    
    /**
     * タスク内でJeeel.jsを使用できるようにする
     * 
     * @private
     */
    _init: function () {
      
        this._messageEvent = Jeeel.Function.simpleBind(this._messageEvent, this);
        this._errorEvent = Jeeel.Function.simpleBind(this._errorEvent, this);
        
        this._worker.onmessage = this._messageEvent;
        this._worker.onerror = this._errorEvent;
        
        var i, l, script = [];
        var globalValues = [
            'jeeelConfig'
        ];

        for (i = 0, l = globalValues.length; i < l; i++) {
            script[i] = globalValues[i] + '=' + Jeeel.Json.encode(Jeeel._global[globalValues[i]]) + ';';
        }
        
        var scriptData = {
            type: Jeeel.Worker.Type.EXECUTE_SCRIPT,
            data: script.join('\n') + '\nif ( ! jeeelConfig) {jeeelConfig = {manualLoad: true};}\n'
        };
        
        this._worker.postMessage(Jeeel.Json.encode(scriptData));
        
        if (Jeeel._auto) {
            var urls = Jeeel.getFilePath().replace(/\n$/g, '').split('\n');

            for (i = 0, l = urls.length; i < l; i++) {
                this.importScript(urls[i]);
            }
        } else {
            this.importScript(Jeeel.directory.Jeeel + 'Jeeel-Set.js');
        }
    },
    
    /**
     * タスク内で使用するスクリプトを読み込ませる(windowやDomを使用しているスクリプトは動作しない: windowの代わりにglobal変数が存在する)
     * 
     * @param {String} url スクリプトのURL
     * @return {Jeeel.Worker} 自インスタンス
     */
    importScript: function (url) {
        var importData = {
            type: Jeeel.Worker.Type.IMPORT_SCRIPT,
            data: url
        };
        
        this._post(Jeeel.Json.encode(importData));
        
        return this;
    },
    
    /**
     * このスレッドで実行を行うタスクの追加を行う(タスク内では外部変数にアクセスしてはならず、window・Domに対してのアクセスは出来ない: JeeelやImportしたライブラリのみ可能, windowの代わりにglobal変数が存在する)
     * 
     * @param {Function} task 実行タスク Mixied task(Mixied data)
     * @return {Jeeel.Worker} 自インスタンス
     */
    addTask: function (task) {
        var taskData = {
            type: Jeeel.Worker.Type.ADD_TASK,
            data: task
        };
        
        this._post(Jeeel.Json.encode(taskData, true));
        
        return this;
    },
    
    /**
     * 様々なアクションを起こした際に呼ばれるイベントの追加を行う
     * 
     * @param {String} actionType アクションタイプ
     * @param {Function} listener イベント
     * @return {Jeeel.Worker} 自インスタンス
     * @see Jeeel.Worker.Type
     */
    addActionEvent: function (actionType, listener) {
        if ( ! this._messages[actionType]) {
            this._messages[actionType] = [];
        }
        
        var actionEvents = this._messages[actionType];
        
        actionEvents[actionEvents.length] = listener;

        return this;
    },
    
    /**
     * タスク内でエラーが発生した場合に呼ばれるイベントの追加を行う
     * 
     * @param {Function} listener イベント
     * @return {Jeeel.Worker} 自インスタンス
     */
    addErrorEvent: function (listener) {
        this._errors.push(listener);

        return this;
    },
    
    /**
     * タスクをバックグラウンドで順に実行する
     * 
     * @param {Mixied} [data] タスクに渡すデータ
     * @return {Jeeel.Worker} 自インスタンス
     */
    execute: function (data) {
        var messageData = {
            type: Jeeel.Worker.Type.EXECUTE_TASK,
            data: Jeeel.Type.isSet(data) ? data : null
        };
        
        this._post(Jeeel.Json.encode(messageData, true));
        
        return this;
    },
    
    /**
     * 現在バックグラウンドで実行・待機中のアクション数を取得する<br />
     * タスクが複数あってもexecuteして増えるアクション数は1である
     * 
     * @return {Integer} アクション数
     */
    getActioningCount: function () {
        return this._workCount;
    },
    
    /**
     * スレッドの実行を停止する
     * 
     * @return {Jeeel.Worker} 自インスタンス
     */
    terminate: function () {
        this._workCount = 0;
        this._worker.terminate();
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Worker,
    
    _post: function (msg) {
        this._workCount++;
        this._worker.postMessage(msg);
    }
};

Jeeel.file.Jeeel.Worker = ['Type'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Worker, Jeeel.file.Jeeel.Worker);

/**
 * @namespace Worker内で使用されるイベントタイプを示す列挙体
 */
Jeeel.Worker.Type = {
    
    /**
     * Scriptのインポートイベント
     * 
     * @type String
     * @constant
     */
    IMPORT_SCRIPT: 'import',
    
    /**
     * Scriptの実行イベント
     * 
     * @type String
     * @constant
     */
    EXECUTE_SCRIPT: 'script',
    
    /**
     * タスク追加イベント
     * 
     * @type String
     * @constant
     */
    ADD_TASK: 'add-task',
    
    /**
     * タスク実行イベント
     * 
     * @type String
     * @constant
     */
    EXECUTE_TASK: 'execute'
};

Jeeel.directory.Jeeel.Database = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Database/';
    }
};

/**
 * @namespace データベースに関連する機能を保有するネームスペース
 */
Jeeel.Database = {

};

Jeeel.file.Jeeel.Database = ['Relation', 'Index'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Database, Jeeel.file.Jeeel.Database);

Jeeel.directory.Jeeel.Database.Relation = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Database + 'Relation/';
    }
};

/**
 * @staticClass リレーショナルデータベースのDBMSに相当するStaticクラス
 *
 * @ignore 未完
 */
Jeeel.Database.Relation = {
  
    /**
     * デフォルトで使用するDBのVersion
     *
     * @type String
     * @private
     */
    _defaultDbVersion: '',

    /**
     * デフォルトで使用するDBの最大サイズ<br />
     * デフォルトで512MB
     *
     * @type Integer
     * @private
     */
    _defaultEstimatedSize: 1024 * 1024 * 512,
    
    /**
     * @type Hash
     * @private
     */
    _dbList: {},

    /**
     * データベースへの接続を行う
     * 
     * @param {String} dbName 対象データベース名
     * @param {String} [displayName] 表示データベース名
     * @return {Jeeel.Database.Relation.Connection} データベースとの接続インスタンス
     */
    connectDatabase: function (dbName, displayName) {

        if ( ! Jeeel.Type.isString(dbName) || dbName.length <= 0) {
            throw new Error('データベース名が不正です。');
        }

        if ( ! Jeeel.Type.isString(displayName) || displayName.length <= 0) {
            displayName = dbName;
        }

        if ( ! (dbName in this._dbList)) {
            this._dbList[dbName] = new this.Connection(
                                       dbName,
                                       this._defaultDbVersion,
                                       displayName,
                                       this._defaultEstimatedSize
                                   );
        }

        return this._dbList[dbName];
    },

    /**
     * SQLインジェクションを防ぐためのクォートを行う
     *
     * @param {Mixied} value クォートする値
     * @return {Mixied} クォート後の値
     */
    quote: function (value) {
        if (Jeeel.Type.isHash(value)) {
            var res = {};
            
            Jeeel.Hash.forEach(value,
                function (val, key) {
                    res[key] = this.quote(val);
                }, this
            );
              
            return res;
        }
        else if ( ! Jeeel.Type.isPrimitive(value)) {
            throw new Error('対応していない型');
        }

        if (Jeeel.Type.isEmpty(value)) {
            return 'NULL';
        }
        else if (Jeeel.Type.isNumber(value)) {
            return value;
        }
        else if (Jeeel.Type.isBoolean(value)) {
            return value.toString();
        }

        value = '' + value;

        return "'"
             + value.replace(/(\\|'|")/, "\\$1")
                    .replace(/\000/, "\\000")
                    .replace(/\n/, "\\n")
                    .replace(/\r/, "\\r")
                    .replace(/\032/, "\\032")
             + "'";
    }
};

Jeeel.file.Jeeel.Database.Relation = ['Connection', 'Transaction', 'Result', 'Table'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Database.Relation, Jeeel.file.Jeeel.Database.Relation);

/**
 * コンストラクタ
 * 
 * @class 1つのデータベースとの接続を管理するクラス
 */
Jeeel.Database.Relation.Connection = function (dbName, dbVersion, displayName, estimatedSize) {
    this._db = openDatabase(dbName, dbVersion, displayName, estimatedSize);
};

Jeeel.Database.Relation.Connection.prototype = {
    /**
     * 基となるデータベース
     * 
     * @type Database
     */
    _db: null,

    /**
     * 成功時のメソッド
     *
     * @type Function
     * @private
     */
    _successMethod: null,

    /**
     * エラー時のメソッド
     *
     * @type Function
     * @private
     */
    _errorMethod: null,

    /**
     * 成功時のメソッドの登録を行う
     *
     * @param {Function} callback 登録メソッド
     * @return {Jeeel.Database.Relation.Connection} 自インスタンス
     */
    setSuccessMethod: function (callback) {
        this._successMethod = callback;

        return this;
    },

    /**
     * 失敗時のメソッドの登録を行う
     *
     * @param {Function} callback 登録メソッド
     * @return {Jeeel.Database.Relation.Connection} 自インスタンス
     */
    setErrorMethod: function (callback) {
        this._errorMethod = callback;

        return this;
    },

    /**
     * トランザクション処理を行う
     *
     * @param {Function} execute 実行トランザクション
     * @return {Jeeel.Database.Relation.Connection} 自インスタンス
     */
    transaction: function (execute) {
        var self = this;

        this._db.transaction(
            function (tx) {
                execute.call(this, new Jeeel.Database.Relation.Transaction(tx));
            },

            function (error) {
                if (self._errorMethod) {
                    self._errorMethod.apply(this, arguments);
                } else {
                    Jeeel.errorDump('TransactionError ', error.message + '(' + error.code + ')');
                }
            },
            
            function () {
                if (self._successMethod) {
                    self._successMethod.apply(this, arguments);
                }
            }
        );

        return this;
    },
    
    /**
     * トランザクション処理を行う<br />
     * 但しこのトランザクション内部では参照しかできない
     *
     * @param {Function} execute 実行トランザクション
     * @return {Jeeel.Database.Relation.Connection} 自インスタンス
     */
    readTransaction: function (execute) {
        var self = this;

        this._db.readTransaction(
            function (tx) {
                execute.call(this, new Jeeel.Database.Relation.Transaction(tx));
            },

            function (error) {
                if (self._errorMethod) {
                    self._errorMethod.apply(this, arguments);
                } else {
                    Jeeel.errorDump('TransactionError ', error.message + '(' + error.code + ')');
                }
            },
            
            function () {
                if (self._successMethod) {
                    self._successMethod.apply(this, arguments);
                }
            }
        );

        return this;
    },

    /**
     * テーブルの作成を行う
     * 
     * @param {Jeeel.Database.Relation.Table} table 作成するテーブル情報をもったオブジェクト
     * @param {Boolean} [ignore] テーブルが存在した場合無視するかどうか
     * @return {Jeeel.Database.Relation.Connection} 自インスタンス
     */
    createTable: function (table, ignore) {
      
        return this.transaction(
            function (tx) {
                tx.query(table.toSql(ignore));
            }
        );
    },

    /**
     * テーブルの削除を行う
     * 
     * @param {String} table テーブル名
     * @param {Boolean} [ignore] テーブルが存在しなかった場合無視するかどうか
     * @return {Jeeel.Database.Relation.Connection} 自インスタンス
     */
    dropTable: function (table, ignore) {
        var sql = 'DROP TABLE ' + (ignore ? 'IF EXISTS ' : '') + '`' + table + '`;';

        return this.transaction(
            function (tx) {
                tx.query(sql);
            }
        );
    }
};

Jeeel.Database.Relation.Transaction = function (transaction) {
    this._transaction = transaction;
};

Jeeel.Database.Relation.Transaction.prototype = {
    /**
     * トランザクション
     * 
     * @type SQLTransaction
     * @private
     */
    _transaction: null,

    /**
     * 成功時のメソッド
     * 
     * @type Function
     * @private
     */
    _successMethod: null,

    /**
     * エラー時のメソッド
     *
     * @type Function
     * @private
     */
    _errorMethod: null,
    
    _errorInfo: null,

    setSuccessMethod: function (callback) {
        this._successMethod = callback;

        return this;
    },

    setErrorMethod: function (callback) {
        this._errorMethod = callback;

        return this;
    },

    query: function (sql, bind) {
      
        var trace = (Jeeel._debugMode ? Jeeel.Debug.Debugger.getTrace() : null);
      
        var self = this;

        this._transaction.executeSql(
            sql,
            bind || [],
            function (transaction, result) {
                if (self._successMethod) {
                    self._successMethod.call(this, self, new Jeeel.Database.Relation.Result(result));
                }
            },
            function (transaction, error) {
                if (trace) {
                    var message = 'Caller:\n' + trace[0].name + '\n\n'
                                + 'Sql:\n' + sql + '\n\n'
                                + 'Bind:\n[' + (bind || []).join(', ') + ']\n\n'
                                + 'BaseError:\n' + error.message;
                    
                    self._errorInfo = {
                        message: message,
                        caller: trace[0].func
                    };
                }
                
                if (self._errorMethod) {
                    self._errorMethod.call(this, self, error);
                } else {
                    throw error;
                }
            }
        );

        return this;
    },

    /**
     * レコードの挿入を行う
     * 
     * @param {String} table テーブル名
     * @param {Hash} bind 挿入するレコード内容のキーと値のペアリスト
     * @return {Jeeel.Database.Relation.Transaction} 自インスタンス
     */
    insertRecord: function (table, bind) {
        var sql = 'INSERT INTO `' + table + '` ';
        var cols = [];
        var vals = [];
        var len = 0;
        
        for (var key in bind) {
            cols[len] = key;
            vals[len] = bind[key];
            len++;
        }
        
        vals = this.quote(vals);
        
        sql += '(`' + cols.join('`, `') + '`)'
             + 'VALUES(' + vals.join(', ') + ');';
           
        return this.query(sql);
    },

    updateRecord: function (table, bind, where) {

    },

    deleteRecord: function (table, bind, where) {
        
    },

    /**
     * SQLインジェクションを防ぐためのクォートを行う
     *
     * @param {Mixied} value クォートする値
     * @return {Mixied} クォート後の値
     */
    quote: function (value) {
        return Jeeel.Database.Relation.quote(value);
    }
};

Jeeel.Database.Relation.Result = function (result) {
    this._result = result;
};

Jeeel.Database.Relation.Result.prototype = {

    /**
     * @type SQLResultSet
     */
    _result: null,

    getInsertId: function () {
        return this._result.insertId;
    },

    getLength: function () {
        return this._result.rows.length;
    },

    get: function (index) {
        return this._result.rows.item(index);
    },

    getAll: function () {
        var res = [];
        var len = this.getLength();

        for (var i = 0; i < len; i++) {
            res[i] = this.get(i);
        }

        return res;
    }
};
Jeeel.directory.Jeeel.Database.Relation.Table = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Database.Relation + 'Table/';
    }
};

/**
 * コンストラクタ
 *
 * @class テーブルを管理するクラス
 * @param {String} name テーブル名
 */
Jeeel.Database.Relation.Table = function (name) {
    this._name = name;
    this._columns = {};
    this._keys = [];
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name テーブル名
 * @return {Jeeel.Database.Relation.Table} 作成したインスタンス
 */
Jeeel.Database.Relation.Table.create = function (name) {
    return new this(name);
};

Jeeel.Database.Relation.Table.prototype = {

    /**
     * テーブル名
     *
     * @type String
     * @private
     */
    _name: '',

    /**
     * テーブルに定義されているカラムのHash
     *
     * @type Hash
     * @private
     */
    _columns: {},

    /**
     * 主キー
     *
     * @type Jeeel.Database.Relation.Table.Key
     * @private
     */
    _primary: null,

    /**
     * ユニークキー・インデックスキー
     *
     * @type Jeeel.Database.Relation.Table.Key[]
     * @private
     */
    _keys: [],

    /**
     * カラムを新規で作成する
     *
     * @param {String} name カラム名
     * @param {String} type カラムの型
     * @param {Boolean} [allowNull] NULL値を許可するかどうか
     * @param {String} [defaultValue] 初期値
     * @param {String} [extra] 追加情報(AUTO_INCREMENT等)
     * @param {String} [comment] カラムの説明
     * @return {Jeeel.Database.Relation.Table.Column} 追加したカラムインスタンス
     */
    createColumn: function (name, type, allowNull, defaultValue, extra, comment) {
        var column = new Jeeel.Database.Relation.Table.Column(name, type);

        if (Jeeel.Type.isBoolean(allowNull)) {
            column.setNull(allowNull);
        }

        if (defaultValue) {
            column.setDefault(defaultValue);
        }

        if (extra) {
            column.setExtra(extra);
        }

        if (comment) {
            column.setComment(comment);
        }

        this.addColumn(column);

        return column;
    },

    /**
     * カラムの追加を行う
     *
     * @param {Jeeel.Database.Relation.Table.Column} column カラムインスタンス
     * @return {Jeeel.Database.Relation.Table} 自インスタンス
     */
    addColumn: function (column) {
        this._columns[column.getName()] = column;

        return this;
    },

    /**
     * 主キーの設定を行う
     *
     * @param {String} var_args 主キーに使用するカラム名を複数引き渡す
     * @return {Jeeel.Database.Relation.Table} 自インスタンス
     */
    setPrimaryKey: function (var_args) {

        if (arguments.length === 0) {
            throw new Error('キーは少なくとも1つは指定してください。');
        }

        var primary = new Jeeel.Database.Relation.Table.Key(Jeeel.Database.Relation.Table.Key.Type.PRIMARY);

        primary.setName('primary_' + arguments[0]);

        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] in this._columns) {
                primary.addKey(arguments[i]);
            }
            else {
                throw new Error('存在しないカラムを指定しています。');
            }
        }

        this._primary = primary;

        return this;
    },

    /**
     * ユニークキーを追加する
     *
     * @param {String} var_args ユニークキーに使用するカラム名を複数引き渡す
     * @return {Jeeel.Database.Relation.Table} 自インスタンス
     */
    addUniqueKey: function (var_args) {
      
        if (arguments.length === 0) {
            throw new Error('キーは少なくとも1つは指定してください。');
        }
        
        var uniqueKey = new Jeeel.Database.Relation.Table.Key(Jeeel.Database.Relation.Table.Key.Type.UNIQUE);

        uniqueKey.setName('unique_' + arguments[0] + '_' + this._keys.length);

        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] in this._columns) {
                uniqueKey.addKey(arguments[i]);
            }
            else {
                throw new Error('存在しないカラムを指定しています。');
            }
        }

        this._keys[this._keys.length] = uniqueKey;

        return this;
    },

    /**
     * インデックスキーを追加する
     *
     * @param {String} var_args インデックスキーに使用するカラム名を複数引き渡す
     * @return {Jeeel.Database.Relation.Table} 自インスタンス
     */
    addIndexKey: function (var_args) {
        if (arguments.length === 0) {
            throw new Error('キーは少なくとも1つは指定してください。');
        }

        var indexKey = new Jeeel.Database.Relation.Table.Key(Jeeel.Database.Relation.Table.Key.Type.INDEX);

        indexKey.setName('index_' + arguments[0] + '_' + this._keys.length);

        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] in this._columns) {
                indexKey.addKey(arguments[i]);
            }
            else {
                throw new Error('存在しないカラムを指定しています。');
            }
        }

        this._keys[this._keys.length] = indexKey;

        return this;
    },

    /**
     * テーブルを作成する際のSQLに変換する
     * 
     * @param {Boolean} [ignore] テーブルが存在する際にSQL文を無視するかどうか
     * @return {String} SQL文字列
     */
    toSql: function (ignore) {
        return this.toString(ignore);
    },

    /**
     * このインスタンスを示すSQLを返す
     * 
     * @param {Boolean} [ignore] テーブルが存在する際にSQL文を無視するかどうか
     * @return {String} SQL文字列
     */
    toString: function (ignore) {
        var sql = 'CREATE TABLE ' + (ignore ? 'IF NOT EXISTS ' : '') + '`' + this._name + '` (';

        for (var columnName in this._columns) {
            sql += ',\n  ' + this._columns[columnName].toSql();
        }

        var keys = Jeeel.Method.clone(this._keys);

        if (this._primary) {
            keys.unshift(this._primary);
        }

        for (var j = 0; j < keys.length; j++) {
            sql += ',\n  ' + keys[j].toSql();
        }

        return sql + '\n);';
    }
};

Jeeel.file.Jeeel.Database.Relation.Table = ['Column', 'Key'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Database.Relation.Table, Jeeel.file.Jeeel.Database.Relation.Table);

/**
 * コンストラクタ
 * 
 * @class カラムを扱うクラス
 * @param {String} name カラム名
 * @param {String} type カラムの型
 */
Jeeel.Database.Relation.Table.Column = function (name, type) {
    this._name = name;
    this._type = type;
};

/**
 * インスタンスの作成を行う
 *
 * @param {String} name カラム名
 * @param {String} type カラムの型
 * @return {Jeeel.Database.Relation.Table.Column} 作成したインスタンス
 */
Jeeel.Database.Relation.Table.Column.create = function (name, type) {
    return new this(name, type);
};

Jeeel.Database.Relation.Table.Column.prototype = {
    _name: '',
    _type: '',
    _null: true,
    _default: 'NULL',
    _extra: '',
    _comment: '',

    getName: function () {
        return this._name;
    },

    getType: function () {
        return this._type;
    },

    getNull: function () {
        return this._null;
    },

    setNull: function (allowNull) {
        this._null = !!allowNull;

        return this;
    },

    getDefault: function () {
        return this._default;
    },

    setDefault: function (defaultValue) {
        this._default = '' + defaultValue;

        return this;
    },

    getExtra: function () {
        return this._extra;
    },

    setExtra: function (extra) {
        this._extra = '' + extra;

        return this;
    },

    getComment: function () {
        return this._comment;
    },

    setComment: function (comment) {
        this._comment = '' + comment;

        return this;
    },

    /**
     * このカラムを示すSQL文字列に変換する
     *
     * @return {String} SQL文字列
     */
    toSql: function () {
        return this.toString();
    },

    /**
     * このカラムを示すSQL文字列に変換する
     *
     * @return {String} SQL文字列
     */
    toString: function () {
        var sql = '`' + this._name + '` ' + this._type
                + (this._null ? '' : ' NOT NULL')
                + (this._default === 'NULL' ? '' : ' DEFAULT ' + this._default)
                + (this._extra ? ' ' + this._extra : '')
                + (this._comment ? ' COMMENT ' + this._comment : '');

        return sql;
    }
};
Jeeel.directory.Jeeel.Database.Relation.Table.Key = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Database.Relation.Table + 'Key/';
    }
};

/**
 * コンストラクタ
 * 
 * @class キーを管理するクラス
 * @param {String} type キーの種類を示す文字列
 * @see Jeeel.Database.Relation.Table.Key.Type
 */
Jeeel.Database.Relation.Table.Key = function (type) {
    if ( ! Jeeel.Hash.inHash(type, Jeeel.Database.Relation.Table.Key.Type, true)) {
        throw new Error('キーの種類が間違っています。');
    }

    this._type = type;
    this._keys = [];
};

Jeeel.Database.Relation.Table.Key.prototype = {

    /**
     * キーの名前
     *
     * @type String
     * @private
     */
    _name: '',

    /**
     * キーの種類
     *
     * @type String
     * @private
     */
    _type: '',

    /**
     * キーの対象のカラムリスト
     *
     * @type String[]
     * @private
     */
    _keys: [],

    /**
     * 名前を取得する
     *
     * @return {String} 名前
     */
    getName: function () {
        return this._name;
    },

    /**
     * 名前を設定する
     *
     * @param {String} name 名前
     * @return {Jeeel.Database.Relation.Table.Key} 自インスタンス
     */
    setName: function (name) {
        this._name = name;

        return this;
    },

    /**
     * キーの種類を取得する
     *
     * @return {String} キーの種類
     */
    getType: function () {
        return this._type;
    },

    /**
     * キーの種類を設定する
     *
     * @param {String} type キーの種類
     * @return {Jeeel.Database.Relation.Table.Key} 自インスタンス
     */
    setType: function (type) {
        if ( ! Jeeel.Hash.inHash(type, Jeeel.Database.Relation.Table.Key.Type, true)) {
            throw new Error('キーの種類が間違っています。');
        }

        this._type = type;

        return this;
    },

    /**
     * 対象のカラムリストを取得する
     * 
     * @return {String[]} 対象のカラムリスト
     */
    getKeys: function () {
        return this._keys;
    },

    /**
     * 対象のカラムを追加する
     *
     * @param {String} key カラム名
     * @return {Jeeel.Database.Relation.Table.Key} 自インスタンス
     */
    addKey: function (key) {
        this._keys.push(key);

        return this;
    },

    /**
     * カラム名のリストを空にする
     * 
     * @return {Jeeel.Database.Relation.Table.Key} 自インスタンス
     */
    clearKeys: function () {
        this._keys = [];

        return this;
    },

    /**
     * このキーを示すSQL文字列に変換する
     *
     * @return {String} SQL文字列
     */
    toSql: function () {
        return this.toString();
    },

    /**
     * このキーを示すSQL文字列に変換する
     *
     * @return {String} SQL文字列
     */
    toString: function () {
      
        var sql = this._type
                + (this._type != Jeeel.Database.Relation.Table.Key.Type.PRIMARY && this._name ? ' `' + this._name + '`' : '') + ' (';

        for (var i = 0; i < this._keys.length; i++) {
            if (i > 0) {
                sql += ', ';
            }

            sql += '`' + this._keys[i] + '`';
        }

        sql += ')';

        return sql;
    }
};

Jeeel.file.Jeeel.Database.Relation.Table.Key = ['Type'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Database.Relation.Table.Key, Jeeel.file.Jeeel.Database.Relation.Table.Key);

/**
 * @namespace キーの種類についての列挙体
 */
Jeeel.Database.Relation.Table.Key.Type = {

    /**
     * 主キー
     *
     * @type String
     * @constant
     */
    PRIMARY: 'PRIMARY KEY',

    /**
     * ユニークキー
     *
     * @type String
     * @constant
     */
    UNIQUE: 'UNIQUE KEY',

    /**
     * インデックス
     *
     * @type String
     * @constant
     */
    INDEX: 'KEY'
};

Jeeel.directory.Jeeel.Database.Index = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Database + 'Index/';
    }
};

/**
 * @staticClass キーバリューストア型データベースのマスターにあたるstaticクラス
 * 
 * @ignore 未完成
 */
Jeeel.Database.Index = {
    
    /**
     * データベースへの接続を行う
     * 
     * @return {Jeeel.Database.Index.Connection} データベースとの接続インスタンス
     */
    connectDatabase: function (dbName, description) {
        
    }
};

Jeeel.file.Jeeel.Database.Index = ['Connection'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Database.Index, Jeeel.file.Jeeel.Database.Index);

/**
 * コンストラクタ
 * 
 * @class 1つのデータベースとの接続を維持するクラス
 * @param {String} dbName データベース名
 * @param {String} [description] データベースの説明
 */
Jeeel.Database.Index.Connection = function (dbName, description) {
    this._request = this.constructor.indexedDB.open(dbName, description);
    this._request.onsuccess = Jeeel.Function.simpleBind(this._succeedOpen, this);
    this._request.onerror = Jeeel.Function.simpleBind(this._failedOpen, this);
};

(function (global) {
    if ( ! global) {
        return;
    }
    
    var indexDB = global.indexedDB
               || global.webkitIndexedDB
               || global.mozIndexedDB
               || global.moz_indexedDB
               || global.msIndexedDB
               || global.oIndexedDB;
    
    if (indexDB) {
        Jeeel.Database.Index.Connection.indexedDB = indexDB;
    }
    
    indexDB = null;
})(Jeeel._global);

Jeeel.Database.Index.Connection.prototype = {
    
    _request: null,
    
    _db: null,
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Database.Index.Connection,
    
    _succeedOpen: function (e) {
        this._db = e.result;
    },
    
    _failedOpen: function (e) {
        
    }
};Jeeel.directory.Jeeel.File = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'File/';
    }
};

/**
 * @namespace ファイルに関するネームスペース
 */
Jeeel.File = {
  
    /**
     * 取得したファイルの数だけデータの作成を行う
     * 
     * @param {Element|FormData} fileOwner ファイル選択をしたfileタイプのinputタグかファイルドロップをしたFormData
     * @return {Jeeel.File.Data[]} 取得したファイルの数だけのデータリスト
     */
    createData: function (fileOwner) {
        if ( ! fileOwner.files) {
            throw new Error('fileOwnerがファイルを保持していません。');
        }
        
        var files = fileOwner.files;
        var res = [];
        
        for (var i = 0, l = files.length; i < l; i++) {
            res[i] = new this.Data(files[i]);
        }
        
        return res;
    }
};

Jeeel.file.Jeeel.File = ['Reader', 'Data'];

Jeeel._autoImports(Jeeel.directory.Jeeel.File, Jeeel.file.Jeeel.File);

/**
 * コンストラクタ
 * 
 * @class ファイルデータの読み込み操作を提供するクラス
 * @param {Jeeel.File.Data} file ファイルデータ
 */
Jeeel.File.Reader = function (file) {
    this._file = file;
    this._reader = new FileReader();
    this._setEvents();
};

Jeeel.File.Reader.prototype = {
  
    /**
     * 読み込み元
     * 
     * @type Jeeel.File.Data
     * @private
     */
    _file: null,
    
    /**
     * 読み込みインスタンス
     * 
     * @type FileReader
     * @private
     */
    _reader: null,
    
    /**
     * 読み込み開始コールバック
     * 
     * @type Hash
     * @private
     */
    _loadStartMethod: null,
    
    /**
     * 読み込み処理完了コールバック
     * 
     * @type Hash
     * @private
     */
    _loadEndMethod: null,
    
    /**
     * 正常読み込み完了コールバック
     * 
     * @type Hash
     * @private
     */
    _loadMethod: null,

    /**
     * 読み込み作業中コールバック
     * 
     * @type Hash
     * @private
     */
    _progressMethod: null,
    
    /**
     * 読み込み中断コールバック
     * 
     * @type Hash
     * @private
     */
    _abortMethod: null,
    
    /**
     * エラーコールバック
     * 
     * @type Hash
     * @private
     */
    _errorMethod: null,
    
    /**
     * 読み込み開始メソッドの登録
     *
     * @param {Function} callBack 読み込み開始メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setLoadStartMethod: function (callBack, thisArg) {
        this._loadStartMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 読み込み処理完了メソッドの登録
     *
     * @param {Function} callBack 読み込み処理完了メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setLoadEndMethod: function (callBack, thisArg) {
        this._loadEndMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 正常読み込み完了メソッドの登録
     *
     * @param {Function} callBack 正常読み込み完了メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setLoadMethod: function (callBack, thisArg) {
        this._loadMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 読み込み作業中メソッドの登録
     *
     * @param {Function} callBack 読み込み作業中メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setProgressMethod: function (callBack, thisArg) {
        this._progressMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 読み込み中断メソッドの登録
     *
     * @param {Function} callBack 読み込み中断メソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setAbortMethod: function (callBack, thisArg) {
        this._abortMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * エラーメソッドの登録
     *
     * @param {Function} callBack エラーメソッド<br />
     *                             コールバックメソッドに渡される引数はEventとなる<br />
     *                             void callBack(ProgressEvent event)
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.File.Reader} 自身のインスタンス
     */
    setErrorMethod: function (callBack, thisArg) {
        this._errorMethod = {func: callBack, thisArg: thisArg};
        
        return this;
    },
    
    /**
     * 読み込み結果を取得する
     * 
     * @return {ArrayBuffer|String} 読み込み結果
     */
    getResult: function () {
        return this._reader.result;
    },
    
    /**
     * 読み込みが完了しているかどうかを取得する
     * 
     * @return {Boolean} 読み込みが完了しているかどうか
     */
    isLoaded: function () {
        return this._reader.readyState === FileReader.DONE;
    },
    
    /**
     * 読み込中かどうかを取得する
     * 
     * @return {Boolean} 読み込中かどうか
     */
    isLoading: function () {
        return this._reader.readyState === FileReader.LOADING;
    },
    
    /**
     * ArrayBufferとして読み込みを行う
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    readArrayBuffer: function () {
        this._errorConfirm();
        
        this._reader.readAsArrayBuffer(this._file.getFileData());
        
        return this;
    },
    
    /**
     * バイナリ文字列として読み込みを行う
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    readBinaryString: function () {
        this._errorConfirm();
        
        this._reader.readAsBinaryString(this._file.getFileData());
        
        return this;
    },
    
    /**
     * テキストとして読み込みを行う
     * 
     * @param {String} [charCode] 明示的にキャラクターコードを設定する場合に指定(Jeeel.Code.CharEncoding参照)
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    readText: function (charCode) {
        this._errorConfirm();
        
        this._reader.readAsText(this._file.getFileData(), charCode);
        
        return this;
    },
    
    /**
     * データのURLの読み込みを行う
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    readDataUrl: function () {
        this._errorConfirm();
      
        this._reader.readAsDataURL(this._file.getFileData());
        
        return this;
    },
    
    /**
     * 読み込みを途中で中断する
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     */
    abort: function () {
        this._reader.abort();
      
        return this;
    },
    
    /**
     * 読み込み込んだ結果を全て破棄する
     * 
     * @return {Jeeel.File.Reader} 自インスタンス
     * @throws {Error} 読み込み中の場合に発生
     */
    reset: function () {
        if (this.isLoading()) {
            throw new Error('読み込み中にこのメソッドは呼び出せません。');
        }
        
        this._reader = new FileReader();
        this._setEvents();
        
        return this;
    },

    /**
     * 読み込みを始める前に呼び出しエラーを確認する
     * 
     * @throws {Error} 読み込み中や読み込みが完了している場合に発生
     */
    _errorConfirm: function () {
        if (this._reader.readyState !== FileReader.EMPTY) {
            throw new Error('読み込み中もしくは読み込み完了後にこのメソッドは呼び出せません。');
        }
    },
    
    /**
     * 初期イベントの設定を行う
     * 
     * @private
     */
    _setEvents: function () {
        var self = this;
        
        this._reader.onloadstart = function () {
            if (self._loadStartMethod) {
                self._loadStartMethod.func.apply(self._loadStartMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onloadend = function () {
            if (self._loadEndMethod) {
                self._loadEndMethod.func.apply(self._loadEndMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onload = function () {
            if (self._loadMethod) {
                self._loadMethod.func.apply(self._loadMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onprogress = function () {
            if (self._progressMethod) {
                self._progressMethod.func.apply(self._progressMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onabort = function () {
            if (self._abortMethod) {
                self._abortMethod.func.apply(self._abortMethod.thisArg || self, arguments);
            }
        };
        
        this._reader.onerror = function () {
            if (self._errorMethod) {
                self._errorMethod.func.apply(self._errorMethod.thisArg || self, arguments);
            }
        };
    }
};

/**
 * コンストラクタ
 * 
 * @class ファイルデータを管理するクラス
 * @param {File} fileData 読み込み元のファイルデータ
 */
Jeeel.File.Data = function (fileData) {
    this._file = fileData;
};

Jeeel.File.Data.prototype = {
  
    /**
     * 読み込み元のファイルデータ
     * 
     * @type File
     * @private
     */
    _file: null,
    
    /**
     * 読み込み元のファイルデータを取得する
     * 
     * @return {File} 読み込み元のファイルデータ
     */
    getFileData: function () {
        return this._file;
    },

    /**
     * ファイルの名前を取得する
     * 
     * @return {String} ファイル名
     */
    getFileName: function () {
        return this._file.fileName;
    },
    
    /**
     * ファイルのサイズを取得する
     * 
     * @return {Integer} ファイルサイズ
     */
    getFileSize: function () {
        return this._file.fileSize;
    },
    
    /**
     * ファイルの種類を取得する
     * 
     * @return {String} ファイル種類
     */
    getFileType: function () {
        return this._file.type;
    },
    
    /**
     * ファイルの最終更新時間を取得する
     * 
     * @return {Jeeel.Object.Date} 最終更新時間
     */
    getLastModifiedDate: function () {
        return Jeeel.Object.Date.create(this._file.lastModifiedDate);
    },
    
    /**
     * 現在のインスタンスを読み込むためのインスタンスを取得する
     * 
     * @return {Jeeel.File.Reader} 読み込みインスタンス
     */
    getReader: function () {
        return new Jeeel.File.Reader(this);
    }
};

Jeeel.directory.Jeeel.Media = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Media/';
    }
};

/**
 * @namespace メディア関連のネームスペース
 */
Jeeel.Media = {

};

Jeeel.file.Jeeel.Media = ['Abstract', 'Audio', 'Video'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Media, Jeeel.file.Jeeel.Media);

/**
 * コンストラクタ
 * 
 * @abstractClass メディア系の抽象クラス
 * @param {HTMLMediaElement} media 基となるメディア要素
 */
Jeeel.Media.Abstract = function (media) {
    if (media) {
        this._media = media;
    }
};

Jeeel.Media.Abstract.prototype = {
  
    /**
     * 基となるメディア要素
     * 
     * @type HTMLMediaElement
     * @private
     */
    _media: null,
    
    /**
     * 内部メディアを取得する
     * 
     * @return {HTMLMediaElement} メディア
     */
    getMedia: function () {
        return this._media;
    },
    
    /**
     * メディアを再生する
     * 
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    play: function () {
        this._media.play();
        
        return this;
    },
    
    /**
     * メディアを停止する
     * 
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    pause: function () {
        this._media.pause();
        
        return this;
    },
    
    /**
     * メディアの再生位置を変更する
     * 
     * @param {Number} time 再生位置(秒)
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    seek: function (time) {
        if (isNaN(this._media.duration)) {
            throw new Error('メディアが読み込まれていません。');
        }
        
        time = +time;
        
        if (time > this._media.duration) {
            time = this._media.duration;
        }
        
        this._media.currentTime = time;
        
        return this;
    },
    
    /**
     * 連続再生の設定を行う
     * 
     * @param {Boolean} enable 連続再生を有効にするかどうか
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    enableLoop: function (enable) {
        this._media.loop = !!enable;
        
        return this;
    },
    
    /**
     * シークの設定を行う
     * 
     * @param {Boolean} enable ユーザーがシークを行えるかどうか
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    enableSeek: function (enable) {
        this._media.seekable = !!enable;
        
        return this;
    },
    
    /**
     * メディアコントロールのUIの設定を行う
     * 
     * @param {Boolean} enable UIを表示するかどうか
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    enableControl: function (enable) {
        this._media.controls = !!enable;
        
        return this;
    },
    
    /**
     * ミュートの設定を行う
     * 
     * @param {Boolean} enable ミュートにするかどうか
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    enableMute: function (enable) {
        this._media.muted = !!enable;
        
        return this;
    },
    
    /**
     * ボリュームを取得する
     * 
     * @return {Number} ボリューム(0.0～1.0)
     */
    getVolume: function () {
        return this._media.volume;
    },
    
    /**
     * ボリュームを設定する
     * 
     * @param {Number} volume ボリューム(0.0～1.0)
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    setVolume: function (volume) {
        this._media.volume = volume;
        
        return this;
    },
    
    /**
     * 現在ユーザーがシーク動作を行っているかどうかを返す
     * 
     * @return {Boolean} シークを行っているかどうか
     */
    seeking: function () {
        return this._media.seeking;
    },
    
    /**
     * 指定したメディアソースのタイプが再生可能かどうかを返す
     * 
     * @param {String} type メディアソースタイプ
     * @return {Boolean} 再生可能かどうか
     */
    canPlayType: function (type) {
        return "" != this._media.canPlayType(type);
    },
    
    /**
     * メディアの読み込みを行う
     * 
     * @param {String} mediaUrl メディアのURL
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    load: function (mediaUrl) {
        this._media.load(mediaUrl);
        
        return this;
    },
    
    /**
     * メディアの再読み込みを行う<br />
     * 読み込みを行うのは元々のメディアである
     * 
     * @return {Jeeel.Media.Abstract} 自インスタンス
     */
    reload: function () {
        return this.load(this._media.src);
    }
};

/**
 * コンストラクタ
 * 
 * @class オーディオを扱うクラス
 * @augments Jeeel.Media.Abstract
 * @param {Audio} audio 基となるオーディオ要素
 */
Jeeel.Media.Audio = function (audio) {
    Jeeel.Media.Abstract.call(this, audio);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Audio} audio 基となるオーディオ要素
 * @return {Jeeel.Media.Audio} 作成したインスタンス
 */
Jeeel.Media.Audio.create = function (audio) {
    return new this(audio);
};

Jeeel.Media.Audio.prototype = {};

Jeeel.Class.extend(Jeeel.Media.Audio, Jeeel.Media.Abstract);

/**
 * コンストラクタ
 * 
 * @class ビデオを扱うクラス
 * @augments Jeeel.Media.Abstract
 * @param {Video} video 基となるビデオ要素
 */
Jeeel.Media.Video = function (video) {
    Jeeel.Media.Abstract.call(this, video);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Video} video 基となるビデオ要素
 * @return {Jeeel.Media.Video} 作成したインスタンス
 */
Jeeel.Media.Video.create = function (video) {
    return new this(video);
};

Jeeel.Media.Video.prototype = {
  
    /**
     * 動画の幅を取得する
     * 
     * @return {Number} 幅(初期値は0)
     */
    getWidth: function () {
        return this._media.width;
    },
    
    /**
     * 動画の幅を設定する
     * 
     * @param {Number} width 幅
     * @return {Jeeel.Media.Video} 自インスタンス
     */
    setWidth: function (width) {
        this._media.width = width;
        
        return this;
    },
    
    /**
     * 動画の高さを取得する
     * 
     * @return {Number} 高さ(初期値は0)
     */
    getHeight: function () {
        return this._media.height;
    },
    
    /**
     * 動画の高さを設定する
     * 
     * @param {Number} height 高さ
     * @return {Jeeel.Media.Video} 自インスタンス
     */
    setHeight: function (height) {
        this._media.height = height;
        
        return this;
    },
    
    /**
     * 動画のサイズを取得する
     * 
     * @return {Jeeel.Object.Size} サイズ
     */
    getSize: function () {
        return new Jeeel.Object.Size(this._media.width, this._media.height);
    },
    
    /**
     * 動画の元の幅を取得する
     * 
     * @return {Number} 幅
     */
    getVideoWidth: function () {
        return this._media.videoWidth;
    },
    
    /**
     * 動画の元の高さを取得する
     * 
     * @return {Number} 高さ
     */
    getVideoHeight: function () {
        return this._media.videoHeight;
    },
    
    /**
     * 動画の元のサイズを取得する
     * 
     * @return {Jeeel.Object.Size} サイズ
     */
    getVideoSize: function () {
        return new Jeeel.Object.Size(this._media.videoWidth, this._media.videoHeight);
    },
    
    /**
     * 再生可能な動画がなかった場合の静止画のURLを取得する
     * 
     * @return {String} 静止画URL
     */
    getPoster: function () {
        return this._media.poster;
    },
    
    /**
     * 再生可能な動画がなかった場合の静止画のURLを設定する
     * 
     * @param {String} url 静止画URL
     * @return {Jeeel.Media.Video} 自インスタンス
     */
    setPoster: function (url) {
        this._media.poster = url;
        
        return this;
    }
};

Jeeel.Class.extend(Jeeel.Media.Video, Jeeel.Media.Abstract);

Jeeel.directory.Jeeel.Graphics = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Graphics/';
    }
};

/**
 * @namespace グラフィックス関連のネームスペース
 * @see Jeeel.Graphics.Raster
 * @see Jeeel.Graphics.Vector
 * @see Jeeel.Graphics.Pen
 * @see Jeeel.Graphics.Brush
 * @see Jeeel.Object.Color
 * @see Jeeel.Object.Font
 * @example
 * Graphicsのネームスペース以下はcanvasやSVGなどのグラフィックス機能を保持している拡張機能の一つ
 * この機能には大きく分けて2つの種類が存在する
 * 双方の機能ともに共通の抽象クラスを持ち操作メソッド自体は同じであり、共通の記述で操作できるようになっている
 * ただ、双方まだ対応していないメソッドが存在するため、複雑なメソッドは未実装エラーが出る箇所がある
 * 
 * 
 * Jeeel.Graphics.Raster
 * ラスター系(ドット単位の色情報で構成されるグラフィックス)の機能を扱うクラス
 * 現在はcanvas要素に対しての描画を補助するクラスのみ
 * 
 * Jeeel.Graphics.Vector
 * ベクター系(座標と式で構成されるグラフィックス)の機能を扱うクラス
 * 現在はSVGの要素を容易に操作できるようにした機能のみ
 * 
 * 
 * Jeeel.Graphics.Raster
 * var canvas = $ID('canvas'); // canvas要素を取得する
 * var graphics = Jeeel.Graphics.Raster.factoryCanvas(canvas); // canvasからラスターインスタンスを作成する
 * 
 * Jeeel.Graphics.Vector
 * var svg = $ID('svg'); // svg要素を取得する
 * var graphics = Jeeel.Graphics.Vector.factorySvg(svg); // SVGからベクターインスタンスを作成する
 * 
 * Rasterは現在
 * strokePie, fillPie, drawArc が未実装である
 * 
 * 以下上記のメソッド以外は共通で使用可能
 * 
 * graphics.drawLine(10, 10, 110, 110); // ラインを引く
 * graphics.strokeRect(10, 10, 100, 100); // 長方形の枠を引く
 * graphics.fillText('text', 5, 5); // 塗りつぶしのテキストを描画する
 * graphics.fillRect(10, 10, 100, 100); // 長方形を塗りつぶす
 * graphics.fillPie(100, 100, 50, 50, 0, Math.PI * 2 / 3); // 0°～60°の扇型を塗りつぶす
 * var pen = graphics.getPen(); // ストロークの設定を行うペンを取得する
 * var brush = graphics.getBrush(); // 塗りつぶしのためのブラシを取得する
 * var font = graphics.getFont(); // テキストを記述するためのフォントを取得する
 * 
 * pen.setWidth(5); // ラインの幅を5pxにする(setPenで設定しなくても即時反映する)
 * pen.setColor(Jeeel.Object.Color.createRgb(255, 0, 0)); // ラインの色を赤に設定する
 * 
 * brush.setColor(Jeeel.Object.Color.createRgb(0, 0, 255)); // 塗りつぶしの色を緑に設定する
 * 
 * font.size = '50px'; // テキストのフォントサイズを50pxにする
 * font.weight = 'bold'; // テキストのフォントを太字にする
 * 
 * graphics.drawLine(20, 20, 50, 50); // 5pxのラインを赤で引く
 * graphics.fillRect(100, 100, 100, 50); // 緑で長方形を塗りつぶす
 * graphics.strokeRect(100, 100, 100, 50); // 赤の5pxのラインで長方形を描く
 * graphics.fillText('テスト文字', 100, 100); // 緑色の50pxの太字で"テスト文字列"とテキストを描画する
 */
Jeeel.Graphics = {

};

Jeeel.file.Jeeel.Graphics = ['Abstract', 'Pen', 'Brush', 'Raster', 'Vector'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics, Jeeel.file.Jeeel.Graphics);

/**
 * コンストラクタ
 * 
 * @abstractClass グラフィックス関連に抽象クラス
 */
Jeeel.Graphics.Abstract = function () {
    
};

Jeeel.Graphics.Abstract.prototype = {
  
    /**
     * 実際の操作を保持するインスタンス
     * 
     * @type Object
     * @private
     */
    _adapter: null,
    
    /**
     * 線を描画する際のペンを取得する
     * 
     * @return {Jeeel.Graphics.Pen} Penオブジェクト
     */
    getPen: function () {
        return this._adapter.getPen();
    },
    
    /**
     * 線を描画する際のペンを設定する<br />
     * getで取得したPenを変更した時はsetしないと反映されない
     * 
     * @param {Jeeel.Graphics.Pen} pen Penオブジェクト
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    setPen: function (pen) {
        this._adapter.setPen(pen);
        
        return this;
    },
    
    /**
     * 面を塗りつぶすためのブラシを取得する<br />
     * getで取得したBrushを変更した時はsetしないと反映されない
     * 
     * @return {Jeeel.Graphics.Brush} Brushオブジェクト
     */
    getBrush: function () {
        return this._adapter.getBrush();
    },
    
    /**
     * 面を塗りつぶすためのブラシを設定する
     * 
     * @param {Jeeel.Graphics.Brush} brush Brushオブジェクト
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    setBrush: function (brush) {
        this._adapter.setBrush(brush);
        
        return this;
    },
    
    /**
     * 文字を描くためのフォントを取得する
     * 
     * @return {Jeeel.Object.Font} フォント
     */
    getFont: function () {
        return this._adapter.getFont();
    },
    
    /**
     * 文字を描くためのフォントを設定する
     * 
     * @param {Jeeel.Object.Font} font フォント
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    setFont: function (font) {
        this._adapter.setFont(font);
        
        return this;
    },
    
    /**
     * 線を描画する
     * 
     * @param {Number} x1 一つ目の座標X
     * @param {Number} y1 一つ目の座標Y
     * @param {Number} x2 二つ目の座標X
     * @param {Number} y2 二つ目の座標Y
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    drawLine: function (x1, y1, x2, y2) {
        this._adapter.drawLine(x1, y1, x2, y2);
        
        return this;
    },
    
    /**
     * 長方形を描画する
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokeRect: function (x, y, width, height) {
        this._adapter.strokeRect(x, y, width, height);
        
        return this;
    },
    
    /**
     * 長方形を描画し塗りつぶす
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillRect: function (x, y, width, height) {
        this._adapter.fillRect(x, y, width, height);
        
        return this;
    },
    
    /**
     * 長方形のパス内をクリッピング対象にする
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipRect: function (x, y, width, height) {
        this._adapter.clipRect(x, y, width, height);
        
        return this;
    },
    
    /**
     * 指定した頂点リストから多角形を描画する
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokePolygon: function (vertexes) {
        if ( ! Jeeel.Type.isArray(vertexes)) {
            throw new Error('vertexesが配列ではありません。');
        } else if (vertexes.length < 3) {
            throw new Error('vertexesが必要数に達していません。');
        }
        
        this._adapter.strokePolygon(vertexes);
        
        return this;
    },
    
    /**
     * 指定した頂点リストから多角形を描画し塗りつぶす
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillPolygon: function (vertexes) {
        if ( ! Jeeel.Type.isArray(vertexes)) {
            throw new Error('vertexesが配列ではありません。');
        } else if (vertexes.length < 3) {
            throw new Error('vertexesが必要数に達していません。');
        }
        
        this._adapter.fillPolygon(vertexes);
        
        return this;
    },
    
    /**
     * 指定した頂点リストから多角形のパスを作り、その範囲をクリッピング対象にする
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipPolygon: function (vertexes) {
        if ( ! Jeeel.Type.isArray(vertexes)) {
            throw new Error('vertexesが配列ではありません。');
        } else if (vertexes.length < 3) {
            throw new Error('vertexesが必要数に達していません。');
        }
        
        this._adapter.clipPolygon(vertexes);
        
        return this;
    },
    
    /**
     * 楕円を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokeEllipse: function (x, y, radiusX, radiusY) {
        this._adapter.strokeEllipse(x, y, radiusX, radiusY);
        
        return this;
    },
    
    /**
     * 楕円を描画し塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillEllipse: function (x, y, radiusX, radiusY) {
        this._adapter.fillEllipse(x, y, radiusX, radiusY);
        
        return this;
    },
    
    /**
     * 楕円のパスを作り、その内部をクリッピング対象にする
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipEllipse: function (x, y, radiusX, radiusY) {
        this._adapter.clipEllipse(x, y, radiusX, radiusY);
        
        return this;
    },
    
    /**
     * 文字列を描画する
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokeText: function (text, x, y) {
        this._adapter.strokeText(text, x, y);
        
        return this;
    },
    
    /**
     * 文字列を描画して塗りつぶす
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillText: function (text, x, y) {
        this._adapter.fillText(text, x, y);
        
        return this;
    },
    
    /**
     * 扇形を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    strokePie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._adapter.strokePie(x, y, radiusX, radiusY, startAngle, endAngle);
        
        return this;
    },
    
    /**
     * 扇形を描画して塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    fillPie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._adapter.fillPie(x, y, radiusX, radiusY, startAngle, endAngle);
        
        return this;
    },
    
    /**
     * 楕円弧を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    drawArc: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._adapter.drawArc(x, y, radiusX, radiusY, startAngle, endAngle);
        
        return this;
    },
    
    /**
     * イメージを描画する
     * 
     * @param {Image} image 描画イメージ
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    drawImage: function (image, x, y) {},
    
    /**
     * 描画されている全ての図形を消去する
     * 
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clear: function () {
        this._adapter.clear();
        
        return this;
    }
};

/**
 * イメージを描画する
 * 
 * @param {Image} image 描画イメージ
 * @param {Jeeel.Object.Point} point 描画先座標
 * @return {Jeeel.Graphics.Abstract} 自インスタンス
 */
Jeeel.Graphics.Abstract.prototype.drawImage = function (image, point) {};

/**
 * イメージを描画する
 * 
 * @param {Image} image 描画イメージ
 * @param {Jeeel.Object.Rect} rect 描画先矩形
 * @return {Jeeel.Graphics.Abstract} 自インスタンス
 */
Jeeel.Graphics.Abstract.prototype.drawImage = function (image, rect) {};

/**
 * イメージを描画する
 * 
 * @param {Image} image 描画イメージ
 * @param {Number} x 描画座標X
 * @param {Number} y 描画座標Y
 * @param {Number} width 描画する幅
 * @param {Number} height 描画する高さ
 * @return {Jeeel.Graphics.Abstract} 自インスタンス
 */
Jeeel.Graphics.Abstract.prototype.drawImage = function (image, x, y, width, height) {
    
    switch (arguments.length) {
        case 2:
            if (x instanceof Jeeel.Object.Point) {
                this._adapter.drawImage(image, x.x, x.y);
            } else {
                this._adapter.drawImage(image, x.x, x.y, x.width, x.height);
            }
            break;
            
        case 3:
            this._adapter.drawImage(image, x, y);
            break;
            
        case 5:
            this._adapter.drawImage(image, x, y, width, height);
            break;
    }
    
    return this;
};

/**
 * コンストラクタ
 * 
 * @class 線を描画する際の情報を管理するクラス
 */
Jeeel.Graphics.Pen = function () {
    this._color = Jeeel.Object.Color.createRgb(0, 0, 0);
};

Jeeel.Graphics.Pen.prototype = {
    
    /**
     * 線の幅
     * 
     * @type Number
     * @private
     */
    _width: 1,
    
    /**
     * 線の色
     * 
     * @type Jeeel.Object.Color
     * @private
     */
    _color: null,
    
    /**
     * キャップのスタイル
     * 
     * @type String
     * @private
     */
    _cap: 'butt',
    
    /**
     * 接続スタイル
     * 
     * @type String
     * @private
     */
    _join: 'miter',
    
    /**
     * マイター限界比率
     * 
     * @type Number
     * @private
     */
    _miterLimit: 10,
    
    /**
     * 更新時自動コールバック
     * 
     * @type Function
     * @private
     */
    _callback: null,
    
    /**
     * ペン幅を取得する
     * 
     * @return {Number} ペン幅
     */
    getWidth: function () {
        return this._width;
    },
    
    /**
     * ペン幅を設定する
     * 
     * @param {Number} width ペン幅
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setWidth: function (width) {
        this._width = +width;
        
        return this.refresh(1);
    },
    
    /**
     * ペンの色を取得する
     * 
     * @return {Jeeel.Object.Color} ペンの色
     */
    getColor: function () {
        return this._color;
    },
    
    /**
     * ペンの色を設定する
     * 
     * @param {Jeeel.Object.Color} color ペンの色
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setColor: function (color) {
        this._color = color;
        
        return this.refresh(2);
    },
    
    /**
     * ペンのキャップスタイルを取得する
     * 
     * @return {String} キャップスタイル
     */
    getCapStyle: function () {
        return this._cap;
    },
    
    /**
     * ペンのキャップスタイルを設定する
     * 
     * @param {String} capStyle キャップスタイル
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setCapStyle: function (capStyle) {
        this._cap = capStyle;
        
        return this.refresh(3);
    },
    
    /**
     * ペンの線接続スタイルを取得する
     * 
     * @return {String} 接続スタイル
     */
    getJoinStyle: function () {
        return this._join;
    },
    
    /**
     * ペンの線接続スタイルを設定する
     * 
     * @param {String} join 接続スタイル
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setJoinStyle: function (join) {
        this._join = join;
        
        return this.refresh(4);
    },
    
    /**
     * ペンのマイター限界比率を取得する
     * 
     * @return {Number} マイター限界比率
     */
    getMiterLimit: function () {
        return this._miterLimit;
    },
    
    /**
     * ペンのマイター限界比率を設定する
     * 
     * @param {Number} miterLimit マイター限界比率
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setMiterLimit: function (miterLimit) {
        this._miterLimit = +miterLimit;
        
        return this.refresh(5);
    },
    
    /**
     * 更新を行った際に呼び出すコールバックを設定する
     * 
     * @param {Function} callback コールバック
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    setRefreshCallback: function (callback) {
        this._callback = callback;
        
        return this;
    },
    
    /**
     * 更新を行いコールバックを呼び出す
     * 
     * @param {Integer} [type] 更新タイプ
     * @return {Jeeel.Graphics.Pen} 自インスタンス
     */
    refresh: function (type) {
        if (this._callback) {
            this._callback(this, type || 0);
        }
        
        return this;
    }
};

/**
 * コンストラクタ
 * 
 * @class 面を塗りつぶす際の情報を管理するクラス
 */
Jeeel.Graphics.Brush = function () {
    this._color = Jeeel.Object.Color.createRgb(0, 0, 0);
};

Jeeel.Graphics.Brush.prototype = {
    
    /**
     * 塗りつぶしの色
     * 
     * @type Jeeel.Object.Color
     * @private
     */
    _color: null,
    
    /**
     * 更新時自動コールバック
     * 
     * @type Function
     * @private
     */
    _callback: null,
    
    /**
     * ブラシの色を取得する
     * 
     * @return {Jeeel.Object.Color} ブラシの色
     */
    getColor: function () {
        return this._color;
    },
    
    /**
     * ブラシの色を設定する
     * 
     * @param {Jeeel.Object.Color} color ブラシの色
     * @return {Jeeel.Graphics.Brush} 自インスタンス
     */
    setColor: function (color) {
        this._color = color;
        
        return this.refresh(1);
    },
    
    /**
     * 更新を行った際に呼び出すコールバックを設定する
     * 
     * @param {Function} callback コールバック
     * @return {Jeeel.Graphics.Brush} 自インスタンス
     */
    setRefreshCallback: function (callback) {
        this._callback = callback;
        
        return this;
    },
    
    /**
     * 更新を行いコールバックを呼び出す
     * 
     * @param {Integer} [type] 更新タイプ
     * @return {Jeeel.Graphics.Brush} 自インスタンス
     */
    refresh: function (type) {
        if (this._callback) {
            this._callback(this, type || 0);
        }
        
        return this;
    }
};
Jeeel.directory.Jeeel.Graphics.Raster = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Graphics + 'Raster/';
    }
};

/**
 * コンストラクタ
 * 
 * @class ラスター系のグラフィックス処理機能を提供するクラス
 * @augments Jeeel.Graphics.Abstract
 * @param {Jeeel.Graphics.Raster.*} adapter 内部アダプター
 */
Jeeel.Graphics.Raster = function (adapter) {
    Jeeel.Graphics.Abstract.call(this);
    
    this._adapter = adapter;
};

/**
 * Canvasタイプのインスタンスを作成する
 * 
 * @param {Canvas} canvas キャンバスElement
 * @param {String} [contextId] コンテキストID
 * @return {Jeeel.Graphics.Raster} 作成したインスタンス
 */
Jeeel.Graphics.Raster.factoryCanvas = function (canvas, contextId) {
    return new this(this.Canvas.factory(canvas, contextId));
};

Jeeel.Graphics.Raster.prototype = {
  
    /**
     * 未実装
     */
    strokePie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        throw new Error('未実装');
    },
    
    /**
     * 未実装
     */
    fillPie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        throw new Error('未実装');
    },
    
    /**
     * 未実装
     */
    drawArc: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        throw new Error('未実装');
    }
};

Jeeel.Class.extend(Jeeel.Graphics.Raster, Jeeel.Graphics.Abstract);

Jeeel.file.Jeeel.Graphics.Raster = ['Canvas'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics.Raster, Jeeel.file.Jeeel.Graphics.Raster);
Jeeel.directory.Jeeel.Graphics.Raster.Canvas = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Graphics.Raster + 'Canvas/';
    }
};

/**
 * @namespace Canvasに関してのネームスペース
 */
Jeeel.Graphics.Raster.Canvas = {
  
    /**
     * キャンバスの操作インスタンスの作成を行う
     * 
     * @param {Canvas} canvas キャンバス
     * @param {String} [contextId] コンテキストID
     * @return {Jeeel.Graphics.Raster.Canvas.Context.*} 作成したインスタンス
     */
    factory: function (canvas, contextId) {
        return this.Context.getContext(canvas, contextId || this.Context.Type.TWO_DIMENSION);
    }
};

Jeeel.file.Jeeel.Graphics.Raster.Canvas = ['Context'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics.Raster.Canvas, Jeeel.file.Jeeel.Graphics.Raster.Canvas);
Jeeel.directory.Jeeel.Graphics.Raster.Canvas.Context = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Graphics.Raster.Canvas + 'Context/';
    }
};

/**
 * @namespace Canvasのコンテキストに関するネームスペース
 */
Jeeel.Graphics.Raster.Canvas.Context = {
    
    /**
     * canvasのコンテキストを取得する
     * 
     * @param {Canvas} canvas キャンバスElement
     * @param {String} contextId コンテキストの種類を示す定数文字列
     * @return {Jeeel.Graphics.Raster.Canvas.Context.2d} コンテキスト
     */
    getContext: function (canvas, contextId) {
        return new this[contextId](canvas);
    },
    
    /**
     * コンストラクタ
     * 
     * @class 2次元のグラフィックスを扱うクラス
     * @param {Canvas} canvas キャンバスElement
     * @name Jeeel.Graphics.Raster.Canvas.Context.2d
     * @constructor
     */
    '2d': function (canvas) {
        this._canvas = canvas;
        this._context = canvas.getContext('2d');
        this._pen = new Jeeel.Graphics.Pen();
        this._brush = new Jeeel.Graphics.Brush();
        this._font = new Jeeel.Object.Font('sans-serif', '10px');
        
        var self = this, rp = this._refreshPen, rb = this._refreshBrush;
        
        /**
         * @ignore
         */
        this._refreshPen = function () {
            rp.apply(self, arguments);
        };
        
        /**
         * @ignore
         */
        this._refreshBrush = function () {
            rb.apply(self, arguments);
        };
        
        this._pen.setRefreshCallback(this._refreshPen);
        this._brush.setRefreshCallback(this._refreshBrush);
        
        this._context.textAlign = 'left';
        this._context.textBaseline = 'top';
    }
};

/**
 * @lends Jeeel.Graphics.Raster.Canvas.Context.2d.prototype
 */
Jeeel.Graphics.Raster.Canvas.Context['2d'].prototype = {
  
    /**
     * キャンバス
     * 
     * @type Canvas
     * @private
     */
    _canvas: null,
  
    /**
     * キャンバスコンテキスト
     * 
     * @type CanvasRenderingContext2D
     * @private
     */
    _context: null,
    
    /**
     * Penオブジェクト
     * 
     * @type Jeeel.Graphics.Pen
     * @private
     */
    _pen: null,
    
    /**
     * Brushオブジェクト
     * 
     * @type Jeeel.Graphics.Brush
     * @private
     */
    _brush: null,
    
    /**
     * Fontオブジェクト
     * 
     * @type Jeeel.Object.Font
     * @private
     */
    _font: null,
    
    /**
     * 線を描画する際のペンを取得する
     * 
     * @return {Jeeel.Graphics.Pen} Penオブジェクト
     */
    getPen: function () {
        return this._pen;
    },
    
    /**
     * 線を描画する際のペンを設定する
     * 
     * @param {Jeeel.Graphics.Pen} pen Penオブジェクト
     */
    setPen: function (pen) {
        this._pen.setRefreshCallback(null);
        this._pen = pen.setRefreshCallback(this._refreshPen).refresh();
    },
    
    /**
     * 面を塗りつぶすためのブラシを取得する
     * 
     * @return {Jeeel.Graphics.Brush} Brushオブジェクト
     */
    getBrush: function () {
        return this._brush;
    },
    
    /**
     * 面を塗りつぶすためのブラシを設定する
     * 
     * @param {Jeeel.Graphics.Brush} brush Brushオブジェクト
     */
    setBrush: function (brush) {
        this._brush.setRefreshCallback(null);
        this._brush = brush.setRefreshCallback(this._refreshPen).refresh();
    },
    
    /**
     * 文字を描くためのフォントを取得する
     * 
     * @return {Jeeel.Object.Font} フォント
     */
    getFont: function () {
        return this._font;
    },
    
    /**
     * 文字を描くためのフォントを設定する
     * 
     * @param {Jeeel.Object.Font} font フォント
     */
    setFont: function (font) {
        this._font = font;
    },
    
    /**
     * 線を描画する
     * 
     * @param {Number} x1 一つ目の座標X
     * @param {Number} y1 一つ目の座標Y
     * @param {Number} x2 二つ目の座標X
     * @param {Number} y2 二つ目の座標Y
     */
    drawLine: function (x1, y1, x2, y2) {
        this._context.beginPath();
        this._context.moveTo(x1, y1);
        this._context.lineTo(x2, y2);
        this._context.stroke();
    },
    
    /**
     * 長方形を描画する
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     */
    strokeRect: function (x, y, width, height) {
        this._context.strokeRect(x, y, width, height);
    },
    
    /**
     * 長方形を描画し塗りつぶす
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     */
    fillRect: function (x, y, width, height) {
        this._context.fillRect(x, y, width, height);
    },
    
    /**
     * 長方形のパス内をクリッピング対象にする
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipRect: function (x, y, width, height) {
        this._context.beginPath();
        this._context.rect(x, y, width, height);
        this._context.clip();
    },
    
    /**
     * 指定した頂点リストから多角形を描画する
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     */
    strokePolygon: function (vertexes) {
        this._drawPolygonPath(vertexes);
        this._context.stroke();
    },
    
    /**
     * 指定した頂点リストから多角形を描画し塗りつぶす
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     */
    fillPolygon: function (vertexes) {
        this._drawPolygonPath(vertexes);
        this._context.fill();
    },
    
    /**
     * 指定した頂点リストから多角形のパスを作り、その範囲をクリッピング対象にする
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipPolygon: function (vertexes) {
        this._drawPolygonPath(vertexes);
        this._context.clip();
    },
    
    /**
     * 楕円を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    strokeEllipse: function (x, y, radiusX, radiusY) {
        this._drawEllipsePath(x, y, radiusX, radiusY);
        this._context.stroke();
    },
    
    /**
     * 楕円を描画し塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    fillEllipse: function (x, y, radiusX, radiusY) {
        this._drawEllipsePath(x, y, radiusX, radiusY);
        this._context.fill();
    },
    
    /**
     * 楕円のパスを作り、その内部をクリッピング対象にする
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @return {Jeeel.Graphics.Abstract} 自インスタンス
     */
    clipEllipse: function (x, y, radiusX, radiusY) {
        this._drawEllipsePath(x, y, radiusX, radiusY);
        this._context.clip();
    },
    
    /**
     * 文字列を描画する
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     */
    strokeText: function (text, x, y) {
        this._context.font = this._font.toString();
        this._context.strokeText(text, x, y);
    },
    
    /**
     * 文字列を描画して塗りつぶす
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     */
    fillText: function (text, x, y) {
        this._context.font = this._font.toString();
        this._context.fillText(text, x, y);
    },
    
    /**
     * 扇形を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    strokePie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._drawArcPath(x, y, radiusX, radiusY, startAngle, endAngle, true);
        this._context.stroke();
    },
    
    /**
     * 扇形を描画して塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    fillPie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._drawArcPath(x, y, radiusX, radiusY, startAngle, endAngle, true);
        this._context.fill();
    },
    
    /**
     * 楕円弧を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    drawArc: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        this._drawArcPath(x, y, radiusX, radiusY, startAngle, endAngle);
        this._context.stroke();
    },
    
    /**
     * イメージを描画する
     * 
     * @param {Image} image 描画イメージ
     * @param {Number} imageX イメージ座標X
     * @param {Number} imageY イメージ座標Y
     * @param {Number} imageWidth 切り抜くイメージ幅
     * @param {Number} imageHeight 切り抜くイメージ高さ
     * @param {Number} drawX 描画座標X
     * @param {Number} drawY 描画座標Y
     * @param {Number} drawWidth 描画する幅
     * @param {Number} drawHeight 描画する高さ
     */
    drawImage: function (image, imageX, imageY, imageWidth, imageHeight, drawX, drawY, drawWidth, drawHeight) {
        switch (arguments.length) {
            case 3:
                this._context.drawImage(image, imageX, imageY);
                break;
                
            case 5:
                this._context.drawImage(image, imageX, imageY, imageWidth, imageHeight);
                break;
                
            case 9:
                this._context.drawImage(image, imageX, imageY, imageWidth, imageHeight, drawX, drawY, drawWidth, drawHeight);
                break;
                
            default:
                this._context.drawImage.apply(this._context, arguments);
                break;
        }
    },
    
    /**
     * 描画されている全ての図形を消去する
     */
    clear: function () {
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
    },
    
    /**
     * Penの更新時に呼ばれるコールバック
     * 
     * @param {Jeeel.Graphics.Pen} pen ペン
     * @param {Integer} type 更新タイプ
     */
    _refreshPen: function (pen, type) {
        switch (type) {
            case 0:
                this._context.lineWidth = pen.getWidth();
                this._context.strokeStyle = pen.getColor().toRgb().toRgbaString();
                this._context.lineCap = pen.getCapStyle();
                this._context.lineJoin = pen.getJoinStyle();
                this._context.miterLimit = pen.getMiterLimit();
                break;
                
            case 1:
                this._context.lineWidth = pen.getWidth();
                break;
                
            case 2:
                this._context.strokeStyle = pen.getColor().toRgb().toRgbaString();
                break;
                
            case 3:
                this._context.lineCap = pen.getCapStyle();
                break;
                
            case 4:
                this._context.lineJoin = pen.getJoinStyle();
                break;
                
            case 5:
                this._context.miterLimit = pen.getMiterLimit();
                break;
                
            default:
                break;
        }
    },
    
    /**
     * Brushの更新時に呼ばれるコールバック
     * 
     * @param {Jeeel.Graphics.Brush} brush ブラシ
     * @param {Integer} type 更新タイプ
     */
    _refreshBrush: function (brush, type) {
        switch (type) {
            case 0:
                this._context.fillStyle = brush.getColor().toRgb().toRgbaString();
                break;
                
            case 1:
                this._context.fillStyle = brush.getColor().toRgb().toRgbaString();
                break;
                
            default:
                break;
        }
    },
    
    /**
     * 多角形を描画する際のパスを設定する
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト
     */
    _drawPolygonPath: function (vertexes) {
        var v = vertexes[0];
        
        this._context.beginPath();
        this._context.moveTo(v.x, v.y);
        
        for (var i = vertexes.length; i--;) {
            v = vertexes[i];
            
            this._context.lineTo(v.x, v.y);
        }

        this._context.closePath();
    },
    
    /**
     * 楕円のパスを描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    _drawEllipsePath: function (x, y, radiusX, radiusY) {
        var top = y - radiusY;
        var left = x - radiusX;
        var bottom = y + radiusY;
        var right = x + radiusX;
        
        var cw = 4.0 * (Math.SQRT2 - 1.0) * radiusX / 3.0;
        var ch = 4.0 * (Math.SQRT2 - 1.0) * radiusY / 3.0;
        
        this._context.beginPath();

        this._context.moveTo(x, top);
        this._context.bezierCurveTo(x + cw, top, right, y - ch, right, y);
        this._context.bezierCurveTo(right, y + ch, x + cw, bottom, x, bottom);
        this._context.bezierCurveTo(x - cw, bottom, left, y + ch, left, y);
        this._context.bezierCurveTo(left, y - ch, x - cw, top, x, top);
        this._context.closePath();
    },
    
    /**
     * 楕円弧のパスを描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @param {Boolean} [isPie] 扇形かどうか
     */
    _drawArcPath: function (x, y, radiusX, radiusY, startAngle, endAngle, isPie) {
        var largeFlag = true, 
            sweepFlag = true, 
            PI2 = Math.PI * 2;
        
        if (startAngle > endAngle) {
            sweepFlag = false;
        }
        
        if (Math.abs(endAngle - startAngle) < Math.PI) {
            largeFlag = false;
        }
        
        while (startAngle < 0) {
            startAngle += PI2;
        }

        while (startAngle > PI2) {
            startAngle -= PI2;
        }

        while (endAngle < 0) {
            endAngle += PI2;
        }
        
        while (endAngle > PI2) {
            endAngle -= PI2;
        }
        
        if (Math.abs(endAngle - startAngle) >= PI2) {
            this._drawEllipsePath(x, y, radiusX, radiusY);
            return;
        }
        
        startAngle = PI2 - startAngle;
        endAngle = PI2 - endAngle;
        
        var sx = radiusX * Math.cos(startAngle);
        var sy = radiusY * Math.sin(startAngle);
        var ex = radiusX * Math.cos(endAngle);
        var ey = radiusY * Math.sin(endAngle);
        
        var cw = (radiusX * Math.cos(endAngle / 2 + startAngle) - sx / 2 - ex / 8) * 8 / 3;
        var ch = (radiusY * Math.sin(endAngle / 2 + startAngle) - ey / 2 - sy / 8) * 8 / 3;
        
        this._context.beginPath();
        this._context.moveTo(x + sx, y - sy);
        this._context.bezierCurveTo(x + sx, y - ch, x + cw, y - ey, x + ex, y - ey);
        this._context.stroke();
        
        console.log([sx + x, y - sy], [sx + x, y - ch], [x - cw, y - ey], [ex + x, y - ey], cw, ch);
    }
};

Jeeel.file.Jeeel.Graphics.Raster.Canvas.Context = ['Type'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics.Raster.Canvas.Context, Jeeel.file.Jeeel.Graphics.Raster.Canvas.Context);

/**
 * @namespace canvasのcontextに使用できるcontextIdの列挙体
 */
Jeeel.Graphics.Raster.Canvas.Context.Type = {
  
    /**
     * 2Dグラフィックスを扱うコンテキスト
     *
     * @type String
     * @constant
     */
    TWO_DIMENSION: '2d'
};
Jeeel.directory.Jeeel.Graphics.Vector = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Graphics + 'Vector/';
    }
};

/**
 * コンストラクタ
 * 
 * @class ベクター系のグラフィックス処理機能を提供するクラス
 * @augments Jeeel.Graphics.Abstract
 * @param {Jeeel.Graphics.Vector.*} adapter 内部アダプター
 */
Jeeel.Graphics.Vector = function (adapter) {
    Jeeel.Graphics.Abstract.call(this);
    
    this._adapter = adapter;
};

/**
 * SVGタイプのインスタンスを作成する
 * 
 * @param {SVG} svg SVGElement
 * @return {Jeeel.Graphics.Vector} 作成したインスタンス
 */
Jeeel.Graphics.Vector.factorySvg = function (svg) {
    return new this(new this.Svg(svg));
};

Jeeel.Graphics.Vector.prototype = {

};

Jeeel.Class.extend(Jeeel.Graphics.Vector, Jeeel.Graphics.Abstract);

Jeeel.file.Jeeel.Graphics.Vector = ['Svg'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Graphics.Vector, Jeeel.file.Jeeel.Graphics.Vector);

/**
 * コンストラクタ
 * 
 * @class SVGを管理するクラス
 * @param {SVGElement} svg SVG要素
 */
Jeeel.Graphics.Vector.Svg = function (svg) {
    this._svg = svg;
    this._doc = Jeeel.Dom.Document.create(svg.ownerDocument);
    this._pen = new Jeeel.Graphics.Pen();
    this._brush = new Jeeel.Graphics.Brush();
    this._font = new Jeeel.Object.Font('sans-serif');
};

Jeeel.Graphics.Vector.Svg.prototype = {
    /**
     * ドキュメント
     * 
     * @type Jeeel.Dom.Document
     * @private
     */
    _doc: null,
    
    /**
     * SVGElement
     * 
     * @type SVGElement
     */
    _svg: null,
    
    /**
     * Penオブジェクト
     * 
     * @type Jeeel.Graphics.Pen
     * @private
     */
    _pen: null,
    
    /**
     * Brushオブジェクト
     * 
     * @type Jeeel.Graphics.Brush
     * @private
     */
    _brush: null,
    
    /**
     * Fontオブジェクト
     * 
     * @type Jeeel.Object.Font
     * @private
     */
    _font: null,
    
    /**
     * 線を描画する際のペンを取得する
     * 
     * @return {Jeeel.Graphics.Pen} Penオブジェクト
     */
    getPen: function () {
        return this._pen;
    },
    
    /**
     * 線を描画する際のペンを設定する
     * 
     * @param {Jeeel.Graphics.Pen} pen Penオブジェクト
     */
    setPen: function (pen) {
        this._pen.setRefreshCallback(null);
        this._pen = pen.setRefreshCallback(this._refreshPen).refresh();
    },
    
    /**
     * 面を塗りつぶすためのブラシを取得する
     * 
     * @return {Jeeel.Graphics.Brush} Brushオブジェクト
     */
    getBrush: function () {
        return this._brush;
    },
    
    /**
     * 面を塗りつぶすためのブラシを設定する
     * 
     * @param {Jeeel.Graphics.Brush} brush Brushオブジェクト
     */
    setBrush: function (brush) {
        this._brush.setRefreshCallback(null);
        this._brush = brush.setRefreshCallback(this._refreshPen).refresh();
    },
    
    /**
     * 文字を描くためのフォントを取得する
     * 
     * @return {Jeeel.Object.Font} フォント
     */
    getFont: function () {
        return this._font;
    },
    
    /**
     * 文字を描くためのフォントを設定する
     * 
     * @param {Jeeel.Object.Font} font フォント
     */
    setFont: function (font) {
        this._font = font;
    },
    
    /**
     * 線を描画する
     * 
     * @param {Number} x1 一つ目の座標X
     * @param {Number} y1 一つ目の座標Y
     * @param {Number} x2 二つ目の座標X
     * @param {Number} y2 二つ目の座標Y
     */
    drawLine: function (x1, y1, x2, y2) {
        var line = this._createSvgElement('line');
        
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        
        this._setStroke(line);
    },
    
    /**
     * 長方形を描画する
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     */
    strokeRect: function (x, y, width, height) {
        var rect = this._createSvgElement('rect');
        
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', width);
        rect.setAttribute('height', height);
        
        this._setStroke(rect);
    },
    
    /**
     * 長方形を描画し塗りつぶす
     * 
     * @param {Number} x 座標X
     * @param {Number} y 座標Y
     * @param {Number} width 幅
     * @param {Number} height 高さ
     */
    fillRect: function (x, y, width, height) {
        var rect = this._createSvgElement('rect');
        
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', width);
        rect.setAttribute('height', height);
        
        this._setFill(rect);
    },
    
    /**
     * 指定した頂点リストから多角形を描画する
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     */
    strokePolygon: function (vertexes) {
        var polygon = this._createSvgElement('polygon');
        
        polygon.setAttribute('points', this._getPolygonPoints(vertexes));
        
        this._setStroke(polygon);
    },
    
    /**
     * 指定した頂点リストから多角形を描画し塗りつぶす
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト(最低3点必要、最後の点と最初の点は自動的に閉じられる)
     */
    fillPolygon: function (vertexes) {
        var polygon = this._createSvgElement('polygon');
        
        polygon.setAttribute('points', this._getPolygonPoints(vertexes));
        
        this._setFill(polygon);
    },
    
    /**
     * 楕円を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    strokeEllipse: function (x, y, radiusX, radiusY) {
        var ellipse = this._createSvgElement('ellipse');
        
        ellipse.setAttribute('cx', x);
        ellipse.setAttribute('cy', y);
        ellipse.setAttribute('rx', radiusX);
        ellipse.setAttribute('ry', radiusY);
        
        this._setStroke(ellipse);
    },
    
    /**
     * 楕円を描画し塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     */
    fillEllipse: function (x, y, radiusX, radiusY) {
        var ellipse = this._createSvgElement('ellipse');
        
        ellipse.setAttribute('cx', x);
        ellipse.setAttribute('cy', y);
        ellipse.setAttribute('rx', radiusX);
        ellipse.setAttribute('ry', radiusY);
        
        this._setFill(ellipse);
    },
    
    /**
     * 文字列を描画する
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     */
    strokeText: function (text, x, y) {
        var svgText = this._createSvgElement('text');
        
        svgText.setAttribute('x', x);
        svgText.setAttribute('font-size', this._font.size);
        svgText.setAttribute('font-family', this._font.family.join(','));
        svgText.setAttribute('font-style', this._font.style);
        svgText.setAttribute('font-weight', this._font.weight);
        
        svgText.appendChild(this._doc.createTextNode(text));
        
        this._setStroke(svgText);
        
        svgText.setAttribute('y', y + Jeeel.Dom.Element.prototype.getSize.call({_element: svgText}).height);
    },
    
    /**
     * 文字列を描画して塗りつぶす
     * 
     * @param {String} text 描画文字
     * @param {Number} x X座標
     * @param {Number} y Y座標
     */
    fillText: function (text, x, y) {
        var svgText = this._createSvgElement('text');
        
        svgText.setAttribute('x', x);
        svgText.setAttribute('font-size', this._font.size);
        svgText.setAttribute('font-family', this._font.family.join(','));
        svgText.setAttribute('font-style', this._font.style);
        svgText.setAttribute('font-weight', this._font.weight);
        
        svgText.appendChild(this._doc.createTextNode(text));
        
        this._setFill(svgText);
        
        svgText.setAttribute('y', y + Jeeel.Dom.Element.prototype.getSize.call({_element: svgText}).height);
    },
    
    /**
     * 扇形を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    strokePie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        var directions = this._getArcDirections(x, y, radiusX, radiusY, startAngle, endAngle, true);
        
        if (directions === false) {
            this.strokeEllipse(x, y, radiusX, radiusY);
            return;
        }
        
        var arc = this._createSvgElement('path');
        
        arc.setAttribute('d', directions);
        
        this._setStroke(arc);
    },
    
    /**
     * 扇形を描画して塗りつぶす
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    fillPie: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        var directions = this._getArcDirections(x, y, radiusX, radiusY, startAngle, endAngle, true);
        
        if (directions === false) {
            this.strokeEllipse(x, y, radiusX, radiusY);
            return;
        }
        
        var arc = this._createSvgElement('path');
        
        arc.setAttribute('d', directions);
        
        this._setFill(arc);
    },
    
    /**
     * 楕円弧を描画する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     */
    drawArc: function (x, y, radiusX, radiusY, startAngle, endAngle) {
        var directions = this._getArcDirections(x, y, radiusX, radiusY, startAngle, endAngle);
        
        if (directions === false) {
            this.strokeEllipse(x, y, radiusX, radiusY);
            return;
        }
        
        var arc = this._createSvgElement('path');
        
        arc.setAttribute('d', directions);
        
        this._setStroke(arc);
    },

    /**
     * イメージを描画する
     * 
     * @param {Image} image 描画イメージ
     * @param {Number} x 描画座標X
     * @param {Number} y 描画座標Y
     * @param {Number} [width] 描画する幅
     * @param {Number} [height] 描画する高さ
     */
    drawImage: function (image, x, y, width, height) {
        var svgImage = this._createSvgElement('image');
        
        svgImage.setAttribute('x', x);
        svgImage.setAttribute('y', y);
        
        if (width && height) {
            svgImage.setAttribute('width', width);
            svgImage.setAttribute('height', height);
        } else {
            svgImage.setAttribute('width', image.width);
            svgImage.setAttribute('height', image.height);
        }
        
        svgImage.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', image.src);
        
        this._svg.appendChild(svgImage);
    },
    
    /**
     * 描画されている全ての図形を消去する
     */
    clear: function () {
        var f, elm = this._svg;

        while (f = elm.firstChild) {
            elm.removeChild(f);
        }
    },
    
    /**
     * SVGエレメントを作成する
     * 
     * @param {String} tagName 作成するSVGエレメントのタグ名
     * @return {SVGElement} 作成したSVGエレメント
     */
    _createSvgElement: function (tagName) {
        return this._doc.createElementNS(this._svg.namespaceURI, tagName);
    },
    
    /**
     * 枠塗り図形としてSVGに追加する
     * 
     * @param {SVGElement} element 対象のSVGエレメント
     */
    _setStroke: function (element) {
        element.setAttribute('fill', 'none');
        element.setAttribute('stroke', this._pen.getColor().toRgb().toRgbaString());
        element.setAttribute('stroke-width', this._pen.getWidth());
        element.setAttribute('stroke-linecap', this._pen.getCapStyle());
        element.setAttribute('stroke-linejoin', this._pen.getJoinStyle());
        element.setAttribute('stroke-miterlimit', this._pen.getMiterLimit());
        
        this._svg.appendChild(element);
    },
    
    /**
     * 塗りつぶし図形としてSVGに追加する
     * 
     * @param {SVGElement} element 対象のSVGエレメント
     */
    _setFill: function (element) {
        element.setAttribute('stroke', 'none');
        element.setAttribute('fill', this._brush.getColor().toRgb().toRgbaString());
        
        this._svg.appendChild(element);
    },
    
    /**
     * 指定した頂点リストから文字列化を行う
     * 
     * @param {Jeeel.Object.Point[]} vertexes 頂点リスト
     * @return {String} 頂点表記文字列
     */
    _getPolygonPoints: function (vertexes) {
        var v,
            p = [];
        
        for (var i = vertexes.length; i--;) {
            v = vertexes[i];
            
            p[p.length] = v.x;
            p[p.length] = v.y;
        }

        return p.join(' ');
    },
    
    /**
     * 楕円弧を作成するための命令文を取得する
     * 
     * @param {Number} x 中心点X
     * @param {Number} y 中心点Y
     * @param {Number} radiusX X方向の半径
     * @param {Number} radiusY Y方向の半径
     * @param {Number} startAngle 円弧の始点の角度(ラジアン)
     * @param {Number} endAngle 円弧の終点の角度(ラジアン)
     * @param {Boolean} [isPie] 扇形かどうか
     * @return {String} 命令文
     */
    _getArcDirections: function (x, y, radiusX, radiusY, startAngle, endAngle, isPie) {
        var largeFlag = true, 
            sweepFlag = true, 
            PI2 = Math.PI * 2;
        
        if (startAngle > endAngle) {
            sweepFlag = false;
        }
        
        if (Math.abs(endAngle - startAngle) < Math.PI) {
            largeFlag = false;
        }
        
        while (startAngle < 0) {
            startAngle += PI2;
        }

        while (startAngle > PI2) {
            startAngle -= PI2;
        }

        while (endAngle < 0) {
            endAngle += PI2;
        }
        
        while (endAngle > PI2) {
            endAngle -= PI2;
        }
        
        if (Math.abs(endAngle - startAngle) >= PI2) {
            return false;
        }
        
        startAngle = PI2 - startAngle;
        endAngle = PI2 - endAngle;
        
        var sx = x + radiusX * Math.cos(startAngle);
        var sy = y - radiusY * Math.sin(startAngle);
        var ex = x + radiusX * Math.cos(endAngle);
        var ey = y - radiusY * Math.sin(endAngle);
        
        var d = [
            'M' + sx, 
            sy, 
            'A' + radiusX, 
            radiusY, 
            0, 
            +largeFlag, 
            +sweepFlag,
            ex, 
            ey
        ];
        
        if (isPie) {
            d[d.length] = 'L' + x;
            d[d.length] = y;
            d[d.length] = 'Z';
        }
        
        return d.join(' ');
    }
};
Jeeel.directory.Jeeel.Framework = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Framework/';
    }
};

/**
 * @namespace 大規模アプリケーション開発を円滑にするための汎用クラス等を保持するネームスペース
 * @see Jeeel.Framework.EventDispatcher
 * @see Jeeel.Framework.Event
 * @see Jeeel.Framework.Layer
 * @see Jeeel.Framework.Net.Connect
 * @see Jeeel.Framework.Mvc.Model
 * @see Jeeel.Framework.Mvc.View
 * @see Jeeel.Framework.Mvc.Controller
 * @see Jeeel.Framework.Acl
 * @see Jeeel.Framework.Acl.Role.Abstract
 * @see Jeeel.Framework.Acl.Resource.Abstract
 * @see Jeeel.Framework.Acl.Role.User
 * @see Jeeel.Framework.Acl.Resource.Url
 * @example
 * Frameworkネームスペース以下は大規模アプリケーション開発の補助ツールを提供する
 * この機能は現在大きく分けてMVCモデルのアプリの枠組みとACLを用いた認証システム機能を保持する
 * 
 * 
 * MVCモデル
 * この機能は継承前提のモデルであり枠組みとして使用するクラスも既に継承関係がある状態である
 * 枠組みに入る前の基底クラスを以下に示す
 * 
 * Jeeel.Framework.EventDispatcher
 * このクラスはイベントの送信、ハンドリングなどイベントの操作を行うクラス
 * このクラスは継承なしで使用できなく、継承後のクラスを使用して実装する
 * 
 * Jeeel.Framework.Event
 * ディスパッチャーと一緒に使うイベントの基底クラスで継承なしでも使用できる
 * 
 * Jeeel.Framework.Layer extends Jeeel.Framework.EventDispatcher
 * ディスパッチャーを継承するクラスで、それに加えて親子関係を管理するクラス
 * また子要素に追加、削除する時点で専用イベントを発生させるようになる
 * ディスパッチしたイベントも親子間のイベント伝搬を行いActionScriptのように、
 * キャプチャ段階、ターゲット段階、バグリング段階(設定をするとフォーリング段階も)を経てイベントが伝搬する
 * すなわち発生した要素の一番上のルート要素から発生要素まで辿って行き、またルート要素まで戻っていく一般的な(ASでは)イベントフローと、
 * ディスパッチするイベントの設定でフォーリング段階を追加した場合、発生要素以下の子要素全てに伝搬して行く逆フローが存在する
 * 発生の順番はキャプチャ、ターゲット、バブリング、フォーリングの順番で発生する
 * 
 * Jeeel.Framework.Net.Connect
 * サーバーへの接続を提供するクラスで、接続結果からコールバックを呼ぶ最低限の機能を保持したクラス
 * ただし、接続後の呼び出されるコールバックを指定しない場合は継承後のクラスのメソッドを呼ぶ仕様になっている
 * 
 * 
 * 派生クラス(MVC)
 * 以下のクラスは派生クラスであるが、MVC合わせて1パーツになるという考えのもと実装してある(.NetのPictureBoxなどを初めとする1パーツで最小完結型)
 * 従って大きなパーツを生成する際には1パーツ単位を複数組み合わせて実装する手法をお勧めする
 * 
 * モデルクラス
 * Jeeel.Framework.Mvc.Model extends Jeeel.Framework.Net.Connect
 * コネクトクラスを継承し、計算・サーバー接続を担うクラス
 * 
 * ビュークラス
 * Jeeel.Framework.Mvc.View extends Jeeel.Framework.Layer
 * レイヤークラスを継承し、HTML要素への描画指示やDOMイベントをハンドリングするクラス
 * このクラスはHTML要素と1対で対応し、対応するコントローラが親コントローラに追加された時に、
 * 親コントローラのビューに対して自動的にaddChildされる機能を保有する
 * ビューの親子関係は実要素となり、そのままHTML要素と同じ構成になるのが望ましい
 * また、子要素に対してコントローラに保持されないビューを追加する事も可能で、コントローラと組み合わせる必要のないくらい単純な要素に適用する(表示のみなど)
 * 
 * コントローラクラス
 * Jeeel.Framework.Mvc.Controller extends Jeeel.Framework.Layer
 * レイヤークラスを継承し、制御を担うクラス
 * このクラスはモデル、ビューを管理するクラスであり外部との中継役でもある
 * パーツ単位で親子関係を築く場合はこのクラス同士が結合し、ビュー同士も自動結合しそれに伴いHTML要素も結合する運びとなる
 * 基本的にイベントをディスパッチするのはこのクラスで行うべきである
 * 
 * 例：
 * <div id="mvc-owner">
 * </div>
 * 
 * // 親コントローラの定義
 * var Parent = function () {
 *     Jeeel.Framework.Mvc.Controller.call(this);
 *     
 *     this.addEventListener('child-click', this.onClick, false, this);
 * };
 * 
 * Parent.prototype = {
 *     onClick: function () {
 *         this._model.countClick();
 *     }
 * };
 * 
 * Jeeel.Class.extend(Parent, Jeeel.Framework.Mvc.Controller);
 * 
 * // 親モデルの定義
 * var ParentModel = function () {
 *     Jeeel.Framework.Mvc.Model.call(this);
 * };
 * 
 * ParentModel.prototype = {
 *     _cnt: 0,
 *     
 *     countClick: function () {
 *         this._cnt++;
 *         
 *         this.notify();
 *     }
 * };
 * 
 * Jeeel.Class.extend(ParentModel, Jeeel.Framework.Mvc.Model);
 * 
 * // 親ビューの定義
 * var ParentView = function () {
 *     Jeeel.Framework.Mvc.View.call(this, 'mvc-owner');
 * };
 * 
 * ParentView.prototype = {
 * };
 * 
 * Jeeel.Class.extend(ParentView, Jeeel.Framework.Mvc.View);
 * 
 * 
 * // 子コントローラの定義
 * var Child = function () {
 *     Jeeel.Framework.Mvc.Controller.call(this);
 *     
 *     this._view.addEventListener('child-click', this.onClick, false, this);
 * };
 * 
 * Child.prototype = {
 *     onClick: function (mvcEvent) {
 *         this.dispatchEvent(mvcEvent.clone(true));
 *     }
 * };
 * 
 * Jeeel.Class.extend(Child, Jeeel.Framework.Mvc.Controller);
 * 
 * // 子ビューの定義
 * var ChildView = function () {
 *     var elm = document.createElement('div');
 *     
 *     elm.innerHTML = 'Click Please!!.';
 *     
 *     Jeeel.Framework.Mvc.View.call(this, elm, true);
 *     
 *     this.addDomEventListener(Jeeel.Dom.Event.Type.CLICK, this.onClick, this);
 * };
 * 
 * ChildView.prototype = {
 *     onClick: function (domEvent) {
 *         var mvcEvent = new Jeeel.Framework.Event('child-click');
 *         
 *         this.dispatchEvent(mvcEvent);
 *     },
 *     
 *     update: function () {
 *         this._element.innerHTML = 'Clicked!!';
 *     }
 * };
 * 
 * Jeeel.Class.extend(ChildView, Jeeel.Framework.Mvc.View);
 * 
 * 
 * 以上のようなHTML、クラスがあった場合に以下のコードを実行する
 * 
 * var parent = new Parent();
 * var parentModel = new ParentModel();
 * var parentView = new ParentView();
 * 
 * parent.setModel(parentModel);
 * parent.setView(parentView);
 * 
 * var child = new Child();
 * child.setView(new ChildView());
 * 
 * parent.addChild(child);
 * 
 * その場合まずHTML要素は以下のようになる
 * 
 * <div id="mvc-owner">
 *   <div>Click Please!!.</div>
 * </div>
 * 
 * そしてクラスのインスタンス間のつながりは以下のようになる
 * 
 * parent: Parent
 *   _model: ParentModel
 *     _cnt: Integer
 *   _view: ParentView
 *     _element: <div id="mvc-owner"></div>
 *     _children: Array
 *       0: ChildView
 *   _children: Array
 *     0: Child
 *       _view: ChildView
 *         _element: <div>Click Please!!.</div>
 *         _parent: ParentView
 *         
 * 少し分かりにくいがPearentインスタンスのビューにはParentViewインスタンス、
 * ChildインスタンスのビューにはChildViewインスタンスがそれぞれセットされている
 * そしてPearentインスタンスの子要素にはChildインスタンス、
 * ParentViewインスタンスの子要素にはChildViewインスタンスがそれぞれ親子関係を結んでいる
 * 
 * 図で親子関係を示すと以下のようになる
 * PC: Parentインスタンス(parent)
 * PV: ParentViewインスタンス(parent._view)
 * CC: Childインスタンス(child)
 * CV: ChildViewインスタンス(child._view)
 * 
 * PC―CC
 * ｜  ｜
 * PV…CV
 * 
 * この状態になった後CVのHTML要素に対してClickをすると以下のようなイベント伝搬＋メソッドの呼び出しが起こる
 * <div>Click Please!!.</div>  ← DOM上でクリック
 * ↓
 * ChildView#onClick
 * ↓
 * Child#onClick
 * ↓
 * Parent#onClick
 * ↓
 * ParentModel#countClick
 * ↓
 * Parent#update スーパークラスで実装済み
 * ↓
 * ParentView#update スーパークラスで実装済み
 * ↓
 * ChildView#update
 * 
 * この伝搬はDOM上でのクリックをChildView#onClickでハンドリング後MVCイベントを生成しディスパッチする
 * Childで対応するビュー(ChildView)に対してイベントハンドリングをしていたのでChild#onClickが呼ばれる
 * Child#onClick内でMVCイベントを複製して親コントローラに対してディスパッチする(イベント伝搬)
 * Parentで自分に対してイベントハンドリングをしていたのでParent#onClickが呼ばれる
 * その後モデルのParentModel#countClickを呼びクリック回数をカウントした後それを更新した主旨をコントローラ(Parent)に伝える(updateメソッド)
 * コントローラ(Parent)はスパークラスでの実装通りにビュー(ParentView)に対して再描画指令(updateメソッド)を出す
 * ビューはスーパークラスの実装通りに子要素のupdateメソッドを呼びChildView#updateが呼ばれる
 * そしてChildView#updateにてClickした要素のinnnerHTMLがClickedに変化する
 * 
 * 他にも以下のようなメソッドが良く使用される
 * 
 * parent.update(); // 実装依存、初期ではビューのupdateを呼ぶ
 * parent.getView(); // ビューを取得する
 * parent.getModel(); // モデルを取得する
 * parentView.update(); // 実装依存、初期では子要素のupdateを呼ぶ(通常はコントローラを通して呼ばれる)
 * parentModel.notify(); // モデルのデータが更新された主旨をコントローラに伝える(コントローラのupdateメソッドを呼ぶ)
 * 
 * 
 * 
 * ACL認証機能
 * 
 * Jeeel.Framework.Acl
 * ロールベースアクセス制御を管理するクラス
 * このインスタンスに対してロールとリソースを追加していきアクセス許可を制御する
 * 
 * Jeeel.Framework.Acl.Role.Abstract
 * ロールの基底クラス
 * 以降に示すロールユーザー以外を定義したい場合に継承して使用する
 * 
 * Jeeel.Framework.Acl.Resource.Abstract
 * リソースの基底クラス
 * 以降に示すURLリソース以外を定義したい場合に継承して使用する
 * 
 * Jeeel.Framework.Acl.Role.User extends Jeeel.Framework.Acl.Role.Abstract
 * ロールの基本クラスであるロールユーザー
 * このクラスはユーザー名を引数に取る単純なロールである
 * ロールは継承を行うことが可能であり(例えばGuestユーザーを継承したAdministratorユーザーなど)、
 * スーパーユーザーの権限はサブユーザーに引き継がれる
 * 
 * Jeeel.Framework.Acl.Resource.Url extends Jeeel.Framework.Acl.Resource.Abstract
 * リソースの基本クラスであるURリソース
 * このクラスはURL(リソースID)と下位下層を同じリソース内と見るかどうかのみを保持するリソースである
 * リソースには権限の種類を追加する事が出来、URLの場合はAccessのみ保持する
 * もし車のリソースがあった場合はIDとなるのは車の車種、
 * 権限の種類はRide, Drive, Buy, Sell等となると思われる
 * 
 * これらの基本クラスを使う限りでは以下の箇所にJeeel.Framework.Aclインスタンスが入っているので利用が簡単である
 * Jeeel.Acl: Jeeel.Framework.Acl
 * このインスタンスは通常のACLに加えてJeeelを通してサーバーにアクセスしたりフォーム、アンカーなどのURL遷移を自動制御することが出来る
 * ロールは初期値でAdministrator(全権限)を保持している
 * 
 * 以下のメソッドが良く使用される
 * Jeeel.Acl.enableAutoControl(); // form、aに対して自動制御を行う(URLの)
 * Jeeel.Acl.addErrorEvent(func, thisArg); // ACLで不許可のURLに対してアクセスしようとしたした際のエラーイベントを追加する
 * 
 * 
 * 例：
 * 現在のURLがhttp://test.co.jp/indexだとする
 * 
 * Jeeel.Acl.enableAutoControl();
 * 
 * var role = Jeeel.Framework.Acl.Role.User.create('Guest');
 * var resource1 = Jeeel.Framework.Acl.Resource.Url.create('/index');
 * var resource2 = Jeeel.Framework.Acl.Resource.Url.create('/test');
 * 
 * Jeeel.Acl.addRole(role);
 * Jeeel.Acl.addResource(resource1);
 * Jeeel.Acl.addResource(resource2);
 * 
 * Jeeel.Acl.addRole.switchRole('Guest');
 * Jeeel.Acl.allow('/index');
 *
 * Jeeel.Acl.isAllowed('/index'); // true
 * Jeeel.Acl.isAllowed('/test'); // false
 * Jeeel.Acl.isAllowed('/join'); // false
 * Jeeel.Acl.isAllowed('http://test.co.jp/index'); // true
 * Jeeel.Acl.isAllowed('http://index.co.jp/index'); // false
 * 
 * Jeeel.UserAgent.setUrl('/index'); // Success
 * Jeeel.UserAgent.setUrl('/test'); // Error
 * 
 * Jeeel.Acl.addRole.switchRole('Administrator');
 * 
 * Jeeel.Acl.isAllowed('/index'); // true
 * Jeeel.Acl.isAllowed('/test'); // true
 * Jeeel.Acl.isAllowed('/join'); // true
 * Jeeel.Acl.isAllowed('http://test.co.jp/index'); // true
 * Jeeel.Acl.isAllowed('http://index.co.jp/index'); // true
 * 
 * Jeeel.UserAgent.setUrl('/index'); // Success
 * Jeeel.UserAgent.setUrl('/test'); // Success
 */
Jeeel.Framework = {
    
};

Jeeel.file.Jeeel.Framework = ['Net', 'Event', 'EventDispatcher', 'Layer', 'Mvc', 'Acl'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework, Jeeel.file.Jeeel.Framework);
Jeeel.directory.Jeeel.Framework.Net = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Framework + 'Net/';
    }
};

/**
 * @namespace ネット関連のネームスペース
 */
Jeeel.Framework.Net = {

};

Jeeel.file.Jeeel.Framework.Net = ['Connect'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework.Net, Jeeel.file.Jeeel.Framework.Net);

/**
 * コンストラクタ
 * 
 * @class サーバーコネクトのプロトタイプ
 */
Jeeel.Framework.Net.Connect = function () {
    
};

Jeeel.Framework.Net.Connect.prototype = {
    
    /**
     * 並列接続時の動作ポリシー
     * 
     * @type Integer
     * @protected
     */
    _collisionPolicy: 0,
    
    /**
     * タイムアウト時間(ミリ秒)
     * 
     * @type Integer
     * @protected
     */
    _timeout: 60000,
    
    /**
     * HTTPメソッド
     * 
     * @type String
     * @protected
     */
    _method: 'POST',
    
    /**
     * Ajaxインスタンス
     * 
     * @type Jeeel.Net.Ajax
     * @protected
     */
    _ajax: null,
    
    /**
     * 並列リクエストをした場合の動作を設定する
     * 
     * @param {Integer} collisionPolicy コリジョンポリシー
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     * @see Jeeel.Net.Ajax.CollisionPolicy
     */
    setCollisionPolicy: function (collisionPolicy) {
        this._collisionPolicy = collisionPolicy;
        
        return this;
    },
    
    /**
     * リクエストのタイムアウトまでの時間を設定する(デフォルトは60秒)
     * 
     * @param {Integer} time タイムアウト時間、0で無制限(ミリ秒)
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     */
    setTimeoutTime: function (time) {
        this._timeout = time;
        
        return this;
    },
    
    /**
     * HTTPメソッドを設定する
     * 
     * @param {String} [method] HTTPメソッド(POSTもしくはGET、大文字小文字は問わない)
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     */
    setMethod: function (method) {
        this._method = method;
        
        return this;
    },
    
    /**
     * サーバーに接続する
     * 
     * @param {String} url 接続URL
     * @param {Hash} [params] 送信データのリスト
     * @param {Function} [success] 成功時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
     * @param {Function} [failure] 失敗時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
     * @param {Function} [timeout] タイムアウト時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     */
    connect: function (url, params, success, failure, timeout) {
        this._ajax = new Jeeel.Net.Ajax(url, this._method);
        
        this._ajax.setAll(params || {})
                  .setTimeoutTime(this._timeout)
                  .setCollisionPolicy(this._collisionPolicy)
                  .setSuccessMethod(success || this.update, this)
                  .setFailureMethod(failure || this.recover, this)
                  .setTimeoutMethod(timeout || this.abanbon, this)
                  .setCompleteMethod(function () {
                      this._ajax = null;
                  }, this)
                  .execute();
        
        return this;
    },
    
    /**
     * 現在の通信を中止させる
     * 
     * @return {Jeeel.Framework.Net.Connect} 自インスタンス
     */
    abort: function () {
        if (this._ajax) {
            this._ajax.abort();
        }
        
        return this;
    },
    
    /**
     * 接続成功時に通常呼ばれるコールバック(内部のthisは自インスタンスになる)
     * 
     * @param {Jeeel.Net.Ajax.Response} response レスポンス
     * @abstract
     */
    update: function (response) {
        
    },
    
    /**
     * タイムアウト時に通常呼ばれるコールバック(内部のthisは自インスタンスになる)
     * 
     * @param {Jeeel.Net.Ajax.Response} response レスポンス
     * @abstract
     */
    abanbon: function (response) {
        
    },
    
    /**
     * エラー時に通常呼ばれるコールバック(内部のthisは自インスタンスになる)
     * 
     * @param {Jeeel.Net.Ajax.Response} response レスポンス
     * @abstract
     */
    recover: function (response) {
        
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Net.Connect
};
Jeeel.directory.Jeeel.Framework.Event = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Framework + 'Event/';
    }
};

/**
 * コンストラクタ
 * 
 * @class イベントを管理するクラス<br />
 *         イベントの伝播は最上層からキャプチャリング段階に入り発生地点までたどる<br />
 *         発生地点でターゲティング段階になり、バブリング段階になって最上層に向かって上っていく<br />
 *         最後にフォーリング段階になり発生地点から最下層まで全ての要素に伝播していく
 * @param {String} type イベントタイプ
 * @param {Boolean} [bubbles=true] バブリング処理をするかどうか(上位伝播)
 * @param {Boolean} [falls] フォーリング処理をするかどうか(下位伝播)
 * @param {Boolean} [cancelable] デフォルト動作をキャンセル出来るかどうか(存在しない場合や出来ない場合がfalse)
 */
Jeeel.Framework.Event = function (type, bubbles, falls, cancelable) {
    this._type = type;
    this._bubbles = !!(bubbles === false ? bubbles : bubbles || true);
    this._falls = !!falls;
    this._cancelable = !!cancelable;
    this._captureTargets = [];
};

Jeeel.Framework.Event.prototype = {
  
    /**
     * イベントタイプ
     * 
     * @type String
     * @protected
     */
    _type: '',
    
    /**
     * 上階層の要素にバブリングフローをするかどうか
     * 
     * @type Boolean
     * @protected
     */
    _bubbles: true,
    
    /**
     * 下階層の要素にフォーリングフローするかどうか
     * 
     * @type Boolean
     * @protected
     */
    _falls: false,
    
    /**
     * デフォルトの動作をキャンセル出来るかどうか
     * 
     * @type Boolean
     * @protected
     */
    _cancelable: false,
    
    /**
     * デフォルトの挙動をキャンセルしたかどうか
     * 
     * @type Boolean
     * @protected
     */
    _cancelDefault: false,
    
    /**
     * イベントのハンドリングをキャンセルしたかどうか
     * 
     * @type Boolean
     * @protected
     */
    _cancelHandle: false,
    
    /**
     * イベントの伝播をキャンセルしたかどうか
     * 
     * @type Boolean
     * @protected
     */
    _cancelFlow: false,
    
    /**
     * イベントフェーズ
     * 
     * @type Integer
     * @protected
     */
    _phase: 1,
    
    /**
     * キャプチャ段階で使用する対象リスト
     * 
     * @type Object[]
     * @protected
     */
    _captureTargets: [],
    
    /**
     * イベント発生対象
     * 
     * @type Object
     * @protected
     */
    _target: null,
    
    /**
     * イベントハンドリング対象
     * 
     * @type Object
     * @protected
     */
    _currentTarget: null,
    
    /**
     * イベントタイプを取得する
     * 
     * @return {String} イベントタイプ
     */
    getType: function () {
        return this._type;
    },
    
    /**
     * バブリング処理をするかどうかを返す
     * 
     * @return {Boolean} バブリング処理をするかどうか
     */
    useBubbles: function () {
        return this._bubbles;
    },
    
    /**
     * フォーリング段階をするかどうかを返す
     * 
     * @return {Boolean} フォーリング処理をするかどうか
     */
    useFalls: function () {
        return this._falls;
    },
    
    /**
     * 現在のイベントフェーズを示す定数を取得する
     * 
     * @return {Integer} イベントフェーズ定数
     */
    getEventPhase: function () {
        return this._phase;
    },
    
    /**
     * イベント発生対象を取得する
     * 
     * @return {Object} イベント発生対象
     */
    getTarget: function () {
        return this._target;
    },
    
    /**
     * イベントハンドリング対象を取得する
     * 
     * @return {Object} イベントハンドリング対象
     */
    getCurrentTarget: function () {
        return this._currentTarget;
    },
    
    /**
     * イベントのデフォルトの動作がキャンセル出来るかどうかを返す
     * 
     * @return {Boolean} キャンセル出来るかどうか
     */
    isCancelable: function () {
        return this._cancelable;
    },
    
    /**
     * デフォルトの挙動がキャンセルされたかどうかを返す
     * 
     * @return {Boolean} キャンセルされたかどうか
     */
    isDefaultPrevented: function () {
        return this._cancelDefault;
    },
    
    /**
     * イベントのデフォルトの動作をキャンセルする<br />
     * デフォルトの挙動のキャンセルが許可されていない場合は無意味
     * 
     * @return {Jeeel.Framework.Event} 自インスタンス
     */
    preventDefault: function () {
        if (this._cancelable) {
            this._cancelDefault = true;
        }
        
        return this;
    },
    
    /**
     * イベントの伝播を止める
     * 
     * @return {Jeeel.Framework.Event} 自インスタンス
     */
    stopPropagation: function () {
        this._cancelFlow = true;
        
        return this;
    },
    
    /**
     * イベントの伝播とハンドリングを止める
     * 
     * @return {Jeeel.Framework.Event} 自インスタンス
     */
    stopImmediatePropagation: function () {
        this._cancelFlow = this._cancelHandle = true;
        
        return this;
    },
    
    /**
     * イベントの伝播、ハンドリング、デフォルトの挙動全てを停止する
     * 
     * @return {Jeeel.Framework.Event} 自インスタンス
     */
    stop: function () {
        this._cancelDefault = this._cancelFlow = this._cancelHandle = true;
        
        return this;
    },
    
    /**
     * 複製を行う
     * 
     * @param {Boolean} [dispatchable] ディスパッチ済みのインスタンスを複製した際にディスパッチ出来るようにするかどうか
     * @return {Jeeel.Framework.Event} 複製したインスタンス
     */
    clone: function (dispatchable) {
        var instance = new this.constructor(this._type, this._bubbles, this._cancelable);
        
        for (var key in this) {
            if ( ! Jeeel.Type.isFunction(this[key])) {
                instance[key] = this[key];
            }
        }
        
        for (var i = this._captureTargets.length; i--;) {
            instance._captureTargets[i] = this._captureTargets[i];
        }
        
        if (dispatchable) {
            instance._phase = 1;
            instance._target = null;
        }
        
        return instance;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Event
};

Jeeel.file.Jeeel.Framework.Event = ['Phase', 'Type'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework.Event, Jeeel.file.Jeeel.Framework.Event);

/**
 * @namespace イベントフェーズの列挙体
 */
Jeeel.Framework.Event.Phase = {
  
    /**
     * キャプチャ段階
     * 
     * @type Integer
     * @constant
     */
    CAPTURING: 1,
    
    /**
     * ターゲット段階
     * 
     * @type Integer
     * @constant
     */
    TARGETING: 2,
    
    /**
     * バブリング段階
     * 
     * @type Integer
     * @constant
     */
    BUBBLING: 3,
    
    /**
     * フォーリング段階
     * 
     * @type Integer
     * @constant
     */
    FALLING: 4
};
/**
 * @namespace イベントタイプの列挙体
 */
Jeeel.Framework.Event.Type = {
  
    /**
     * レイヤーオブジェクトがaddChildで追加された時に発生する
     * 
     * @type String
     * @constant
     */
    ADDED: 'Added',
    
    /**
     * レイヤーオブジェクトがremoveChildで削除された時に発生する
     * 
     * @type String
     * @constant
     */
    REMOVED: 'Removed'
};
/**
 * コンストラクタ
 * 
 * @class イベントのハンドリング、ディスパッチを行うクラス
 */
Jeeel.Framework.EventDispatcher = function () {
    this._eventHandlers = {};
};

Jeeel.Framework.EventDispatcher.prototype = {
    
    /**
     * 登録イベントハンドラー
     * 
     * @type Hash
     * @private
     */
    _eventHandlers: {},
    
    /**
     * イベントの登録を行う
     * 
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録リスナー
     * @param {Boolean} [useCapture] キャプチャ段階でリスナーを呼び出すかどうか
     * @param {Mixied} [thisArg] イベントリスナー内でthisに相当する値
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Framework.Event、２つ目以降に任意引数)
     * @return {Jeeel.Framework.EventDispatcher} 自インスタンス
     */
    addEventListener: function (type, listener, useCapture, thisArg, var_args) {
        if ( ! this._eventHandlers[type]) {
            this._eventHandlers[type] = [];
        }
        
        useCapture = !!useCapture;
        
        var handlers = this._eventHandlers[type];
        
        for (var i = handlers.length; i--;) {
            if (handlers[i].listener === listener && handlers[i].useCapture === useCapture) {
                return this;
            }
        }
        
        var args = Array.prototype.slice.call(arguments, 4, arguments.length);
        
        args.unshift(null);
          
        handlers[handlers.length] = {
            listener: listener,
            useCapture: useCapture,
            thisArg: thisArg,
            args: args
        };
        
        return this;
    },
    
    /**
     * イベントの削除を行う
     * 
     * @param {String} type イベントタイプ
     * @param {Function} listener 削除リスナー
     * @param {Boolean} [useCapture] キャプチャ段階でリスナーを呼び出すかどうか
     * @return {Jeeel.Framework.EventDispatcher} 自インスタンス
     */
    removeEventListener: function (type, listener, useCapture) {
        var handlers = this._eventHandlers[type];
        
        if ( ! handlers) {
            return this;
        }
        
        useCapture = !!useCapture;
        
        for (var i = handlers.length; i--;) {
            if (handlers[i].listener === listener && handlers[i].useCapture === useCapture) {
                handlers.splice(i, 1);
                break;
            }
        }
        
        return this;
    },
    
    /**
     * 指定したイベントタイプのイベントが登録されているかどうかを返す
     * 
     * @param {String} type イベントタイプ
     * @return {Boolean} 登録されているかどうか
     */
    hasEventListener: function (type) {
        return !!(this._eventHandlers[type] && this._eventHandlers[type].length);
    },
    
    /**
     * イベントを発生させる
     * 
     * @param {Jeeel.Framework.Event} event 発生対象のEvent
     * @return {Jeeel.Framework.EventDispatcher} 自インスタンス
     */
    dispatchEvent: function (event) {
        if (event._target) {
            throw new Error('eventは既にディスパッチ済みのEventオブジェクトです。');
        }
        
        event._target = this;
        
        event._captureTargets.push(this);
        
        return this._flowEvent(event);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.EventDispatcher,
    
    /**
     * 他のディスパッチャーで発生したイベントを疑似フローさせる
     * 
     * @param {Jeeel.Framework.Event} event 疑似フロー対象のEvent
     * @return {Jeeel.Framework.EventDispatcher} 自インスタンス
     * @final
     * @protected
     */
    _flowEvent: function (event) {
        if (event._cancelFlow) {
            return this;
        }
        
        var phase = event.getEventPhase();
        
        this._callListener(event, phase === Jeeel.Framework.Event.Phase.CAPTURING);
        
        switch (phase) {
            case Jeeel.Framework.Event.Phase.CAPTURING:
                var capture = event._captureTargets.pop();
                
                if (capture === event._target) {
                    event._phase = Jeeel.Framework.Event.Phase.TARGETING;
                } else if (capture === this) {
                    capture = event._captureTargets.pop();
                    
                    if (capture === event._target) {
                        event._phase = Jeeel.Framework.Event.Phase.TARGETING;
                    }
                }
                
                capture._flowEvent(event);
                break;
                
            case Jeeel.Framework.Event.Phase.TARGETING:
                if (event.useBubbles() || event.useFalls()) {
                    if (event.useBubbles()) {
                        event._phase = Jeeel.Framework.Event.Phase.BUBBLING;
                        this._flowBubblingPhaseEvent(event);
                    }
                    
                    if (event.useFalls()) {
                        event._phase = Jeeel.Framework.Event.Phase.FALLING;
                        this._flowFallingPhaseEvent(event);
                    }
                } else {
                    event._cancelFlow = true;
                }
                
                break;
            
            case Jeeel.Framework.Event.Phase.BUBBLING:
                if (event.useBubbles()) {
                    this._flowBubblingPhaseEvent(event);
                }
                break;
                
            case Jeeel.Framework.Event.Phase.FALLING:
                if (event.useFalls()) {
                    this._flowFallingPhaseEvent(event);
                }
                break;
                
            default:
                throw new Error('フェーズの状態が不明です。');
                break;
        }
        
        return this;
    },
    
    /**
     * イベントをバブリングする
     * 
     * @param {Jeeel.Framework.Event} event バブリング対象のEvent
     * @protected
     * @abstract
     */
    _flowBubblingPhaseEvent: function (event) {
        
    },
    
    /**
     * イベントをフォーリングする
     * 
     * @param {Jeeel.Framework.Event} event フォーリング対象のEvent
     * @protected
     * @abstract
     */
    _flowFallingPhaseEvent: function (event) {
        
    },
    
    /**
     * このインスタンスに定義されているリスナーを呼び出す
     * 
     * @param {Jeeel.Framework.Event} event Eventオブジェクト
     * @param {Boolean} useCapture キャプチャ段階でのリスナーをキャッチするかどうか
     * @final
     * @protected
     */
    _callListener: function (event, useCapture) {
        if (event._cancelHandle) {
            return this;
        }
        
        var handlers = this._eventHandlers[event.getType()];
        
        if ( ! handlers) {
            return this;
        }
        
        event._currentTarget = this;
        
        var cloneHandlers = handlers.concat();
        
        for (var i = 0, l = cloneHandlers.length; i < l; i++) {
            
            if (cloneHandlers[i].useCapture === useCapture) {
                cloneHandlers[i].args[0] = event;
                
                cloneHandlers[i].listener.apply(cloneHandlers[i].thisArg, cloneHandlers[i].args);
                
                cloneHandlers[i].args[0] = null;

                if (event._cancelHandle) {
                    break;
                }
            }
        }
        
        return this;
    }
};

/**
 * コンストラクタ
 * 
 * @class 階層構造のオブジェクトを管理するクラス
 * @augments Jeeel.Framework.EventDispatcher
 */
Jeeel.Framework.Layer = function () {
    Jeeel.Framework.EventDispatcher.call(this);
    
    this._children = [];
};

Jeeel.Framework.Layer.prototype = {
    
    /**
     * 親レイヤー
     * 
     * @type Jeeel.Framework.Layer
     * @protected
     */
    _parent: null,
    
    /**
     * 子レイヤーリスト
     * 
     * @type Jeeel.Framework.Layer[]
     * @protected
     */
    _children: [],
    
    /**
     * 子レイヤーを追加する
     * 
     * @param {Jeeel.Framework.Layer} child 子レイヤー
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    addChild: function (child) {
        this._children[this._children.length] = child;
        
        child._refreshRelationship(this);
        
        return this;
    },
    
    /**
     * 子レイヤーを削除する
     * 
     * @param {Jeeel.Framework.Layer} child 子レイヤー
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    removeChild: function (child) {
        for (var i = this._children.length; i--;) {
            if (this._children[i] === child) {
                this._children.splice(i, 1);
                child._refreshRelationship();
                break;
            }
        }

        return this;
    },
    
    /**
     * 指定したインデックスの子レイヤーを削除する
     * 
     * @param {Integer} index インデックス
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    removeChildAt: function (index) {
        if (this._children[index]) {
            var child = this._children[index];
            
            this._children.splice(index, 1);
            
            child._refreshRelationship();
        }
        
        return this;
    },
    
    /**
     * 全ての子レイヤーを削除する
     * 
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    removeChildren: function () {
        for (var i = this._children.length; i--;) {
            this._children[i]._refreshRelationship();
        }
        
        this._children.splice(0, this._children.length);
        
        return this;
    },
    
    /**
     * 親レイヤーを取得する
     * 
     * @return {Jeeel.Framework.Layer} 親レイヤー
     */
    getParent: function () {
        return this._parent;
    },
    
    /**
     * 子レイヤーリストを取得する
     * 
     * @return {Jeeel.Framework.Layer[]} 子レイヤーリスト
     */
    getChildren: function () {
        return this._children;
    },
    
    /**
     * 指定したインデックスの子レイヤーを取得する
     * 
     * @param {Integer} index インデックス
     * @return {Jeeel.Framework.Layer} 子レイヤー
     */
    getChildAt: function (index) {
        return this._children[index] || null;
    },
    
    /**
     * 子レイヤーの数を取得する
     * 
     * @return {Integer} 子レイヤーの数
     */
    getChildSize: function () {
        return this._children.length;
    },
    
    /**
     * イベントを発生させる
     * 
     * @param {Jeeel.Framework.Event} event 発生対象のEvent
     * @return {Jeeel.Framework.Layer} 自インスタンス
     */
    dispatchEvent: function (event) {
        if ( ! (event instanceof Jeeel.Framework.Event)) {
            throw new Error('eventが指定されていません。');
        } else if (event._target) {
            throw new Error('eventは既にディスパッチ済みのEventオブジェクトです。');
        }
        
        event._target = this;
        
        var layer = this;
        var captureTargets = event._captureTargets;
        
        while (layer) {
            captureTargets[captureTargets.length] = layer;
            layer = layer._parent;
        }
        
        captureTargets[captureTargets.length - 1]._flowEvent(event);
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Layer,
    
    /**
     * ディスパッチされたイベントのフローを親レイヤーに伝える
     * 
     * @param {Jeeel.Framework.Event} event フロー対象のEvent
     * @return {Jeeel.Framework.Layer} 自インスタンス
     * @protected
     */
    _flowBubblingPhaseEvent: function (event) {
        // 上位伝播対象でイベントがキャンセルしていない場合に親レイヤーに伝播する
        if (this._parent && event.useBubbles() && ! event._cancelFlow) {
            this._parent._flowEvent(event);
        }
    },
    
    /**
     * ディスパッチされたイベントのフローを子レイヤーに伝える
     * 
     * @param {Jeeel.Framework.Event} event フォーリング対象のEvent
     * @return {Jeeel.Framework.Layer} 自インスタンス
     * @protected
     */
    _flowFallingPhaseEvent: function (event) {
        // 下位伝播対象でイベントがキャンセルしていない場合に子レイヤーに伝播する
        if (event.useFalls() && ! event._cancelFlow) {
            for (var i =  this._children.length; i--;) {
                this._children[i]._flowEvent(event);
            }
        }
    },
    
    /**
     * 親に追加された時に呼び出される(デフォルトの挙動)
     * 
     * @abstract
     * @protected
     */
    _onAddedThis: function (parent) {
        
    },
    
    /**
     * 親から削除された時に呼び出される(デフォルトの挙動)
     * 
     * @abstract
     * @protected
     */
    _onRemovedThis: function (parent) {
        
    },
    
    /**
     * 親子関係の更新する
     * 
     * @param {Jeeel.Framework.Layer} parent 親レイヤー
     * @final
     * @protected
     */
    _refreshRelationship: function (parent) {
        var event;
        
        if ( ! parent) {
            parent = this._parent;
            this._parent = null;
            
            event = new Jeeel.Framework.Event(Jeeel.Framework.Event.Type.REMOVED, true, false, true);
            
            this.dispatchEvent(event);
            
            if ( ! event.isDefaultPrevented()) {
                this._onRemovedThis(parent);
            }
            return;
        } else if (this._parent) {
            this._parent.removeChild(this);
        }
        
        this._parent = parent;
        
        event = new Jeeel.Framework.Event(Jeeel.Framework.Event.Type.ADDED, true, false, true);
        
        this.dispatchEvent(event);
        
        if ( ! event.isDefaultPrevented()) {
            this._onAddedThis(parent);
        }
    }
};

Jeeel.Class.extend(Jeeel.Framework.Layer, Jeeel.Framework.EventDispatcher);
Jeeel.directory.Jeeel.Framework.Mvc = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Framework + 'Mvc/';
    }
};

/**
 * @namespace MVCモデル関連のネームスペース
 */
Jeeel.Framework.Mvc = {
    
};

Jeeel.file.Jeeel.Framework.Mvc = ['Model', 'View', 'Controller'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework.Mvc, Jeeel.file.Jeeel.Framework.Mvc);

/**
 * コンストラクタ
 * 
 * @class モデルのプロトタイプ
 * @augments Jeeel.Framework.Net.Connect
 */
Jeeel.Framework.Mvc.Model = function () {
    Jeeel.Framework.Net.Connect.call(this);
    
    this._state = {};
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Framework.Mvc.Model} 作成したインスタンス
 */
Jeeel.Framework.Mvc.Model.create = function () {
    return new this();
};

Jeeel.Framework.Mvc.Model.prototype = {
    
    /**
     * モデルのステータス(配列もしくは連想配列)
     * 
     * @type Hash
     * @protected
     */
    _state: {},
    
    /**
     * このモデルを管理するコントローラ
     * 
     * @type Jeeel.Framework.Mvc.Controller
     * @protected
     */
    _controller: null,
    
    /**
     * ステータスを取得する
     * 
     * @return {Hash} ステータス
     */
    getState: function () {
        return this._state;
    },
    
    /** 
     * ステータスを設定する
     * 
     * @param {Hash} state ステータス
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    setState: function (state) {},
    
    /**
     * モデルの初期化を行い、登録してあるビューに通知する
     * 
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    init: function () {
        this._state = {};
        return this.notify();
    },
    
    /**
     * サーバー接続後に呼び出される
     * 
     * @param {Jeeel.Net.Ajax.Response} response レスポンス
     */
    update: function (response) {
        var res;
        
        try {
            res = Jeeel.Json.decode(decodeURIComponent(response.responseText));
        } catch (e) {}
        
        if ( ! Jeeel.Type.isHash(res)) {
            this.recover(response);
        } else {
            this._state = res;
            this.notify();
        }
    },
        
    /**
     * コントローラを紐付ける
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    attach: function (controller) {
        if (this._controller) {
            this._controller.setModel(null);
        }
        
        this._controller = controller;
        
        return this;
    },
    
    /**
     * コントローラとの紐付けを解除する
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    detach: function (controller) {
        if (this._controller === controller) {
            this._controller = null;
        }
        
        return this;
    },
    
    /**
     * ビューへの通知を行う
     * 
     * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
     */
    notify: function () {
        this._controller.update();
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Mvc.Model
};

/**
 * ステータスをサーバーから取得し設定する
 * 
 * @param {String} url 取得先URL
 * @param {Hash} [params] 送信データのリスト
 * @param {Function} [success] 成功時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
 * @param {Function} [failure] 失敗時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
 * @param {Function} [timeout] タイムアウト時のコールバック(明示的に指定する場合) void callBack(Jeeel.Net.Ajax.Response response)
 * @return {Jeeel.Framework.Mvc.Model} 自インスタンス
 */
Jeeel.Framework.Mvc.Model.prototype.setState = function (url, params, success, failure, timeout) {
    var state = url;
    
    if (Jeeel.Type.isString(url) || arguments.length > 1) {
        return this.connect(url, params, success, failure, timeout);
    }
    
    if ( ! Jeeel.Type.isHash(state)) {
        throw new Error('stateがHashではありません。');
    }

    this._state = state;
    
    return this;
};

Jeeel.Class.extend(Jeeel.Framework.Mvc.Model, Jeeel.Framework.Net.Connect);

/**
 * コンストラクタ
 * 
 * @class ビューのプロトタイプ(Elementのラッパー要素の代わりでもある)
 * @augments Jeeel.Framework.Layer
 * @param {Element|String} element このビューが扱うElement
 * @param {Boolean} [useAutoAdd] このビューのオーナーコントローラが親コントローラに追加された時に、<br />
 *                                自動的にこのビューのElementを親コントローラのビューに追加するかどうか
 * @throws {Error} elementがHTML要素かIDで無かった場合に発生
 */
Jeeel.Framework.Mvc.View = function (element, useAutoAdd) {
    if (Jeeel.Type.isString(element)) {
        element = Jeeel.Document.getElementById(element);
    }
    
    if ( ! Jeeel.Type.isElement(element)) {
        throw new Error('このビューに対するElementを指定して下さい。');
    }
    
    this._element = element;
    this._useAutoAdd = !!useAutoAdd;
    
    Jeeel.Framework.Layer.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @param {Element|String} element このビューが扱うElement
 * @param {Boolean} [useAutoAdd] このビューのオーナーコントローラが親コントローラに追加された時に、<br />
 *                                自動的にこのビューのElementを親コントローラのビューに追加するかどうか
 * @return {Jeeel.Framework.Mvc.View} 作成したインスタンス
 * @throws {Error} elementがHTML要素かIDで無かった場合に発生
 */
Jeeel.Framework.Mvc.View.create = function (element, useAutoAdd) {
    return new this(element, useAutoAdd);
};

Jeeel.Framework.Mvc.View.prototype = {
    
    /**
     * このビューを管理するコントローラ
     * 
     * @type Jeeel.Framework.Mvc.Controller
     * @protected
     */
    _controller: null,
    
    /**
     * このビューに関連付けられているElement
     * 
     * @type Element
     * @protected
     */
    _element: null,
    
    /**
     * Dom上に自動追加するかどうか
     * 
     * @type Boolean
     * @protected
     */
    _useAutoAdd: false,
    
    /**
     * このビューに関連付けられているElementを取得する
     * 
     * @return {Element} 関連付けElement
     */
    getElement: function () {
        return this._element;
    },
    
    /**
     * 子ビューを追加する<br />
     * この追加でコントローラ管理されているビューを追加するとElement間の追加しか行われない
     * 
     * @param {Jeeel.Framework.Mvc.View} child 追加要素
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    addChild: function (child) {
      
        if ( ! child._controller) {
            Jeeel.Framework.Layer.prototype.addChild.call(this, child);
        }
        
        if (child._useAutoAdd) {
            this._element.appendChild(child._element);
        }
        
        return this;
    },
    
    /**
     * 子ビューを削除する<br />
     * この削除でコントローラ管理されているビューを削除するとElement間の削除しか行われない
     * 
     * @param {Jeeel.Framework.Mvc.View} child 削除要素
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    removeChild: function (child) {
      
        if ( ! child._controller) {
            Jeeel.Framework.Layer.prototype.removeChild.call(this, child);
        }
        
        if (child._useAutoAdd) {
            this._element.removeChild(child._element);
        }
        
        return this;
    },
    
    /**
     * このビューのElementへイベントの登録を行う
     * 
     * @param {String} type イベントタイプ
     * @param {Function} listener 登録リスナー
     * @param {Mixied} [thisArg] イベントリスナー内でthisに相当する値(デフォルトはこのインスタンス)
     * @param {Mixied} var_args 可変引数、コールバックに渡す引数(最初の引数はJeeel.Dom.Eventで固定)
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    addDomEventListener: function (type, listener, thisArg, var_args) {
        var args = Array.prototype.slice.call(arguments, 0, arguments.length);
        
        args.unshift(this._element);
        
        if ( ! thisArg) {
            args[3] = this;
        }
        
        Jeeel.Dom.Event.addEventListener.apply(Jeeel.Dom.Event, args);
        
        return this;
    },
    
    /**
     * このビューのElementからイベントの削除を行う
     * 
     * @param {String} type イベントタイプ
     * @param {Function} listener 削除リスナー
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    removeDomEventListener: function (type, listener) {
        Jeeel.Dom.Event.removeEventListener(this._element, type, listener);
        
        return this;
    },
    
    /**
     * コントローラを紐付ける
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    attach: function (controller) {
        if (this._controller) {
            this._controller.removeView(this);
        }
        
        this._controller = controller;
        
        return this;
    },
    
    /**
     * コントローラとの紐付けを解除する
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    detach: function (controller) {
        if (this._controller === controller) {
            this._controller = null;
        }
        
        return this;
    },
    
    /**
     * コントローラが親コントローラに追加された時に呼び出される<br />
     * デフォルトでは親コントローラのビューにaddChildされる
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @param {Jeeel.Framework.Mvc.Controller} parentController 親コントローラ
     */
    onControllerAdded: function (controller, parentController) {
        if ( ! this._useAutoAdd) {
            return;
        }
        
        var parentView = parentController.getView();
        
        if (parentView) {
            parentView.addChild(this);
        }
    },
    
    /**
     * コントローラが親コントローラから削除された時に呼び出される<br />
     * デフォルトでは親コントローラのビューからremoveChildされる
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @param {Jeeel.Framework.Mvc.Controller} parentController 親コントローラ
     */
    onControllerRemoved: function (controller, parentController) {
        if ( ! this._useAutoAdd) {
            return;
        }
        
        var parentView = parentController.getView();
        
        if (parentView) {
            parentView.removeChild(this);
        }
    },
    
    /**
     * モデルが変化した際にコントローラから呼び出される<br />
     * デフォルトでは子ビュー全てのupdateメソッドを呼び出す
     * 
     * @param {Jeeel.Framework.Mvc.Controller} controller コントローラ
     * @return {Jeeel.Framework.Mvc.View} 自インスタンス
     */
    update: function (controller) {
        for (var i = 0, l = this._children.length; i < l; i++) {
            this._children[i].update(controller);
        }
        
        return this;
    },
    
    /**
     * コンストラクタ
     * 
     * @param {Element|String} element このビューが扱うElement
     * @param {Boolean} [useAutoAdd] このビューのオーナーコントローラが親コントローラに追加された時に、<br />
     *                                自動的にこのビューのElementを親コントローラのビューに追加するかどうか
     * @constructor
     */
    constructor: Jeeel.Framework.Mvc.View
};

Jeeel.Class.extend(Jeeel.Framework.Mvc.View, Jeeel.Framework.Layer);

/**
 * コンストラクタ
 * 
 * @class コントローラのプロトタイプ<br />
 *         役割はそれぞれ、モデルが通信・計算・ステータス保持、<br />
 *         ビューが描画・構成・HTML要素とのやりとり、<br />
 *         コントローラが制御・イベントリスナ・カスタムイベントディスパッチなどとなる<br />
 *         なおコントローラとビューはLayerを継承しており、子供にそれぞれコントローラ、ビューを持つ事が出来る<br />
 *         また、EventDispatcherも継承しているのでイベントの制御も可能であり、<br />
 *         子に追加された時や削除された時はデフォルトでイベントがディスパッチされるようになっている
 * @augments Jeeel.Framework.Layer
 * @example
 * コントローラとビューは対応するビュー・モデルやオーナーコントローラが無くても存在出来るが、モデルは必ずオーナーコントローラが無ければならない
 * RC: ルートコントローラ
 * RV: ルートビュー
 * RM: ルートモデル
 * C1: グループ1のコントローラ
 * V1: グループ1のビュー
 * M1: グループ1のモデル
 * V2: グループ2のビュー
 * 
 * RM  M1
 * ｜  ｜
 * RC―C1
 * ｜  ｜
 * RV…V1―V2
 * 
 * この図はMVCの構成の一例である
 * まず大本のルートコントローラとそれに付属するモデルとビューが1つずつ存在する
 * ルートコントローラは子供にコントローラ、モデル、ビューのセットを保持しており、V1はuseAutoAddをtrueにしたことにより、RVの子要素ともなっている
 * この構成は基本構成であり、MVCで完結する要素がそれぞれ親子関係を築き、ビューは内部的に親子関係になるといった具合である
 * 
 * それに対してV2はオーナーコントローラもそれに対するモデルも無い
 * この構成は要素が描画のみでデータや制御を持たない場合に用いられる
 * ビューはHTML上の1つの要素と紐付けられるので、要素内の子要素が簡単な描画だけ行うような形式の時に用いる
 * この形式の場合はV1内部でV2を生成し明示的にaddChildするのが一般的だと思われる
 * 
 * コントローラやビューは複数の子要素を持てるのでそれを用いて大規模な要素を分割していく手法を用いるべきである
 * コントローラやビューはディスパッチャーを継承しているので、イベントをディスパッチするとキャプチャ段階、ターゲット段階、バブリング段階(もうひとつフォーリング段階もあるが通常は使わない)の順に伝搬を行う
 * イベントはstopされるまで全ての対象の要素に対して伝搬していくが、必ずコントローラ同士かビュー同士の伝搬になる
 * ルートコントローラ及びルートビューは親が存在しないため、HTMLに対して反映させるためには手動で要素を追加もしくは追加してある要素からルートビューを作成する必要がある
 */
Jeeel.Framework.Mvc.Controller = function () {
    Jeeel.Framework.Layer.call(this);
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Framework.Mvc.Controller} 作成したインスタンス
 */
Jeeel.Framework.Mvc.Controller.create = function () {
    return new this();
};

Jeeel.Framework.Mvc.Controller.prototype = {
  
    /**
     * このコントローラに紐づくモデル
     * 
     * @type Jeeel.Framework.Mvc.Model
     * @protected
     */
    _model: null,
    
    /**
     * このコントローラに紐づくビュー
     * 
     * @type Jeeel.Framework.Mvc.View
     * @protected
     */
    _view: null,
    
    /**
     * ビューへの通知を行う
     * 
     * @return {Jeeel.Framework.Mvc.Controller} 自インスタンス
     */
    update: function () {
        this._view.update(this);
        
        return this;
    },
    
    /**
     * モデルを取得する
     * 
     * @return {Jeeel.Framework.Mvc.Model} モデル
     */
    getModel: function () {
        return this._model;
    },
    
    /**
     * モデルを設定する
     * 
     * @param {Jeeel.Framework.Mvc.Model} model モデル
     * @return {Jeeel.Framework.Mvc.Controller} 自インスタンス
     */
    setModel: function (model) {
        if (this._model) {
            this._model.detach(this);
        }
        
        this._model = model;
        
        if (model) {
            model.attach(this);
        }
        
        return this;
    },
    
    /**
     * ビューを取得する
     * 
     * @return {Jeeel.Framework.Mvc.View} ビュー
     */
    getView: function () {
        return this._view;
    },
    
    /**
     * ビューを設定する
     * 
     * @param {Jeeel.Framework.Mvc.View} view ビュー
     * @return {Jeeel.Framework.Mvc.Controller} 自インスタンス
     */
    setView: function (view) {
        if (this._view) {
            this._view.detach(this);
        }
        
        this._view = view;
        
        if (view) {
            view.attach(this);
        }
        
        return this;
    },
       
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Mvc.Controller,
    
    /**
     * 親に追加された時に呼び出される(デフォルトの挙動)
     * 
     * @param {Jeeel.Framework.Mvc.Controller} parent 親コントローラ
     * @protected
     */
    _onAddedThis: function (parent) {
        this._view.onControllerAdded(this, parent);
    },
    
    /**
     * 親から削除された時に呼び出される(デフォルトの挙動)
     * 
     * @param {Jeeel.Framework.Mvc.Controller} parent 親コントローラ
     * @protected
     */
    _onRemovedThis: function (parent) {
        this._view.onControllerRemoved(this, parent);
    }
};

Jeeel.Class.extend(Jeeel.Framework.Mvc.Controller, Jeeel.Framework.Layer);
Jeeel.directory.Jeeel.Framework.Acl = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Framework + 'Acl/';
    }
};

/**
 * コンストラクタ
 * 
 * @class ロールベースアクセス制御を管理するクラス
 */
Jeeel.Framework.Acl = function () {
    this._roleManager = new this.constructor.Role.Manager();
    this._resourceManager = new this.constructor.Resource.Manager();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Framework.Acl} 作成したインスタンス
 */
Jeeel.Framework.Acl.create = function () {
    return new this();
};

Jeeel.Framework.Acl.prototype = {
    
    /**
     * デフォルトのロールタイプ
     * 
     * @type String
     * @private
     */
    _defaultRoleType: 'User',
    
    /**
     * デフォルトのリソースタイプ
     * 
     * @type String
     * @private
     */
    _defaultResourceType: 'Url',
    
    /**
     * ロール管理インスタンス
     * 
     * @type Jeeel.Framework.Acl.Role.Manager
     * @private
     */
    _roleManager: null,
    
    /**
     * リソース管理インスタンス
     * 
     * @type Jeeel.Framework.Acl.Resource.Manager
     * @private
     */
    _resourceManager: null,
    
    /**
     * デフォルトのロールの種類を設定する
     * 
     * @param {String} roleType ロールの種類
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    setDefaultRoleType: function (roleType) {
        this._defaultRoleType = roleType;
        
        return this;
    },
    
    /**
     * デフォルトのリソースの種類を設定する
     * 
     * @param {String} resourceType リソースの種類
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    setDefaultResourceType: function (resourceType) {
        this._defaultResourceType = resourceType;
        
        return this;
    },

    /**
     * ロールを追加する
     * 
     * @param {Jeeel.Framework.Acl.Role.Abstract} role ロール
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    addRole: function (role) {
        this._roleManager.addRole(role);
        
        return this;
    },
    
    /**
     * リソースを追加する
     * 
     * @param {Jeeel.Framework.Acl.Resource.Abstract} resource リソース
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    addResource: function (resource) {
        this._resourceManager.addResource(resource);
        
        return this;
    },
    
    /**
     * ロールを取得する
     * 
     * @param {String} roleId ロールID
     * @param {String} [roleType] ロールタイプ
     * @return {Jeeel.Framework.Acl.Role.Abstract} 取得したロール
     */
    getRole: function (roleId, roleType) {
        if ( ! roleType) {
            roleType = this._defaultRoleType;
        }
        
        return this._roleManager.getRole(roleType, roleId);
    },
    
    /**
     * リソースを取得する
     * 
     * @param {String} resourceId リソースID
     * @param {String} [resourceType] リソースタイプ
     * @return {Jeeel.Framework.Acl.Resource.Abstract} 取得したリソース
     */
    getResource: function (resourceId, resourceType) {
        if ( ! resourceType) {
            resourceType = this._defaultResourceType;
        }
        
        return this._resourceManager.getResource(resourceType, resourceId);
    },
    
    /**
     * 現在のロールを取得する
     * 
     * @return {Jeeel.Framework.Acl.Role.Abstract} 取得したロール
     */
    getCurrentRole: function () {
        return this._roleManager.getCurrentRole();
    },
    
    /**
     * 現在のロールを切り替える
     * 
     * @param {String} roleId ロールID
     * @param {String} [roleType] ロールタイプ
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    switchRole: function (roleId, roleType) {
        
        if ( ! roleType) {
            roleType = this._defaultRoleType;
        }
        
        this._roleManager.switchRole(roleType, roleId);
        
        return this;
    },
    
    /**
     * 現在のロールに対してリソースへの権限を許可する
     * 
     * @param {String} resourceId リソースID
     * @param {String|String[]} [authorizations] 問い合わせ権限(省略は全権限)
     * @param {String} [resourceType] リソースタイプ
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    allow: function (resourceId, authorizations, resourceType) {
        var role = this._roleManager.getCurrentRole();
        var resource = (resourceId instanceof Jeeel.Framework.Acl.Resource.Abstract) ? resourceId : this.getResource(resourceId, resourceType);
        
        if (role && resource) {
            role.allow(resource, authorizations);
        }
        
        return this;
    },
    
    /**
     * 現在のロールに対してリソースへの権限を禁止する
     * 
     * @param {String} resourceId リソースID
     * @param {String|String[]} [authorizations] 問い合わせ権限(省略は全権限)
     * @param {String} [resourceType] リソースタイプ
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    deny: function (resourceId, authorizations, resourceType) {
        var role = this._roleManager.getCurrentRole();
        var resource = (resourceId instanceof Jeeel.Framework.Acl.Resource.Abstract) ? resourceId : this.getResource(resourceId, resourceType);
        
        if (role && resource) {
            role.deny(resource, authorizations);
        }
        
        return this;
    },
    
    /**
     * 現在のロールが指定したリソースに対して権限か許可されているどうかを返す
     * 
     * @param {String} resourceId リソースID
     * @param {String|String[]} [authorizations] 問い合わせ権限(省略は全権限)
     * @param {String} [resourceType] リソースタイプ
     * @return {Boolean} 許可されているかどうか
     */
    isAllowed: function (resourceId, authorizations, resourceType) {
        var role = this._roleManager.getCurrentRole();
        var resource = (resourceId instanceof Jeeel.Framework.Acl.Resource.Abstract) ? resourceId : this.getResource(resourceId, resourceType);
        
        if ( ! role) {
            throw new Error('Role does not exist.');
        }
        
        return role.isAllowed(resource, authorizations);
    },
    
    /**
     * 現在のロールが指定したリソースに対して権限か禁止されているどうかを返す
     * 
     * @param {String} resourceId リソースID
     * @param {String|String[]} [authorizations] 問い合わせ権限(省略は全権限)
     * @param {String} [resourceType] リソースタイプ
     * @return {Boolean} 禁止されているかどうか
     */
    isDenied: function (resourceId, authorizations, resourceType) {
        return ! this.isAllowed(resourceId, authorizations, resourceType);
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Acl
};

Jeeel.file.Jeeel.Framework.Acl = ['Role', 'Resource', 'Error'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework.Acl, Jeeel.file.Jeeel.Framework.Acl);Jeeel.directory.Jeeel.Framework.Acl.Role = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Framework.Acl + 'Role/';
    }
};

/**
 * @namespace ロールに関するネームスペース
 */
Jeeel.Framework.Acl.Role = {
    
    /**
     * コンストラクタ
     *
     * @abstractClass ロールクラスを作る際の抽象クラス
     */
    Abstract: function () {
        this._extends = [];
        this._resourceAllowedAuthorizations = {};
        this._resourceDeniedAuthorizations = {};
    }
};

Jeeel.Framework.Acl.Role.Abstract.prototype = {
    
    /**
     * 継承ロール
     * 
     * @type Jeeel.Framework.Acl.Role.Abstract[]
     * @protected
     */
    _extends: [],
    
    /**
     * リソースに対しての許可権限情報
     */
    _resourceAllowedAuthorizations: {},
    
    /**
     * リソースに対しての拒否権限情報
     */
    _resourceDeniedAuthorizations: {},
    
    /**
     * リソースをデフォルトで許可するかどうか
     * 
     * @type Boolean
     * @protected
     */
    _defaultAuthorizationAllow: false,
    
    /**
     * ロールの継承を行う
     * 
     * @param {Jeeel.Framework.Acl.Role.Abstract} role ロール
     * @return {Jeeel.Framework.Acl.Role.Abstract} 自インスタンス
     */
    extend: function (role) {
        
        if ( ! (role instanceof Jeeel.Framework.Acl.Role.Abstract)) {
            throw new Error('Argument role is not instance of Jeeel.Framework.Acl.Role.Abstract.');
        } else if (role.getRoleType() !== this.getRoleType()) {
            throw new Error('Role type does not match.');
        }
        
        var roleId = role.getRoleId();
        
        for (var i = this._extends.length; i--;) {
            if (this._extends[i].getRoleId() === roleId) {
                return this;
            }
        }
        
        this._extends.push(role);
        
        return this;
    },
    
    /**
     * 権限リストに載っていない権限を許可として扱うようにする
     * 
     * @return {Jeeel.Framework.Acl.Role.Abstract} 自インスタンス
     */
    allowDefaultAuthorization: function () {
        this._defaultAuthorizationAllow = true;
        
        return this;
    },
    
    /**
     * 権限リストに載っていない権限を禁止として扱うようにする
     * 
     * @return {Jeeel.Framework.Acl.Role.Abstract} 自インスタンス
     */
    denyDefaultAuthorization: function () {
        this._defaultAuthorizationAllow = false;
        
        return this;
    },
    
    /**
     * リソースへの権限を許可する
     * 
     * @param {Jeeel.Framework.Acl.Resource.Abstract} resource リソース
     * @param {String|String[]} [authorizations] 許可権限(省略は全権限)
     * @return {Jeeel.Framework.Acl.Role.Abstract} 自インスタンス
     */
    allow: function (resource, authorizations) {
        return this._addAuthorization(resource, authorizations);
    },
    
    /**
     * リソースへの権限の許可を取り消す
     * 
     * @param {Jeeel.Framework.Acl.Resource.Abstract} resource リソース
     * @param {String|String[]} [authorizations] 許可取り消し権限(省略は全権限)
     * @return {Jeeel.Framework.Acl.Role.Abstract} 自インスタンス
     */
    removeAllowance: function (resource, authorizations) {
        return this._removeAuthorization(resource, authorizations);
    },
    
    /**
     * リソースへの権限を禁止する
     * 
     * @param {Jeeel.Framework.Acl.Resource.Abstract} resource リソース
     * @param {String|String[]} [authorizations] 禁止権限(省略は全権限)
     * @return {Jeeel.Framework.Acl.Role.Abstract} 自インスタンス
     */
    deny: function (resource, authorizations) {
        return this._addAuthorization(resource, authorizations, true);
    },
    
    /**
     * リソースへの権限の禁止を取り消す
     * 
     * @param {Jeeel.Framework.Acl.Resource.Abstract} resource リソース
     * @param {String|String[]} [authorizations] 禁止取り消し権限(省略は全権限)
     * @return {Jeeel.Framework.Acl.Role.Abstract} 自インスタンス
     */
    removeDenial: function (resource, authorizations) {
        return this._removeAuthorization(resource, authorizations, true);
    },
    
    /**
     * リソースへの権限が許可されているかどうかを取得する
     * 
     * @param {Jeeel.Framework.Acl.Resource.Abstract} resource リソース
     * @param {String|String[]} [authorizations] 問い合わせ権限(省略は全権限)
     * @return {Boolean} 許可されているかどうか
     */
    isAllowed: function (resource, authorizations) {
        if ( ! (resource instanceof Jeeel.Framework.Acl.Resource.Abstract)) {
            return this._defaultAuthorizationAllow;
        }
        
        if ( ! authorizations) {
            authorizations = '*';
        } else if ( ! Jeeel.Type.isArray(authorizations)) {
            authorizations = [authorizations];
        }
        
        var type = resource.getResourceType();
        var id = resource.getResourceId();
        var i, perm;
        
        var alloweds = this._resourceAllowedAuthorizations[type] && this._resourceAllowedAuthorizations[type][id];
        var denieds = this._resourceDeniedAuthorizations[type] && this._resourceDeniedAuthorizations[type][id];
        
        for (i = this._extends.length; i--;) {
            if (this._extends[i].isAllowed(resource, authorizations)) {
                return true;
            }
        }
        
        perm = [
            alloweds && alloweds.perms || [],
            denieds && denieds.perms || []
        ];
        
        // デフォルトで許可の場合はまず禁止リストを優先する
        if (this._defaultAuthorizationAllow) {
            if (this._isDenied(resource, authorizations, perm[1])) {
                return false;
            }
            
            if (this._isAllowed(resource, authorizations, perm[0])) {
                return true;
            }
        } else {
            if (this._isAllowed(resource, authorizations, perm[0])) {
                return true;
            }
          
            if (this._isDenied(resource, authorizations, perm[1])) {
                return false;
            }
        }

        return this._defaultAuthorizationAllow;
    },
    
    /**
     * リソースへの権限が禁止されているかどうかを取得する
     * 
     * @param {Jeeel.Framework.Acl.Resource.Abstract} resource リソース
     * @param {String|String[]} [authorizations] 問い合わせ権限(省略は全権限)
     * @return {Boolean} 禁止されているかどうか
     */
    isDenied: function (resource, authorizations) {
        return ! this.isAllowed(resource, authorizations);
    },
    
    /**
     * ロールの種類を取得する
     * 
     * @return {String} ロール種類
     */
    getRoleType: function () {
        throw new Error('This method does not always have to override.');
    },
    
    /**
     * このロールを示すIDを取得する
     * 
     * @return {String} ロールID
     */
    getRoleId: function () {
        throw new Error('This method does not always have to override.');
    },
    
    /**
     * 指定したロールがこのロールと同等かどうかを返す<br />
     * 場合によってはオーバーライドして挙動を変えることが可能
     * 
     * @param {String} roleId 比較ロールID
     * @param {Boolean} [strict] 厳密に判定するかどうか
     * @return {Boolean} 同等かどうか
     */
    isMatch: function (roleId, strict) {
        if (roleId === this.getRoleId()) {
            return true;
        } else if (strict) {
            return false;
        }
        
        for (var i = this._extends.length; i--;) {
            if (this._extends[i].isMatch(roleId)) {
                return true;
            }
        }
        
        return false;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Acl.Role.Abstract,
    
    /**
     * @param {Jeeel.Framework.Acl.Resource.Abstract} resource リソース
     * @param {String|String[]} [authorizations] 付与権限(省略は全権限)
     * @param {Boolean} [isDenied] 拒否リストかどうか
     * @return {Jeeel.Framework.Acl.Role.Abstract} 自インスタンス
     */
    _addAuthorization: function (resource, authorizations, isDenied) {
        if ( ! (resource instanceof Jeeel.Framework.Acl.Resource.Abstract)) {
            return this;
        }
        
        if ( ! authorizations) {
            authorizations = ['*'];
        } else if ( ! Jeeel.Type.isArray(authorizations)) {
            authorizations = [authorizations];
        }
        
        var resourcePerms = resource.getAuthorizations();
        var perms = [];
        
        // 実際にリソースに存在する権限かどうかを確認してフィルターをかける
        for (var i = authorizations.length; i--;) {
            if (authorizations[i] === '*' || Jeeel.Hash.inHash(authorizations[i], resourcePerms, true)) {
                perms.push(authorizations[i]);
            }
        }
        
        // フィルターをかけた後に追加が必要な場合は追加を実行
        if (perms.length) {
            
            var type = resource.getResourceType();
            var id = resource.getResourceId();

            if (isDenied) {
                authorizations = this._resourceDeniedAuthorizations;
            } else {
                authorizations = this._resourceAllowedAuthorizations;
            }
            
            if ( ! authorizations[type]) {
                authorizations[type] = {};
            }
            
            if ( ! authorizations[type][id]) {
                authorizations[type][id] = {
                    resource: resource,
                    perms: []
                };
            }
            
            // 権限が全ての場合は追加の必要が無いので無視
            if (authorizations[type][id].perms !== '*') {
                
                // 追加権限に*を含んでいた場合は強制的に全権限になる
                if (Jeeel.Hash.inHash('*', perms, true)) {
                    authorizations[type][id].perms = '*';
                } else {
                    var tmp = Jeeel.Hash.merge(authorizations[type][id].perms, perms);
                    
                    authorizations[type][id].perms = Jeeel.Filter.Hash.Unique.create(true, true).filter(tmp);
                }
            }
        }
        
        return this;
    },
    
    _removeAuthorization: function (resource, authorizations, isDenied) {
        if ( ! (resource instanceof Jeeel.Framework.Acl.Resource.Abstract)) {
            return this;
        }
        
        if ( ! authorizations) {
            authorizations = ['*'];
        } else if ( ! Jeeel.Type.isArray(authorizations)) {
            authorizations = [authorizations];
        }
        
        var resourcePerms = resource.getAuthorizations();
        var i, perms = [];
        
        // 実際にリソースに存在する権限かどうかを確認してフィルターをかける
        for (i = authorizations.length; i--;) {
            if (authorizations[i] === '*' || Jeeel.Hash.inHash(authorizations[i], resourcePerms, true)) {
                perms.push(authorizations[i]);
            }
        }
        
        // フィルターをかけた後に削除が必要な場合は削除を実行
        if (perms.length) {
            
            var type = resource.getResourceType();
            var id = resource.getResourceId();

            if (isDenied) {
                authorizations = this._resourceDeniedAuthorizations;
            } else {
                authorizations = this._resourceAllowedAuthorizations;
            }
            
            if ( ! authorizations[type]) {
                return this;
            }
            
            if ( ! authorizations[type][id]) {
                return this;
            }
            
            var clear = false;
            var tmp;
            
            if (Jeeel.Hash.inHash('*', perms, true)) {
                clear = true;
            } else if (authorizations[type][id].perms === '*') {
                tmp = [];
                
                for (i = resourcePerms.length; i--;) {
                    if ( ! Jeeel.Hash.inHash(resourcePerms[i], perms, true)) {
                        tmp.push(resourcePerms[i]);
                    }
                }
                
                authorizations[type][id].perms = tmp;
                
                clear = tmp.length === 0;
            } else {
                var tmp = [];
                
                for (i = authorizations[type][id].perms.length; i--;) {
                    if (Jeeel.Hash.inHash(authorizations[type][id].perms[i], perms, true)) {
                        tmp.push(authorizations[type][id].perms[i]);
                    }
                }
                
                authorizations[type][id].perms = tmp;
                
                clear = tmp.length === 0;
            }
            
            if (clear) {
                delete authorizations[type][id];
                
                if (Jeeel.Type.isEmptyHash(authorizations[type])) {
                    delete authorizations[type];
                }
            }
        }
        
        return this;
    },
    
    _isAllowed: function (resource, authorizations, alloweds) {
        
        if (alloweds === '*') {
            return true;
        }
        
        var i;
        
        if (authorizations === '*') {
            var rperms = resource.getAuthorizations();
            
            for (i = rperms.length; i--;) {
                if ( ! Jeeel.Hash.inHash(rperms[i], alloweds, true)) {
                    return false;
                }
            }
            
            return true;
        }
        
        for (i = alloweds.length; i--;) {

            var tmp = Jeeel.Hash.search(alloweds[i], authorizations, true);

            if (tmp === null) {
                return false;
            } else {
                authorizations.splice(tmp, 1);
            }
        }
        
        return ! authorizations.length;
    },
    
    _isDenied: function (resource, authorizations, denieds) {
        
        if (denieds === '*') {
            return true;
        }
        
        if (authorizations === '*') {
            if (denieds.length) {
                return true;
            }
            
            return false;
        }
        
        for (var i = denieds.length; i--;) {
            if (Jeeel.Hash.inHash(denieds[i], authorizations, true)) {
                return true;
            }
        }
        
        return false;
    }
};

Jeeel.file.Jeeel.Framework.Acl.Role = ['User', 'Manager'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework.Acl.Role, Jeeel.file.Jeeel.Framework.Acl.Role);
/**
 * コンストラクタ
 * 
 * @class ユーザーに対してのロールを扱うクラス
 * @augments Jeeel.Framework.Acl.Role.Abstract
 * @param {String} roleName ロール名
 */
Jeeel.Framework.Acl.Role.User = function (roleName) {
    Jeeel.Framework.Acl.Role.Abstract.call(this);
    
    this._roleName = roleName;
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} roleName ロール名
 * @return {Jeeel.Framework.Acl.Role.User} 作成したインスタンス
 */
Jeeel.Framework.Acl.Role.User.create = function (roleName) {
    return new this(roleName);
};

Jeeel.Framework.Acl.Role.User.prototype = {
    
    _roleName: '',
    
    /**
     * ロールの種類を取得する
     * 
     * @return {String} ロール種類
     */
    getRoleType: function () {
        return 'User';
    },
    
    /**
     * このロールを示す名前を取得する
     * 
     * @return {String} ロールURL
     */
    getRoleId: function () {
        return this._roleName;
    }
};

Jeeel.Class.extend(Jeeel.Framework.Acl.Role.User, Jeeel.Framework.Acl.Role.Abstract);

/**
 * コンストラクタ
 * 
 * @class ロール管理クラス
 */
Jeeel.Framework.Acl.Role.Manager = function () {
    this._roles = {};
};

Jeeel.Framework.Acl.Role.Manager.prototype = {
    
    /**
     * ロール
     * 
     * @type Jeeel.Framework.Acl.Role.Abstract[]
     * @private
     */
    _roles: {},
    
    /**
     * 現在のロール
     * 
     * @type Jeeel.Framework.Acl.Role.Abstract
     * @private
     */
    _currentRole: null,
    
    /**
     * ロールを追加する
     * 
     * @param {Jeeel.Framework.Acl.Role.Abstract} role ロール
     * @return {Jeeel.Framework.Acl.Role.Manager} 自クラス
     */
    addRole: function (role) {
        if ( ! (role instanceof Jeeel.Framework.Acl.Role.Abstract)) {
            throw new Error('Argument role is not instance of Jeeel.Framework.Acl.Role.Abstract.');
        }
        
        var type = role.getRoleType();

        if (this.getRole(type, role.getRoleId())) {
            return this;
        }
        
        if ( ! this._roles[type]) {
            this._roles[type] = [];
        }
        
        this._roles[type].push(role);
        
        if ( ! this._currentRole) {
            this._currentRole = role;
        }
        
        return this;
    },
    
    /**
     * ロールを取得する
     * 
     * @param {String} roleType ロールタイプ
     * @param {String} roleId ロールID
     * @return {Jeeel.Framework.Acl.Role.Abstract} ロール
     */
    getRole: function (roleType, roleId) {
        if ( ! this._roles[roleType]) {
            return null;
        }
        
        for (var i = this._roles[roleType].length; i--;) {
            var role = this._roles[roleType][i];
            
            if (role.isMatch(roleId, true)) {
                return role;
            }
        }
        
        return null;
    },
    
    /**
     * ロールを保持しているかどうかを取得する
     * 
     * @param {String} roleType ロールタイプ
     * @param {String} roleId ロールID
     * @return {Boolean} 保持しているかどうか
     */
    hasRole: function (roleType, roleId) {
        
        if ( ! this._roles[roleType]) {
            return false;
        }
        
        for (var i = this._roles[roleType].length; i--;) {
            var role = this._roles[roleType][i];
            
            if (role.isMatch(roleId, true)) {
                return true;
            }
        }
        
        return false;
    },
    
    /**
     * 現在のロールを取得する
     * 
     * @return {Jeeel.Framework.Acl.Role.Abstract} ロール
     */
    getCurrentRole: function () {
        return this._currentRole;
    },
    
    /**
     * 現在のロールを切り替える
     * 
     * @param {String} roleType ロールタイプ
     * @param {String} roleId ロールID
     * @return {Jeeel.Framework.Acl.Role.Manager} 自クラス
     */
    switchRole: function (roleType, roleId) {
        
        var role = this.getRole(roleType, roleId);
        
        if (role) {
            this._currentRole = role;
        }
        
        return this;
    }
};
Jeeel.directory.Jeeel.Framework.Acl.Resource = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Framework.Acl + 'Resource/';
    }
};

/**
 * @namespace リソースに関するネームスペース
 */
Jeeel.Framework.Acl.Resource = {
    
    /**
     * コンストラクタ
     *
     * @abstractClass リソースクラスを作る際の抽象クラス
     */
    Abstract: function () {
        this._permissions = [];
    }
};

Jeeel.Framework.Acl.Resource.Abstract.prototype = {
    
    /**
     * 権限リスト
     * 
     * @type String[]
     * @private
     */
    _permissions: [],
    
    /**
     * リソースに対しての権限を追加する
     * 
     * @param {String} permission 権限
     * @return {Jeeel.Framework.Acl.Resource.Abstract} 自インスタンス
     */
    addAuthorization: function (permission) {
        this._permissions.push(permission);
        
        return this;
    },
    
    /**
     * 権限一覧を取得する
     * 
     * @return {String} 権限一覧
     */
    getAuthorizations: function () {
        return this._permissions;
    },
    
    /**
     * リソースの種類を取得する
     * 
     * @return {String} リソース種類
     */
    getResourceType: function () {
        throw new Error('This method does not always have to override.');
    },
    
    /**
     * このリソースを示すIDを取得する
     * 
     * @return {String} リソースID
     */
    getResourceId: function () {
        throw new Error('This method does not always have to override.');
    },
    
    /**
     * 指定したリソースがこのリソースと同等かどうかを返す<br />
     * 場合によってはオーバーライドして挙動を変えることが可能
     * 
     * @param {String} resourceId 比較リソースID
     * @param {Boolean} [strict] 厳密に判定するかどうか
     * @return {Boolean} 同等かどうか
     */
    isMatch: function (resourceId, strict) {
        return resourceId === this.getResourceId();
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Framework.Acl.Resource.Abstract
};

Jeeel.file.Jeeel.Framework.Acl.Resource = ['Url', 'Manager'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Framework.Acl.Resource, Jeeel.file.Jeeel.Framework.Acl.Resource);
/**
 * コンストラクタ
 * 
 * @class URLをリソースとして扱うクラス
 * @augments Jeeel.Framework.Acl.Resource.Abstract
 * @param {String} url リソースのURL
 * @param {Boolean} [includeHierarchy] 下位階層を含むかどうか
 */
Jeeel.Framework.Acl.Resource.Url = function (url, includeHierarchy) {
    Jeeel.Framework.Acl.Resource.Abstract.call(this);
    
    var absUrl = Jeeel.UserAgent.getBaseUrl() + url;
    
    var suffix;
    
    if (includeHierarchy) {
        suffix = '(?:[?\\/]|$)';
    } else {
        suffix = '\\/?(?:\\?[^#]*)?(?:#.*)?$';
    }
    
    this._url = url;
    this._reg = new RegExp('^' + Jeeel.String.escapeRegExp(this._url) + suffix, 'i');
    this._regFull = new RegExp('^' + Jeeel.String.escapeRegExp(absUrl) + suffix, 'i');
    
    // URLのリソースはアクセス以外に権限がない
    this.addAuthorization('Access');
};

/**
 * インスタンスの作成を行う
 * 
 * @param {String} url リソースのURL
 * @param {Boolean} [includeHierarchy] 下位階層を含むかどうか
 * @return {Jeeel.Framework.Acl.Resource.Url} 作成したインスタンス
 */
Jeeel.Framework.Acl.Resource.Url.create = function (url, includeHierarchy) {
    return new this(url, includeHierarchy);
};

Jeeel.Framework.Acl.Resource.Url.prototype = {
    
    _url: '',
    _reg: null,
    _regFull: null,
    
    /**
     * リソースの種類を取得する
     * 
     * @return {String} リソース種類
     */
    getResourceType: function () {
        return 'Url';
    },
    
    /**
     * このリソースを示すURLを取得する
     * 
     * @return {String} リソースURL
     */
    getResourceId: function () {
        return this._url;
    },
    
    /**
     * 指定したリソースがこのリソースと同等かどうかを返す
     * 
     * @param {String} resourceId 比較リソースID
     * @param {Boolean} [strict] 継承関係を無視して厳密に判定するかどうか
     * @return {Boolean} 同等かどうか
     */
    isMatch: function (resourceId, strict) {
        if (strict) {
            return this._url === resourceId;
        }
        
        return this._reg.test(resourceId) || this._regFull.test(resourceId);
    }
};

Jeeel.Class.extend(Jeeel.Framework.Acl.Resource.Url, Jeeel.Framework.Acl.Resource.Abstract);

/**
 * コンストラクタ
 * 
 * @class リソース管理クラス
 */
Jeeel.Framework.Acl.Resource.Manager = function () {
    this._resources = {};
};

Jeeel.Framework.Acl.Resource.Manager.prototype = {
  
    /**
     * リソース
     * 
     * @type Jeeel.Framework.Acl.Resource.Abstract[]
     * @private
     */
    _resources: {},
  
    /**
     * リソースを追加する
     * 
     * @param {Jeeel.Framework.Acl.Resource.Abstract} resource ロール
     * @return {Jeeel.Framework.Acl.Resource.Manager} 自クラス
     */
    addResource: function (resource) {
        if ( ! (resource instanceof Jeeel.Framework.Acl.Resource.Abstract)) {
            throw new Error('Argument resource is not instance of Jeeel.Framework.Acl.Resource.Abstract.');
        }
        
        var type = resource.getResourceType();
        
        if (this.getResource(type, resource.getResourceId())) {
            return this;
        }
        
        if ( ! this._resources[type]) {
            this._resources[type] = [];
        }
        
        this._resources[type].push(resource);
        
        return this;
    },
    
    /**
     * リソースを取得する
     * 
     * @param {String} resourceType リソースタイプ
     * @param {String} resourceId リソースID
     * @return {Jeeel.Framework.Acl.Resource.Abstract} リソース
     */
    getResource: function (resourceType, resourceId) {
        if ( ! this._resources[resourceType]) {
            return null;
        }
        
        for (var i = this._resources[resourceType].length; i--;) {
            var resource = this._resources[resourceType][i];
            
            if (resource.isMatch(resourceId)) {
                return resource;
            }
        }
        
        return null;
    },
    
    /**
     * リソースを保持しているかどうかを取得する
     * 
     * @param {String} resourceType リソースタイプ
     * @param {String} resourceId リソースID
     * @return {Boolean} 保持しているかどうか
     */
    hasResource: function (resourceType, resourceId) {
        if ( ! this._resources[resourceType]) {
            return false;
        }
        
        for (var i = this._resources[resourceType].length; i--;) {
            var resource = this._resources[resourceType][i];
            
            if (resource.isMatch(resourceId)) {
                return true;
            }
        }
        
        return false;
    }
};

(function () {
    Jeeel.Acl = new Jeeel.Framework.Acl();
    
    var role = new Jeeel.Framework.Acl.Role.User('Administrator');
    
    role.allowDefaultAuthorization();
    
    Jeeel.Acl.addRole(role);
})();

if (Jeeel.Acl) {
    
    /**
     * @ignore
     */
    Jeeel.Acl._enableAutoControl = false;
    
    /**
     * @ignore
     */
    Jeeel.Acl._errors = [];
    
    /**
     * 自動制御を有効にする<br />
     * 自動制御を有効にした場合、Jeeel内部の挙動とアンカー、フォーム等にも影響を及ぼす<br />
     * 但し、onloadイベント後にこのメソッドを実行した場合やonload後に追加された要素に対しては別途メソッドを使用する必要がある<br />
     * またlocation.hrefを直接変更したり、他のライブラリや独自実装のAJAX等には効果がない
     * 
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    Jeeel.Acl.enableAutoControl = function () {
        this._enableAutoControl = true;

        return this.controlDocument();
    };
    
    /**
     * 現在のドキュメント全ての要素の制御を行う
     * 
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    Jeeel.Acl.controlDocument = function () {
      
        if ( ! this.isAutoControl()) {
            return this;
        }
        
        var anchors = Jeeel.Document.getElementsByTagName('a');
        var forms = Jeeel.Document.getElementsByTagName('form');
        
        return this.control(forms.concat(anchors));
    };
    
    /**
     * 要素の制御を行う
     * 
     * @param {Element|Element[]} elements アンカーやフォーム要素もしくはそのリスト
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    Jeeel.Acl.control = function (elements) {
        
        if ( ! this.isAutoControl()) {
            return this;
        }
        
        if ( ! Jeeel.Type.isArray(elements)) {
            elements = [elements];
        }
        
        for (var i = elements.length; i--;) {
            var elm = elements[i];
            var name = elm.nodeName.toUpperCase();
            var listener = this.CONTROLS[name];
            var storage = Jeeel.Storage.Object(elm, this.CONTROL_NAME);
            
            if (storage.get('controlled')) {
                continue;
            }
            
            // 対象タグのみにイベントを追加
            switch (name) {
                case 'A':
                    Jeeel.Dom.Event.addEventListener(elm, Jeeel.Dom.Event.Type.CLICK, listener, this);
                    storage.set('controlled', true);
                    break;
                    
                case 'FORM':
                    Jeeel.Dom.Event.addEventListener(elm, Jeeel.Dom.Event.Type.SUBMIT, listener, this);
                    storage.set('controlled', true);
                    break;
                    
                default:
                    break;
            }
        }
        
        return this;
    };
    
    /**
     * 制御のための値を保持するネーム
     * 
     * @type String
     */
    Jeeel.Acl.CONTROL_NAME = 'jeeel-acl-controls';
    
    /**
     * @namespace 制御のための関数を保持するネームスペース
     */
    Jeeel.Acl.CONTROLS = {
      
        /**
         * アンカータグ用
         * 
         * @param {Jeeel.Dom.Event} e イベントオブジェクト
         * @ignore
         */
        A: function (e) {
            var a = e.currentTarget;
            
            // hrefが設定していなかったりt、フラグメントは無視
            if ( ! a.href) {
                return;
            } else if (a.href.match(/^#/)) {
                return;
            }
            
            var scheme = a.href.match(/^([a-z]+):/i);
            
            scheme = (scheme && scheme[1] || '').toLowerCase();
            
            // スキームが付いていてhttp系以外は無視
            if (scheme && ! (scheme === 'http' || scheme === 'https')) {
                return;
            }
            
            if (this.isDenied(a.href, '*', 'Url')) {
                e.stop();
                this.throwError('Access Error', 404);
            }
        },
        
        /**
         * フォームタグ用
         * 
         * @param {Jeeel.Dom.Event} e イベントオブジェクト
         * @ignore
         */
        FORM: function (e) {
            var form = e.currentTarget;
            
            // アクションが未設定は無視
            if ( ! form.action) {
                return;
            } else if (form.action.match(/^#/)) {
                return;
            }
            
            var scheme = form.action.match(/^([a-z]+):/i);
            
            scheme = (scheme && scheme[1] || '').toLowerCase();
            
            // スキームが付いていてhttp系以外は無視
            if (scheme && ! (scheme === 'http' || scheme === 'https')) {
                return;
            }

            if (this.isDenied(form.action, '*', 'Url')) {
                e.stop();
                this.throwError('Access Error', 404);
            }
        }
    };
    
    /**
     * 自動制御かどうかを取得する
     * 
     * @return {Boolean} 自動制御かどうか
     */
    Jeeel.Acl.isAutoControl = function () {
        return this._enableAutoControl;
    };
    
    /**
     * ACLのエラーイベントの追加
     * 
     * @param {Function} callback エラーコールバック
     * @param {Mixied} [thisArg] コールバック中のthisに相当する値(デフォルトはこのインスタンスになる)
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    Jeeel.Acl.addErrorEvent = function (callback, thisArg) {
        this._errors.push({
            callback: callback,
            thisArg: thisArg
        });
        
        return this;
    };
    
    /**
     * ACLのエラーイベントを起動する
     * 
     * @param {Mixied} var_args 登録メソッドに引き渡す引数
     * @return {Jeeel.Framework.Acl} 自インスタンス
     */
    Jeeel.Acl.dispatchErrorEvent = function (var_args) {
        for (var i = this._errors.length; i--;) {
            var error = this._errors[i];
            
            error.callback.apply(error.thisArg || this, arguments);
        }
        
        return this;
    };
    
    /**
     * ACL用のエラーを投げる
     * 
     * @param {String} [message] エラーメッセージ
     * @param {Integer} [code] エラーコード
     */
    Jeeel.Acl.throwError = function (message, code) {
        
        if ( ! this.isAutoControl()) {
            return;
        }
        
        var err = new Jeeel.Framework.Acl.Error(message, code, 1);
        this.dispatchErrorEvent(err);
        
        throw err;
    };
}

/**
 * コンストラクタ
 * 
 * @class ACL用のカスタムエラー
 * @param {String} [message] エラーメッセージ
 * @param {Integer} [code] エラーコード
 * @param {Integer} [nestCount] このエラーメッセージを本来投げるべき箇所以外で作成した場合に指定
 */
Jeeel.Framework.Acl.Error = function (message, code, nestCount) {
    if ( ! (nestCount > 0)) {
        nestCount = 1;
    } else {
        nestCount++;
    }
    
    Jeeel.Error.call(this, message, code, nestCount);
};

Jeeel.Framework.Acl.Error.prototype = {
    
    /**
     * Error名
     * 
     * @type String
     */
    name: 'AclError',
    
    /**
     * コンストラクタ
     * 
     * @param {String} [message] エラーメッセージ
     * @param {Integer} [code] エラーコード
     * @constructor
     */
    constructor: Jeeel.Framework.Acl.Error
};

Jeeel.Class.extend(Jeeel.Framework.Acl.Error, Jeeel.Error);Jeeel.directory.Jeeel.Debug = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel + 'Debug/';
    }
};

/**
 * @namespace デバッグ関連の機能を保持するネームスペース
 * @example
 * Debugネームスペース以下にはJSのデバッグに使える機能を保有する
 * この機能は主にIEやスマフォでのデバッグに役に立つ
 * その中でも主に以下のクラスが筆頭に立つ
 * Jeeel.Debug.Console
 * Jeeel.Debug.ErrorMessage
 * Jeeel.Debug.Timer
 * Jeeel.Debug.Profiler
 * 
 * Jeeel.Debug.Console
 * ChromeやFirefoxを初めとする高機能ブラウザに搭載されているJSコンソールの再現である
 * このクラスは主にIE8以下などのコンソール機能が弱いブラウザで使用する
 * 
 * 例：
 * Jeeel.Debug.Console.create(); // JSコンソールを生成し画面上に表示する、createConsole()と同じ意味
 * Jeeel.Debug.Console.log(); // JSコンソール上にログを出す
 * Jeeel.Debug.Console.clear(); // JSコンソールの履歴・表示を全て消去する
 * 
 * コンソールを生成した後は画面上に出たテキストエリア(コンソール)で操作を行う
 * コンソール上では通常通りにキーを入力すればグローバル階層からの予測変換とともにJSを入力する事が可能になる
 * またwindow.nameに履歴を保存するのでタブを閉じない限り履歴が保持される
 * 以下が通常記述以外の操作になる
 * 
 * Ctrl+m：複数行モードと単数行モードの変更
 * 
 * 単数行モード時
 *
 * ↑, PageUp：実行履歴を上がる
 * ↓, PageDown：実行履歴を下る
 * Enter：実行
 * 
 * 複数行モード時
 *
 * Ctrl+↑, Ctrl+PageUp：実行履歴を上がる
 * Ctrl+↓, Ctrl+PageDown：実行履歴を下る
 * Ctrl+Enter：実行 
 * 
 * 
 * Jeeel.Debug.ErrorMessage
 * 単にメッセージやHTMLをダンプするダンパーである
 * 基本的にJeeel以下にデバッグモードだったら機能する幾つかのメソッドがあるのでそちらを利用する
 * 
 * 例：
 * Jeeel.Debug.ErrorMessage.dump(1, 'eee'); // 画面上に可変引数で取った値を文字列として出力する、Jeeel.errorDumpがこれに相当する
 * Jeeel.Debug.ErrorMessage.dumpHtml('<p>Test!!</p>', '<div>AAA</div>'); // 画面上に可変引数で取った値をHTMLとして出力する、Jeeel.errorHtmlDumpがこれに相当する
 * Jeeel.Debug.ErrorMessage.dumpStripTags('<p>Test!!</p>', '<div>AAA</div>'); // 画面上に可変引数で取った値をタグ取りしてから出力する、対応するメソッドはない
 * 
 * 
 * Jeeel.Debug.Timer
 * 処理に掛った時間を計測するタイマー
 * Jeeel.Timerとの違いは遅延実行などの制御ではなく、ストップウォッチに近い機能を提供するところである
 * 
 * 例：
 * var timer = Jeeel.Debug.Timer.create(); // mew Jeeel.Debug.Timer()でも同じ
 * 
 * // 重い処理(2500ms経過したとする)
 * timer.lap('A'); // ラップを記録する
 * timer.interval('A'); // インターバルを記録する
 * 
 * // 重い処理(1500ms経過したとする)
 * timer.lap('B'); // ラップを記録する
 * timer.interval('B'); // インターバルを記録する
 * timer.stop(); // タイマーを停止する
 * 
 * 上記のように記録を取ると以下のような値が取得できる
 * timer.loadAllLap(); // {A: 2500, B: 4000}
 * timer.loadAllInterval(); // {A: 2500, B: 1500}
 * 
 * 
 * Jeeel.Debug.Profiler
 * 何処の処理が重いのかを判定するプロファイラー
 * 指定した名前空間や関数に対してトリガーを仕込みそれぞれの関数の呼び出し回数、経過時間、その平均等を割り出すことが出来る
 * 
 * 例：
 * var Test = {
 *     getHoge: funcion () {
 *         return this.getFuga();
 *     },
 *     
 *     getFuga: function () {
 *         return this.Circle.getArea();
 *     },
 *     
 *     Circle: {
 *         getArea: function () {
 *             return ths.getHalfDiameter() * ths.getHalfDiameter() * Math.PI;
 *         },
 *         
 *         getHalfDiameter: function () {
 *             return 2.5;
 *         }
 *     }
 * };
 * 
 * Jeeel.Debug.Profiler.profile(Test, 'Test', true); // Testネームスペース以下を全てプロファイル対象にする
 * 
 * Test.getHoge();
 * Test.getHoge();
 * Test.getHoge();
 * Test.getHoge();
 * 
 * 上記の様に4回先のメソッドを実行すると
 * 4回プロファイルが作成される
 * 
 * Jeeel.Debug.Profiler.getAverageProfileHash(); // 基本的にこのメソッドだけで十分、メソッド毎の平均して掛った時間を連想配列として返す
 * Jeeel.Debug.Profiler.getBottleneckProfile(); // 一番実行に時間が掛ったプロファイルを取得する
 * var m = Jeeel.Debug.Profiler.getProfiles(); // このメソッドを実行するとプロファイルマネージャーインスタンスが取得できる
 * m.getProfiles(); // このメソッドを実行するとプロファイルの時系列順配列を取得できる
 * 
 * このクラスは調節状況であり、継承などが複雑になりすぎるとデータを追えなくなってしまうことがある
 * クロージャなどのJSからアクセスできない関数には対応出来ないなどの欠点もある
 * 
 * <input type="button" value="コンソール生成" onclick="createConsole();" />
 */
Jeeel.Debug = {

};

/**
 * @private
 */
Jeeel._Object.JeeelDebug = {
    /**
     * 不特定なオブジェクトの名前を取得する
     *
     * @param {Mixied} obj 展開対象のオブジェクト
     * @return {String} 名前
     */
    getUnknownObjectName: function (obj) {
        var objType;
        var tmp;

        if (obj.__proto__ && obj.__proto__.constructor && obj.__proto__.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME]) {
            objType = obj.__proto__.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME].name;
        }
        else if ( ! obj.__proto__ && Object.getPrototypeOf && (tmp = Object.getPrototypeOf(obj)).constructor && tmp.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME]) {
            objType = tmp.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME].name;
        }
        else if ( ! obj.__proto__ && ! Object.getPrototypeOf && obj.hasOwnProperty && obj.hasOwnProperty('constructor') && obj.constructor !== Object) {
            objType = obj._super && obj._super.constructor && obj._super.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME].name || 'Object';
        }
        else if ( ! obj.__proto__ && obj.constructor && obj.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME]) {
            objType = obj.constructor[Jeeel.Debug.Debugger.INFORMATION_NAME].name;
        }
        else if (obj.constructor && obj.constructor.name) {
            objType = obj.constructor.name;
        }
        else {
            objType = Object.prototype.toString.call(obj);
            objType = objType.substring(8, objType.length - 1);
        }

        return objType;
    }
};

Jeeel.file.Jeeel.Debug = ['ObjectExport', 'ObjectExpander', 'ErrorMessage', 'Timer', 'Console', 'Profiler', 'UnitTest', 'Debugger', 'Compressor'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Debug, Jeeel.file.Jeeel.Debug);
/**
 * 指定したオブジェクトを展開する
 *
 * @param {Mixied} obj 展開するオブジェクト
 * @return {String} 展開したオブジェクト
 */
Jeeel.Debug.objectExport = function (obj) {
    var res = typeof obj;
    var cnt = (arguments[1] ? arguments[1] : 0);
    var i, l;
    var sp = '';

    for (i = 0; i < cnt; i++) {
        sp += '    ';
    }

    if (Jeeel.Type.isPrimitive(obj)) {
        if (Jeeel.Type.isString(obj)) {
            return '"' + obj + '"';
        }
        
        return '' + obj;
    }

    if (Jeeel.Type.isFunction(obj)) {
        var str = obj.toString();
        var remove = str.match(/ +}$/gi);
        if (remove) {
            remove = remove[0].substring(0, remove[0].length - 1);
            var regExp = new RegExp('(\\n|\\r\\n)' + remove, 'ig');
            str = str.replace(regExp, '\n');
        }

        return str.replace(/(\n|\r\n)/ig, '$1' + sp);
    }

    cnt++;

    if (Jeeel.Type.isArray(obj)) {
        res = [];

        for (i = 0, l = obj.length; i < l; i++) {
            res[i] = sp + '    ' + i + ': ' + arguments.callee(obj[i], cnt);
        }

        return 'Array {\n' + res.join(',\n') + '\n' + sp + '}';
    } else {
        var className = Jeeel._Object.JeeelDebug.getUnknownObjectName(obj);
        
        res = [];

        for (var key in obj) {
            if (key === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }
            
            res[res.length] = sp + '    ' + key + ': ' + arguments.callee(obj[key], cnt);
        }

        return className + ' {\n' + res.join(',\n') + '\n' + sp + '}';
    }
};

/**
 * コンストラクタ
 *
 * @class オブジェクトの展開を動的に行うクラス
 * @param {Boolean} [useHtmlExplorer=false] Html展開及び操作を行う機能を使用するかどうか
 */
Jeeel.Debug.ObjectExpander = function (useHtmlExplorer) {
    Jeeel.Debug.ObjectExpander._createCss();
    
    this._useHtmlExplorer = !!useHtmlExplorer;
    this._mouseGesture = Jeeel.Gui.Mouse.Gesture.create();
};

/**
 * インスタンスの作成を行う
 *
 * @param {Boolean} [useHtmlExplorer=false] Html展開及び操作を行う機能を使用するかどうか
 * @return {Jeeel.Debug.ObjectExpander} 作成したインスタンス
 */
Jeeel.Debug.ObjectExpander.create = function (useHtmlExplorer) {
    return new this(useHtmlExplorer);
};

/**
 * 指定したオブジェクトを展開する
 *
 * @param {Mixied} obj 展開するオブジェクト
 * @param {Boolean} [useHtmlExplorer=false] Html展開及び操作を行う機能を使用するかどうか
 * @return {Element} 展開したオブジェクト
 */
Jeeel.Debug.ObjectExpander.expand = function (obj, useHtmlExplorer) {
    return this.create(useHtmlExplorer).expand(obj);
};

/**
 * 展開HTML要素のClass名
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.EXPAND_OBJECT_ROOT_CLASS = 'jeeel-expand-object-root';

/**
 * 展開HTML要素のtableタグにあたる子要素のClass名
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.EXPAND_TABLE_CLASS = 'jeeel-expand-object-table';

/**
 * 展開HTML要素のtrタグにあたる子要素のClass名
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.EXPAND_CHILD_CLASS = 'jeeel-expand-object-child';

/**
 * HtmlExplorerを有効にした時の前景レイヤーのClass名
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.HTML_LAYER_CLASS = 'jeeel-expand-element-layer';

/**
 * 開いている時の矢印のHTML文字列
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.EXPAND_ARROW = '<font color="#515151">&#9660;</font>';

/**
 * 閉じている時の矢印のHTML文字列
 *
 * @type String
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.COLLAPSE_ARROW = '<font color="#515151">&#9654;</font>';

/**
 * メインに使用するフォントサイズ
 *
 * @type Integer
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.MAIN_FONT_SIZE = 16;

/**
 * 展開する矢印のフォントサイズ
 *
 * @type Integer
 * @scope Jeeel.Debug.ObjectExpander
 * @constant
 */
Jeeel.Debug.ObjectExpander.ARROW_FONT_SIZE = 15;

/**
 * この機能内で使用するCSSを定義する
 *
 * @private
 */
Jeeel.Debug.ObjectExpander._createCss = function () {
    if (arguments.callee.ignore) {
        return;
    }

    arguments.callee.ignore = true;

    var css = 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' {\n'
            + '    position: relative;\n'
            + '    z-index: 10;\n'
            + '    border-spacing: 0px;\n'
            + '    white-space: nowrap;\n'
            + '    color: black;\n'
            + '    background-color: white;\n'
            + '    text-align: left;\n'
            + '    vertical-align: middle;\n'
            + '    font-family: "Arial", "Times New Roman", "Courier New", "Courier", cursive;\n'
            + '    width: auto;\n'
            + '}\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' th,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' td {\n'
            + '    display: table-cell;\n'
            + '}\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' table {\n'
            + '    width: auto;\n'
            + '    border-spacing: 0px;\n'
            + '}\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' table,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' tbody,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' tr,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' th,\n'
            + 'table.' + this.EXPAND_OBJECT_ROOT_CLASS + ' td {\n'
            + '    font-size: ' + this.MAIN_FONT_SIZE + 'px;\n'
            + '    font-weight: normal;\n'
            + '    font-style: normal;\n'
            + '    margin: 0px;\n'
            + '    padding: 0px;\n'
            + '}\n'
            + 'tr.' + this.EXPAND_CHILD_CLASS + ' th,\n'
            + 'tr.' + this.EXPAND_CHILD_CLASS + ' td {\n'
            + '    padding: 0 0 2px 0;\n'
            + '}';

    Jeeel.Loader.addStyle(css);
};

Jeeel.Debug.ObjectExpander.prototype = {

    /**
     * Html要素の展開及び操作を行うモードかどうかを示す
     *
     * @type Boolean
     * @private
     */
    _useHtmlExplorer: false,
    
    /**
     * 展開を行った情報を保持するHtml要素
     * 
     * @type Element
     * @private
     */
    _rootElement: null,

    /**
     * 現在選択中のHTML要素
     *
     * @type Element
     * @private
     */
    _selectedElement: null,

    /**
     * 現在選択中のexpand要素
     *
     * @type Element
     * @private
     */
    _selectedTarget: null,

    /**
     * 現在選択中の削除expand要素
     *
     * @type Element
     * @private
     */
    _selectedRemoveTarget: null,

    /**
     * マウスジェスチャインスタンス
     *
     * @type Jeeel.Gui.Mouse.Gesture
     * @private
     */
    _mouseGesture: null,

    /**
     * Html要素の削除を行うジェスチャー<br />
     * ↓→
     *
     * @type Integer[]
     * @private
     * @constant
     */
    _removeGesture: [40, 39],
    
    /**
     * コンストラクタ
     * 
     * @param {Boolean} [useHtmlExplorer=false] Html展開及び操作を行う機能を使用するかどうか
     * @constructor
     */
    constructor: Jeeel.Debug.ObjectExpander,

    /**
     * 指定したオブジェクトを展開する
     *
     * @param {Mixied} obj 展開するオブジェクト
     * @return {Element} 展開したオブジェクト
     */
    expand: function (obj) {
        this._rootElement = this._createExpander.call(this, obj, null, false, true);
        this._rootElement.className = this.constructor.EXPAND_OBJECT_ROOT_CLASS;
        
        return this._rootElement;
    },
    
    /**
     * オブジェクトを展開できるHTML要素を作成する
     *
     * @param {Mixied} obj 展開対象のオブジェクト
     * @param {String} [key] オブジェクトに対応するキー
     * @param {Boolean} [isSimple=false] シンプルな形で取得するかどうか
     * @param {Boolean} [isFirst=false] 最初の呼び出しかどうか
     * @param {Boolean} [isHided=false] この展開キーが隠されているかどうか
     * @return {Element} テーブルタグのHTML要素
     * @private
     */
    _createExpander: function (obj, key, isSimple, isFirst, isHided) {

        var elm = this._expandObject.call(this, obj, key, isHided, isFirst);

        if (isSimple && ! elm.canExpand && ! elm.isError) {
            return elm;
        }

        var table = Jeeel.Document.createElement('table');
        var tbody = Jeeel.Document.createElement('tbody');
        var tr    = Jeeel.Document.createElement('tr');
        var th    = Jeeel.Document.createElement('th');
        var td    = Jeeel.Document.createElement('td');

        var thStyle = th.style;
        var arrowSize = this.constructor.ARROW_FONT_SIZE + 'px';
        
        thStyle.fontSize  = arrowSize;
        thStyle.width     = arrowSize;
        thStyle.height    = arrowSize;
        thStyle.textAlign = 'center';

        table.className = this.constructor.EXPAND_TABLE_CLASS;

        var self = this;

        if (elm.canExpand) {
            th.innerHTML = this.constructor.COLLAPSE_ARROW;
            thStyle.cursor = 'pointer';

            /**
             * @ignore
             */
            var func = function () {
                var data  = arguments.callee.data;
                var tbody = arguments.callee.tbody;

                if (arguments.callee.isExpand) {
                    self._collapseTable.call(self, data, tbody);
                } else {
                    self._expandTable.call(self, data, tbody, arguments.callee.first);
                }

                arguments.callee.first = false;
                arguments.callee.isExpand = ! arguments.callee.isExpand;
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            func.first = true;
            func.isExpand = false;
            func.data = obj;
            func.tbody = tbody;

            th.onclick = func;
        } else if (elm.isError) {
            th.innerHTML = '<font color="red">&#8855;</font>';
        } else {
            thStyle.width = arrowSize;
            th.innerHTML = '<div style="width: ' + arrowSize + '; height: ' + arrowSize + ';">&nbsp;</div>';
        }

        if (elm.isElement) {

            /**
             * @ignore
             */
            var mouseDown = function () {
                var data   = arguments.callee.data;
                var target = arguments.callee.targetTr;

                self._selectElement(data, target);
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            mouseDown.data = obj;
            mouseDown.targetTr = tr;

            /**
             * @ignore
             */
            var mouseUp = function () {
                var event  = Jeeel.Dom.Event.getEventObject();

                if (event.ctrlKey && event.isLeftDown) {
                    self._removeElement();
                }
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            /**
             * @ignore
             */
            var over = function () {
                var data   = arguments.callee.data;
                var target = arguments.callee.targetTr;

                if (target.enableMouse) {
                    self._markupElement(data, target);
                }
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            over.data = obj;
            over.targetTr = tr;

            /**
             * @ignore
             */
            var out = function () {
                var data   = arguments.callee.data;
                var target = arguments.callee.targetTr;

                if (target.enableMouse) {
                    self._cleanupElement(data, target);
                }
                
                Jeeel.Dom.Event.getEventObject().stop();
            };

            out.data = obj;
            out.targetTr = tr;

            elm.onmousedown = mouseDown;
            elm.onmouseup   = mouseUp;
//            tr.onmouseover = over;
//            tr.onmouseout  = out;
            tr.enableMouse = true;
        }
        
        td.appendChild(elm);
        tr.appendChild(th);
        tr.appendChild(td);
        tbody.appendChild(tr);
        table.appendChild(tbody);

        return table;
    },
    
    /**
     * 不特定なオブジェクトの名前を取得する
     *
     * @param {Mixied} obj 展開対象のオブジェクト
     * @return {String} 名前
     * @private
     */
    _getUnknownObjectName: Jeeel._Object.JeeelDebug.getUnknownObjectName,

    /**
     * 不特定なオブジェクトの展開を定義づける
     *
     * @param {Element} elm 定義づけ対象のElement
     * @param {Mixied} obj 展開対象のオブジェクト
     * @private
     */
    _expandForUnknownObject: function (elm, obj) {
        elm.color = 'black';
        elm.innerHTML = this._getUnknownObjectName(obj);
    },

    /**
     * オブジェクトを展開し、それを示す文字列等に変換して返す
     *
     * @param {Mixied} obj 展開対象のオブジェクト
     * @param {String} [key] オブジェクトに対応するキー
     * @param {Boolean} [isFirst=false] 最初の呼び出しかどうか
     * @return {Element} 要素を示す文字列等を含むHTML要素
     * @private
     */
    _expandObject: function (obj, key, isHided, isFirst) {

        var elm = Jeeel.Document.createElement('font');
        var type;
        var canExpand = true;
        var isError   = false;
        var isElement = false;
        var isArray   = false;

        try {
            type = Jeeel.Type.getType(obj);
        } catch (e) {
            obj = e;
            type = Jeeel.Type.getType(obj);
        }

        switch (type) {
            case Jeeel.Type.ObjectType.STRING:
                elm.color = 'red';
                elm.innerHTML = '&quot;' + Jeeel.String.escapeHtml(obj, true) + '&quot;';

                if (obj.match(/^(https?|ttp):\/\/.+/)) {
                    var url = (obj.match(/^ttp:\/\/.+/) ? 'h' + obj : obj);

                    elm.innerHTML = '<a href="' + url + '" target="_blank">' + elm.innerHTML + '</a>';
                }

                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.REGULAR_EXPRESSION:
                elm.color = 'violet';
                elm.innerHTML = Jeeel.String.escapeHtml('' + obj, true);
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.DATE:
                elm.color = 'black';
                elm.innerHTML = Jeeel.String.escapeHtml(obj.toString(), true);
                break;

            case Jeeel.Type.ObjectType.BOOLEAN:
            case Jeeel.Type.ObjectType.NUMBER:
                elm.color = 'blue';
                elm.innerHTML = '' + obj;
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.UNDEFINED:
            case Jeeel.Type.ObjectType.NULL:
                elm.color = 'gray';
                elm.innerHTML = '' + obj;
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.ARGUMENTS:
            case Jeeel.Type.ObjectType.ARRAY:
                isArray = true;
                
                if ( ! isFirst || obj.length > 100) {
                    elm.innerHTML = type + '[' + obj.length + ']';
                    break;
                }
                
                elm = Jeeel.Document.createElement('table');
                var tbody = Jeeel.Document.createElement('tbody');
                var tr = Jeeel.Document.createElement('tr');
                var th, td;

                tr.style.verticalAlign = 'top';
                
                var tmp;
                var txt = Jeeel.Document.createTextNode('[');
                th = Jeeel.Document.createElement('th');
                th.style.verticalAlign = 'top';
                th.appendChild(txt);
                tr.appendChild(th);

                for (var i = 0; i < obj.length; i++) {
                    if (i > 0) {
                        txt = Jeeel.Document.createTextNode(',　');
                        th = Jeeel.Document.createElement('th');
                        th.appendChild(txt);
                        tr.appendChild(th);
                    }

                    tmp = this._createExpander.call(this, obj[i], null, true);
                    td = Jeeel.Document.createElement('td');
                    td.appendChild(tmp);
                    td.style.verticalAlign = 'top';
                    tr.appendChild(td);
                }

                txt = Jeeel._doc.createTextNode(']');
                th = Jeeel.Document.createElement('th');
                th.appendChild(txt);
                th.style.verticalAlign = 'top';
                tr.appendChild(th);
                
                tbody.appendChild(tr);
                elm.appendChild(tbody);
                
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.FUNCTION:
                var func = Jeeel.String.escapeHtml('' + obj).replace(/(\r\n|\n)/g, '&crarr;');
                elm.color = 'black';
                elm.innerHTML = (func.length > 100 ? func.substr(0, 100) + ' ...' : func);
                break;

            case Jeeel.Type.ObjectType.WINDOW:
                elm.color = 'green';
                elm.innerHTML = 'Window';
                break;

            case Jeeel.Type.ObjectType.DOCUMENT_FRAGMENT:
                elm.color = 'black';
                elm.innerHTML = 'Document Fragment';
                break;

            case Jeeel.Type.ObjectType.DOCUMENT:
                elm.color = 'green';
                elm.innerHTML = 'Document';
                break;

            case Jeeel.Type.ObjectType.OBJECT:
                this._expandForUnknownObject(elm, obj);
                break;

            case Jeeel.Type.ObjectType.PROTOTYPE:
                elm.color = 'black';
                elm.innerHTML = 'Object(__proto__)';
                break;

            case Jeeel.Type.ObjectType.ELEMENT:

                if ( ! this._useHtmlExplorer) {
                    this._expandForUnknownObject(elm, obj);
                    break;
                }

                elm.color = '#881391';
                elm.innerHTML = this._createInfoElement(obj);
                isElement = true;

                if ( ! obj.contentWindow && ( ! obj.childNodes[0] || this._isAlwaysOpenedElement(obj))) {
                    canExpand = false;
                }
                break;
                
            case Jeeel.Type.ObjectType.ATTRIBUTE:

                if ( ! this._useHtmlExplorer) {
                    elm.color = 'black';
                    elm.innerHTML = type;
                    break;
                }
                
                var div = Jeeel.Document.createElement('div');
                var name = Jeeel.Document.createElement('font');
                
                name.color = '#994500';
                name.innerHTML = obj.name;
                
                elm.color = '#1A1AA6';
                elm.innerHTML = Jeeel.String.escapeHtml('"' + obj.value + '"', true);
                
                div.appendChild(name);
                div.appendChild(elm);
                
                elm = div;

                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.TEXT:

                if ( ! this._useHtmlExplorer) {
                    elm.color = 'black';
                    elm.innerHTML = type;
                    break;
                }

                var replaceCR = !(obj.data.match(/^(\r|\n|\t| )*$/) && true);
                elm.color = 'black';
                elm.innerHTML = Jeeel.String.escapeHtml('"' + obj.data + '"', replaceCR);

                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.COMMENT:

                if ( ! this._useHtmlExplorer) {
                    elm.color = 'black';
                    elm.innerHTML = type;
                    break;
                }
                
                elm.color = '#236E25';
                elm.innerHTML = Jeeel.String.escapeHtml('<!--' + obj.data + '-->', true);
                canExpand = false;
                break;

            case Jeeel.Type.ObjectType.EVENT:
                var eventType = this._getUnknownObjectName(obj);
                
                elm.color = '#0080FF';
                elm.innerHTML = (eventType == 'Object' ? 'Event' : eventType);
                break;

            case Jeeel.Type.ObjectType.ERROR:
                elm.color = 'red';
                elm.innerHTML = Jeeel.String.escapeHtml(obj.name + ': ' + obj.message, true);
                canExpand = false;
                isError = true;
                break;
                
            case Jeeel.Type.ObjectType.MATH:
                elm.color = '#006699';
                elm.innerHTML = 'Math';
                break;
                
            case Jeeel.Type.ObjectType.JSON:
                elm.color = '#61A458';
                elm.innerHTML = 'JSON';
                break;  

            case Jeeel.Type.ObjectType.STORAGE:
                elm.color = 'black';
                elm.innerHTML = 'Storage';
                break;

            default:
                elm.innerHTML = type;
                break;
        }

        if (Jeeel.Type.isString(key)) {
            var tab = Jeeel.Document.createElement('table');
            var tby = Jeeel.Document.createElement('tbody');
            var tre = Jeeel.Document.createElement('tr');
            var the = Jeeel.Document.createElement('th');
            var tde = Jeeel.Document.createElement('td');
            var col = '881391';
            
            if (isHided) {
                col = 'B771BD';
            }

            the.innerHTML = '<font color="#' + col + '">' + key + '</font>:&nbsp;&nbsp;';

            the.style.verticalAlign = 'top';
            tde.appendChild(elm);
            
            tre.appendChild(the);
            tre.appendChild(tde);
            tby.appendChild(tre);
            tab.appendChild(tby);
            
            elm = tab;
        }

        elm.canExpand = canExpand;
        elm.isError   = isError;
        elm.isElement = isElement;
        elm.isArray   = isArray;
        
        return elm;
    },

    /**
     * Tableを展開する
     *
     * @param {Mixied} obj Tableに定義づけられているオブジェクト
     * @param {Element} tbody 閉じる対象のtbody
     * @param {Boolean} [isFirst=false] 最初の展開かどうか
     * @private
     */
    _expandTable: function (obj, tbody, isFirst) {

        if (this._useHtmlExplorer && Jeeel.Type.isDocumentFragment(obj)) {
            this._expandTableForDocumentFragment.call(this, obj, tbody, isFirst);
            return;
        } else if (this._useHtmlExplorer && Jeeel.Type.isElement(obj)) {
            this._expandTableForElement.call(this, obj, tbody, isFirst);
            return;
        }

        var i, l, tmp, th;

        th = tbody.firstChild.firstChild;
        th.innerHTML = Jeeel.Debug.ObjectExpander.EXPAND_ARROW;

        if (isFirst) {
            var tr;
            var list = Jeeel.Hash.getPairs(obj);
            var flag = Jeeel._doc.createDocumentFragment();
            
            for (i = 0, l = list.length; i < l; i++) {
                var key = list[i].key;
                var val = list[i].value;
                
                if (Object.getOwnPropertyDescriptor && Object.prototype.hasOwnProperty && Object.prototype.hasOwnProperty.call(obj, key)) {
                  
                    try {
                        tmp = Object.getOwnPropertyDescriptor(obj, key);
                    } catch (e) {
                        tmp = {
                            enumerable: key !== '__proto__'
                        };
                    }

                    if (tmp && (tmp.get || tmp.set)) {
                        if (tmp.get) {
                            tr = this._createExpanderTr(tmp.get, 'get ' + key, ! tmp.enumerable);
                            flag.appendChild(tr);
                        }

                        if (tmp.set) {
                            tr = this._createExpanderTr(tmp.set, 'set ' + key, ! tmp.enumerable);
                            flag.appendChild(tr);
                        }
                    } else {
                        tr = this._createExpanderTr(val, key, !tmp || !tmp.enumerable);
                        flag.appendChild(tr);
                    }
                } else {
                    tr = this._createExpanderTr(val, key, key === '__proto__');
                    flag.appendChild(tr);
                }
            }
            
            tbody.appendChild(flag);
        } else {
            var children = tbody.childNodes;

            for (i = 0, l = children.length; i < l; i++) {
                if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                    children[i].style.display = '';
                }
            }
        }
    },
    
    _createExpanderTr: function (val, key, isHided) {
        var tr = Jeeel.Document.createElement('tr');
        var th = Jeeel.Document.createElement('th');
        var td = Jeeel.Document.createElement('td');

        var elm = this._createExpander.call(this, val, key, false, false, isHided);

        td.appendChild(elm);

        tr.appendChild(th);
        tr.appendChild(td);
        tr.className = this.constructor.EXPAND_CHILD_CLASS;

        return tr;
    },

    /**
     * Tableを閉じる
     *
     * @param {Mixied} obj Tableに定義づけられているオブジェクト
     * @param {Element} tbody 閉じる対象のtbody
     * @private
     */
    _collapseTable: function (obj, tbody) {

        if (this._useHtmlExplorer && Jeeel.Type.isElement(obj)) {
            this._collapseTableForElement.call(this, obj, tbody);
            return;
        }

        var th;

        th = tbody.firstChild.firstChild;
        th.innerHTML = this.constructor.COLLAPSE_ARROW;

        var children = tbody.childNodes;

        for (var i = 0, l = children.length; i < l; i++) {
            if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                children[i].style.display = 'none';
            }
        }
    },

    /**
     * Html要素のための展開メソッド
     *
     * @param {Element} element 展開するElement
     * @param {Element} tbody 閉じる対象のtbody
     * @param {Boolean} [isFirst=false] 最初の展開かどうか
     * @private
     */
    _expandTableForElement: function (element, tbody, isFirst) {

        var i, l, th, td, children;
        var nodeName = element.nodeName.toLowerCase();

        th = tbody.firstChild.firstChild;
        td = tbody.firstChild.children[1];
        th.innerHTML = this.constructor.EXPAND_ARROW;

        if (td.firstChild.nodeName.toLowerCase() !== 'font') {
            td = td.firstChild.firstChild.firstChild.children[1];
        }

        td.firstChild.innerHTML = this._createInfoElement(element, true);
        tbody.firstChild.enableMouse = false;
        this._cleanupElement(element);

        if (isFirst) {
            var tr;
            var flag = Jeeel.Document.createDocumentFragment();
            children = (element.contentWindow ? [element.contentWindow.document.documentElement] : element.childNodes);

            for (i = 0, l = children.length; i < l; i++) {

                if (Jeeel.Type.isText(children[i]) && children[i].data.match(/^(\r|\n|\t| )*$/)) {
                    continue;
                }
                
                tr = this._createExpanderTr(children[i]);
                flag.appendChild(tr);
            }

            tr = Jeeel.Document.createElement('tr');
            th = Jeeel.Document.createElement('th');
            td = Jeeel.Document.createElement('td');
            
            td.innerHTML = '<font color="#881391">&lt;/' + nodeName + '&gt;</font>';

            var self = this;
            var mouseDown = function () {
                var data   = arguments.callee.data;
                var target = arguments.callee.targetTr;

                self._selectElement(data, target);
            };

            mouseDown.data = element;
            mouseDown.targetTr = tr;

            var mouseUp = function () {
                var event  = Jeeel.Dom.Event.getEventObject();

                if (event.ctrlKey && event.isLeftDown) {
                    self._removeElement();
                }
            };

            td.firstChild.onmousedown = mouseDown;
            td.firstChild.onmouseup   = mouseUp;
            
            tr.appendChild(th);
            tr.appendChild(td);
            
            flag.appendChild(tr);

            tbody.appendChild(flag);

        } else {
            children = tbody.childNodes;

            for (i = 0, l = children.length; i < l; i++) {
                if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                    children[i].style.display = '';
                }
            }

            tbody.lastChild.style.display = '';
        }
    },

    /**
     * Html要素のための閉じるメソッド
     *
     * @param {Element} element 閉じるElement
     * @param {Element} tbody 閉じる対象のtbody
     * @private
     */
    _collapseTableForElement: function (element, tbody) {
        var th, td;

        th = tbody.firstChild.firstChild;
        td = tbody.firstChild.children[1];
        th.innerHTML = this.constructor.COLLAPSE_ARROW;

        if (td.firstChild.nodeName.toLowerCase() !== 'font') {
            td = td.firstChild.firstChild.firstChild.children[1];
        }
        
        td.firstChild.innerHTML = this._createInfoElement(element);
        tbody.firstChild.enableMouse = true;

        var children = tbody.childNodes;

        for (var i = 0, l = children.length; i < l; i++) {
            if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                children[i].style.display = 'none';
            }
        }

        tbody.lastChild.style.display = 'none';
    },

    /**
     * DocumentFragmentを展開する
     *
     * @param {Mixied} obj Tableに定義づけられているオブジェクト
     * @param {Element} tbody 閉じる対象のtbody
     * @param {Boolean} [isFirst=false] 最初の展開かどうか
     * @private
     */
    _expandTableForDocumentFragment: function (obj, tbody, isFirst) {

        var i, l, th;

        th = tbody.firstChild.firstChild;
        th.innerHTML = this.constructor.EXPAND_ARROW;

        if (isFirst) {
            var tr;
            var flag = Jeeel.Document.createDocumentFragment();
            var length = obj.childNodes.length;

            for (i = 0; i < length; i++) {
                var val = obj.childNodes[i];
                
                tr = this._createExpanderTr(val);
                flag.appendChild(tr);
            }
            
            tbody.appendChild(flag);
        } else {
            var children = tbody.childNodes;

            for (i = 0, l = children.length; i < l; i++) {
                if (children[i].className == this.constructor.EXPAND_CHILD_CLASS) {
                    children[i].style.display = '';
                }
            }
        }
    },

    /**
     * ジェスチャーの判定を行う
     * 
     * @param {Integer[]} judge 判定対象のジェスチャー
     * @type Jeeel.Function.create
     * @function
     */
    _mouseGestureJudge: Jeeel.Function.create(function (judge) {

        if (this._mouseGesture.matchGesture(judge)) {
            this._removeElement();
            this._mouseGesture.end();
        }
    }),

    /**
     * @ignore
     */
    _markupElement: function (element, target) {
        var foreground = Jeeel.Document.createElement('div');
        var foregroundStyle = Jeeel.Dom.Style.create(foreground);
        var elementStyle = element.style;
        
        Jeeel.Dom.Event.disableMouseEvent(foreground);
        
        foreground.className = this.constructor.HTML_LAYER_CLASS;
        
        foregroundStyle.setStyleList({
            backgroundColor: '#3879D9',
            width: '100%',
            height: '100%',
            zIndex: '50',
            top: '0px',
            left: '0px',
            position: 'absolute',
            opacity: 0.3
        });

//        target._position = elementStyle.position;
//        target._zIndex   = elementStyle.zIndex;
//
//        elementStyle.position = 'relative';
//
//        if ( ! elementStyle.zIndex) {
//            elementStyle.zIndex   = '1';
//        }
        
        element.appendChild(foreground);
    },

    /**
     * @ignore
     */
    _cleanupElement: function (element, target) {
        var elm = Jeeel.Dom.Element.create(element);
        var elementStyle = element.style;
        var foreground = elm.getElementsByClassName(this.constructor.HTML_LAYER_CLASS)[0];

        if ( ! foreground) {
            return;
        }

        Jeeel.Dom.Element.create(foreground).remove();

//        if (Jeeel.Type.isString(target._position)) {
//            elementStyle.position = target._position;
//        }
//
//        if (Jeeel.Type.isString(target._zIndex)) {
//            elementStyle.zIndex = target._zIndex;
//        }
    },

    /**
     * 指定したHTML要素を選択し、それに対応するexpand要素をセレクト状態にする
     *
     * @param {Element} element 対象HTML要素
     * @param {Element} target 対象expand要素
     */
    _selectElement: function (element, target) {
        if (this._selectedTarget) {
            this._mouseGesture.end();
            this._selectedTarget.style.backgroundColor = '';
        }

        target.style.backgroundColor = '#C8D8FB';

        this._selectedElement = element;
        this._selectedTarget  = target;
        this._selectedRemoveTarget = target.parentNode.parentNode.parentNode.parentNode;
        this._mouseGestureJudge.reset();
        this._mouseGestureJudge.curry(this._removeGesture).bind(this);
        this._mouseGesture.setInactiveCallback(this._mouseGestureJudge)
                          .start();
    },

    /**
     * 現在選択中のHTML要素を取り除く
     */
    _removeElement: function () {
        if ( ! this._selectedTarget) {
            return;
        }

        Jeeel.Dom.Element.create(this._selectedElement).remove();
        Jeeel.Dom.Element.create(this._selectedRemoveTarget).remove();

        this._selectedElement = null;
        this._selectedTarget  = null;
        this._selectedRemoveTarget = null;
    },

    /**
     * Html要素を表すHTML文字列を作成する
     *
     * @param {Element} element 対象のElement
     * @param {Boolean} [isExpanded] 開いた状態のHTML文字列かどうか
     * @private
     */
    _createInfoElement: function (element, isExpanded) {
        var nodeName = (element.scopeName && element.scopeName !== 'HTML' ? element.scopeName + ':' : '')
                     + element.nodeName.toLowerCase();
        var html = ['&lt;' + nodeName];
        var attr = element.attributes;
        var isIE = Jeeel.UserAgent.isInternetExplorer();

        for (var i = 0, l = attr.length; i < l; i++) {

            if ( ! attr[i].value || (isIE && attr[i].value === 'null')) {
                continue;
            }

            html[html.length] = ' <font color="#994500">' + attr[i].name + '=&quot;<font color="#1A1AA6">' + attr[i].value + '</font>&quot;</font>';
        }

        html[html.length] = '&gt;';

        if ( ! isExpanded) {

            if (element.firstChild || element.tagName.toUpperCase() == 'STYLE') {
              
                var isOpendElm = this._isAlwaysOpenedElement(element);
                var multiLine = false;
                var innerText;
                
                if (isOpendElm) {
                    innerText = (element.styleSheet && element.styleSheet.cssText || element.innerHTML).replace(/(^(\r\n|\n))|((\r\n|\n)$)/, '');
                }
                
                if (innerText && innerText.indexOf('\n') + 1) {
                    multiLine = true;
                }
                
                var txt = (isOpendElm ? Jeeel.String.escapeHtml(innerText, true) : '_');
                
                if (isOpendElm && multiLine) {
                    txt = '<br />' + txt + '<br />';
                }
                
                html[html.length] = '<font color="black">' + txt + '</font>';
            }

            html[html.length] = '&lt;/' + nodeName + '&gt;';
        }

        return html.join('');
    },

    /**
     *
     */
    _isAlwaysOpenedElement: function (element) {
        var closeElm = ['SCRIPT', 'STYLE'];

//        if (Jeeel.Hash.inHash(element.tagName.toUpperCase(), closeElm)) {
//            return true;
//        }

        return (element.childNodes.length == 1 && Jeeel.Type.isText(element.childNodes[0]));
    }
};

/**
 * @staticClass メッセージをHTML上に表示するためのモジュール
 */
Jeeel.Debug.ErrorMessage = {
    
    _timer: 0,
    
    _setLf: false,
    
    /**
     * エラーメッセージの出力するためのdivタグを作る
     *
     * @return {Element} 取得したdiv要素
     * @private
     */
    _create: function () {
        var errorDiv = 'jeeel-debug-error-message-div';

        var div = Jeeel._doc.getElementById(errorDiv);

        if ( ! div) {
            div = Jeeel.Document.createElement('div');
            div.id = errorDiv;
            
            var style = div.style;
            
            style.backgroundColor = 'white';
            style.color = 'black';
            style.textAlign = 'left';
            style.fontSize = '15px';
            style.fontWeight = 'normal';
            
            Jeeel.Debug.Debugger.elementInsertTop(div);
        }

        return div;
    },

    /**
     * エラーをダンプする<br />
     * errorDiv変数のIDからdivを取得<br />
     * なければ作成する
     *
     * @param {Mixied} var_args 可変引数、ダンプするエラーを羅列する
     */
    dump: function (var_args) {
        var div = Jeeel.Debug.ErrorMessage._create();

        var error = [];

        for (var i = 0, l = arguments.length; i < l; i++) {
            error[i] = Jeeel.String.escapeHtml(arguments[i], true);
        }

        Jeeel.Debug.ErrorMessage._setLinefeed();

        div.innerHTML += error.join(' ');

        Jeeel.Debug.ErrorMessage._setLinefeedTimer();
    },

    /**
     * タグを全て取り除いたエラーダンプする<br />
     * errorDiv変数のIDからdivを取得<br />
     * なければ作成する
     *
     * @param {Mixied} var_args 可変引数、ダンプするエラーを羅列する
     */
    dumpStripTags: function (var_args) {

        for (var i = 0, l = arguments.length; i < l; i++) {
            arguments[i] = Jeeel.String.stripTags(''+arguments[i]);
        }

        Jeeel.Debug.ErrorMessage.dump.apply(this, arguments);
    },

    /**
     * タグをエスケープしないで直接ダンプを行う<br />
     * errorDiv変数のIDからdivを取得<br />
     * なければ作成する
     *
     * @param {Mixied} var_args 可変引数、ダンプするエラーを羅列する
     */
    dumpHtml: function (var_args) {
        var div = Jeeel.Debug.ErrorMessage._create();

        var error = [];

        for (var i = 0, l = arguments.length; i < l; i++) {
            error[i] = arguments[i];
        }
        
        Jeeel.Debug.ErrorMessage._setLinefeed();
        
        div.innerHTML += error.join(' ');
        
        Jeeel.Debug.ErrorMessage._setLinefeedTimer();
    },

    /**
     * エラーを消去する<br />
     * errorDiv変数のIDからdivを取得<br />
     * なければ作成する
     */
    clear: function () {

        var div = Jeeel.Debug.ErrorMessage._create();

        div.innerHTML = '';
    },

    /**
     * エラーメッセージを出力するためのdiv要素を得る
     *
     * @return {Element} 取得したdiv要素
     */
    get: function () {
        return Jeeel.Debug.ErrorMessage._create();
    },

    /**
     * 出力されたエラーメッセージを文字列として得る
     *
     * @return {String} 取得したエラーメッセージ
     */
    getText: function () {
        return Jeeel.String.unescapeHtml(Jeeel.Debug.ErrorMessage._create().innerHTML, true);
    },
    
    _setLinefeed: function () {
        if (this._setLf) {
            this._create().innerHTML += '<br />';
            this._setLf = false;
        }
    },
    
    _setLinefeedTimer: function () {
        if (this._timer) {
            return;
        }
        
        this._timer = Jeeel.Timer.setTimeout(function () {
            Jeeel.Debug.ErrorMessage._setLf = true;
            Jeeel.Debug.ErrorMessage._timer = 0;
        }, 0);
    }
};

/**
 * コンストラクタ
 * 
 * @class デバッグ用のタイマー(ストップウォッチ)を管理するクラス
 */
Jeeel.Debug.Timer = function () {
    this.reset();
};

/**
 * インスタンスの作成を行う
 * 
 * @return {Jeeel.Debug.Timer} 作成したインスタンス
 */
Jeeel.Debug.Timer.create = function () {
    return new this();
};

Jeeel.Debug.Timer.prototype = {
    
    /**
     * Timerを作る際のベースにする現時刻
     * 
     * @type Jeeel.Object.Date
     * @private
     */
    _date: null,
    
    /**
     * ラップタイムの記録
     * 
     * @type Hash
     * @private
     */
    _laps: {},
    
    /**
     * インターバルの記録
     * 
     * @type Hash
     * @private
     */
    _interval: {},
    
    /**
     * インターバルを最後に記録した際のタイム
     * 
     * @type Integer
     * @private
     */
    _lastTime: 0,
    
    /**
     * 現在動いているかどうか
     * 
     * @type Boolean
     */
    _active: true,
    
    /**
     * stopメソッドを呼び出した際の時間
     * 
     * @type Integer
     */
    _stopTime: 0,
    
    /**
     * タイマーをスタートする<br />
     * 作成時は既にスタート済み
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    start: function () {
        if ( ! this._active) {
            this._date.setElapsedTime(this._stopTime);
            this._active = true;
        }

        return this;
    },
    
    /**
     * タイマーを一時停止する<br />
     * もう一度使いたい場合はstartメソッドを呼び出す
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    stop: function () {
        this._active   = false;
        this._stopTime = this._date.getElapsedTime();
        
        return this;
    },
    
    /**
     * インスタンスを作成時の状態にリセットする
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    reset: function () {

        this._laps = {};
        this._interval = {};
        this._lastTime = 0;
        this._stopTime = 0;
        this._date = Jeeel.Object.Date.create();
        this._active = true;
        
        return this;
    },
    
    /**
     * ラップタイムを記録する
     * 
     * @param {String} [key] 任意の記録キーを指定したい場合に引き渡す(デフォルトは現在の記録数)
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    lap: function (key) {
        if ( ! this._active) {
            return this;
        }
        
        if ( ! key) {
            key = Jeeel.Hash.getCount(this._laps);
        }
        
        this._laps[key] = this._date.getElapsedTime();
        
        return this;
    },
    
    /**
     * ラップタイムの記録を返す
     * 
     * @param {String} key 読み込みたいラップのキー
     * @return {Integer} ラップタイム
     */
    loadLap: function (key) {
        return this._laps[key];
    },
    
    /**
     * ラップタイムの記録を全て返す
     * 
     * @return {Hash} ラップタイムとそのキーのペアリスト
     */
    loadAllLap: function () {
        return this._laps;
    },
    
    /**
     * ラップタイムの記録を全て破棄する
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    clearLap: function () {
        this._laps = {};
        
        return this;
    },
    
    /**
     * インターバルを記録する
     * 
     * @param {String} [key] 任意の記録キーを指定したい場合に引き渡す(デフォルトは現在の記録数)
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    interval: function (key) {
        if ( ! this._active) {
            return this;
        }
        
        if ( ! key) {
            key = Jeeel.Hash.getCount(this._interval);
        }
        
        var t = this._date.getElapsedTime();
        
        this._interval[key] = (this._interval[key] || 0) + t - this._lastTime;
        
        this._lastTime = t;
        
        return this;
    },
    
    /**
     * インターバルの記録を取得する
     * 
     * @param {String} key 読み込みたいインターバルのキー
     * @return {Integer} インターバル
     */
    loadInterval: function (key) {
        return this._interval[key];
    },
    
    /**
     * インターバルの記録を全て取得する
     * 
     * @return {Hash} インターバルとそのキーのペアリスト
     */
    loadAllInterval: function () {
        return this._interval;
    },
    
    /**
     * インターバルの記録を全破棄する
     * 
     * @return {Jeeel.Debug.Timer} 自インスタンス
     */
    clearInterval: function () {
        this._interval = {};
        this._lastTime = 0;
        
        return this;
    }
};

/**
 * @staticClass コンソールを管理するスタティッククラス
 */
Jeeel.Debug.Console = {

    /**
     * コンソールの識別子
     *
     * @type String
     * @constant
     */
    CONSOLE_ID: 'jeeel-debug-console',

    /**
     * コンソールログの識別子
     *
     * @type String
     * @constant
     */
    CONSOLE_LOG_ID: 'jeeel-debug-console-log',
    
    /**
     * コンソールキーボードの識別子
     * 
     * @type String
     * @constant
     */
    CONSOLE_KEYBOARD_ID: 'jeeel-debug-console-keyboard',

    /**
     * コンソール実行結果の識別子
     *
     * @type String
     * @constant
     */
    CONSOLE_RESULT_ID: 'jeeel-debug-console-res',

    /**
     * コンソールの関数補完識別子
     *
     * @type String
     * @constant
     */
    CONSOLE_CODE_ASSIST_ID: 'jeeel-debug-console-code-assist',
    
    /**
     * コンソール
     *
     * @type Element
     * @private
     */
    _console: null,

    /**
     * コンソール入力部
     *
     * @type Jeeel.Dom.Element.Textarea
     * @private
     */
    _consoleIn: null,
    
    /**
     * コンソールキーボード
     * 
     * @type Element
     * @private
     */
    _consoleKeyboard: null,

    /**
     * コンソール出力部
     *
     * @type Element
     * @private
     */
    _consoleOut: null,

    /**
     * コンソール関数補完ウィンドウ
     *
     * @type Jeeel.Dom.ElementOperator
     * @private
     */
    _consoleCodeAssistWindow: null,

    /**
     * コンソールログの現在のポジション
     *
     * @type Integer
     * @private
     */
    _consolePosition: 0,

    /**
     * コンソールのログ
     *
     * @type String[]
     * @private
     */
    _consoleLog: [],

    /**
     * コンソールの実行結果
     *
     * @type Element[]
     * @private
     */
    _consoleResult: [],
    
    /**
     * コンソールの保存媒体
     * 
     * @type Jeeel.Session.Name
     * @private
     */
    _consoleSession: null,
    
    /**
     * 現在のモードが単数行モードかどうか
     * 
     * @type Boolean
     * @private
     */
    _isSingleLineMode: true,

    /**
     * Html要素の展開及び操作を行うモードかどうかを示す
     *
     * @type Boolean
     * @private
     */
    _useHtmlExplorer: true,

    /**
     * 関数補完に使用するデータ
     *
     * @type Hash
     * @private
     * @ignore
     */
    _codeAssistData: {
      
        /**
         * コード補完を使うかどうか
         * 
         * @type Boolean
         */
        use: true,
        
        /**
         * 補完Windowの子リストを収めたElementラッパー
         * 
         * @type Jeeel.Dom.ElementOperator
         */
        winChild: null,
        
        /**
         * 使用中かどうか
         * 
         * @type Boolean
         */
        enable: false,
        
        /**
         * ウィンドウが表示中かどうか
         * 
         * @type Boolean
         */
        show: false,
        
        /**
         * 次のデータ更新をキャンセルするかどうか
         * 
         * @type Boolean
         */
        cancel: false,
        
        /**
         * 親要素
         * 
         * @type String
         */
        parent: '',
        
        /**
         * 子要素
         * 
         * @type String
         */
        child: '',
        
        /**
         * 補完した際に書き換えを行うインデックス
         * 
         * @type Interger
         */
        index: 0,
        
        /**
         * 補完した際の選択中のデータのインデックス
         * 
         * @type Interger
         */
        selectIndex: -1,
        
        /**
         * 現在補完している要素のキーと値のペアリストを保持する配列
         * 
         * @type Jeeel.Object.Item[]
         */
        pairs: [],
        
        /**
         * 現在補完している要素のキーを保持する配列
         * 
         * @type String[]
         */
        keys: [],
        
        /**
         * 検索が完了したキャッシュ
         * 
         * @type Hash
         */
        cache: {}
    },

    /**
     * 簡易コンソールを生成する<br />
     * 以下操作方法<br />
     * 単数行モード<br />
     * <ul>
     *   <li>Enterで実行</li>
     *   <li>上下で履歴</li>
     *   <li>Ctrl+Mで複数行モードに切り替え</li>
     *   <li>結果がオブジェクトの場合は矢印をクリックで展開</li>
     * </ul><br />
     * 複数行モード<br />
     * <ul>
     *   <li>Ctrl+Enterで実行</li>
     *   <li>Ctrl+上下で履歴</li>
     *   <li>Ctrl+Mで複数行モードに切り替え</li>
     *   <li>結果がオブジェクトの場合は矢印をクリックで展開</li>
     * </ul>
     */
    create: function () {

        if (arguments.callee.ignore) {
            return;
        }
        
        // thisをbind
        for (var property in this) {
            if (Jeeel.Type.isFunction(this[property])) {
                this[property] = Jeeel.Function.simpleBind(this[property], this);
            }
        }

        arguments.callee.ignore = true;

        this._setStyle();

        var div = Jeeel.Document.createElement('div');
        div.innerHTML = '<textarea style="height: 25px;" id="' + this.CONSOLE_LOG_ID + '"></textarea>\n'
                      + '<div id="' + this.CONSOLE_KEYBOARD_ID + '"><div class="title">キーボード</div></div>\n'
                      + '<div id="' + this.CONSOLE_RESULT_ID + '"></div>\n'
                      + '<ul style="display: none;" id="' + this.CONSOLE_CODE_ASSIST_ID + '"></ul>';

        div.id = this.CONSOLE_ID;
        this._console = Jeeel.Debug.Debugger.elementInsertTop(div);

        var self = this;
        var session = Jeeel.Session.Name.create();

        this._consoleSession = session.setExpires(-1).setPath('/');
        
        this._consoleIn  = Jeeel.Dom.Element.Textarea.create(Jeeel.Document.getElementById(this.CONSOLE_LOG_ID));
        this._consoleOut = Jeeel.Document.getElementById(this.CONSOLE_RESULT_ID);
        this._consoleKeyboard = Jeeel.Document.getElementById(this.CONSOLE_KEYBOARD_ID);
        this._consoleCodeAssistWindow = Jeeel.Dom.ElementOperator.create(Jeeel.Dom.Element.create(Jeeel.Document.getElementById(this.CONSOLE_CODE_ASSIST_ID)).setShim());

        this._consoleLog    = session.get(this.CONSOLE_LOG_ID, []);
        this._consoleResult = Jeeel.Filter.Hash.Fill.create(0, this._consoleLog.length, null).filter([]);
        this._initKeyboard();

        this._consolePosition = this._consoleLog.length;
        
        // モバイル系ではキーボードがショボイためソフトウェアキーボードを有効化
        if (Jeeel.UserAgent.isMobile()) {
            this._consoleKeyboard.style.display = 'block';
        }
        
        var singleLine, multiLine;

        var setEvent = function (listener) {
            if (Jeeel.UserAgent.isOpera()) {
                self._consoleIn.getElement()['on' + Jeeel.Dom.Event.Type.KEY_PRESS] =listener;
            } else {
                self._consoleIn.getElement()['on' + Jeeel.Dom.Event.Type.KEY_DOWN] = listener;
            }
            
            self._isSingleLineMode = listener === singleLine;
        };

        /**
         * @ignore
         */
        singleLine = function () {
            var e = Jeeel.Dom.Event.getEventObject();
            var keyCode = e.getKeyCode();
            var timeoutId;
            
            if (self._codeAssistData.use) {
                if (Jeeel.Hash.inHash(keyCode, [Jeeel.Dom.Event.KeyCode.Space, Jeeel.Dom.Event.KeyCode.LeftBracket, Jeeel.Dom.Event.KeyCode.RightBracket])) {
                    self._codeAssistDataClose();
                } else if (self._codeAssistData.enable || Jeeel.Hash.inHash(keyCode, [Jeeel.Dom.Event.KeyCode.Period, Jeeel.Dom.Event.KeyCode.BackSpace]) || ! self._consoleIn.getText()) {
                    timeoutId = Jeeel.Timer.setTimeout(self._setCodeAssistData, 1);
                }
            }

            if (keyCode === Jeeel.Dom.Event.KeyCode.Enter) {

                e.stop();

                self._evalConsoleText();
                
                return false;
                
            } else if (Jeeel.Hash.inHash(keyCode, [Jeeel.Dom.Event.KeyCode.Up, Jeeel.Dom.Event.KeyCode.PageUp])) {

                e.stop();

                self._consoleUp();
                
                Jeeel.Timer.clearTimeout(timeoutId);

                return false;
                
            } else if (Jeeel.Hash.inHash(keyCode, [Jeeel.Dom.Event.KeyCode.Down, Jeeel.Dom.Event.KeyCode.PageDown])) {
                
                e.stop();

                self._consoleDown();
                
                Jeeel.Timer.clearTimeout(timeoutId);

                return false;
                
            } else if (self._codeAssistData.enable && keyCode === Jeeel.Dom.Event.KeyCode.Tab) {
                e.stop();

                if (e.shiftKey) {
                    self._consoleUp();
                } else {
                    self._consoleDown();
                }
                
                Jeeel.Timer.clearTimeout(timeoutId);

                return false;
                
            } else if (keyCode === Jeeel.Dom.Event.KeyCode.M && e.ctrlKey) {

                e.stop();

                self._consoleIn.getStyle().height = '75px';
                setEvent(multiLine);
                
                self._codeAssistDataClose(true);
                
                Jeeel.Dom.Element.create(self._consoleOut).hide().show();

                return false;
            } else if (keyCode === Jeeel.Dom.Event.KeyCode.Shift) {
                e.stop();
                
                Jeeel.Timer.clearTimeout(timeoutId);

                return false;
            }

            return true;
        };

        /**
         * @ignore
         */
        multiLine = function () {
            var e = Jeeel.Dom.Event.getEventObject();
            var keyCode = e.getKeyCode();
            
            if (e.ctrlKey) {
                if (keyCode === Jeeel.Dom.Event.KeyCode.Enter) {

                    e.stop();

                    self._evalConsoleText();

                    return false;

                } else if (Jeeel.Hash.inHash(keyCode, [Jeeel.Dom.Event.KeyCode.Up, Jeeel.Dom.Event.KeyCode.PageUp])) {

                    e.stop();

                    self._consoleUp();

                    return false;

                } else if (Jeeel.Hash.inHash(keyCode, [Jeeel.Dom.Event.KeyCode.Down, Jeeel.Dom.Event.KeyCode.PageDown])) {

                    e.stop();

                    self._consoleDown();

                    return false;

                } else if (keyCode === Jeeel.Dom.Event.KeyCode.M) {

                    e.stop();

                    self._consoleIn.getStyle().height = '25px';
                    setEvent(singleLine);
                    self._setConsoleText(self._consoleIn.replace(/\r\n|\n/g, ' '));
                    
                    Jeeel.Dom.Element.create(self._consoleOut).hide().show();

                    return false;
                }
            }

            return true;
        };

        setEvent(singleLine);
    },

    /**
     * コンソール出力に値を表示する<br />
     * 履歴には残らない
     *
     * @param {Mixied} var_args 表示する値の可変引数
     * @return {Array} 表示する値をそのまま返す
     */
    log: function (var_args) {
        Jeeel.Debug.Console.create();

        var logs = Array.prototype.slice.call(arguments, 0, arguments.length);

        Jeeel.Debug.Console._addResult(logs);

        return logs;
    },

    /**
     * コンソールの履歴等を全て破棄する
     */
    clear: function () {
        this._consoleLog = this._consoleResult = [];
        this._consolePosition = 0;
        this._setConsoleText('');
        
        Jeeel.Dom.ElementOperator.create(this._consoleOut.childNodes).remove();

        this._consoleSession.set(this.CONSOLE_LOG_ID, [])
                            .save();
    },

    /**
     * コンソールの履歴を返す
     *
     * @param {Integer} index 履歴番号
     * @return {String} 結果値
     */
    getLog: function (index) {
        if (0 <= index && index < this._consoleLog.length) {
            return this._consoleLog[index];
        }

        return null;
    },

    /**
     * コンソールの結果履歴を全て返す
     *
     * @return {String[]} 結果値のリスト
     */
    getLogAll: function () {
        return this._consoleLog;
    },

    /**
     * HTML操作、閲覧機能の有効にするかどうかを設定する
     *
     * @param {Boolean} enable 有効にするかどうか
     */
    enableHtmlExplorer: function (enable) {
        this._useHtmlExplorer = !!enable;
    },
    
    /**
     * コード補完を有効にするかどうかを設定する
     * 
     * @param {Boolean} enable 有効にするかどうか
     */
    enableCodeAssist: function (enable) {
        this._codeAssistData.use = !!enable;
        
        if ( ! enable) {
            this._codeAssistDataClose(true);
        }
    },

    /**
     * コンソールを上部に移動する(デフォルト)
     */
    moveTop: function () {
        Jeeel.Debug.Debugger.elementInsertTop(this._console);
    },

    /**
     * コンソールを下部に移動する
     */
    moveBottom: function () {
        Jeeel._doc.body.appendChild(this._console);
    },

    /**
     * コンソールに対するスタイルの設定を行う
     */
    _setStyle: function () {
        if (arguments.callee.ignore) {
            return;
        }

        arguments.callee.ignore = true;

        var css = 'div#' + this.CONSOLE_ID + ' {\n'
                + '    position: relative;\n'
                + '    z-index: 100000;\n'
                + '    background-color: white;\n'
                + '    text-align: left;\n'
                + '    font-family: "Arial", "Times New Roman", "Courier New", "Courier", cursive;\n'
                + '}\n'
                + 'textarea#' + this.CONSOLE_LOG_ID + ' {\n'
                + '    width: 99.3%;\n'
                + '    font-size: 20px;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_RESULT_ID + ' {\n'
                + '    background-color: white;\n'
                + '    text-align: left;\n'
                + '    width: 100%;\n'
                + '    height: auto;\n'
                + '    font-size:15px;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_KEYBOARD_ID + ' {\n'
                + '    background-color: white;\n'
                + '    position: fixed;\n'
                + '    z-index: 20;\n'
                + '    top: 38%;\n'
                + '    left: 38%;\n'
                + '    border: 1px solid #C2C2C2;\n'
                + '    width: 30%;\n'
                + '    height: 100px;\n'
                + '    display: none;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_KEYBOARD_ID + ' .title {\n'
                + '    text-align: center;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_KEYBOARD_ID + ' .keyboard {\n'
                + '    border-top: 1px solid #F2F2F2;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_KEYBOARD_ID + ' .operator {\n'
                + '    text-align: center;\n'
                + '}\n'
                + 'div#' + this.CONSOLE_KEYBOARD_ID + ' .button {\n'
                + '    cursor: pointer;\n'
                + '    display: inline-block;\n'
                + '    color: #d9eef7;\n'
                + '    padding: .2em 1.25em .4em;\n'
                + '    margin: 3px;\n'
                + '    border: solid 1px #0076a3;\n'
                + '    -webkit-border-radius: .5em;\n'
                + '    -moz-border-radius: .5em;\n'
                + '    border-radius: .5em;\n'
                + '    -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.2);\n'
                + '    -moz-box-shadow: 0 1px 2px rgba(0,0,0,.2);\n'
                + '    box-shadow: 0 1px 2px rgba(0,0,0,.2);\n'
                + '    background: #0095cd;\n'
                + '    background: -webkit-gradient(linear, left top, left bottom, from(#00adee), to(#0078a5));\n'
                + '    background: -moz-linear-gradient(top,  #00adee,  #0078a5);\n'
                + '    filter:  progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#00adee\', endColorstr=\'#0078a5\');\n'
                + '}\n'
                + 'div#' + this.CONSOLE_KEYBOARD_ID + ' .button:hover {\n'
                + '    background: #007ead;\n'
                + '    background: -webkit-gradient(linear, left top, left bottom, from(#0095cc), to(#00678e));\n'
                + '    background: -moz-linear-gradient(top,  #0095cc,  #00678e);\n'
                + '    filter:  progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#0095cc\', endColorstr=\'#00678e\');\n'
                + '}\n'
                + 'div#' + this.CONSOLE_KEYBOARD_ID + ' .button:active {\n'
                + '    position: relative;\n'
                + '    top: 1px;\n'
                + '    color: #80bed6;\n'
                + '    background: -webkit-gradient(linear, left top, left bottom, from(#0078a5), to(#00adee));\n'
                + '    background: -moz-linear-gradient(top,  #0078a5,  #00adee);\n'
                + '    filter:  progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#0078a5\', endColorstr=\'#00adee\');\n'
                + '}\n'
                + 'ul#' + this.CONSOLE_CODE_ASSIST_ID + ' {\n'
                + '    padding: 0;\n'
                + '    font-size: 15px;\n'
                + '    line-height: 18px;\n'
                + '    text-align: left;\n'
                + '    overflow: auto;\n'
                + '    border: solid 1px gray;\n'
                + '    z-index: 200;\n'
                + '    position: absolute;\n'
                + '    left: 200px;\n'
                + '    top: 40px;\n'
                + '    overflow-x: hidden;\n'
                + '    overflow-y: auto;\n'
                + '    background-color: white;\n'
                + '    max-height: 200px;\n'
                + '    _height: 200px;\n'
                + '}\n'
                + 'ul#' + this.CONSOLE_CODE_ASSIST_ID + ' li {\n'
                + '    list-style-type: none;\n'
                + '    padding: 1px 20px 1px 2px;\n'
                + '    cursor: pointer;\n'
                + '}';

        Jeeel.Loader.addStyle(css);
    },

    /**
     * コンソール入力部にテキストをセットする
     *
     * @param {String} text 設定値
     * @private
     */
    _setConsoleText: function (text) {

        this._codeAssistDataClose();
        this._consoleIn.setText(text);
    },
    
    /**
     * thisをbindして実行を行う
     * 
     * @param {String} _$txt$_ 実行文字列
     * @return {Mixied} 実行結果
     */
    _eval: function (_$txt$_) {
        // eval中に使える関数の定義
        var clear = this.clear;
        var enableCodeAssist = this.enableCodeAssist;
        var enableHtmlExplorer = this.enableHtmlExplorer;
        
        // 先頭のvar宣言は自動的にグローバル宣言に切り替える
        _$txt$_ = _$txt$_.replace(/^ *var +([a-zA-Z$_][a-zA-Z0-9$_]*) *= */g, "this['$1'] = ");
        
        return (function (){
            return eval(_$txt$_);
        }).call(Jeeel._global);
    },
    
    /**
     * コンソールの文字列をスクリプトとして実行し結果を保持する
     */
    _evalConsoleText: function () {
        if (this._codeAssistData.show) {
            this._selectCodeAssistDataExecute();
            return;
        }
        
        if ( ! this._consoleIn.getText()) {
            return;
        }
        
        var tmp;

        try {
            tmp = this._eval(this._consoleIn.getText());
        } catch (e) {
            tmp = e;
        }

        this._addResult(tmp);

        this._consolePosition = this._consoleLog.length;

        this._consoleResult[this._consolePosition] = tmp;
        this._consoleLog[this._consolePosition] = this._consoleIn.getText();

        this._consoleSession.set(this.CONSOLE_LOG_ID, this._consoleLog).save();

        this._consolePosition++;

        this._setConsoleText('');
    },
    
    /**
     * コンソールの履歴ポジションを上に一つ上げる
     */
    _consoleUp: function () {
        if (this._codeAssistData.show) {
            this._selectCodeAssistData(1);
            return;
        }
        
        if (this._consoleLog.length === 0) {
            return;
        }

        this._consolePosition--;

        if (this._consolePosition < 0) {
            this._consolePosition = 0;
        }
        
        var txt = this._consoleLog[this._consolePosition];
        
        this._setConsoleText(this._isSingleLineMode ? txt.replace(/\r\n|\n/g, ' ') : txt);
    },
    
    /**
     * コンソールの履歴ポジションを下に一つ下げる
     */
    _consoleDown: function () {
        if (this._codeAssistData.show) {
            this._selectCodeAssistData(-1);
            return;
        }
      
        if (this._consoleLog.length === 0) {
            return;
        }

        this._consolePosition++;

        if (this._consolePosition > this._consoleLog.length) {
            this._consolePosition = this._consoleLog.length;
        }

        if (this._consolePosition < this._consoleLog.length) {
            var txt = this._consoleLog[this._consolePosition];

            this._setConsoleText(this._isSingleLineMode ? txt.replace(/\r\n|\n/g, ' ') : txt);
        } else {
            this._setConsoleText('');
        }
    },

    /**
     * 結果を展開できる状態にする
     *
     * @param {Mixied} obj 展開する結果値
     * @private
     */
    _addResult: function (obj) {
        var res = Jeeel.Debug.ObjectExpander.expand(obj, this._useHtmlExplorer);

        if (this._consoleOut.firstChild) {
            var hr = Jeeel.Document.createElement('hr');
            this._consoleOut.appendChild(hr);
        }
        
        this._consoleOut.appendChild(res);
    },

    /**
     * コード補完のデータを初期化して終了させる
     * 
     * @param {Boolean} [cancel] この後の動作キャンセルを行うかどうか
     */
    _codeAssistDataClose: function (cancel) {
        var caData = this._codeAssistData;
        
        caData.selectIndex = -1;
        caData.enable = false;
        caData.cancel = !!cancel;
        
        this._codeAssistWindowHide();
    },
    
    /**
     * コード補完ウィンドウを表示させる
     * 
     * @ignore
     */
    _codeAssistWindowShow: function () {
        var left = this._codeAssistData.index * 10 + 20;
        
        this._consoleCodeAssistWindow.shiftTo(left, 40);
        
        this._consoleCodeAssistWindow.show();
        this._codeAssistData.show = true;
    },
    
    /**
     * コード補完ウィンドウを非表示にする
     * 
     * @ignore
     */
    _codeAssistWindowHide: function () {
        this._consoleCodeAssistWindow.hide();
        this._codeAssistData.show = false;
    },
    
    /**
     * コード補完に必要なデータを更新する
     * 
     * @ignore
     */
    _setCodeAssistData: (function () {
        var txtReg = /(^|[;:{}(\[\] ])([a-zA-Z$_][a-zA-Z0-9$_.]*)\.(|[a-zA-Z$_][a-zA-Z0-9$_]*)$/;
        var idxReg = /\.(|[a-zA-Z$_][a-zA-Z0-9$_]*)$/;
        var appendKeys = [
            'var',
            'function',
            'return',
            'delete',
            'in',
            'typeof',
            'instanceof',
            'for',
            'do',
            'while',
            'switch',
            'case',
            'break',
            'continue',
            'if',
            'else',
            'else if',
            'with',
            'arguments'
        ];
        
        return function () {
            var caData = this._codeAssistData;

            if (caData.cancel) {
                caData.cancel = false;
                return;
            }

            var txt = this._consoleIn.getText();
            var appendThis = false;
            
            if ( ! txt) {
                this._codeAssistDataClose();
                return;
            }
            
            if (txt.indexOf('.') < 0) {
                appendThis = true;
                txt = 'this.' + txt;
            }

            var tmp = txt.match(txtReg);
            var index = txt.search(idxReg) + 1 - (appendThis ? 5 : 0);

            if ( ! tmp) {
                this._codeAssistDataClose();
                return;
            }

            caData.enable = false;
            caData.child  = tmp[3];

            if (caData.parent != tmp[2] || ! appendThis && tmp[2] === 'this') {
                if (false && caData.cache[tmp[2]]) {
                    var cache = this._codeAssistData.cache[tmp[2]];

                    caData = this._codeAssistData = Jeeel.Hash.merge(caData, cache);
                }
                else {
                    caData.parent = tmp[2];

                    try {
                        var target = this._eval(caData.parent);
                    } catch(e) {
                        this._codeAssistWindowHide();
                        return;
                    }

                    try {
                        caData.pairs = Jeeel.Hash.getPairs(target, true, true);
                    } catch(e) {
                        this._codeAssistDataClose(true);
                        return;
                    }
                    
                    var pairs = caData.pairs;
                    
                    if (appendThis) {
                        pairs[pairs.length] = new Jeeel.Object.Item('clear', this.clear);
                        pairs[pairs.length] = new Jeeel.Object.Item('enableCodeAssist', this.enableCodeAssist);
                        pairs[pairs.length] = new Jeeel.Object.Item('enableHtmlExplorer', this.enableHtmlExplorer);
                        
                        for (i = 0, l = appendKeys.length; i < l; i++) {
                            pairs[pairs.length] = new Jeeel.Object.Item(appendKeys[i], null);
                        }
                    }
                    
                    caData.cache[tmp[2]] = {
                        parent: tmp[2],
                        pairs: caData.pairs
                    };
                }
            }

            if (caData.pairs.length < 1) {
                this._codeAssistWindowHide();
                return;
            }

            caData.selectIndex = -1;
            caData.index  = index;
            caData.enable = true;

            var i, l, keys = [];

            if (caData.child) {

                var regVal = Jeeel.String.escapeRegExp(caData.child);

                var reg = new RegExp('^' + regVal);

                for (i = 0, l = caData.pairs.length; i < l; i++) {

                    if ( ! caData.pairs[i].key.match(reg)) {
                        continue;
                    }

                    keys[keys.length] = caData.pairs[i].key;
                }
            } else {
                for (i = 0, l = caData.pairs.length; i < l; i++) {
                    keys[keys.length] = caData.pairs[i].key;
                }
            }

            caData.keys = keys;

            if (keys.length < 1) {
                this._codeAssistWindowHide();
                return;
            }

            var elm = this._consoleCodeAssistWindow;
            var lis = [];
            var self = this;

            if (caData.winChild) {
                caData.winChild.remove();
            }

            for (i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                var li = Jeeel.Document.createElement('li');
                li.innerHTML = key;

                /**
                 * @ignore
                 */
                li.onclick = function () {
                    self._replaceLog(arguments.callee.data);
                };

                li.onclick.data = key;

                lis[i] = li;
            }

            caData.winChild = new Jeeel.Dom.ElementOperator(lis);

            elm.appendChild(lis);
            this._codeAssistWindowShow();
        }
    })(),
    
    /**
     * @ignore
     */
    _setCodeData: function (index, divs) {
        var self = this;
        var key = this._codeAssistData.keys[index];
        var div = this._codeAssistData.winChild[index] || Jeeel.Document.createElement('div');
        div.innerHTML = key;

        /**
         * @ignore
         */
        div.onclick = function () {
            self._replaceLog(arguments.callee.data);
        };

        div.onclick.data = key;

        divs[index] = div;
    },
    
    /**
     * コード補完の候補を選択する
     * 
     * @ignore
     */
    _selectCodeAssistData: function (advanceIndex) {
        var caData = this._codeAssistData;
        var index = caData.selectIndex - advanceIndex;
        
        if (index < 0) {
            index = caData.keys.length - 1;
        } else if (index >= caData.keys.length) {
            index = 0;
        }
        
        if (index === caData.selectIndex) {
            return;
        }
        
        caData.winChild.$GET(caData.selectIndex).setCss('backgroundColor', '#FFF');
        
        caData.winChild.$GET(index).setCss('backgroundColor', '#FFD700');

        caData.selectIndex = index;
        
        var top = index * 20;
        var pos = this._consoleCodeAssistWindow.getScrollPos();
        
        if (pos.y < (top - 180)) {
            this._consoleCodeAssistWindow.scroll(0, top - 180);
        } else if (pos.y > top) {
            this._consoleCodeAssistWindow.scroll(0, top);
        }
    },
    
    /**
     * 選択されているコード補完候補を使用して適用する
     * 
     * @ignore
     */
    _selectCodeAssistDataExecute: function () {
        var caData = this._codeAssistData;
        var index = caData.selectIndex;
        
        if (caData.keys.length === 0) {
            return;
        } else if (index < 0) {
            index = 0;
        } else if (index >= caData.keys.length) {
            return;
        }
        
        caData.winChild[index].onclick();
        caData.cancel = true;
    },

    /**
     * 補完データを選択した時に現在の値を書き換える
     * 
     * @ignore
     */
    _replaceLog: function (key) {
        var txt = this._consoleIn.getText();

        txt = txt.substring(0, this._codeAssistData.index) + key;

        this._setConsoleText(txt);

        this._consoleIn.setSelectionStart(txt.length);
    },
    
    /**
     * ソフトウェアキーボードの初期化を行う
     * 
     * @ignore
     */
    _initKeyboard: function () {
        var keyboard = this._consoleKeyboard;
        
        var keyboardArea = Jeeel.Document.createElement('div');
        var keyInputer = Jeeel.Document.createElement('div');
        var consoleOperator = Jeeel.Document.createElement('div');
        
        keyboardArea.className = 'keyboard';
        consoleOperator.className = 'operator';
        
        var button, type, keyTypes = [
//            {txt: '{' , dispatch: Jeeel.Function.Template.EMPTY},
//            {txt: '}' , key: Jeeel.Dom.Event.KeyCode.RightBracket, shift: true, ctrl: false},
//            {txt: '[' , key: Jeeel.Dom.Event.KeyCode.LeftBracket, shift: false, ctrl: false},
//            {txt: ']' , key: Jeeel.Dom.Event.KeyCode.RightBracket, shift: false, ctrl: false}
        ], operatorTypes = [
            {txt: '↑' , dispatch: function (){this._consoleUp();}},
            {txt: '↓' , dispatch: function (){this._consoleDown();}},
            {txt: Jeeel.Code.HtmlCode.CarriageReturn , dispatch: function (){
                    if (this._codeAssistData.enable || ! this._consoleIn.getText()) {
                        Jeeel.Timer.setTimeout(this._setCodeAssistData, 1);
                    }
                    
                    this._evalConsoleText();
                }
            }
        ];
        
        var self = this, consoleIn = this._consoleIn.getElement();
        
        for (var i = 0; i < keyTypes.length; i++) {
            type = keyTypes[i];
            
            button = Jeeel.Document.createElement('div');
            button.innerHTML = type.txt;
            
            /**
             * @ignore
             */
            button.onclick = function () {
                var op = new Jeeel.Dom.Event.Option();
                op.setKeyCodeArg(type.key)
                  .setCtrlKeyArg(type.ctrl)
                  .setShiftKeyArg(type.shift);
                
                Jeeel.Dom.Event.dispatchEvent(consoleIn, Jeeel.Dom.Event.Type.KEY_DOWN, op);
            };
            
            keyInputer.appendChild(button);
        }
        
        for (var i = 0; i < operatorTypes.length; i++) {
            type = operatorTypes[i];
            
            button = Jeeel.Document.createElement('div');
            button.className = 'button';
            button.innerHTML = type.txt;
            
            /**
             * @ignore
             */
            button.onclick = function () {
                arguments.callee.type.dispatch.call(self);
                
                return false;
            };
            
            button.onclick.type = type;
            button.onmousemove = Jeeel.Function.Template.RETURN_FALSE;
            
            consoleOperator.appendChild(button);
        }
        
        keyboardArea.appendChild(keyInputer);
        keyboardArea.appendChild(consoleOperator);
        
        keyboard.appendChild(keyboardArea);
    },
    
    /**
     * @ignore
     */
    _appendLogText: function (appendText) {
        
        var txt = this._consoleIn.getText() + appendText;
        
        this._setConsoleText(txt);

        this._consoleIn.setSelectionStart(txt.length);
    }
};
Jeeel.directory.Jeeel.Debug.Profiler = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Debug + 'Profiler/';
    }
};

/**
 * @staticClass メソッドのプロファイリング機能を提供するスタティッククラス
 */
Jeeel.Debug.Profiler = {
  
    /**
     * メソッドの呼び出しの際に一時的に借りる名前
     *
     * @type String
     * @constant
     */
    TEMPORARY_METHOD_NAME: '@JEEEL-METHOD@',
    
    /**
     * プロファイルが完了しているものに対してチェックと入れるためのキー
     * 
     * @type String
     * @constant
     */
    PROFILE_CHECK_NAME: '@PROFILE-CHECK@',
    
    /**
     * メソッド実行ログ
     * 
     * @type Jeeel.Debug.Profiler.Profile[]
     * @private
     */
    _logs: [],
    
    /**
     * 1メソッドが現在までの掛かった時間の総合計
     * 
     * @type Hash
     * @private
     */
    _times: {},
    
    /**
     * 1メソッドが現在までに呼ばれた回数
     * 
     * @type Hash
     * @private
     */
    _counts: {},
    
    /**
     * 現在呼び出されているメソッドのチェイン階層
     * 
     * @type Integer
     * @private
     */
    _hierarchy: 0,
    
    /**
     * 現在アクセス中のデータ
     * 
     * @type Jeeel.Debug.Profiler.Profile
     * @private
     */
    _accessData: null,
    
    /**
     * メソッド呼び出しの書き込みデータ
     * 
     * @type Jeeel.Debug.Profiler.Profile
     * @private
     */
    _data: null,
    
    /**
     * 指定したオブジェクト以下のメソッドをプロファイリング対象にする
     * 
     * @param {Object|Function} object プロファイリング対象のメソッドを保持するオブジェクトもしくは関数
     * @param {String} name オブジェクトの名前
     * @param {Boolean} [deepSet] オブジェクトのプロパティに対して再帰的にプロファイリングするかどうか
     * @return {Jeeel.Debug.Profiler} 自クラス
     */
    profile: function (object, name, deepSet) {
      
        if ( ! object || object === this) {
            return this;
        }
        
        var type = typeof object;
        
        if (type !== 'object' && type !== 'function') {
            return this;
        } else if ('nodeType' in object) {
            return this;
        } else if ('Object' in object && 'Array' in object && 'String' in object && 'Number' in object && 'Boolean' in object && 'Function' in object) {
            return this;
        } else if ( ! object.hasOwnProperty || object.hasOwnProperty(this.PROFILE_CHECK_NAME) && object[this.PROFILE_CHECK_NAME]) {
            return this;
        }
        
        object[this.PROFILE_CHECK_NAME] = name;
        
        var property;
        
        for (var propertyName in object) {
            try {
                property = object[propertyName];
            } catch (e) {
                continue;
            }
            
            if ( ! property || propertyName === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            } else if ( ! property.hasOwnProperty || property.hasOwnProperty(this.PROFILE_CHECK_NAME) && property[this.PROFILE_CHECK_NAME]) {
                continue;
            }
            
            var fullName = (arguments[3] ? name + '#' + propertyName : name + '.' + propertyName);
            var propertyType = typeof property;
            
            if (deepSet) {
                this.profile(property, fullName, deepSet);
            }

            if (property instanceof Function && ! property.toString().match(/\{(\n|\s)+\[native code\](\n|\s)+\}/)) {
                object[propertyName] = this._getProfilingClosure(name, propertyName, fullName, object, property);
                
                for (var key in property) {
                    try {
                        object[propertyName][key] = property[key];
                    } catch (e) {
                        continue;
                    }
                }
                
                object[propertyName].prototype = property.prototype;
                
                object[propertyName][this.PROFILE_CHECK_NAME] = fullName;
            }
        }
        
        if (deepSet && object instanceof Function) {
            this.profile(object.prototype, name, deepSet, true);
        }
        
        return this;
    },
    
    /**
     * 現在までに呼び出されたメソッドのプロファイルを全て取得する
     * 
     * @return {Jeeel.Debug.Profiler.ProfileManager} プロファイル管理オブジェクト
     */
    getProfiles: function () {
        var manager = new this.ProfileManager();
        
        for (var i = 0, l = this._logs.length; i < l; i++) {
            manager.addProfile(this._logs[i]);
        }
        
        return manager;
    },
    
    getProfileHash: function (compareFunction) {
        var methodName,
            time,
            cnt,
            avg, 
            tmp = [],
            res = {};

        for (methodName in this._times) {
            if (methodName === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }

            time = this._times[methodName];
            cnt = this._counts[methodName];
            avg = time / this._counts[methodName];
            tmp[tmp.length] = [methodName, time, cnt, avg];
        }
        
        tmp.sort(compareFunction || function (a, b) {
            return b[1] - a[1];
        });
        
        for (var i = 0, l = tmp.length; i < l; i++) {
            res[tmp[i][0]] = tmp[i][1] + 'ms / ' + tmp[i][2] + 'times = ' + tmp[i][3] + 'ms/time';
        }

        return res;
    },
    
    getAverageProfileHash: function (compareFunction) {
        var methodName,
            avg, 
            tmp = [],
            res = {};

        for (methodName in this._times) {
            if (methodName === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }

            avg = this._times[methodName] / this._counts[methodName];
            tmp[tmp.length] = [methodName, avg];
        }
        
        tmp.sort(compareFunction || function (a, b) {
            return b[1] - a[1];
        });
        
        for (var i = 0, l = tmp.length; i < l; i++) {
            res[tmp[i][0]] = tmp[i][1];
        }

        return res;
    },
    
    /**
     * 現在までの呼び出されたメソッドの平均呼び出し時間のプロファイルを取得する
     * 
     * @return {Jeeel.Debug.Profiler.ProfileManager} プロファイル管理オブジェクト
     */
    getAverageProfiles: function () {
        var manager = new this.ProfileManager();
        
        if ( ! this._logs.length) {
            return manager;
        }
        
        var avg, methodName;
        
        for (methodName in this._times) {
            if (methodName === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }
            
            avg = this._times[methodName] / this._counts[methodName];
            manager.addProfile(new this.Profile(methodName, null, avg));
        }
        
        return manager;
    },
    
    /**
     * 現在までに収集したプロファイルの中から一番時間がかかっているプロファイルを取得する
     * 
     * @return {Jeeel.Debug.Profiler.Profile} 最遅のメソッドプロファイル
     */
    getBottleneckProfile: function () {
        if ( ! this._logs.length) {
            return null;
        }
        
        var max = this._logs[0].time,
            l = this._logs.length,
            i = 1,
            j = 0;

        for (; i < l; i++) {
            if (max < this._logs[i].time) {
                max = this._logs[i].time;
                j = i;
            }
        }
        
        return this._logs[j];
    },
    
    /**
     * 現在までに呼び出されたメソッドの中で平均で一番時間が掛かっているメソッドのプロファイルを取得する
     * 
     * @return {Jeeel.Debug.Profiler.Profile} 平均が最遅のメソッドプロファイル
     */
    getBottleneckAverageProfile: function () {
        if ( ! this._logs.length) {
            return null;
        }
        
        var first = true,
            max, 
            avg, 
            key;

        for (var methodName in this._times) {
            if (methodName === Jeeel.Debug.Debugger.INFORMATION_NAME) {
                continue;
            }
            
            avg = this._times[methodName] / this._counts[methodName];
            
            if (first) {
                max = avg;
                key = methodName;
                first = false;
            } else if (max < this._times[methodName]) {
                max = avg;
                key = methodName;
            }
        }
        
        return new this.Profile(key, null, max);
    },
    
    /**
     * プロファイリングのためのクロージャを取得する
     * 
     * @param {String} name メソッドの持ち主の名前
     * @param {String} property メソッド自身の名前
     * @param {String} fullName メソッドのネームスペース・クラスネームを含めた名前
     * @param {Object} owner メソッドの持ち主
     * @param {Function} func メソッド
     * @return {Function} プロファイリングクロージャ
     * @private
     */
    _getProfilingClosure: function (name, property, fullName, owner, func) {
        var self = this;
        
        return function () {
            var tmp,
                res, 
                time;

            if ( ! self._hierarchy) {
                self._accessData = self._data = new self.Profile(fullName, this);
            } else {
                tmp = self._accessData;

                self._accessData = tmp.calls[tmp.calls.length] = new self.Profile(fullName, this);
            }

            self._hierarchy++;

            time = (new Date()).getTime();

            try {
                
                // このクロージャインスタンスだったらインスタンスの作成を行う
                if (this instanceof arguments.callee && this.constructor === arguments.callee.prototype.constructor) {
                  
                    owner[self.TEMPORARY_METHOD_NAME] = func;
                    
                    // 引数が5つまでは高速化のために直接記述
                    switch (arguments.length) {
                        case 0:
                            res = new owner[self.TEMPORARY_METHOD_NAME]();
                            break;
                            
                        case 1:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0]);
                            break;
                            
                        case 2:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0], arguments[1]);
                            break;
                            
                        case 3:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0], arguments[1], arguments[2]);
                            break;
                            
                        case 4:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0], arguments[1], arguments[2], arguments[3]);
                            break;
                            
                        case 5:
                            res = new owner[self.TEMPORARY_METHOD_NAME](arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                            break;
                            
                        default:
                            res = (function (obj, methodName) {
                                methodName = 'new this["' + methodName + '"]';

                                return function () {
                                    var params = [];

                                    for (var i = arguments.length; i--;) {
                                        params[i] = "_" + i;
                                    }

                                    params = params.join(',');

                                    return Function(
                                        params,
                                        'return ' + methodName + '(' + params + ')'
                                    ).apply(obj, arguments);
                                };
                            })(owner, self.TEMPORARY_METHOD_NAME).apply(null, arguments);                
                            break;
                    }
                    
                    delete owner[self.TEMPORARY_METHOD_NAME];
                    
                } else {
                    res = func.apply(this, arguments);
                }
                
            } catch (e) {
                
                // エラー補足のための補助をする
                if ( ! e.jeeelStackTrace) {
                    e.jeeelStackTrace = [];
                }
                
                e.jeeelStackTrace[e.jeeelStackTrace.length] = fullName;
                
                throw e;
                
            } finally {
                time = (new Date()).getTime() - time;

                self._hierarchy--;

                if ( ! self._times[fullName]) {
                    self._counts[fullName] = 0;
                    self._times[fullName] = 0;
                }

                self._counts[fullName]++;
                self._times[fullName] += time;

                if ( ! self._hierarchy) {
                    self._data.time = time;

                    self._logs[self._logs.length] = self._data;
                } else {
                    self._accessData.time = time;
                    self._accessData = tmp;
                }
            }

            return res;
        };
    }
};

Jeeel.file.Jeeel.Debug.Profiler = ['Profile', 'ProfileManager'];

Jeeel._autoImports(Jeeel.directory.Jeeel.Debug.Profiler, Jeeel.file.Jeeel.Debug.Profiler);

/**
 * コンストラクタ
 * 
 * @class プロファイル結果を保持するクラス
 * @param {String} methodName メソッド名
 * @param {Object} instance インスタンス
 * @param {Number} [time] メソッドの実行に掛かった時間
 */
Jeeel.Debug.Profiler.Profile = function (methodName, instance, time) {
    var self = this;
    
    self.instance = instance || null;
    self.method = methodName;
    self.time = time || 0;
    self.calls = [];
};

Jeeel.Debug.Profiler.Profile.prototype = {
    
    /**
     * メソッドを保有するインスタンス
     * 
     * @type Object
     */
    instance: null,
    
    /**
     * メソッド名
     * 
     * @type String
     */
    method: '',
    
    /**
     * このメソッドに処理に掛かった時間(ミリ秒)
     * 
     * @type Number
     */
    time: 0,
    
    /**
     * メソッド内で呼び出しを行ったメソッドのリスト
     * 
     * @type Jeeel.Debug.Profiler.Profile[]
     */
    calls: [],
    
    /**
     * このメソッド内で一番時間が掛かっているものを取得する
     * 
     * @param {Boolean} [deepGet] 再帰的に内部メソッドのボトルネックを取得するかどうか
     * @return {Jeeel.Debug.Profiler.Profile} 取得したプロファイル
     */
    getBottleneck: function (deepGet) {
        if ( ! this.calls.length) {
            return this;
        }
        
        var max = this.calls[0].time,
            l = this.calls.length,
            i = 1,
            j = 0;

        for (; i < l; i++) {
            if (max < this.calls[i].time) {
                max = this.calls[i].time;
                j = i;
            }
        }
        
        if (deepGet) {
            return this.calls[j].getBottleneck(deepGet);
        }
        
        return this.calls[j];
    },
    
    /**
     * このメソッド名を取得する
     * 
     * @return {String} メソッド名
     */
    toString: function () {
        return this.method;
    },
    
    /**
     * このメソッドに掛かった時間を取得する
     * 
     * @return {Integer} 掛かった時間
     */
    valueOf: function () {
        return this.time;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Debug.Profiler.Profile
};

/**
 * コンストラクタ
 * 
 * @class プロファイル管理クラス
 */
Jeeel.Debug.Profiler.ProfileManager = function () {
    this._profiles = [];
};

Jeeel.Debug.Profiler.ProfileManager.prototype = {
  
    /**
     * 管理プロファイルリスト
     * 
     * @type Jeeel.Debug.Profiler.Profile[]
     * @private
     */
    _profiles: [],
    
    /**
     * 管理プロファイルの数
     * 
     * @type Integer
     * @private
     */
    _length: 0,
    
    /**
     * プロファイルの追加を行う
     * 
     * @param {Jeeel.Debug.Profiler.Profile} profile 追加プロファイル
     * @return {Jeeel.Debug.Profiler.ProfileManager} 自インスタンス
     */
    addProfile: function (profile) {
        this._profiles[this._length] = profile;
        this._length++;
        
        return this;
    },
    
    /**
     * 管理プロファイル数を取得する
     * 
     * @return {Integer} 管理プロファイル数
     */
    getProfileLength: function () {
        return this._length;
    },
    
    /**
     * 管理プロファイルを全て取得する
     * 
     * @return {Jeeel.Debug.Profiler.Profile[]} 管理プロファイル
     */
    getProfiles: function () {
        return this._profiles;
    },

    /**
     * 管理プロファイルの中から一番時間がかかっているプロファイルを取得する
     * 
     * @return {Jeeel.Debug.Profiler.Profile} 最遅のメソッドプロファイル
     */
    getBottleneckProfile: function () {
        if ( ! this._length) {
            return null;
        }
        
        var max = this._profiles[0].time,
            l = this._length,
            i = 1,
            j = 0;

        for (; i < l; i++) {
            if (max < this._profiles[i].time) {
                max = this._profiles[i].time;
                j = i;
            }
        }
        
        return this._profiles[j];
    },
    
    searchProfile: function (pattern) {
        var manager = new this.constructor();
        
        for (var i = 0; i < this._length; i++) {
          
            if (this._profiles[i].method.match(pattern)) {
                manager.addProfile(this._profiles[i]);
            }
        }
        
        return manager;
    },
    
    /**
     * 管理プロファイルを並び変える
     * 
     * @param {Function} [compareFunction] 比較関数 Boolean callback(Jeeel.Debug.Profiler.Profile a, Jeeel.Debug.Profiler.Profile b)
     * @return {Jeeel.Debug.Profiler.ProfileManager} 自インスタンス
     */
    sort: function (compareFunction) {
        this._profiles.sort(compareFunction || function (a, b) {
            return b.time - a.time;
        });
        
        return this;
    },
    
    constructor: Jeeel.Debug.Profiler.ProfileManager
};

/**
 * コンストラクタ
 * 
 * @class ユニットテストを提供するクラス(通常継承して使用する)
 */
Jeeel.Debug.UnitTest = function () {
    
};

/**
 * 複数のユニットテストクラスを渡して実行を行う<br />
 * 結果はJeeel.Debug.ErrorMessageにて表示する<br />
 * ユニットテストクラスのコンストラクタにはそのクラスのコンストラクタを実装して名前を付けておくか、<br />
 * Jeeel.Debug.Debugger.setInformationにて情報を付与しておくと見やすくなる
 * 
 * @param {Jeeel.Debug.UnitTest|Function} var_args ユニットテスト継承のクラスもしくはインスタンスを順に渡す
 * @return {Boolean} 全てのテストが正常終了したかどうか
 * @throws {Error} 引数にユニットテストクラスかインスタンス以外を渡した場合に発生
 */
Jeeel.Debug.UnitTest.test = function (var_args) {
    
    var condition = true;
    
    for (var i = 0, l = arguments.length; i < l; i++) {
        var testCase = arguments[i];
        
        if (Jeeel.Type.isFunction(testCase)) {
            testCase = new testCase();
        }
        
        if ( ! (testCase instanceof Jeeel.Debug.UnitTest)) {
            throw new Error((i + 1) + 'つ目の引数がユニットテストクラスではありません。');
        }
        
        if (i) {
            Jeeel.Debug.ErrorMessage.dump('\n\n\n\n');
        }
        
        testCase.run();
        
        var asserts = testCase.getAsserts(),
            successes = testCase.getSuccesses(),
            errors = testCase.getErrors(),
            assertLength = asserts.length,
            successLength = successes.length,
            errorLength = errors.length,
            testCount = testCase.getTestCount(),
            assertCount = testCase.getAssertCount(),
            j;
            
        for (j = 0; j < assertLength; j++) {
            var assert = asserts[j];
            
            Jeeel.Debug.ErrorMessage.dump(assert.condition ? '.' : 'F');
        }
        
        Jeeel.Debug.ErrorMessage.dump('\n\nTime: ' + testCase.getTestTime() + ' milli seconds\n');
        
        if (errorLength) {
            condition = false;
            
            Jeeel.Debug.ErrorMessage.dump('\nThere were ' + errorLength + ' errors:\n\n');
            
            for (j = 0; j < errorLength; j++) {
                var error = errors[j];
                
                Jeeel.Debug.ErrorMessage.dump((j + 1) + ') ' + error.fullMethod + '\n');
                Jeeel.Debug.ErrorMessage.dump('error: ' + error.assert + '\n\n');
                
                if (error.message) {
                    Jeeel.Debug.ErrorMessage.dump(error.message + '\n\n');
                }
            }
            
            Jeeel.Debug.ErrorMessage.dump('\nFAILURES!\n');
            Jeeel.Debug.ErrorMessage.dump('Tests: ' + testCount +', Assertions: ' + assertCount + ',  Errors: ' + errorLength + '.');
        } else {
            Jeeel.Debug.ErrorMessage.dump('OK (' + testCount + ' tests, ' + assertCount + ' assertions)');
        }
    }
    
    return condition;
};

Jeeel.Debug.UnitTest.prototype = {
  
    /**
     * テストケースで失敗したアサート情報リスト
     * 
     * @type Hash[]
     * @private
     */
    _errors: [],
    
    /**
     * テストケースで成功したアサート情報リスト
     * 
     * @type Hash[]
     * @private
     */
    _successes: [],
    
    /**
     * テストケースのアサート情報リスト
     * 
     * @type Hash[]
     * @private
     */
    _asserts: [],
    
    /**
     * 実行テストメソッドのステータス
     * 
     * @type Hash
     * @private
     */
    _runState: {},
    
    /**
     * テストを実行する
     * 
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    run: function () {},
    
    /**
     * テストケース開始時に実行されるメソッド
     */
    setUpBeforeClass: function () {
        
    },
    
    /**
     * テストメソッド前に実行されるメソッド
     */
    setUp: function () {
        
    },
    
    /**
     * テストメソッド後に実行されるメソッド
     */
    tearDown: function () {
        
    },
    
    /**
     * テストケース終了後に実行されるメソッド
     */
    tearDownAfterClass: function () {
        
    },
    
    /**
     * trueかどうか確認する
     * 
     * @param {Boolean} condition 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertTrue: function (condition, message) {
        return this._setAssertResult(condition === true, 'assertTrue', message);
    },
    
    /**
     * falseかどうか確認する
     * 
     * @param {Boolean} condition 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertFalse: function (condition, message) {
        return this._setAssertResult(condition === false, 'assertFalse', message);
    },
    
    /**
     * nullかどうか確認する
     * 
     * @param {Mixied} value 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNull: function (value, message) {
        return this._setAssertResult(value === null, 'assertNull', message);
    },
    
    /**
     * nullじゃないかどうか確認する
     * 
     * @param {Mixied} value 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotNull: function (value, message) {
        return this._setAssertResult(value !== null, 'assertNotNull', message);
    },
    
    /**
     * undefined・nullかどうか確認する
     * 
     * @param {Mixied} value 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertEmpty: function (value, message) {
        return this._setAssertResult(Jeeel.Type.isEmpty(value), 'assertEmpty', message);
    },
    
    /**
     * undefined・nullじゃないかどうか確認する
     * 
     * @param {Mixied} value 確認する値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotEmpty: function (value, message) {
        return this._setAssertResult( ! Jeeel.Type.isEmpty(value), 'assertNotEmpty', message);
    },
    
    /**
     * 値が一致するかどうか確認する
     * 
     * @param {Mixied} expected 確認する値1
     * @param {Mixied} actual 確認する値2
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertEquals: function (expected, actual, message) {
        return this._setAssertResult(expected == actual, 'assertEquals', message);
    },
    
    /**
     * 値が一致しないかどうか確認する
     * 
     * @param {Mixied} expected 確認する値1
     * @param {Mixied} actual 確認する値2
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotEquals: function (expected, actual, message) {
        return this._setAssertResult(expected != actual, 'assertNotEquals', message);
    },
    
    /**
     * 値と型が一致するかどうか確認する
     * 
     * @param {Mixied} expected 確認する値1
     * @param {Mixied} actual 確認する値2
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertIdentical: function (expected, actual, message) {
        return this._setAssertResult(expected === actual, 'assertIdentical', message);
    },
    
    /**
     * 値と型が一致しないかどうか確認する
     * 
     * @param {Mixied} expected 確認する値1
     * @param {Mixied} actual 確認する値2
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotIdentical: function (expected, actual, message) {
        return this._setAssertResult(expected !== actual, 'assertNotIdentical', message);
    },
    
    /**
     * キーを保持するかどうか確認する
     * 
     * @param {String} key キー
     * @param {Hash} hash オブジェクト
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertHasKey: function (key, hash, message) {
        return this._setAssertResult(Jeeel.Hash.keyExists(key, hash), 'assertHasKey', message);
    },
    
    /**
     * キーを保持しないかどうか確認する
     * 
     * @param {String} key キー
     * @param {Hash} hash オブジェクト
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNotHasKey: function (key, hash, message) {
        return this._setAssertResult( ! Jeeel.Hash.keyExists(key, hash), 'assertNotHasKey', message);
    },
    
    /**
     * instanceがtypeクラスかどうかを確認する
     * 
     * @param {Mixied} instance インスタンス
     * @param {Function} type クラスタイプ
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertIsA: function (instance, type, message) {
        return this._setAssertResult(Jeeel.Type.isFunction(type) && instance instanceof type, 'assertIsA', message);
    },
    
    /**
     * instanceがtypeクラスじゃないかどうかを確認する
     * 
     * @param {Mixied} instance インスタンス
     * @param {Function} type クラスタイプ
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertIsNotA: function (instance, type, message) {
        return this._setAssertResult(Jeeel.Type.isFunction(type) && ! (instance instanceof type), 'assertIsNotA', message);
    },
    
    /**
     * subjectがpatternに一致したかどうかを確認する
     * 
     * @param {RegExp} pattern 検索パターン
     * @param {String} subject 対象文字列
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertPattern: function (pattern, subject, message) {
        return this._setAssertResult(Jeeel.Type.isRegularExpression(pattern) && pattern.test(subject), 'assertPattern', message);
    },
    
    /**
     * subjectがpatternに一致しなかったかどうかを確認する
     * 
     * @param {RegExp} pattern 検索パターン
     * @param {String} subject 対象文字列
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertNoPattern: function (pattern, subject, message) {
        return this._setAssertResult(Jeeel.Type.isRegularExpression(pattern) && ! pattern.test(subject), 'assertNoPattern', message);
    },
    
    /**
     * expect &lt; valueかどうか確認する
     * 
     * @param {Number} expect 比較値
     * @param {Number} value 対象値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertGreaterThan: function (expect, value, message) {
        return this._setAssertResult(expect < value, 'assertGreaterThan', message);
    },
    
    /**
     * expect &lt;= valueかどうか確認する
     * 
     * @param {Number} expect 比較値
     * @param {Number} value 対象値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertGreaterThanOrEqual: function (expect, value, message) {
        return this._setAssertResult(expect <= value, 'assertGreaterThanOrEqual', message);
    },
    
    /**
     * expect &gt; valueかどうか確認する
     * 
     * @param {Number} expect 比較値
     * @param {Number} value 対象値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertLessThan: function (expect, value, message) {
        return this._setAssertResult(expect > value, 'assertLessThan', message);
    },
    
    /**
     * expect &gt;= valueかどうか確認する
     * 
     * @param {Number} expect 比較値
     * @param {Number} value 対象値
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertLessThanOrEqual: function (expect, value, message) {
        return this._setAssertResult(expect >= value, 'assertLessThanOrEqual', message);
    },
    
    /**
     * abs(expect - value) &lt; marginかどうかを確認する
     * 
     * @param {Number} expect 基準値
     * @param {Number} value 比較値
     * @param {Number} margin 幅
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertWithinMargin: function (expect, value, margin, message) {
        return this._setAssertResult(Math.abs(expect - value) < margin, 'assertWithinMargin', message);
    },
    
    /**
     * abs(expect - value) &gt;= marginかどうかを確認する
     * 
     * @param {Number} expect 基準値
     * @param {Number} value 比較値
     * @param {Number} margin 幅
     * @param {String} [message] エラー時に表示するカスタムメッセージ
     * @return {Jeeel.Debug.UnitTest} 自インスタンス
     */
    assertOutsideMargin : function (expect, value, margin, message) {
        return this._setAssertResult(Math.abs(expect - value) >= margin, 'assertOutsideMargin', message);
    },

    /**
     * このテストケースで実行したアサートのリストを返す
     * 
     * @return {Hash[]} アサート連想配列のリスト(condition, method, fullMethod, assert, message)
     */
    getAsserts: function () {
        return this._asserts;
    },
    
    /**
     * このテストケースで成功したアサートのリストを返す
     * 
     * @return {Hash[]} 成功連想配列のリスト(method, fullMethod, assert, message)
     */
    getSuccesses: function () {
        return this._successes;
    },
    
    /**
     * このテストケースでエラーになったアサートのリストを返す
     * 
     * @return {Hash[]} エラー連想配列のリスト(method, fullMethod, assert, message)
     */
    getErrors: function () {
        return this._errors;
    },
    
    /**
     * テストメソッドの実行回数を返す
     * 
     * @return {Integer} 実行回数
     */
    getTestCount: function () {
        return this._runState.testCount || 0;
    },
    
    /**
     * アサートメソッドの実行回数を返す
     * 
     * @return {Integer} 実行回数
     */
    getAssertCount: function () {
        return this._runState.assertCount || 0;
    },
    
    /**
     * テスト実行時間を返す
     * 
     * @return {Integer} 実行時間(ミリ秒)
     */
    getTestTime: function () {
        return this._runState.time || 0;
    },
    
    /**
     * コンストラクタ
     * 
     * @constructor
     */
    constructor: Jeeel.Debug.UnitTest,
    
    /**
     * アサートの結果をセットする
     * 
     * @param {Boolean} condition 成功したかどうか
     * @param {String} assert アサート名
     * @param {String} [message] カスタムメッセージ
     * @private
     */
    _setAssertResult: function (condition, assert, message) {
        this._runState.assertCount++;
        
        this._asserts[this._asserts.length] = {
            condition: !!condition,
            method: this._runState.method.name,
            fullMethod: this._runState.method.fullName,
            assert: assert,
            message: message || ''
        };
        
        if (condition) {
            this._setSuccess(assert, message);
        } else {
            this._setError(assert, message);
        }
        
        return this;
    },
    
    /**
     * 成功をセットする
     * 
     * @param {String} assert アサート名
     * @param {String} [message] カスタムメッセージ
     * @private
     */
    _setSuccess: function (assert, message) {
        this._successes[this._successes.length] = {
            method: this._runState.method.name,
            fullMethod: this._runState.method.fullName,
            assert: assert,
            message: message || ''
        };
    },
    
    /**
     * エラーをセットする
     * 
     * @param {String} assert アサート名
     * @param {String} [message] カスタムメッセージ
     * @private
     */
    _setError: function (assert, message) {
        this._errors[this._errors.length] = {
            method: this._runState.method.name,
            fullMethod: this._runState.method.fullName,
            assert: assert,
            message: message || ''
        };
    },
    
    _init: function () {
        var testMethodPattern = /^test.+$/;
        
        this.run = function () {
            var constructor = this.constructor,
                debugInfo = constructor[Jeeel.Debug.Debugger.INFORMATION_NAME];
            
            this._runState = {
                className: debugInfo && debugInfo.name || constructor.name,
                testCount: 0,
                assertCount: 0
            };
            
            this._asserts = [];
            this._successes = [];
            this._errors = [];
            
            this.setUpBeforeClass();
            
            var date = new Date();

            for (var key in this) {
                if (key.match(testMethodPattern) && Jeeel.Type.isFunction(this[key])) {
                    
                    this._runState.method = {
                        name: key,
                        fullName: this._runState.className ? this._runState.className + '#' + key : key
                    };
                    
                    this._runState.testCount++;
                    
                    this.setUp();
                    this[key]();
                    this.tearDown();
                }
            }
            
            this._runState.time = new Date() - date;
            
            this.tearDownAfterClass();
            
            return this;
        };
        
        delete this._init;
    }
};

Jeeel.Debug.UnitTest.prototype._init();

Jeeel.directory.Jeeel.Debug.Debugger = {

    /**
     * 自身を文字列参照された場合の変換
     *
     * @return {String} 自身のディレクトリ
     * @private
     */
    toString: function () {
        return Jeeel.directory.Jeeel.Debug + 'Debugger/';
    }
};

/**
 * @staticClass 専門的なデバッグを行うためのモジュール等を保持するスタティッククラス
 */
Jeeel.Debug.Debugger = {

    /**
     * 内部参照関数を作るための文字列定数<br />
     * 内部参照をしたい場所でevalで展開する
     *
     * @type String
     * @constant
     */
    INSPECTOR: '(function (){return function (___$){try{return eval(___$);}catch(e){return e.message;}}})();',

    /**
     * 解析情報を設定する時の名前
     *
     * @type String
     * @constant
     */
    INFORMATION_NAME: '_jeeelInfo',

    /**
     * 内部の変数などを動的に参照するブレークポイントを設定する<br />
     * このメソッドを呼んだ際のプロンプトに変数名を入れると変数の値がdumpされる<br />
     * なおこのメソッドにignoreをつけると全ての呼び出し時の動作が無効になる
     *
     * @param {Function} inspector このオブジェクトのメンバのINSPECTORを関数内部でevalした関数
     * @param {Mixied} [self] 参照変数の際のthisを示す値
     * @param {String} [title] この関数を区別するために表記するタイトル
     * @throws {Error} inspectorがメソッドではない場合に発生
     */
    inspect: function (inspector, self, title) {

        if ( ! Jeeel.Type.isFunction(inspector)) {
            throw new Error('inspectorがメソッドではありません。');
        }

        var expression, result;

        if ('ignore' in arguments.callee) {
            return;
        }

        while(true) {

            var message = "";

            if (title) {
                message += title + '\n';
            }

            if (expression) {
                expression += ' = ' + result + ';';
            } else {
                expression = '';
            }

            message += '変数名を入力:';

            expression = Jeeel.Debug.Debugger.showPrompt(message, expression);

            if ( ! expression) {
                return;
            }

            result = inspector.call(self, expression);
        }
    },
    
    /**
     * @ignore
     */
    getLocalVariableList: function (inspector, thisArg) {
        var variableNames = this.getLocalVariableNames(arguments.callee.caller);
        var name, list = {};
        
        for (var i = 0, l = variableNames.length; i < l; i++) {
            name = variableNames[i];
            
            list[name] = inspector.call(thisArg, name);
        }
        
        return list;
    },
    
    /**
     * @ignore
     */
    getLocalVariableNames: function (func) {
        var source = func.toString();
        
        // 文字列、コメント、正規表現の削除
        source = source.replace(/(^|[^\\])'[^']*'/g, '$1')
                       .replace(/(^|[^\\])"[^"]*"/g, '$1');
                       
        var args = source.match(/function ?([a-zA-Z_$][a-zA-Z0-9_$]*)?\(([^)]*)\)/)[2].split(',');
        var reg = /var\s+(\w+)/g;
        var match = null;
        var variables = [];
        
        while(match = reg.exec(source)) {
            variables[variables.length] = match[1];
        }
        
        return variables;
    },

    /**
     * HTML要素をbodyの最初に差し込む
     *
     * @param {Element} element 差し込む要素
     * @return {Element} 差し込んだ要素
     */
    elementInsertTop: function (element) {
        var body  = Jeeel.Document.getBody();
        var first = body.firstChild;

        if (first) {
            body.insertBefore(element, first);
        } else {
            body.appendChild(element);
        }
        
        return element;
    },

    /**
     * JavaScriptソースの表示を行う
     *
     * @param {String} url JavaScriptソースの相対URL
     * @return {Boolean} 常にtrue
     */
    showSource: function (url) {
        Jeeel.Window.createDialogOpener(Jeeel.HOST + Jeeel.BASE_URL + url)
                  .setOption('dialogWidth', 600)
                  .setOption('dialogHeight', 300)
                  .open();

        return true;
    },

    /**
     * プロンプトの表示を行う
     *
     * @param {String} title プロンプトのタイトル
     * @param {String} message プロンプトの初期メッセージ
     */
    showPrompt: function (title, message) {
        var callback = function (args, selfWindow) {
            var html = '<div><p style="float:left;width: 440px;margin: 0; padding: 0;">ダイアログプロンプト</p><div style="">'
                     + '<button onclick="closeDialog(document.getElementById(\'result\').value);">OK</button>'
                     + '</div></div><br/><div><p style="float:left;width: 440px;margin: 0; padding: 0;">' + args.title
                     + '</p><div style="">'
                     + '<button onclick="closeDialog(false);">CANCEL</button></div></div>'
                     + '<br /><textarea id="result" style="width:560px;height:200px;">'
                     + args.message + '</textarea>';
            
            selfWindow.document.body.innerHTML = html;
        };
        
        return Jeeel.Window.createDialogOpener('')
                         .setArgument('title', title)
                         .setArgument('message', message)
                         .setOption('dialogWidth', 600)
                         .setOption('dialogHeight', 300)
                         .openTemplate(callback);
    },

    /**
     * サーバ側のスクリプトを走らせる
     *
     * @param {String} script サーバー側で走らせるスクリプト文字列
     * @param {Hash} [params] サーバー側に渡すパラメータ
     * @param {Function} [callback] クロスドメイン時のコールバック
     * @return {Mixied} サーバー側からの戻り値をデコードしたもの
     */
    evalServer: function (script, params, callback) {

        if ( ! params) {
            params = {};
        }

        if ( ! Jeeel.Type.isHash(params)) {
            throw new Error('paramsはHashでなければなりません。');
        }

        params = {params: params};

        if (script) {
            params.script = script;
        }
        
        if (Jeeel.CROSS_DOMAIN) {
            return this._jsonpDebug('evalServer', callback, params);
        }

        var res = Jeeel.Net.Ajax.serverResponse(Jeeel.HOST + Jeeel.DEBUG_URL, params);

        if (Jeeel.Type.isString(res)) {

            try {
                res = Jeeel.Json.decode(res);
            } catch(e) {
                res = Jeeel.String.stripTags(res);
            }

            return res;
        }

        Jeeel.Debug.ErrorMessage.dumpStripTags(res.response);

        return false;
    },

    /**
     * サーバー側でSQLを実行する
     *
     * @param {String} sql サーバー側実行するSQL文字列
     * @param {Function} [callback] クロスドメイン時のコールバック
     * @return {Mixied} サーバー側からの戻り値をデコードしたもの
     */
    evalSql: function (sql, callback) {

        if (sql) {
            sql = {sql: sql};
        }
        
        if (Jeeel.CROSS_DOMAIN) {
            return this._jsonpDebug('evalServer', callback, sql);
        }

        var res = Jeeel.Net.Ajax.serverResponse(Jeeel.HOST + Jeeel.SQL_DEBUG_URL, sql);

        if (Jeeel.Type.isString(res)) {
          
            try {
                res = Jeeel.Json.decode(res);
            } catch(e) {
                res = Jeeel.String.stripTags(res);
            }

            return res;
        }

        Jeeel.Debug.ErrorMessage.dumpStripTags(res.response);

        return false;
    },

    /**
     * メールを送信する
     * 
     * @param {String} to メール送信先
     * @param {Mixied} body メール本文
     * @param {Boolean} [isHtml] HTMLメールとして送信を行うかどうかを示す(デフォルトはfalse)
     * @param {Function} [callback] クロスドメイン時のコールバック
     * @return {Boolean} メール送信が成功ならばtrueそれ以外はfalseを返す
     */
    sendMail: function (to, body, isHtml, callback) {
      
        var validator = Jeeel.Validator.Helper.create(to)
                                            .email();

        if ( ! validator.isValid()) {
            return false;
        }

        var params = {to: to, body: body};

        if (isHtml) {
            params.type = 'html';
        } else {
            params.type = 'text';
        }
        
        if (Jeeel.CROSS_DOMAIN) {
            return this._jsonpDebug('evalServer', callback, params);
        }

        var res = Jeeel.Net.Ajax.serverResponse(Jeeel.HOST + Jeeel.MAIL_URL, params);

        if (Jeeel.Type.isString(res)) {

            try {
                res = Jeeel.Json.decode(res);
            } catch(e) {
                res = Jeeel.String.stripTags(res);
            }

            return res;
        }

        Jeeel.Debug.ErrorMessage.dumpStripTags(res.response);

        return false;
    },

    /**
     * 識別子をファイルとしてブラウザに読み込ませる
     *
     * @param {Mixied} value 読み込ませる値
     * @param {String} [fileName] 指定した名前で認識させたい時に指定する
     * @return {Boolean} 正常終了ならばtrueそれ以外はfalseを返す
     */
    fileOpen: function (value, fileName) {

        try {
            var form = Jeeel.Net.Form.newForm();
            
            form.setMethod('POST')
                .setAction(Jeeel.HOST + Jeeel.FILE_OPEN_URL)
                .set('value', value);

            if (Jeeel.Type.isString(fileName)) {
                form.set('file', fileName);
            }

            form.submit();
        } catch (e) {
            return false;
        }

        return true;
    },
    
    /**
     * 呼び出し元のメソッドのトレースを取得する
     *
     * @param {Integer} [nestCount]
     * @return {Jeeel.Object.Technical.Trace[]} トレース内容のリスト
     */
    getTrace: function (nestCount) {
        var res = [];
        var func = arguments.callee;
        
        if ( ! (nestCount >= 0)) {
            nestCount = 0;
        }
        
        while(func.caller && nestCount--) {
            func = func.caller;
        }

        while(func.caller) {

            func = func.caller;

            res[res.length] = new Jeeel.Object.Technical.Trace(func);
        }

        return res;
    },

    /**
     * 指定したオブジェクトに解析情報を設定する
     *
     * @param {Mixied} object 解析情報を設定するオブジェクト
     * @param {String} name オブジェクトに付ける名前
     * @param {Boolean} [deepSet] 再帰的に情報を設定するかどうか
     * @return {Boolean} 解析情報の設定が正しく行われたかどうか
     */
    setInformation: function (object, name, deepSet) {

        if (Jeeel.Type.isPrimitive(object)) {
            return false;
        } else if (object instanceof Jeeel.Object.Technical.Information) {
            return false;
        } else if (Jeeel.Type.isElement(object) || Jeeel.Type.isDocument(object) || Jeeel.Type.isWindow(object)) {
            return false;
        } else if (object instanceof Jeeel.Session.Core) {
            return false;
        } else if (object === Jeeel.Class.Abstract) {
            object[this.INFORMATION_NAME] = new Jeeel.Object.Technical.Information('Jeeel.Class.Abstract', Jeeel.Class);
            
            return false;
        } else if (this.INFORMATION_NAME in object) {
            return false;
        }
        
        var isPrototype = arguments[4];

        if (Jeeel.Type.isFunction(object) && object.prototype) {
            object.prototype.constructor = object;
        }
        
        if (isPrototype) {
            object[this.INFORMATION_NAME] = new Jeeel.Object.Technical.Information(name + '.prototype', arguments[3]);
        } else {
            object[this.INFORMATION_NAME] = new Jeeel.Object.Technical.Information(name, arguments[3]);
        }

        if (deepSet) {
            var keys = Jeeel.Hash.getKeys(object);
            
            if (Jeeel.Type.isFunction(object) && object.prototype) {
                keys.push('prototype');
            }
            
            for (var i = 0, l = keys.length; i < l; i++) {
                
                var property = keys[i];
                
                if (property === 'constructor') {
                    continue;
                } else if ( ! object.hasOwnProperty(property)) {
                    continue;
                }
                
                try {
                    var childName = isPrototype ? name + '#' + property : name + '.' + property;
                    
                    if (property === 'prototype') {
                        childName = name;
                    } else if (property === '_inherited') {
                        childName = name;
                    }

                    this.setInformation(object[property], childName, deepSet, object, property === 'prototype');
                } catch (e) {}
            }
        }

        return true;
    },
    
    /**
     * Element固有のIDを定義する(IEのuniqueIDを他ブラウザで再現)
     * 
     * @return {Boolean} 定義が行われたかどうか
     */
    defineUniqueId: function () {
        
        if (Jeeel._doc.uniqueID) {
            return false;
        } else if (typeof HTMLElement !== 'function') {
            return false;
        } else if ( ! Object.prototype.__defineGetter__ || ! Object.defineProperty) {
            return false;
        }
        
        var nextUniqueID = 1;
        
        if (Object.prototype.__defineGetter__) {
            HTMLElement.prototype.__defineGetter__('uniqueID', function () {
                var uniqueID = 'id' + nextUniqueID++;

                this.__defineGetter__("uniqueID", function (){return uniqueID});

                return uniqueID;
            });
        } else {
            Object.defineProperty(HTMLElement.prototype, 'uniqueID', {
                get: function () {
                    var uniqueID = 'id' + nextUniqueID++;

                    Object.defineProperty(this, "uniqueID", {get: function (){return uniqueID}});

                    return uniqueID;
                }
            });
        }
        
        return true;
    },
    
    /**
     * このクラスのevalServer, evalSql, sendMailをJsonp通信で実行する
     * 
     * @param {String} callMethodName 実行するメソッド名
     * @param {Function} [callback] Jsonp通信の結果のコールバック
     * @param {Hash} [params] サーバー側に引き渡す値
     * @return {Boolean} 正常終了ならばtrueそれ以外はfalseを返す
     * @private
     */
    _jsonpDebug: function (callMethodName, callback, params) {
        
        callback = callback || Jeeel.Debug.Console.log;
        params = params || {};
        
        var url;
        
        switch(callMethodName) {
            case 'evalServer':
                url = Jeeel.DEBUG_URL;
                break;
                
            case 'evalSql':
                url = Jeeel.SQL_DEBUG_URL;
                break;
                
            case 'sendMail':
                url = Jeeel.MAIL_URL;
                break;
                
            default:
                return false;
                break;
        }
        
        url = url.match(/\/([a-z\-]+)\/?$/)[1];
        
        var jsonp = new Jeeel.Net.Jsonp(Jeeel.HOST + Jeeel.JSONP_URL);
        
        jsonp.setAll(params || {})
             .set('exec-action', url)
             .setCallback('callback', callback)
             .execute();

        return true;
    }
};

Jeeel.file.Jeeel.Debug.Debugger = [];

Jeeel._autoImports(Jeeel.directory.Jeeel.Debug.Debugger, Jeeel.file.Jeeel.Debug.Debugger);

(function () {
  
    if (typeof window === 'undefined') {
        return;
    }

    // 現在のJeeelを保存
    var Jeeel = window.Jeeel;

    var listener =  function () {
        var state = document.readyState.toLowerCase();
        
        if (state.match(/loaded|complete/) && Jeeel.Object && Jeeel.Object.Technical && Jeeel.Object.Technical.Information) {
          
            // 現在のJeeelと保存したJeeelが同一の場合のみ実行
            if (Jeeel === window.Jeeel) {
                Jeeel.Debug.Debugger.setInformation(Jeeel, 'Jeeel', true, window);
            }
        } else {
            setTimeout(arguments.callee, 1);
        }
    };

    setTimeout(listener, 1);

})();

(function (createPacker) {

    /**
     * @staticClass ファイルを圧縮するスタティッククラス
     * @ignore 未完成
     */
    Jeeel.Debug.Compressor = {
        
        _packer: null,
        
        /**
         * スクリプトを圧縮する
         * 
         * @param {String} script JavaScript文字列
         * @param {Boolean} [base64] Base64圧縮を行うかどうか
         * @param {Boolean} [shrink] 関数の引数を変更するかどうか
         * @return {String} 圧縮後のスクリプト
         */
        compress: function (script, base64, shrink) {
            return this._getPacker().pack(script, !!base64, !!shrink);
        },
        
        _getPacker: function() {
            if (this._packer) {
                return this._packer;
            }
            
            return this._packer = createPacker();
        }
    };

})(function() {
    
    /**
     * @ignore
     */
    var base2 = {
        name: "base2",
        version: "1.0.1(pre)",
        exports: "Base, Package, Abstract, Module, Enumerable, Map, Collection, RegGrp, " + "assert, assertArity, assertType, " + "assignID, copy, counter, detect, extend, forEach, format, instanceOf, match, rescape, slice, trim, " + "I, K, Undefined, Null, True, False, bind, delegate, flip, not, partial, unbind",
        global: this,
        namespace: "var global=base2.global;function base(o,a){return o.base.apply(o,a)};",
        detect: new function(_) {
            var global = _;
            var jscript /*@cc_on=@_jscript_version@*/;

            if (_.navigator) {
                var element = Jeeel._doc.createElement("span");
                var userAgent = navigator.platform + " " + navigator.userAgent;
                
                if (!jscript) {
                    userAgent = userAgent.replace(/MSIE\s[\d.]+/, "");
                }
                
                userAgent = userAgent.replace(/([a-z])[\s\/](\d)/gi, "$1$2");
            }

            return function(a) {
                var r = false;
                var b = a.charAt(0) == "!";
                
                if (b) {
                    a = a.slice(1);
                }
                
                if (a.charAt(0) == "(") {
                    try {
                        eval("r=!!" + a);
                    } catch (error) {
                    }
                } else {
                    r = new RegExp("(" + a + ")", "i").test(userAgent);
                }
                
                return !!(b ^ r);
            };
        }(this)
    };

    new function(_) {
        var detect = base2.detect;
        var slice = Array.slice || (function(b) {
            return function(a) {
                return b.apply(a, b.call(arguments, 1));
            };
        })(Array.prototype.slice);

        var Undefined = K(), Null = K(null), True = K(true), False = K(false);
        var _0 = /%([1-9])/g;
        var _1 = /^\s\s*/;
        var _2 = /\s\s*$/;
        var _3 = /([\/()[\]{}|*+-.,^$?\\])/g;
        var _4 = /eval/.test(detect) ? /\bbase\s*\(/ : /.*/;
        var _5 = ["constructor", "toString", "valueOf"];
        var _6 = String(new RegExp);
        var _7 = 1;

        _8();

        eval(base2.namespace);

        var _9 = function(a, b) {
            base2.__prototyping = true;
            var c = new this;
            extend(c, a);
            delete base2.__prototyping;
            var d = c.constructor;

            var _10 = function () {
                if (!base2.__prototyping) {
                    if (this.constructor == arguments.callee || this.__constructing) {
                        this.__constructing = true;
                        d.apply(this, arguments);
                        delete this.__constructing;
                    } else {
                        return extend(arguments[0], c);
                    }
                }

                return this;
            };

            c.constructor = _10;

            for (var i in Base) {
                _10[i] = this[i];
            }

            _10.toString = K(String(d));
            _10.ancestor = this;
            _10.base = Undefined;
            _10.init = Undefined;
            extend(_10, b);
            _10.prototype = c;
            _10.init();

            return _10;
        };

        var Base = _9.call(
            Object, {
                constructor: function() {
                    if (arguments.length > 0) {
                        this.extend(arguments[0]);
                    }
                },

                base: function() {
                },

                extend: delegate(extend)

            }, Base = {
                ancestorOf: delegate(_11),
                extend: _9,
                forEach: delegate(_8),
                
                /**
                 * @ignore
                 */
                implement: function(a) {
                    if (typeof a == "function") {
                        if (_11(Base, a)) {
                            a(this.prototype);
                        }
                    } else {
                        extend(this.prototype, a);
                    }
                    
                    return this;
                }
            }
        );

        var Package = Base.extend({
            constructor: function(d, e) {
                this.extend(e);
                
                if (this.init) {
                    this.init();
                }
                
                if (this.name != "base2") {
                    if (!this.parent) {
                        this.parent = base2;
                    }
                    
                    this.parent.addName(this.name, this);
                    this.namespace = format("var %1=%2;", this.name, String(this).slice(1, -1))
                }
                
                var f = /[^\s,]+/g;
                
                if (d) {
                    d.imports = Array2.reduce(this.imports.match(f), function(a, b) {
                        eval("var ns=base2." + b);
                        assert(ns, format("Package not found: '%1'.", b));
                        return a += ns.namespace;
                    }, base2.namespace + JavaScript.namespace);
                    
                    d.exports = Array2.reduce(this.exports.match(f), function(a, b) {
                        var c = this.name + "." + b;
                        this.namespace += "var " + b + "=" + c + ";";
                        return a += "if(!" + c + ")" + c + "=" + b + ";";
                    }, "", this);
                }
            },
            
            exports: "",
            
            imports: "",
            
            name: "",
            
            namespace: "",
            
            parent: null,
            
            addName: function(a, b) {
                if (!this[a]) {
                    this[a] = b;
                    this.exports += ", " + a;
                    this.namespace += format("var %1=%2.%1;", a, this.name);
                }
            },
            
            addPackage: function(a) {
                this.addName(a, new Package(null, {name: a,parent: this}));
            },
            
            toString: function() {
                return format("[%1]", this.parent ? String(this.parent).slice(1, -1) + "." + this.name : this.name);
            }}
        );

        var Abstract = Base.extend({
            constructor: function() {
                throw new TypeError("Class cannot be instantiated.");
            }}
        );
        
        var Module = Abstract.extend(null, {
            extend: function(a, b) {
                var c = this.base();
                _12(c, this);
                
                c.implement(a);
                extend(c, b);
                c.init();
                
                return c;
            },
            
            implement: function(c) {
                var d = this;
                
                if (typeof c == "function") {
                    d.base(c);
                    if (_11(Module, c)) {
                        _12(d, c);
                    }
                } else {
                    var e = {};
                    
                    _8(Object, c, function(a, b) {
                        if (b.charAt(0) == "@") {
                            if (detect(b.slice(1))) {
                                forEach(a, arguments.callee);
                            }
                        } else if (!Module[b] && typeof a == "function" && a.call) {
                            function _13() {
                                return d[b].apply(d, [this].concat(slice(arguments)));
                            }
                            
                            _13.__base = _4.test(a);
                            e[b] = _13;
                        }
                    });
                    
                    extend(d.prototype, e);
                    extend(d, c);
                }
                
                return d;
            }}
        );
        
        
        function _12(a, b) {
            for (var c in b) {
                var method = b[c];
                
                if (!Module[c] && typeof method == "function" && method.call) {
                    a[c] = method;
                }
            }
        }

        var Enumerable = Module.extend({
            every: function(c, d, e) {
                var f = true;
                
                try {
                    this.forEach(c, function(a, b) {
                        f = d.call(e, a, b, c);
                        
                        if (!f) {
                            throw StopIteration;
                        }
                    });
                } catch (error) {
                    if (error != StopIteration) {
                        throw error;
                    }
                }
                
                return !!f;
            },
            
            filter: function(d, e, f) {
                var i = 0;
                
                return this.reduce(d, function(a, b, c) {
                    if (e.call(f, b, c, d)) {
                        a[i++] = b;
                    }
                    
                    return a;
                }, []);
            },
            
            invoke: function(b, c) {
                var d = slice(arguments, 2);
                
                return this.map(b, (typeof c == "function") ? function(a) {
                    return (a == null) ? undefined : c.apply(a, d);
                } : function(a) {
                    return (a == null) ? undefined : a[c].apply(a, d);
                });
            },
            
            map: function(c, d, e) {
                var f = [], i = 0;
                
                this.forEach(c, function(a, b) {
                    f[i++] = d.call(e, a, b, c);
                });
                
                return f;
            },
            
            pluck: function(b, c) {
                return this.map(b, function(a) {
                    return (a == null) ? undefined : a[c];
                });
            },
            
            reduce: function(c, d, e, f) {
                var g = arguments.length > 2;
                
                this.forEach(c, function(a, b) {
                    if (g) {
                        e = d.call(f, e, a, b, c);
                    } else {
                        e = a;
                        g = true;
                    }
                });
                
                return e;
            },
            
            some: function(a, b, c) {
                return !this.every(a, not(b), c);
            }}, {forEach: forEach}
        );
        
        var _14 = "#";
        var Map = Base.extend({
            constructor: function(a) {
                this.merge(a);
            },
            
            copy: delegate(copy),
            
            forEach: function(a, b) {
                for (var c in this) {
                    if (c.charAt(0) == _14) {
                        a.call(b, this[c], c.slice(1), this);
                    }
                }
            },
            
            get: function(a) {
                return this[_14 + a];
            },
            
            getKeys: function() {
                return this.map(flip(I));
            },
            
            getValues: function() {
                return this.map(I);
            },
            
            has: function(a) { /*@cc_on@*/ /*@if(@_jscript_version<5.5)return $Legacy.has(this,_14+a);@else@*/
                return _14 + a in this; /*@end@*/
            },
            
            merge: function(b) {
                var c = flip(this.put);
                forEach(arguments, function(a) {
                    forEach(a, c, this);
                }, this);
                
                return this;
            },
            
            remove: function(a) {
                delete this[_14 + a];
            },
            
            put: function(a, b) {
                if (arguments.length == 1) {
                    b = a;
                }
                
                this[_14 + a] = b;
            },
            
            size: function() {
                var a = 0;
                
                for (var b in this) {
                    if (b.charAt(0) == _14) {
                        a++;
                    }
                }
                
                return a;
            },
            
            union: function(a) {
                return this.merge.apply(this.copy(), arguments);
            }}
        );
          
        
        Map.implement(Enumerable);
        var _15 = "~";
        var Collection = Map.extend({
            constructor: function(a) {
                this[_15] = new Array2;
                this.base(a)
            },
            
            add: function(a, b) {
                assert(!this.has(a), "Duplicate key '" + a + "'.");
                this.put.apply(this, arguments)
            },
            
            copy: function() {
                var a = this.base();
                a[_15] = this[_15].copy();
                return a
            },
            
            forEach: function(a, b) {
                var c = this[_15];
                var d = c.length;
                for (var i = 0; i < d; i++) {
                    a.call(b, this[_14 + c[i]], c[i], this)
                }
            },
            
            getAt: function(a) {
                if (a < 0)
                    a += this[_15].length;
                var b = this[_15][a];
                return (b === undefined) ? undefined : this[_14 + b]
            },
            
            getKeys: function() {
                return this[_15].concat()
            },
            
            indexOf: function(a) {
                return this[_15].indexOf(String(a))
            },
            
            insertAt: function(a, b, c) {
                assert(Math.abs(a) < this[_15].length, "Index out of bounds.");
                assert(!this.has(b), "Duplicate key '" + b + "'.");
                this[_15].insertAt(a, String(b));
                this.put.apply(this, slice(arguments, 1))
            },
            
            item: Undefined,
            
            put: function(a, b) {
                if (arguments.length == 1)
                    b = a;
                if (!this.has(a)) {
                    this[_15].push(String(a))
                }
                var c = this.constructor;
                if (c.Item && !instanceOf(b, c.Item)) {
                    b = c.create.apply(c, arguments)
                }
                this[_14 + a] = b
            },
            
            putAt: function(a, b) {
                assert(Math.abs(a) < this[_15].length, "Index out of bounds.");
                arguments[0] = this[_15].item(a);
                this.put.apply(this, arguments)
            },
            
            remove: function(a) {
                if (this.has(a)) {
                    this[_15].remove(String(a));
                    delete this[_14 + a]
                }
            },
            
            removeAt: function(a) {
                this[_15].removeAt(a);
                delete this[_14 + key]
            },
            
            reverse: function() {
                this[_15].reverse();
                return this
            },
            
            size: function() {
                return this[_15].length
            },
            
            sort: function(c) {
                if (c) {
                    var d = this;
                    this[_15].sort(function(a, b) {
                        return c(d[_14 + a], d[_14 + b], a, b)
                    })
                } else
                    this[_15].sort();
                return this
            },
            
            toString: function() {
                return String(this[_15])
            }}, {Item: null,init: function() {
                this.prototype.item = this.prototype.getAt
            },
            
            create: function(a, b) {
                return this.Item ? new this.Item(a, b) : b
            },
            
            extend: function(a, b) {
                var c = this.base(a);
                c.create = this.create;
                extend(c, b);
                if (!c.Item) {
                    c.Item = this.Item
                } else if (typeof c.Item != "function") {
                    c.Item = (this.Item || Base).extend(c.Item)
                }
                c.init();
                return c
            }});
        var _16 = /\\(\d+)/g, _17 = /\\./g, _18 = /\(\?[:=!]|\[[^\]]+\]/g, _19 = /\(/g, _20 = /\$(\d+)/, _21 = /^\$\d+$/;
        var RegGrp = Collection.extend({constructor: function(a, b) {
                this.base(a);
                if (typeof b == "string") {
                    this.global = /g/.test(b);
                    this.ignoreCase = /i/.test(b)
                }
            },global: true,ignoreCase: false,exec: function(h, j) {
                var k = (this.global ? "g" : "") + (this.ignoreCase ? "i" : "");
                h = String(h) + "";
                if (arguments.length == 1) {
                    var l = this;
                    var m = this[_15];
                    
                    /**
                     * @ignore
                     */
                    j = function(a) {
                        if (a) {
                            var b, c = 1, i = 0;
                            while ((b = l[_14 + m[i++]])) {
                                var d = c + b.length + 1;
                                if (arguments[c]) {
                                    var e = b.replacement;
                                    switch (typeof e) {
                                        case "function":
                                            var f = slice(arguments, c, d);
                                            var g = arguments[arguments.length - 2];
                                            return e.apply(l, f.concat(g, h));
                                        case "number":
                                            return arguments[c + e];
                                        default:
                                            return e
                                    }
                                }
                                c = d
                            }
                        }
                        return ""
                    }
                }
                return h.replace(new RegExp(this, k), j)
            },insertAt: function(a, b, c) {
                if (instanceOf(b, RegExp)) {
                    arguments[1] = b.source
                }
                return base(this, arguments)
            },test: function(a) {
                return this.exec(a) != a
            },toString: function() {
                var e = 0;
                return "(" + this.map(function(c) {
                    var d = String(c).replace(_16, function(a, b) {
                        return "\\" + (1 + Number(b) + e)
                    });
                    e += c.length + 1;
                    return d
                }).join(")|(") + ")"
            }}, {IGNORE: "$0",init: function() {
                forEach("add,get,has,put,remove".split(","), function(b) {
                    _22(this, b, function(a) {
                        if (a && a.source) {
                            arguments[0] = a.source
                        }
                        return base(this, arguments)
                    })
                }, this.prototype)
            },Item: {constructor: function(a, b) {
                    a = (a && a.source) ? a.source : String(a);
                    if (typeof b == "number")
                        b = String(b);
                    else if (b == null)
                        b = "";
                    if (typeof b == "string" && _20.test(b)) {
                        if (_21.test(b)) {
                            b = parseInt(b.slice(1))
                        } else {
                            var Q = /'/.test(b.replace(/\\./g, "")) ? '"' : "'";
                            b = b.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\$(\d+)/g, Q + "+(arguments[$1]||" + Q + Q + ")+" + Q);
                            b = new Function("return " + Q + b.replace(/(['"])\1\+(.*)\+\1\1$/, "$1") + Q);
                        }
                    }
                    this.length = RegGrp.count(a);
                    this.replacement = b;
                    this.toString = K(a)
                },length: 0,replacement: ""},count: function(a) {
                a = String(a).replace(_17, "").replace(_18, "");
                return match(a, _19).length
            }});
        var JavaScript = {name: "JavaScript",version: base2.version,exports: "Array2, Date2, String2",namespace: "",bind: function(c) {
                forEach(this.exports.match(/\w+/g), function(a) {
                    var b = a.slice(0, -1);
                    extend(c[b], this[a]);
                    this[a](c[b].prototype)
                }, this)
            }};
        if ((new Date).getYear() > 1900) {
            /**
             * @ignore
             */
            Date.prototype.getYear = function() {
                return this.getFullYear() - 1900
            };
            
            /**
             * @ignore
             */
            Date.prototype.setYear = function(a) {
                return this.setFullYear(a + 1900)
            }
        }
        
        /**
         * @ignore
         */
        (Function || {}).prototype.prototype = {};
        
        if ("".replace(/^/, K("$$")) == "$") {
            extend(String.prototype, "replace", function(a, b) {
                if (typeof b == "function") {
                    var c = b;
                    
                    /**
                     * @ignore
                     */
                    b = function() {
                        return String(c.apply(null, arguments)).split("$").join("$$")
                    };
                }
                
                return this.base(a, b);
            });
        }
        
        /**
         * @ignore
         */
        var Array2 = _23(Array, Array, "concat,join,pop,push,reverse,shift,slice,sort,splice,unshift", [Enumerable, {combine: function(d, e) {
                    if (!e)
                        e = d;
                    return this.reduce(d, function(a, b, c) {
                        a[b] = e[c];
                        return a
                    }, {})
                },contains: function(a, b) {
                    return this.indexOf(a, b) != -1
                },copy: function(a) {
                    var b = this.slice(a);
                    if (!b.swap)
                        this(b);
                    return b
                },flatten: function(c) {
                    return this.reduce(c, function(a, b) {
                        if (this.like(b)) {
                            this.reduce(b, arguments.callee, a, this)
                        } else {
                            a.push(b)
                        }
                        return a
                    }, [], this)
                },forEach: _24,indexOf: function(a, b, c) {
                    var d = a.length;
                    if (c == null) {
                        c = 0
                    } else if (c < 0) {
                        c = Math.max(0, d + c)
                    }
                    for (var i = c; i < d; i++) {
                        if (a[i] === b)
                            return i
                    }
                    return -1
                },insertAt: function(a, b, c) {
                    this.splice(a, b, 0, c);
                    return c
                },item: function(a, b) {
                    if (b < 0)
                        b += a.length;
                    return a[b]
                },lastIndexOf: function(a, b, c) {
                    var d = a.length;
                    if (c == null) {
                        c = d - 1
                    } else if (from < 0) {
                        c = Math.max(0, d + c)
                    }
                    for (var i = c; i >= 0; i--) {
                        if (a[i] === b)
                            return i
                    }
                    return -1
                },map: function(c, d, e) {
                    var f = [];
                    this.forEach(c, function(a, b) {
                        f[b] = d.call(e, a, b, c)
                    });
                    return f
                },remove: function(a, b) {
                    var c = this.indexOf(a, b);
                    if (c != -1)
                        this.removeAt(a, c);
                    return b
                },removeAt: function(a, b) {
                    return this.splice(a, b, 1)
                },swap: function(a, b, c) {
                    var d = a[b];
                    a[b] = a[c];
                    a[c] = d;
                    return a
                }}]);
        Array2.reduce = Enumerable.reduce;
        
        /**
         * @ignore
         */
        Array2.like = function(a) {
            return !!(a && typeof a == "object" && typeof a.length == "number")
        };
        
        var _25 = /^((-\d+|\d{4,})(-(\d{2})(-(\d{2}))?)?)?T((\d{2})(:(\d{2})(:(\d{2})(\.(\d{1,3})(\d)?\d*)?)?)?)?(([+-])(\d{2})(:(\d{2}))?|Z)?$/;
        var _26 = {FullYear: 2,Month: 4,Date: 6,Hours: 8,Minutes: 10,Seconds: 12,Milliseconds: 14};
        var _27 = {Hectomicroseconds: 15,UTC: 16,Sign: 17,Hours: 18,Minutes: 20};
        var _28 = /(((00)?:0+)?:0+)?\.0+$/;
        var _29 = /(T[0-9:.]+)$/;
        
        var Date2 = _23(Date, function(a, b, c, h, m, s, d) {
            switch (arguments.length) {
                case 0:
                    return new Date;
                case 1:
                    return new Date(a);
                default:
                    return new Date(a, b, arguments.length == 2 ? 1 : c, h || 0, m || 0, s || 0, d || 0)
            }
        }, "", [{
            toISOString: function(c) {
                    var d = "####-##-##T##:##:##.###";
                    
                    for (var e in _26) {
                        d = d.replace(/#+/, function(a) {
                            var b = c["getUTC" + e]();
                            if (e == "Month") {
                                b++;
                            }
                            
                            return ("000" + b).slice(-a.length);
                        });
                    }
                    
                    return d.replace(_28, "").replace(_29, "$1Z");
                }
            }
        ]);
            
        /**
         * @ignore
         */
        Date2.now = function() {
            return (new Date).valueOf();
        };
        
        /**
         * @ignore
         */
        Date2.parse = function(a, b) {
            if (arguments.length > 1) {
                assertType(b, "number", "defaultDate should be of type 'number'.");
            }
            
            var c = String(a).match(_25);
            
            if (c) {
                if (c[_26.Month])
                    c[_26.Month]--;
                if (c[_27.Hectomicroseconds] >= 5)
                    c[_26.Milliseconds]++;
                var d = new Date(b || 0);
                var e = c[_27.UTC] || c[_27.Hours] ? "UTC" : "";
                for (var f in _26) {
                    var value = c[_26[f]];
                    if (!value)
                        continue;
                    d["set" + e + f](value);
                    if (d["get" + e + f]() != c[_26[f]]) {
                        return NaN
                    }
                }
                if (c[_27.Hours]) {
                    var g = Number(c[_27.Sign] + c[_27.Hours]);
                    var h = Number(c[_27.Sign] + (c[_27.Minutes] || 0));
                    d.setUTCMinutes(d.getUTCMinutes() + (g * 60) + h)
                }
                return d.valueOf()
            } else {
                return Date.parse(a)
            }
        };
        
        /**
         * @ignore
         */
        var String2 = _23(String, function(a) {
            return new String(arguments.length == 0 ? "" : a)
        }, "charAt,charCodeAt,concat,indexOf,lastIndexOf,match,replace,search,slice,split,substr,substring,toLowerCase,toUpperCase", [{trim: trim}]);
        
        /**
         * @ignore
         */
        function _23(c, d, e, f) {
            var g = Module.extend();
            forEach(e.match(/\w+/g), function(a) {
                g[a] = unbind(c.prototype[a])
            });
            forEach(f, g.implement, g);
            var h = function() {
                return g(this.constructor == g ? d.apply(null, arguments) : arguments[0])
            };
            h.prototype = g.prototype;
            forEach(g, function(a, b) {
                if (c[b]) {
                    delete g.prototype[b]
                }
                h[b] = g[b]
            });
            h.ancestor = Object;
            delete h.extend;
            if (c != Array)
                delete h.forEach;
            return h
        }
        
        /**
         * @ignore
         */
        function extend(a, b) {
            if (a && b) {
                if (arguments.length > 2) {
                    var c = b;
                    b = {};
                    b[c] = arguments[2]
                }
                var d = (typeof b == "function" ? Function : Object).prototype;
                var i = _5.length, c;
                if (base2.__prototyping) {
                    while ((c = _5[--i])) {
                        var f = b[c];
                        if (f != d[c]) {
                            if (_4.test(f)) {
                                _22(a, c, f)
                            } else {
                                a[c] = f
                            }
                        }
                    }
                }
                for (c in b) {
                    if (d[c] === undefined) {
                        var f = b[c];
                        if (c.charAt(0) == "@" && detect(c.slice(1))) {
                            arguments.callee(a, f);
                            continue
                        }
                        var h = a[c];
                        if (h && typeof f == "function") {
                            if (f != h && (!h.method || !_11(f, h))) {
                                if (f.__base || _4.test(f)) {
                                    _22(a, c, f)
                                } else {
                                    a[c] = f
                                }
                            }
                        } else {
                            a[c] = f
                        }
                    }
                }
            }
            return a
        }
        
        /**
         * @ignore
         */
        function _11(a, b) {
            while (b) {
                if (!b.ancestor)
                    return false;
                b = b.ancestor;
                if (b == a)
                    return true
            }
            return false
        }
        
        /**
         * @ignore
         */
        function _22(c, d, e) {
            var f = c[d];
            
            /**
             * @ignore
             */
            function _30() {
                var a = this.base;
                this.base = f;
                var b = e.apply(this, arguments);
                this.base = a;
                return b
            }
            
            _30.ancestor = f;
            _30.method = e;
            
            /**
             * @ignore
             */
            _30.toString = function() {
                return String(e)
            };
            
            c[d] = _30;
        }
        
        if (typeof StopIteration == "undefined") {
            StopIteration = new Error("StopIteration")
        }
        
        /**
         * @ignore
         */
        function forEach(a, b, c, d) {
            if (a == null) {
                return;
            }
            
            if (!d) {
                if (typeof a == "function" && a.call) {
                    d = Function;
                } else if (typeof a.forEach == "function" && a.forEach != arguments.callee) {
                    a.forEach(b, c);
                    return;
                } else if (typeof a.length == "number") {
                    _24(a, b, c);
                    return;
                }
            }
            
            _8(d || Object, a, b, c);
        }
        
        /**
         * @ignore
         */
        function _24(a, b, c) {
            if (a == null)
                return;
            var d = a.length, i;
            if (typeof a == "string") {
                for (i = 0; i < d; i++) {
                    b.call(c, a.charAt(i), i, a)
                }
            } else {
                for (i = 0; i < d; i++) { /*@cc_on@*/ /*@if(@_jscript_version<5.2)if(a[i]!==undefined||$Legacy.has(a,i))@else@*/
                    if (i in a) /*@end@*/
                        b.call(c, a[i], i, a)
                }
            }
        }
        
        /**
         * @ignore
         */
        function _8(g, h, j, k) {
            var l = function() {
                this.i = 1
            };
            l.prototype = {i: 1};
            var m = 0;
            for (var i in new l)
                m++;
            _8 = (m > 1) ? function(a, b, c, d) {
                var e = {};
                for (var f in b) {
                    if (!e[f] && a.prototype[f] === undefined) {
                        e[f] = true;
                        c.call(d, b[f], f, b)
                    }
                }
            } : function(a, b, c, d) {
                for (var e in b) {
                    if (a.prototype[e] === undefined) {
                        c.call(d, b[e], e, b)
                    }
                }
            };
            _8(g, h, j, k)
        }
        
        /**
         * @ignore
         */
        function instanceOf(a, b) {
            if (typeof b != "function") {
                throw new TypeError("Invalid 'instanceOf' operand.");
            }
            if (a == null)
                return false; /*@cc_on@*/ /*@if(@_jscript_version<5.1)if($Legacy.instanceOf(a,b))return true;@else@*/
            if (a instanceof b)
                return true; /*@end@*/
            if (Base.ancestorOf == b.ancestorOf)
                return false;
            var c = a.constructor;
            if (typeof c != "function")
                return false;
            if (Base.ancestorOf == c.ancestorOf)
                return b == Object;
            switch (b) {
                case Array:
                    return !!(typeof a == "object" && a.join && a.splice);
                case Function:
                    return !!(typeof a == "function" && a.call);
                case RegExp:
                    return c.prototype.toString() == _6;
                case Date:
                    return !!a.getTimezoneOffset;
                case String:
                case Number:
                case Boolean:
                    return typeof a == typeof b.prototype.valueOf();
                case Object:
                    return true
            }
            return false
        }
        
        /**
         * @ignore
         */
        function assert(a, b, c) {
            if (!a) {
                throw new (c || Error)(b || "Assertion failed.");
            }
        }
        
        /**
         * @ignore
         */
        function assertArity(a, b, c) {
            if (b == null)
                b = a.callee.length;
            if (a.length < b) {
                throw new SyntaxError(c || "Not enough arguments.");
            }
        }
        
        /**
         * @ignore
         */
        function assertType(a, b, c) {
            if (b && (typeof b == "function" ? !instanceOf(a, b) : typeof a != b)) {
                throw new TypeError(c || "Invalid type.");
            }
        }
        
        /**
         * @ignore
         */
        function assignID(a) {
            if (!a.base2ID) {
                a.base2ID = "b2_" + counter();
            }
            
            return a.base2ID;
        }
        
        /**
         * @ignore
         */
        function counter() {
            return _7++;
        }
        
        /**
         * @ignore
         */
        function copy(a) {
          
            /**
             * @ignore
             */
            var b = function() {
            };
            
            b.prototype = a;
            
            return new b;
        }
        
        /**
         * @ignore
         */
        function format(c) {
            var d = arguments;
            var e = new RegExp("%([1-" + arguments.length + "])", "g");
            
            return String(c).replace(e, function(a, b) {
                return b < d.length ? d[b] : a;
            });
        }
        
        /**
         * @ignore
         */
        function match(a, b) {
            return String(a).match(b) || []
        }
        
        /**
         * @ignore
         */
        function rescape(a) {
            return String(a).replace(_3, "\\$1")
        }
        
        /**
         * @ignore
         */
        function trim(a) {
            return String(a).replace(_1, "").replace(_2, "");
        }
        
        /**
         * @ignore
         */
        function I(i) {
            return i;
        }
        
        /**
         * @ignore
         */
        function K(k) {
            return function() {
                return k;
            }
        }
        
        /**
         * @ignore
         */
        function bind(a, b) {
            var c = slice(arguments, 2);
            
            /**
             * @ignore
             */
            var d = function() {
                return a.apply(b, c.concat(slice(arguments)));
            };
            
            d._31 = assignID(a);
            
            return d;
        }
        
        /**
         * @ignore
         */
        function delegate(a, b) {
            return function() {
                return a.apply(b, [this].concat(slice(arguments)));
            };
        }
        
        /**
         * @ignore
         */
        function flip(a) {
            return function() {
                return a.apply(this, Array2.swap(arguments, 0, 1));
            };
        }
        
        /**
         * @ignore
         */
        function not(a) {
            return function() {
                return !a.apply(this, arguments);
            };
        }
        
        /**
         * @ignore
         */
        function partial(a) {
            var b = slice.call(arguments, 1);
            
            return function() {
                return a.apply(this, b.concat(slice(arguments)));
            };
        }
        
        /**
         * @ignore
         */
        function unbind(b) {
            return function(a) {
                return b.apply(a, slice(arguments, 1))
            }
        }
        
        
        base2 = new Package(this, base2);
        eval(this.exports);
        base2.extend = extend;
        forEach(Enumerable, function(a, b) {
            if (!Module[b]) {
                base2.addName(b, bind(a, Enumerable));
            }
        });
        
        JavaScript = new Package(this, JavaScript);
        eval(this.exports);
    };
    
    new function(_) {
        var DOM = new base2.Package(this, {name: "DOM",version: "1.0 (beta 1)",exports: "Interface, Binding, Node, Document, Element, AbstractView, Event, EventTarget, DocumentEvent, " + "NodeSelector, DocumentSelector, ElementSelector, StaticNodeList, " + "ViewCSS, HTMLDocument, HTMLElement, Selector, Traversal, XPathParser",bind: function(a) {
                if (a && a.nodeType) {
                    var b = assignID(a);
                    if (!arguments.callee[b]) {
                        switch (a.nodeType) {
                            case 1:
                                if (typeof a.className == "string") {
                                    (HTMLElement.bindings[a.tagName] || HTMLElement).bind(a)
                                } else {
                                    Element.bind(a)
                                }
                                break;
                            case 9:
                                if (a.writeln) {
                                    HTMLDocument.bind(a)
                                } else {
                                    Document.bind(a)
                                }
                                break;
                            default:
                                Node.bind(a)
                        }
                        arguments.callee[b] = true
                    }
                }
                return a
            },"@MSIE5.+win": {bind: function(a) {
                    if (a && a.writeln) {
                        a.nodeType = 9
                    }
                    return this.base(a)
                }}});
        eval(this.imports);
        var _32 = detect("MSIE");
        var _33 = detect("MSIE5");
        if (detect("MSIE[56].+win") && !detect("SV1")) {
            var closures = {};
            extend(base2, "bind", function(b, c) {
                if (!c || c.nodeType != 1) {
                    return this.base(b, c)
                }
                var d = c.uniqueID;
                var e = assignID(b);
                closures[e] = b;
                b = null;
                c = null;
                if (!closures[d]) {
                    closures[d] = {};
                }
                
                var f = closures[d][e];
                if (f) {
                    return f;
                }
                
                /**
                 * @ignore
                 */
                var g = function() {
                    var a = document.all[d];
                    return a ? closures[e].apply(a, arguments) : undefined
                };
                g._31 = e;
                closures[d][e] = g;
                return g
            });
            
            attachEvent("onunload", function() {
                closures = null;
            });
        }
        
        
        var Interface = Module.extend(null, {implement: function(c) {
                if (typeof c == "object") {
                    forEach(c, function(a, b) {
                        if (b.charAt(0) == "@") {
                            forEach(a, arguments.callee, this)
                        } else if (!this[b] && typeof a == "function") {
                            this.createDelegate(b, a.length)
                        }
                    }, this)
                }
                return this.base(c)
            },createDelegate: function(a, b) {
                if (!this[a]) {
                    var c = "var fn=function _%1(%2){%3.base=%3.%1.ancestor;var m=%3.base?'base':'%1';return %3[m](%4)}";
                    var d = "abcdefghij".split("").slice(-b);
                    eval(format(c, a, d, d[0], d.slice(1)));
                    this[a] = fn
                }
            }});
        var Binding = Interface.extend(null, {extend: function(d, a) {
                if (a && a.bind != Function.bind) {
                    var c = a.bind;
                    delete a.bind
                }
                var b = this.base(d, a);
                b.bind = this.bind;
                if (c)
                    extend(b, "bind", c);
                return b
            },bind: function(b) {
                return extend(b, this.prototype)
            }});
        var Node = Binding.extend({"@!(element.compareDocumentPosition)": {compareDocumentPosition: function(a, b) {
                    if (Traversal.contains(a, b)) {
                        return 4 | 16;
                    } else if (Traversal.contains(b, a)) {
                        return 2 | 8;
                    }
                    
                    var c = _34(a);
                    var d = _34(b);
                    
                    if (c < d) {
                        return 4;
                    } else if (c > d) {
                        return 2;
                    }
                    
                    return 0;
                }}});
        var _34 = document.documentElement.sourceIndex ? function(a) {
            return a.sourceIndex
        } : function(a) {
            var b = 0;
            while (a) {
                b = Traversal.getNodeIndex(a) + "." + b;
                a = a.parentNode
            }
            return b
        };
        var Document = Node.extend(null, {bind: function(b) {
                extend(b, "createElement", function(a) {
                    return DOM.bind(this.base(a))
                });
                AbstractView.bind(b.defaultView);
                if (b != window.document)
                    new DOMContentLoadedEvent(b);
                return this.base(b)
            },"@!(document.defaultView)": {bind: function(a) {
                    a.defaultView = Traversal.getDefaultView(a);
                    return this.base(a)
                }}});
        var _35 = /^(href|src|type|value)$/;
        var _36 = {"class": "className","for": "htmlFor"};
        var Element = Node.extend({"@MSIE.+win": {getAttribute: function(a, b, c) {
                    if (a.className === undefined) {
                        return this.base(a, b)
                    }
                    var d = _37(a, b);
                    if (d && d.specified) {
                        if (_35.test(b)) {
                            return this.base(a, b, 2)
                        } else if (b == "style") {
                            return a.style.cssText
                        } else {
                            return d.nodeValue
                        }
                    }
                    return null
                },setAttribute: function(a, b, c) {
                    if (a.className === undefined) {
                        this.base(a, b, c)
                    } else if (b == "style") {
                        a.style.cssText = c
                    } else {
                        this.base(a, _36[b] || b, String(c))
                    }
                }},"@!(element.hasAttribute)": {hasAttribute: function(a, b) {
                    return this.getAttribute(a, b) != null
                }}});
        extend(Element.prototype, "cloneNode", function(a) {
            var b = this.base(a || false);
            b.base2ID = undefined;
            return b
        });
        if (_32) {
            var names = "colSpan,rowSpan,vAlign,dateTime,accessKey,tabIndex,encType,maxLength,readOnly,longDesc";
            extend(_36, Array2.combine(names.toLowerCase().split(","), names.split(",")));
            var _37 = _33 ? function(a, b) {
                return a.attributes[b] || a.attributes[_36[b.toLowerCase()]]
            } : function(a, b) {
                return a.getAttributeNode(b)
            }
        }
        var TEXT = _32 ? "innerText" : "textContent";
        var Traversal = Module.extend({getDefaultView: function(a) {
                return this.getDocument(a).defaultView
            },getNextElementSibling: function(a) {
                while (a && (a = a.nextSibling) && !this.isElement(a))
                    continue;
                return a
            },getNodeIndex: function(a) {
                var b = 0;
                while (a && (a = a.previousSibling))
                    b++;
                return b
            },getOwnerDocument: function(a) {
                return a.ownerDocument
            },getPreviousElementSibling: function(a) {
                while (a && (a = a.previousSibling) && !this.isElement(a))
                    continue;
                return a
            },getTextContent: function(a) {
                return a[TEXT]
            },isEmpty: function(a) {
                a = a.firstChild;
                while (a) {
                    if (a.nodeType == 3 || this.isElement(a))
                        return false;
                    a = a.nextSibling
                }
                return true
            },setTextContent: function(a, b) {
                return a[TEXT] = b
            },"@MSIE": {getDefaultView: function(a) {
                    return this.getDocument(a).parentWindow
                },"@MSIE5": {getOwnerDocument: function(a) {
                        return a.ownerDocument || a.document
                    }}}}, {contains: function(a, b) {
                while (b && (b = b.parentNode) && a != b)
                    continue;
                return !!b
            },getDocument: function(a) {
                return this.isDocument(a) ? a : this.getOwnerDocument(a)
            },isDocument: function(a) {
                return !!(a && a.documentElement)
            },isElement: function(a) {
                return !!(a && a.nodeType == 1)
            },"@(element.contains)": {contains: function(a, b) {
                    return a != b && (this.isDocument(a) ? a == this.getOwnerDocument(b) : a.contains(b))
                }},"@MSIE5": {isElement: function(a) {
                    return !!(a && a.nodeType == 1 && a.tagName != "!")
                }}});
        var AbstractView = Binding.extend();
        var Event = Binding.extend({"@!(document.createEvent)": {initEvent: function(a, b, c, d) {
                    a.type = b;
                    a.bubbles = c;
                    a.cancelable = d;
                    a.timeStamp = new Date().valueOf()
                },"@MSIE": {initEvent: function(a, b, c, d) {
                        this.base(a, b, c, d);
                        a.cancelBubble = !a.bubbles
                    },preventDefault: function(a) {
                        if (a.cancelable !== false) {
                            a.returnValue = false
                        }
                    },stopPropagation: function(a) {
                        a.cancelBubble = true
                    }}}}, {"@!(document.createEvent)": {"@MSIE": {"@Mac": {bind: function(a) {
                            return this.base(extend(copy(a), {preventDefault: function() {
                                    if (this.cancelable !== false) {
                                        this.returnValue = false
                                    }
                                }}))
                        }},"@Windows": {bind: function(a) {
                            if (!a.timeStamp) {
                                a.bubbles = !!_38[a.type];
                                a.cancelable = !!_39[a.type];
                                a.timeStamp = new Date().valueOf()
                            }
                            if (!a.target) {
                                a.target = a.srcElement
                            }
                            a.relatedTarget = a[(a.type == "mouseout" ? "to" : "from") + "Element"];
                            return this.base(a)
                        }}}}});
        if (_32) {
            var _38 = "abort,error,select,change,resize,scroll";
            var _39 = "click,mousedown,mouseup,mouseover,mousemove,mouseout,keydown,keyup,submit,reset";
            _38 = Array2.combine((_38 + "," + _39).split(","));
            _39 = Array2.combine(_39.split(","))
        }
        var EventTarget = Interface.extend({"@!(element.addEventListener)": {addEventListener: function(a, b, c, d) {
                    var e = assignID(a);
                    var f = c._31 || assignID(c);
                    var g = _40[e];
                    if (!g)
                        g = _40[e] = {};
                    var h = g[b];
                    var i = a["on" + b];
                    if (!h) {
                        h = g[b] = {};
                        if (i)
                            h[0] = i
                    }
                    h[f] = c;
                    if (i !== undefined) {
                        a["on" + b] = delegate(_40.handleEvent)
                    }
                },dispatchEvent: function(a, b) {
                    return _40.handleEvent(a, b)
                },removeEventListener: function(a, b, c, d) {
                    var e = _40[a.base2ID];
                    if (e && e[b]) {
                        delete e[b][c.base2ID]
                    }
                },"@MSIE.+win": {addEventListener: function(a, b, c, d) {
                        if (typeof c == "function") {
                            c = bind(c, a)
                        }
                        this.base(a, b, c, d)
                    },dispatchEvent: function(a, b) {
                        b.target = a;
                        try {
                            return a.fireEvent(b.type, b)
                        } catch (error) {
                            return this.base(a, b)
                        }
                    }}}});
        var _40 = new Base({handleEvent: function(a, b) {
                var c = true;
                var d = _40[a.base2ID];
                if (d) {
                    b = Event.bind(b);
                    var e = d[b.type];
                    for (var i in e) {
                        var listener = e[i];
                        if (listener.handleEvent) {
                            var result = listener.handleEvent(b)
                        } else {
                            result = listener.call(a, b)
                        }
                        if (result === false || b.returnValue === false)
                            c = false
                    }
                }
                return c
            },"@MSIE": {handleEvent: function(a, b) {
                    if (a.Infinity) {
                        a = a.document.parentWindow;
                        if (!b)
                            b = a.event
                    }
                    return this.base(a, b || Traversal.getDefaultView(a).event)
                }}});
        var DocumentEvent = Interface.extend({"@!(document.createEvent)": {createEvent: function(a, b) {
                    return Event.bind({})
                },"@(document.createEventObject)": {createEvent: function(a, b) {
                        return Event.bind(a.createEventObject())
                    }}},"@(document.createEvent)": {"@!(document.createEvent('Events'))": {createEvent: function(a, b) {
                        return this.base(a, b == "Events" ? "UIEvents" : b)
                    }}}});
        var DOMContentLoadedEvent = Base.extend({constructor: function(b) {
                var c = false;
                
                /**
                 * @ignore
                 */
                this.fire = function() {
                    if (!c) {
                        c = true;
                        
                        setTimeout(function() {
                            var a = DocumentEvent.createEvent(b, "Events");
                            Event.initEvent(a, "DOMContentLoaded", false, false);
                            EventTarget.dispatchEvent(b, a);
                        }, 1);
                    }
                };
                
                EventTarget.addEventListener(b, "DOMContentLoaded", function() {
                    c = true;
                }, false);
                
                EventTarget.addEventListener(Traversal.getDefaultView(b), "load", this.fire, false);
                
            },"@(attachEvent)": {constructor: function() {
                    this.base(document);
                    Traversal.getDefaultView(document).attachEvent("onload", this.fire)
                }},"@MSIE.+win": {constructor: function(a) {
                    this.base(a);
                    if (a.readyState != "complete") {
                        var b = this;
                        a.write("<script id=__ready defer src=//:><\/script>");
                        
                        /**
                         * @ignore
                         */
                        a.all.__ready.onreadystatechange = function() {
                            if (this.readyState == "complete") {
                                this.removeNode();
                                b.fire();
                            }
                        };
                    }
                }},"@KHTML": {constructor: function(a) {
                    this.base(a);
                    if (a.readyState != "complete") {
                        var b = this;
                        var c = setInterval(function() {
                            if (/loaded|complete/.test(a.readyState)) {
                                clearInterval(c);
                                b.fire()
                            }
                        }, 100)
                    }
                }}});
        new DOMContentLoadedEvent(document);
        Document.implement(DocumentEvent);
        Document.implement(EventTarget);
        Element.implement(EventTarget);
        var _41 = /^\d+(px)?$/i;
        var _42 = /(width|height|top|bottom|left|right|fontSize)$/;
        var _43 = /^(color|backgroundColor)$/;
        var ViewCSS = Interface.extend({"@!(document.defaultView.getComputedStyle)": {"@MSIE": {getComputedStyle: function(b, c, d) {
                        var e = c.currentStyle;
                        var f = {getPropertyValue: function(a) {
                                return this[ViewCSS.toCamelCase(a)]
                            }};
                        for (var i in e) {
                            if (_42.test(i)) {
                                f[i] = _44(c, f[i]) + "px"
                            } else if (_43.test(i)) {
                                f[i] = _45(c, i == "color" ? "ForeColor" : "BackColor")
                            } else {
                                f[i] = e[i]
                            }
                        }
                        return f
                    }}}}, {toCamelCase: function(c) {
                return c.replace(/\-([a-z])/g, function(a, b) {
                    return b.toUpperCase()
                })
            }});
        function _44(a, b) {
            if (_41.test(b))
                return parseInt(b);
            var c = a.style.left;
            var d = a.runtimeStyle.left;
            a.runtimeStyle.left = a.currentStyle.left;
            a.style.left = b || 0;
            b = a.style.pixelLeft;
            a.style.left = c;
            a.runtimeStyle.left = d;
            return b
        }
        ;
        function _45(a, b) {
            var c = a.document.body.createTextRange();
            c.moveToElementText(a);
            var d = c.queryCommandValue(b);
            return format("rgb(%1,%2,%3)", d & 0xff, (d & 0xff00) >> 8, (d & 0xff0000) >> 16)
        }
        ;
        AbstractView.implement(ViewCSS);
        var NodeSelector = Interface.extend({"@!(element.querySelector)": {querySelector: function(a, b) {
                    return new Selector(b).exec(a, 1)
                },querySelectorAll: function(a, b) {
                    return new Selector(b).exec(a)
                }}});
        extend(NodeSelector.prototype, {querySelector: function(a) {
                return DOM.bind(this.base(a))
            },querySelectorAll: function(b) {
                return extend(this.base(b), "item", function(a) {
                    return DOM.bind(this.base(a))
                })
            }});
        var DocumentSelector = NodeSelector.extend();
        var ElementSelector = NodeSelector.extend({"@!(element.matchesSelector)": {matchesSelector: function(a, b) {
                    return new Selector(b).test(a)
                }}});
        var StaticNodeList = Base.extend({constructor: function(b) {
                b = b || [];
                this.length = b.length;
                
                /**
                 * @ignore
                 */
                this.item = function(a) {
                    return b[a];
                };
            },length: 0,forEach: function(a, b) {
                for (var i = 0; i < this.length; i++) {
                    a.call(b, this.item(i), i, this)
                }
            },item: Undefined,"@(XPathResult)": {constructor: function(b) {
                    if (b && b.snapshotItem) {
                        this.length = b.snapshotLength;
                        
                        /**
                         * @ignore
                         */
                        this.item = function(a) {
                            return b.snapshotItem(a)
                        };
                    } else
                        this.base(b)
                }}});
        StaticNodeList.implement(Enumerable);
        var CSSParser = RegGrp.extend({constructor: function(a) {
                this.base(a);
                this.cache = {};
                this.sorter = new RegGrp;
                this.sorter.add(/:not\([^)]*\)/, RegGrp.IGNORE);
                this.sorter.add(/([ >](\*|[\w-]+))([^: >+~]*)(:\w+-child(\([^)]+\))?)([^: >+~]*)/, "$1$3$6$4")
            },cache: null,ignoreCase: true,escape: function(b) {
                var c = /'/g;
                var d = this._46 = [];
                return this.optimise(this.format(String(b).replace(CSSParser.ESCAPE, function(a) {
                    d.push(a.slice(1, -1).replace(c, "\\'"));
                    return "\x01" + d.length
                })))
            },format: function(a) {
                return a.replace(CSSParser.WHITESPACE, "$1").replace(CSSParser.IMPLIED_SPACE, "$1 $2").replace(CSSParser.IMPLIED_ASTERISK, "$1*$2")
            },optimise: function(a) {
                return this.sorter.exec(a.replace(CSSParser.WILD_CARD, ">* "))
            },parse: function(a) {
                return this.cache[a] || (this.cache[a] = this.unescape(this.exec(this.escape(a))))
            },unescape: function(c) {
                var d = this._46;
                return c.replace(/\x01(\d+)/g, function(a, b) {
                    return d[b - 1]
                })
            }}, {ESCAPE: /'(\\.|[^'\\])*'|"(\\.|[^"\\])*"/g,IMPLIED_ASTERISK: /([\s>+~,]|[^(]\+|^)([#.:@])/g,IMPLIED_SPACE: /(^|,)([^\s>+~])/g,WHITESPACE: /\s*([\s>+~(),]|^|$)\s*/g,WILD_CARD: /\s\*\s/g,_47: function(c, d, e, f, g, h, i, j) {
                f = /last/i.test(c) ? f + "+1-" : "";
                if (!isNaN(d))
                    d = "0n+" + d;
                else if (d == "even")
                    d = "2n";
                else if (d == "odd")
                    d = "2n+1";
                d = d.split(/n\+?/);
                var a = d[0] ? (d[0] == "-") ? -1 : parseInt(d[0]) : 1;
                var b = parseInt(d[1]) || 0;
                var k = a < 0;
                if (k) {
                    a = -a;
                    if (a == 1)
                        b++
                }
                var l = format(a == 0 ? "%3%7" + (f + b) : "(%4%3-%2)%6%1%70%5%4%3>=%2", a, b, e, f, h, i, j);
                if (k)
                    l = g + "(" + l + ")";
                return l
            }});
        var XPathParser = CSSParser.extend({constructor: function() {
                this.base(XPathParser.rules);
                this.sorter.putAt(1, "$1$4$3$6")
            },escape: function(a) {
                return this.base(a).replace(/,/g, "\x02")
            },unescape: function(a) {
                return this.base(a.replace(/\[self::\*\]/g, "").replace(/(^|\x02)\//g, "$1./").replace(/\x02/g, " | "))
            },"@opera": {unescape: function(a) {
                    return this.base(a.replace(/last\(\)/g, "count(preceding-sibling::*)+count(following-sibling::*)+1"))
                }}}, {init: function() {
                this.values.attributes[""] = "[@$1]";
                forEach(this.types, function(a, b) {
                    forEach(this.values[b], a, this.rules)
                }, this)
            },optimised: {pseudoClasses: {"first-child": "[1]","last-child": "[last()]","only-child": "[last()=1]"}},rules: extend({}, {"@!KHTML": {"(^|\\x02) (\\*|[\\w-]+)#([\\w-]+)": "$1id('$3')[self::$2]","([ >])(\\*|[\\w-]+):([\\w-]+-child(\\(([^)]+)\\))?)": function(a, b, c, d, e, f) {
                        var g = (b == " ") ? "//*" : "/*";
                        if (/^nth/i.test(d)) {
                            g += _47(d, f, "position()")
                        } else {
                            g += XPathParser.optimised.pseudoClasses[d]
                        }
                        return g + "[self::" + c + "]"
                    }}}),types: {identifiers: function(a, b) {
                    this[rescape(b) + "([\\w-]+)"] = a
                },combinators: function(a, b) {
                    this[rescape(b) + "(\\*|[\\w-]+)"] = a
                },attributes: function(a, b) {
                    this["\\[([\\w-]+)\\s*" + rescape(b) + "\\s*([^\\]]*)\\]"] = a
                },pseudoClasses: function(a, b) {
                    this[":" + b.replace(/\(\)$/, "\\(([^)]+)\\)")] = a
                }},values: {identifiers: {"#": "[@id='$1'][1]",".": "[contains(concat(' ',@class,' '),' $1 ')]"},combinators: {" ": "/descendant::$1",">": "/child::$1","+": "/following-sibling::*[1][self::$1]","~": "/following-sibling::$1"},attributes: {"*=": "[contains(@$1,'$2')]","^=": "[starts-with(@$1,'$2')]","$=": "[substring(@$1,string-length(@$1)-string-length('$2')+1)='$2']","~=": "[contains(concat(' ',@$1,' '),' $2 ')]","|=": "[contains(concat('-',@$1,'-'),'-$2-')]","!=": "[not(@$1='$2')]","=": "[@$1='$2']"},pseudoClasses: {"empty": "[not(child::*) and not(text())]","first-child": "[not(preceding-sibling::*)]","last-child": "[not(following-sibling::*)]","not()": _48,"nth-child()": _47,"nth-last-child()": _47,"only-child": "[not(preceding-sibling::*) and not(following-sibling::*)]","root": "[not(parent::*)]"}},"@opera": {init: function() {
                    this.optimised.pseudoClasses["last-child"] = this.values.pseudoClasses["last-child"];
                    this.optimised.pseudoClasses["only-child"] = this.values.pseudoClasses["only-child"];
                    this.base()
                }}});
        var _49 = new XPathParser;
        function _48(a, b) {
            return "[not(" + _49.exec(trim(b)).replace(/\[1\]/g, "").replace(/^(\*|[\w-]+)/, "[self::$1]").replace(/\]\[/g, " and ").slice(1, -1) + ")]"
        }
        ;
        function _47(a, b, c) {
            return "[" + CSSParser._47(a, b, c || "count(preceding-sibling::*)+1", "last()", "not", " and ", " mod ", "=") + "]"
        }
        ;
        var _50 = ":(checked|disabled|enabled|contains)|^(#[\\w-]+\\s*)?\\w+$";
        if (detect("KHTML")) {
            if (detect("WebKit5")) {
                _50 += "|nth\\-|,"
            } else {
                _50 = "."
            }
        }
        _50 = new RegExp(_50);
        var _51;
        var Selector = Base.extend({constructor: function(a) {
                this.toString = K(trim(a))
            },exec: function(a, b) {
                return Selector.parse(this)(a, b)
            },test: function(a) {
                var b = new Selector(this + "[-base2-test]");
                a.setAttribute("-base2-test", true);
                var c = b.exec(Traversal.getOwnerDocument(a), true);
                a.removeAttribute("-base2-test");
                return c == a
            },toXPath: function() {
                return Selector.toXPath(this)
            },"@(XPathResult)": {exec: function(a, b) {
                    if (_50.test(this)) {
                        return this.base(a, b)
                    }
                    var c = Traversal.getDocument(a);
                    var d = b ? 9 : 7;
                    var e = c.evaluate(this.toXPath(), a, null, d, null);
                    return b ? e.singleNodeValue : e
                }},"@MSIE": {exec: function(a, b) {
                    if (typeof a.selectNodes != "undefined" && !_50.test(this)) {
                        var c = b ? "selectSingleNode" : "selectNodes";
                        return a[c](this.toXPath())
                    }
                    return this.base(a, b)
                }},"@(true)": {exec: function(a, b) {
                    try {
                        var c = this.base(a || document, b)
                    } catch (error) {
                        throw new SyntaxError(format("'%1' is not a valid CSS selector.", this));
                    }
                    return b ? c : new StaticNodeList(c)
                }}}, {toXPath: function(a) {
                if (!_51)
                    _51 = new XPathParser;
                return _51.parse(a)
            }});
        new function(_) {
            var _52 = {"=": "%1=='%2'","!=": "%1!='%2'","~=": /(^| )%1( |$)/,"|=": /^%1(-|$)/,"^=": /^%1/,"$=": /%1$/,"*=": /%1/};
            _52[""] = "%1!=null";
            var _53 = {"checked": "e%1.checked","contains": "e%1[TEXT].indexOf('%2')!=-1","disabled": "e%1.disabled","empty": "Traversal.isEmpty(e%1)","enabled": "e%1.disabled===false","first-child": "!Traversal.getPreviousElementSibling(e%1)","last-child": "!Traversal.getNextElementSibling(e%1)","only-child": "!Traversal.getPreviousElementSibling(e%1)&&!Traversal.getNextElementSibling(e%1)","root": "e%1==Traversal.getDocument(e%1).documentElement"};
            var _54 = detect("(element.sourceIndex)");
            var _55 = "var p%2=0,i%2,e%2,n%2=e%1.";
            var _56 = _54 ? "e%1.sourceIndex" : "assignID(e%1)";
            var _57 = "var g=" + _56 + ";if(!p[g]){p[g]=1;";
            var _58 = "r[r.length]=e%1;if(s)return e%1;";
            var _59 = "r.sort(sorter);";
            var _60 = "fn=function(e0,s){indexed++;var r=[],p={},reg=[%1]," + "d=Traversal.getDocument(e0),c=d.body?'toUpperCase':'toString';";
            var byId = _32 ? function(a, b) {
                var c = a.all[b] || null;
                if (!c || c.id == b)
                    return c;
                for (var i = 0; i < c.length; i++) {
                    if (c[i].id == b)
                        return c[i]
                }
                return null
            } : function(a, b) {
                return a.getElementById(b)
            };
            var indexed = 1;
            function register(a) {
                if (a.rows) {
                    a.b2_length = a.rows.length;
                    a.b2_lookup = "rowIndex"
                } else if (a.cells) {
                    a.b2_length = a.cells.length;
                    a.b2_lookup = "cellIndex"
                } else if (a.b2_indexed != indexed) {
                    var b = 0;
                    var c = a.firstChild;
                    while (c) {
                        if (c.nodeType == 1 && c.nodeName != "!") {
                            c.b2_index = ++b
                        }
                        c = c.nextSibling
                    }
                    a.b2_length = b;
                    a.b2_lookup = "b2_index"
                }
                a.b2_indexed = indexed;
                return a
            }
            ;
            var sorter = _54 ? function(a, b) {
                return a.sourceIndex - b.sourceIndex
            } : Node.compareDocumentPosition;
            var fn;
            var reg;
            var _61;
            var _62;
            var _63;
            var _64;
            var _65 = {};
            var parser = new CSSParser({"^ \\*:root": function(a) {
                    _62 = false;
                    var b = "e%2=d.documentElement;if(Traversal.contains(e%1,e%2)){";
                    return format(b, _61++, _61)
                }," (\\*|[\\w-]+)#([\\w-]+)": function(a, b, c) {
                    _62 = false;
                    var d = "var e%2=byId(d,'%4');if(e%2&&";
                    if (b != "*")
                        d += "e%2.nodeName=='%3'[c]()&&";
                    d += "Traversal.contains(e%1,e%2)){";
                    if (_63)
                        d += format("i%1=n%1.length;", _63);
                    return format(d, _61++, _61, b, c)
                }," (\\*|[\\w-]+)": function(a, b) {
                    _64++;
                    _62 = b == "*";
                    var c = _55;
                    c += (_62 && _33) ? "all" : "getElementsByTagName('%3')";
                    c += ";for(i%2=0;(e%2=n%2[i%2]);i%2++){";
                    return format(c, _61++, _63 = _61, b)
                },">(\\*|[\\w-]+)": function(a, b) {
                    var c = _32 && _63;
                    _62 = b == "*";
                    var d = _55;
                    d += c ? "children" : "childNodes";
                    if (!_62 && c)
                        d += ".tags('%3')";
                    d += ";for(i%2=0;(e%2=n%2[i%2]);i%2++){";
                    if (_62) {
                        d += "if(e%2.nodeType==1){";
                        _62 = _33
                    } else {
                        if (!c)
                            d += "if(e%2.nodeName=='%3'[c]()){"
                    }
                    return format(d, _61++, _63 = _61, b)
                },"\\+(\\*|[\\w-]+)": function(a, b) {
                    var c = "";
                    if (_62 && _32)
                        c += "if(e%1.tagName!='!'){";
                    _62 = false;
                    c += "e%1=Traversal.getNextElementSibling(e%1);if(e%1";
                    if (b != "*")
                        c += "&&e%1.nodeName=='%2'[c]()";
                    c += "){";
                    return format(c, _61, b)
                },"~(\\*|[\\w-]+)": function(a, b) {
                    var c = "";
                    if (_62 && _32)
                        c += "if(e%1.tagName!='!'){";
                    _62 = false;
                    _64 = 2;
                    c += "while(e%1=e%1.nextSibling){if(e%1.b2_adjacent==indexed)break;if(";
                    if (b == "*") {
                        c += "e%1.nodeType==1";
                        if (_33)
                            c += "&&e%1.tagName!='!'"
                    } else
                        c += "e%1.nodeName=='%2'[c]()";
                    c += "){e%1.b2_adjacent=indexed;";
                    return format(c, _61, b)
                },"#([\\w-]+)": function(a, b) {
                    _62 = false;
                    var c = "if(e%1.id=='%2'){";
                    if (_63)
                        c += format("i%1=n%1.length;", _63);
                    return format(c, _61, b)
                },"\\.([\\w-]+)": function(a, b) {
                    _62 = false;
                    reg.push(new RegExp("(^|\\s)" + rescape(b) + "(\\s|$)"));
                    return format("if(e%1.className&&reg[%2].test(e%1.className)){", _61, reg.length - 1)
                },":not\\((\\*|[\\w-]+)?([^)]*)\\)": function(a, b, c) {
                    var d = (b && b != "*") ? format("if(e%1.nodeName=='%2'[c]()){", _61, b) : "";
                    d += parser.exec(c);
                    return "if(!" + d.slice(2, -1).replace(/\)\{if\(/g, "&&") + "){"
                },":nth(-last)?-child\\(([^)]+)\\)": function(a, b, c) {
                    _62 = false;
                    b = format("e%1.parentNode.b2_length", _61);
                    var d = "if(p%1!==e%1.parentNode)p%1=register(e%1.parentNode);";
                    d += "var i=e%1[p%1.b2_lookup];if(";
                    return format(d, _61) + CSSParser._47(a, c, "i", b, "!", "&&", "%", "==") + "){"
                },":([\\w-]+)(\\(([^)]+)\\))?": function(a, b, c, d) {
                    return "if(" + format(_53[b] || "throw", _61, d || "") + "){"
                },"\\[([\\w-]+)\\s*([^=]?=)?\\s*([^\\]]*)\\]": function(a, b, c, d) {
                    var e = _36[b] || b;
                    if (c) {
                        var f = "e%1.getAttribute('%2',2)";
                        if (!_35.test(b)) {
                            f = "e%1.%3||" + f
                        }
                        b = format("(" + f + ")", _61, b, e)
                    } else {
                        b = format("Element.getAttribute(e%1,'%2')", _61, b)
                    }
                    var g = _52[c || ""];
                    if (instanceOf(g, RegExp)) {
                        reg.push(new RegExp(format(g.source, rescape(parser.unescape(d)))));
                        g = "reg[%2].test(%1)";
                        d = reg.length - 1
                    }
                    return "if(" + format(g, b, d) + "){"
                }
            });
            
            /**
             * @ignore
             */
            Selector.parse = function(a) {
                if (!_65[a]) {
                    reg = [];
                    fn = "";
                    var b = parser.escape(a).split(",");
                    for (var i = 0; i < b.length; i++) {
                        _62 = _61 = _63 = 0;
                        _64 = b.length > 1 ? 2 : 0;
                        var c = parser.exec(b[i]) || "throw;";
                        if (_62 && _32) {
                            c += format("if(e%1.tagName!='!'){", _61)
                        }
                        var d = (_64 > 1) ? _57 : "";
                        c += format(d + _58, _61);
                        c += Array(match(c, /\{/g).length + 1).join("}");
                        fn += c
                    }
                    if (b.length > 1)
                        fn += _59;
                    eval(format(_60, reg) + parser.unescape(fn) + "return s?null:r}");
                    _65[a] = fn
                }
                return _65[a]
            }
        };
        Document.implement(DocumentSelector);
        Element.implement(ElementSelector);
        var HTMLDocument = Document.extend(null, {"@(document.activeElement===undefined)": {bind: function(b) {
                    b.activeElement = null;
                    EventTarget.addEventListener(b, "focus", function(a) {
                        b.activeElement = a.target
                    }, false);
                    return this.base(b)
                }}});
        var HTMLElement = Element.extend({addClass: function(a, b) {
                if (!this.hasClass(a, b)) {
                    a.className += (a.className ? " " : "") + b
                }
            },hasClass: function(a, b) {
                var c = new RegExp("(^|\\s)" + b + "(\\s|$)");
                return c.test(a.className)
            },removeClass: function(a, b) {
                var c = new RegExp("(^|\\s)" + b + "(\\s|$)", "g");
                a.className = a.className.replace(c, "$2")
            },toggleClass: function(a, b) {
                if (this.hasClass(a, b)) {
                    this.removeClass(a, b)
                } else {
                    this.addClass(a, b)
                }
            }}, {bindings: {},tags: "*",extend: function() {
                var b = base(this, arguments);
                var c = (b.tags || "").toUpperCase().split(",");
                forEach(c, function(a) {
                    HTMLElement.bindings[a] = b
                });
                return b
            },"@!(element.ownerDocument)": {bind: function(a) {
                    a.ownerDocument = Traversal.getOwnerDocument(a);
                    return this.base(a)
                }}});
        eval(this.exports)
    };
    new function(_) {
        var JSB = new base2.Package(this, {name: "JSB",version: "0.7",imports: "DOM",exports: "Behavior, Rule, RuleList"});
        eval(this.imports);
        var Behavior = Abstract.extend();
        var Call = Base.extend({
            constructor: function(a, b, c, d) {
                /**
                 * @ignore
                 */
                this.release = function() {
                    b.apply(a, c)
                };
                
                this.rank = d || (100 + Call.list.length);
            }
        }, {
            list: [],
            
            defer: function(a, b) {
                return function() {
                    if (Call.list) {
                        Call.list.push(new Call(this, a, arguments, b));
                    } else {
                        a.apply(this, arguments);
                    }
                };
            },
            
            init: function() {
                EventTarget.addEventListener(document, "DOMContentLoaded", function() {
                    if (Call.list) {
                        DOM.bind(document);
                        Call.list.sort(function(a, b) {
                            return a.rank - b.rank
                        });
                        
                        invoke(Call.list, "release");
                        delete Call.list;
                        
                        setTimeout(function() {
                          
                            var a = DocumentEvent.createEvent(document, "Events");
                            Event.initEvent(a, "ready", false, false);
                            EventTarget.dispatchEvent(document, a);
                        }, 1);
                    }
                }, false);
            }
        });
        
        var _66 = /^on[a-z]+$/;
        
        var Rule = Base.extend({
            constructor: function(e, f) {
                e = new Selector(e);
                
                if (Behavior.ancestorOf(f)) {
                    f = f.prototype;
                }
                
                var g = {}, h = {}, i = f.style, j = {};
                
                forEach(f, function(a, b) {
                    if (b.charAt(0) == "@") {
                        if (detect(b.slice(1))) {
                            forEach(a, arguments.callee);
                        }
                    } else if (typeof a == "function" && _66.test(b)) {
                        h[b.slice(2)] = a;
                    } else if (b != "style") {
                        g[b] = a;
                    }
                });
                
                function addBehavior(a) {
                    var b = assignID(a);
                    
                    if (!j[b]) {
                        j[b] = true;
                        DOM.bind(a);
                        extend(a, g);
                        extend(a.style, i);
                        
                        for (var c in h) {
                            var target = a;
                            var d = h[c];
                            if (c.indexOf("document") == 0) {
                                target = document;
                                c = c.slice(8);
                                d = bind(d, a);
                            }
                            
                            target.addEventListener(c, d, false);
                        }
                    }
                }
                
                this.refresh = Call.defer(function() {
                    e.exec(document).forEach(addBehavior);
                });
                
                this.toString = K(String(e));
                this.refresh()
            },
            
            refresh: Undefined
        });
        
        var RuleList = Collection.extend({
            constructor: function(a) {
                this.base(a);
                this.globalize();
            },
            
            globalize: Call.defer(function() {
                var e = /[^\s,]+/g;
                var f = /^#[\w-]+$/;
                forEach(this, function(c, d) {
                    forEach(match(d, e), function(a) {
                        if (f.test(a)) {
                            var b = ViewCSS.toCamelCase(a.slice(1));
                            window[b] = Document.querySelector(document, a);
                        }
                    });
                })
            }, 10),
            
            refresh: function() {
                this.invoke("refresh");
            }
        }, {Item: Rule});
        
        eval(this.exports);
    };
    
    eval(base2.namespace);
    
    var DEFAULT = "@0";
    var IGNORE = RegGrp.IGNORE;
    
    var Colorizer = RegGrp.extend({
        constructor: function(c, d, e) {
            this.extend(e);
            this.patterns = c || {};
            
            var f = {}, i;
            
            forEach(c, function(a, b) {
                f[b] = d[b] || DEFAULT;
            });
            
            forEach(d, function(a, b) {
                f[b] = d[b];
            });
            
            this.base(f);
        },
        
        patterns: null,
        
        tabStop: 4,
        
        urls: true,
        
        copy: function() {
            var a = this.base();
            a.patterns = copy(this.patterns);
            
            return a;
        }, 
        
        exec: function(a, b) {
            a = this.base(this.escape(a));
            
            if ( ! b) {
                a = this._67(a);
                
                if (this.urls) {
                    a = Colorizer.urls.exec(a);
                }
            }
            
            return this.unescape(a);
        },
        
        escape: function(a) {
            return String(a).replace(/</g, "\x01").replace(/&/g, "\x02");
        },
        
        put: function(c, d) {
            if ( ! instanceOf(c, RegGrp.Item)) {
                if (typeof d === "string") {
                    d = d.replace(/@(\d)/, function(a, b) {
                        return format(Colorizer.FORMAT, c, b);
                    });
                }
                
                c = this.patterns[c] || Colorizer.patterns[c] || c;
                
                if (instanceOf(c, RegExp)) {
                    c = c.source;
                }
                
                c = this.escape(c);
            }
            
            return this.base(c, d);
        },
        
        unescape: function(a) {
            return a.replace(/\x01/g, "&lt;").replace(/\x02/g, "&amp;");
        },
        
        _67: function(c) {
            var d = this.tabStop;
            
            if (d > 0) {
                var e = Array(d + 1).join(" ");
                
                return c.replace(Colorizer.TABS, function(a) {
                    a = a.replace(Colorizer.TAB, e);
                    if (d > 1) {
                        var b = (a.length - 1) % d;
                        
                        if (b) {
                            a = a.slice(0, -b);
                        }
                    }
                    
                    return a.replace(/ /g, "&nbsp;");
                });
            }
            
            return c;
        },
        
        "@MSIE": {
            _67: function(a) {
                return this.base(a).replace(/\r?\n/g, "<br>");
            }
        }
    }, {
        version: "0.8",
        FORMAT: '<span class="%1">$%2</span>',
        DEFAULT: DEFAULT,
        IGNORE: IGNORE,
        TAB: /\t/g,
        TABS: /\n([\t \xa0]+)/g,
        init: function() {
            forEach(this.patterns, function(c, d, e) {
                if (instanceOf(c, Array)) {
                    e[d] = reduce(c, function(a, b) {
                        a.add(e[b]);
                        
                        return a;
                    }, new RegGrp);
                }
            });
            
            this.urls = this.patterns.urls.copy();
            this.urls.putAt(0, '<a href="mailto:$0">$0</a>');
            this.urls.putAt(1, '<a href="$0">$0</a>');
        },
        
        addScheme: function(a, b, c, d) {
            this[a] = new this(b, c, d);
        },
        
        patterns: {
            block_comment: /\/\*[^*]*\*+([^\/][^*]*\*+)*\//,
            email: /([\w.+-]+@[\w.-]+\.\w+)/,
            line_comment: /\/\/[^\r\n]*/,
            number: /\b\-?(0|[1-9]\d*)(\.\d+)?([eE][-+]?\d+)?\b/,
            string1: /'(\\.|[^'\\])*'/,
            string2: /"(\\.|[^"\\])*"/,
            url: /(http:\/\/+[\w\/\-%&#=.,?+$]+)/,
            comment: ["block_comment", "line_comment"],
            string: ["string1", "string2"],
            urls: ["email", "url"]
        },
        
        urls: null
    });
    
    base2.addPackage("code");
    base2.code.addName("Colorizer", Colorizer);
    
    with (base2.code.Colorizer) {
        addScheme("xml", {attribute: /(\w+)=("[^"]*"|'[^']*')/,cdata: /<!\[CDATA\[([^\]]|\][^\]]|\]\][^>])*\]\]>/,comment: /<!\s*(--([^-]|[\r\n]|-[^-])*--\s*)>/,entity: /&#?\w+;/,"processing-instruction": /<\?[\w-]+[^>]+>/,tag: /(<\/?)([\w:-]+)/,text: /[>;][^<>&]*/}, {cdata: IGNORE,tag: "$1@2",attribute: '@1=<span class="attribute value">$2</span>',text: IGNORE}, {tabStop: 1});
    }
    
    with (base2) {
        code.Colorizer.addScheme("html", {
            conditional: /<!(--)?\[[^\]]*\]>|<!\[endif\](--)?>/,
            doctype: /<!(DOCTYPE|doctype)[^>]+>/,
            inline: /<(script|style)([^>]*)>((\\.|[^\\])*)<\/\1>/
        }, {
            inline: function(a, b, c, d) {
                return format(this.INLINE, b, this.exec(c, true), d);
            }
        }, {
            INLINE: '&lt;<span class="tag">%1</span>%2&gt;%3&lt;/<span class="tag">%1</span>&gt;',
            tabStop: 1
        });
    }
    
    with (base2.code.Colorizer) {
        html.merge(xml);
    }
    
    with (base2.code.Colorizer) {
        addScheme("css", {at_rule: /@[\w\s]+/,bracketed: /\([^'\x22)]*\)/,comment: patterns.block_comment,property: /(\w[\w-]*\s*):([^;}]+)/,special: /(\-[\w-]*\s*):/,selector: /([\w-:\[.#][^{};]*)\{/}, {bracketed: IGNORE,selector: "@1{",special: "@1:",property: '@1:<span class="property value">$2</span>'});
    }
    
    with (base2.code.Colorizer) {
        addScheme("javascript", {conditional: /\/\*@if\s*\([^\)]*\)|\/\*@[\s\w]*|@\*\/|\/\/@\w+|@else[\s\w]*/,global: /\b(clearInterval|clearTimeout|constructor|document|escape|hasOwnProperty|Infinity|isNaN|NaN|parseFloat|parseInt|prototype|setInterval|setTimeout|toString|unescape|valueOf|window)\b/,keyword: /\b(&&|\|\||arguments|break|case|continue|default|delete|do|else|false|for|function|if|in|instanceof|new|null|return|switch|this|true|typeof|var|void|while|with|undefined)\b/,regexp: /([\[(\^=,{}:;&|!*?]\s*)(\/(\\\/|[^\/*])(\\.|[^\/\n\\])*\/[mgi]*)/,special: /\b(assert\w*|alert|catch|confirm|console|debug|debugger|eval|finally|prompt|throw|try)\b/}, {comment: DEFAULT,string: DEFAULT,regexp: "$1@2",number: DEFAULT});
    }
    
    with (base2) {
        with (code) {
            Colorizer["html-multi"] = Colorizer.html.union({
                inline: function(a, b, c, d) {
                    var e = b == "style" ? "css" : "javascript";
                    d = Colorizer[e].exec(d, true);
                    d = format('<span class="%1">%2</span>', e, d);
                    
                    return format(this.INLINE, b, this.exec(c, true), d);
                }
            });
        }
    }
              
    with (base2.code.Colorizer.javascript) {
        add("\\b(" + (base2.exports + ",base,base2,merge,union,implement,Array2,Date2,String2").match(/[^\s,]+/g).join("|") + ")\\b", '<span class="base2">$0</span>');
        insertAt(0, /("@[^"]+"):/, '<span class="special">$1</span>:');
        tabStop = 2;
    }
    
    eval(base2.namespace);
    eval(DOM.namespace);
    eval(JSB.namespace);
    
    var bindings = new RuleList;
    
    bindings.add("pre", {
        ondocumentready: function() {
            if (this.hasClass("js")) {
                this.addClass("javascript");
            }
            
            var a = this.className.split(/\s+/);
            
            for (var i = 0; i < a.length; i++) {
                var b = a[i];
                var c = Colorizer[b];
                if (c instanceof Colorizer) {
                    var d = Traversal.getTextContent(this);
                    this.innerHTML = c.exec(d);
                    this.addClass("highlight");
                    
                    if (b === "html-multi") {
                        this.addClass("html");
                    }
                    
                    break
                }
            }
        }
    });
    
    function updateFlag() {
        this.nextSibling.style.color = this.value ? "#898E79" : "#A03333"
    }
    
    bindings.add("input.required,textarea.required", {ondocumentready: updateFlag,ondocumentmouseup: updateFlag,ondocumentkeyup: updateFlag});

    eval(base2.namespace);
    eval(JavaScript.namespace);

    var IGNORE = RegGrp.IGNORE;
    var REMOVE = "";
    var SPACE = " ";
    var WORDS = /\w+/g;

    var Packer = Base.extend({
        minify: function(script) {
            script = script.replace(Packer.CONTINUE, "");
            script = Packer.data.exec(script);
            script = Packer.whitespace.exec(script);
            script = Packer.clean.exec(script);
            
            return script;
        },

        pack: function(script, base62, shrink) {
            script = this.minify(script + "\n");
            
            if (shrink) {
                script = this._shrinkVariables(script);
            }
            
            if (base62) {
                script = this._base62Encode(script);	
            }
            
            return script;
        },

        _base62Encode: function(script) {
            var words = new Words(script);
            
            var encode = function(word) {
                return words.get(word).encoded;
            };

            /* build the packed script */

            var p = this._escape(script.replace(WORDS, encode));		
            var a = Math.min(Math.max(words.size(), 2), 62);
            var c = words.size();
            var k = words;
            var e = Packer["ENCODE" + (a > 10 ? a > 36 ? 62 : 36 : 10)];
            var r = a > 10 ? "e(c)" : "c";

            // the whole thing
            return format(Packer.UNPACK, p,a,c,k,e,r);
        },

        _escape: function(script) {
            // single quotes wrap the final string so escape them
            // also escape new lines required by conditional comments
            return script.replace(/([\\'])/g, "\\$1").replace(/[\r\n]+/g, "\\n");
        },

        _shrinkVariables: function(script) {
            // Windows Scripting Host cannot do regexp.test() on global regexps.
            var global = function(regexp) {
                // This function creates a global version of the passed regexp.
                return new RegExp(regexp.source, "g");
            };

            var data = []; // encoded strings and regular expressions
            var REGEXP = /^[^'"]\//;
            var store = function(string) {
                var replacement = "#" + data.length;
                
                if (REGEXP.test(string)) {
                    replacement = string.charAt(0) + replacement;
                    string = string.slice(1);
                }
                
                data.push(string);
                
                return replacement;
            };

            // Base52 encoding (a-Z)
            var encode52 = function(c) {
                return (c < 52 ? '' : arguments.callee(parseInt(c / 52)))
                     + ((c = c % 52) > 25 ? String.fromCharCode(c + 39) : String.fromCharCode(c + 97));
            };

            // identify blocks, particularly identify function blocks (which define scope)
            var BLOCK = /(function\s*[\w$]*\s*\(\s*([^\)]*)\s*\)\s*)?(\{([^{}]*)\})/;
            var VAR_ = /var\s+/g;
            var VAR_NAME = /var\s+[\w$]+/g;
            var COMMA = /\s*,\s*/;
            var blocks = []; // store program blocks (anything between braces {})
            // encoder for program blocks
            
            var encode = function(block, func, args) {
                if (func) { // the block is a function block

                    // decode the function block (THIS IS THE IMPORTANT BIT)
                    // We are retrieving all sub-blocks and will re-parse them in light
                    // of newly shrunk variables
                    block = decode(block);

                    // create the list of variable and argument names 
                    var vars = match(block, VAR_NAME).join(",").replace(VAR_, "");
                    var ids = Array2.combine(args.split(COMMA).concat(vars.split(COMMA)));

                    // process each identifier
                    var count = 0, shortId;
                    forEach (ids, function(id) {
                        id = trim(id);
                        
                        if (id && id.length > 1) { // > 1 char
                            id = rescape(id);
                            // find the next free short name (check everything in the current scope)
                            do shortId = encode52(count++);
                            while (new RegExp("[^\\w$.]" + shortId + "[^\\w$:]").test(block));
                            // replace the long name with the short name
                            var reg = new RegExp("([^\\w$.])" + id + "([^\\w$:])");
                            while (reg.test(block)) block = block.replace(global(reg), "$1" + shortId + "$2");
                            var reg = new RegExp("([^{,\\w$.])" + id + ":", "g");
                            block = block.replace(reg, "$1" + shortId + ":");
                        }
                    });
                }
                
                var replacement = "~" + blocks.length + "~";
                
                blocks.push(block);
                
                return replacement;
            };

            // decoder for program blocks
            var ENCODED = /~(\d+)~/;
            var decode = function(script) {
                while (ENCODED.test(script)) {
                    script = script.replace(global(ENCODED), function(match, index) {
                        return blocks[index];
                    });
                }
                
                return script;
            };

            // encode strings and regular expressions
            script = Packer.data.exec(script, store);

            // remove closures (this is for base2 namespaces only)
            script = script.replace(/new function\(_\)\s*\{/g, "{;#;");

            // encode blocks, as we encode we replace variable and argument names
            while (BLOCK.test(script)) {
                script = script.replace(global(BLOCK), encode);
            }

            // put the blocks back
            script = decode(script);

            // put back the closure (for base2 namespaces only)
            script = script.replace(/\{;#;/g, "new function(_){");

            // put strings and regular expressions back
            script = script.replace(/#(\d+)/g, function(match, index) {		
                return data[index];
            });

            return script;
        }
    }, {
        CONTINUE: /\\\r?\n/g,

        ENCODE10: "String",
        ENCODE36: "function(c){return c.toString(a)}",
        ENCODE62: "function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))}",

        UNPACK: "eval(function(p,a,c,k,e,r){e=%5;if(!''.replace(/^/,String)){while(c--)r[%6]=k[c]"
              + "||%6;k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p."
              + "replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('%1',%2,%3,'%4'.split('|'),0,{}))",

        init: function() {
            this.data = reduce(this.data, function(data, replacement, expression) {
                data.put(this.javascript.exec(expression), replacement);
                return data;
            }, new RegGrp, this);

            this.clean = this.data.union(this.clean);
            this.whitespace = this.data.union(this.whitespace);
        },

        clean: {
            "\\(\\s*;\\s*;\\s*\\)": "(;;)", // for (;;) loops
            "throw[^};]+[};]": IGNORE, // a safari 1.3 bug
            ";+\\s*([};])": "$1"
        },

        data: {
            // strings
            "STRING1": IGNORE,
            'STRING2': IGNORE,
            "CONDITIONAL": IGNORE, // conditional comments
            "(COMMENT1)\\n\\s*(REGEXP)?": "\n$3",
            "(COMMENT2)\\s*(REGEXP)?": " $3",
            "([\\[(\\^=,{}:;&|!*?])\\s*(REGEXP)": "$1$2"
        },

        javascript: new RegGrp({
            COMMENT1:    /(\/\/|;;;)[^\n]*/.source,
            COMMENT2:    /\/\*[^*]*\*+([^\/][^*]*\*+)*\//.source,
            CONDITIONAL: /\/\*@|@\*\/|\/\/@[^\n]*\n/.source,
            REGEXP:      /\/(\\[\/\\]|[^*\/])(\\.|[^\/\n\\])*\/[gim]*/.source,
            STRING1:     /'(\\.|[^'\\])*'/.source,
            STRING2:     /"(\\.|[^"\\])*"/.source
        }),

        whitespace: {
            "(\\d)\\s+(\\.\\s*[a-z\\$_\\[(])": "$1 $2", // http://dean.edwards.name/weblog/2007/04/packer3/#comment84066
            "([+-])\\s+([+-])": "$1 $2", // c = a++ +b;
            "\\b\\s+\\$\\s+\\b": " $ ", // var $ in
            "\\$\\s+\\b": "$ ", // object$ in
            "\\b\\s+\\$": " $", // return $object
            "\\b\\s+\\b": SPACE,
            "\\s+": REMOVE
        }
    });

    var Words = Collection.extend({
        constructor: function(script) {
            this.base();
            forEach(script.match(WORDS), this.add, this);
            this.encode();
        },

        add: function(word) {
            if (!this.has(word))
                this.base(word);
            word = this.get(word);
            word.count++;
            return word;
        },

        encode: function() {
            // sort by frequency
            this.sort(function(word1, word2) {
                return word2.count - word1.count;
            });

            eval("var a=62,e=" + Packer.ENCODE62);
            var encode = e;
            var encoded = new Collection; // a dictionary of base62 -> base10
            var count = this.size();
            for (var i = 0; i < count; i++) {
                encoded.put(encode(i), i);
            }

            var empty = function() {
                return ""
            };
            
            var index = 0;
            
            forEach(this, function(word) {
                if (encoded.has(word)) {
                    word.index = encoded.get(word);
                    word.toString = empty;
                } else {
                    while (this.has(encode(index))) {
                        index++;
                    }
                    
                    word.index = index++;
                }
                
                word.encoded = encode(word.index);
            }, this);

            // sort by encoding
            this.sort(function(word1, word2) {
                return word1.index - word2.index;
            });
        },

        toString: function() {
            return this.getValues().join("|");
        }
    }, {
        Item: {
            constructor: function(word) {
              
                /**
                 * @ignore
                 */
                this.toString = function() {
                    return word;
                };
            },

            count: 0,
            encoded: "",
            index: -1
        }
    });

    return new Packer();
});
